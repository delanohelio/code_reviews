{"pr_number": 3666, "pr_title": "feature-NXP-28424-Define-the-ColdStorage-facet", "pr_author": "nuxeojenkins", "pr_createdAt": "2020-01-14T12:51:27Z", "pr_url": "https://github.com/nuxeo/nuxeo/pull/3666", "timeline": [{"oid": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "url": "https://github.com/nuxeo/nuxeo/commit/2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-12T17:24:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQxOTk5OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r378419998", "body": "```suggestion\r\n        // auto-subscribe the user, this way they will receive the mail notification when the content is available\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // auto-subscribe the user, this way he will receive the mail notification when the content is available\n          \n          \n            \n                    // auto-subscribe the user, this way they will receive the mail notification when the content is available", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c\"><span class=\"pl-c\">//</span> auto-subscribe the user, this way <span class=\"x x-first x-last\">he</span> will receive the mail notification when the content is available</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c\"><span class=\"pl-c\">//</span> auto-subscribe the user, this way <span class=\"x x-first x-last\">they</span> will receive the mail notification when the content is available</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-12T18:02:51Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Requests a retrieval from the cold storage content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n+ * \n+ * @since 11.1\n+ */\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval of the cold storage content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n+\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n+\n+    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n+    protected int numberOfDaysOfAvailability;\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        // auto-subscribe the user, this way he will receive the mail notification when the content is available", "originalCommit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d45704561a863e82dd784759acffd93cc29c0297", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nindex 47f1835baef..61e1954657c 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -54,14 +54,18 @@ public class RequestRetrievalFromColdStorage {\n \n     @OperationMethod(collector = DocumentModelCollector.class)\n     public DocumentModel run(DocumentModel doc) {\n-        // auto-subscribe the user, this way he will receive the mail notification when the content is available\n+        // request a retrieval\n+        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n+                numberOfDaysOfAvailability);\n+\n+        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n         NuxeoPrincipal principal = session.getPrincipal();\n         String username = NotificationConstants.USER_PREFIX + principal.getName();\n         NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n         notificationManager.addSubscription(username,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, doc, false, principal,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n                 ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n \n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(), numberOfDaysOfAvailability);\n+        return documentModel;\n     }\n }\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nsimilarity index 83%\nrename from nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nrename to nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nindex 61e1954657c..ff037ccacda 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -66,6 +70,10 @@ public class RequestRetrievalFromColdStorage {\n                 ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n                 ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n \n+        if (save) {\n+            documentModel = session.saveDocument(documentModel);\n+        }\n+\n         return documentModel;\n     }\n }\n", "next_change": null}]}}]}}, {"oid": "d45704561a863e82dd784759acffd93cc29c0297", "url": "https://github.com/nuxeo/nuxeo/commit/d45704561a863e82dd784759acffd93cc29c0297", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-13T12:11:07Z", "type": "forcePushed"}, {"oid": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "url": "https://github.com/nuxeo/nuxeo/commit/38f8aea272f782bad3391f557f53efea9c3b5e0f", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-20T16:53:58Z", "type": "forcePushed"}, {"oid": "590344f14c7c362984cde2a7308edab994972aea", "url": "https://github.com/nuxeo/nuxeo/commit/590344f14c7c362984cde2a7308edab994972aea", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-21T08:13:55Z", "type": "forcePushed"}, {"oid": "6eef336b384a9c7fa912abb0041ca08c0b57d68e", "url": "https://github.com/nuxeo/nuxeo/commit/6eef336b384a9c7fa912abb0041ca08c0b57d68e", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-21T08:53:30Z", "type": "forcePushed"}, {"oid": "e79e79cf3b52c7ae075339c8e07e3812e6b75910", "url": "https://github.com/nuxeo/nuxeo/commit/e79e79cf3b52c7ae075339c8e07e3812e6b75910", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-21T09:15:32Z", "type": "forcePushed"}, {"oid": "434ed557ac5ddc81e3493bd67148941167b1fded", "url": "https://github.com/nuxeo/nuxeo/commit/434ed557ac5ddc81e3493bd67148941167b1fded", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-21T12:13:17Z", "type": "forcePushed"}, {"oid": "9ac7ea1e5868af4a7e30fd8d9364910f6c8908fd", "url": "https://github.com/nuxeo/nuxeo/commit/9ac7ea1e5868af4a7e30fd8d9364910f6c8908fd", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-21T12:21:10Z", "type": "forcePushed"}, {"oid": "c0830954071c339167cbed7919140c1aa4023295", "url": "https://github.com/nuxeo/nuxeo/commit/c0830954071c339167cbed7919140c1aa4023295", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-21T13:42:33Z", "type": "forcePushed"}, {"oid": "b0b40d92306ff9957c532129a54e69d2f296f085", "url": "https://github.com/nuxeo/nuxeo/commit/b0b40d92306ff9957c532129a54e69d2f296f085", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-21T13:45:39Z", "type": "forcePushed"}, {"oid": "d080e48aa5cc3668bb1de3aeae016936c1889026", "url": "https://github.com/nuxeo/nuxeo/commit/d080e48aa5cc3668bb1de3aeae016936c1889026", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-21T17:10:06Z", "type": "forcePushed"}, {"oid": "d613271a20d8ceb00720556d8559c6996e39b57a", "url": "https://github.com/nuxeo/nuxeo/commit/d613271a20d8ceb00720556d8559c6996e39b57a", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-21T17:21:12Z", "type": "forcePushed"}, {"oid": "5b84ba761215c2c54994be451173e134d1bc83b6", "url": "https://github.com/nuxeo/nuxeo/commit/5b84ba761215c2c54994be451173e134d1bc83b6", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-21T17:26:36Z", "type": "forcePushed"}, {"oid": "960e6c655858499f414887fda04e08d3262c19ee", "url": "https://github.com/nuxeo/nuxeo/commit/960e6c655858499f414887fda04e08d3262c19ee", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-25T10:51:07Z", "type": "forcePushed"}, {"oid": "baa94a4d093c1b512badb4ab68339f26e89ff3e5", "url": "https://github.com/nuxeo/nuxeo/commit/baa94a4d093c1b512badb4ab68339f26e89ff3e5", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-25T17:28:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4NzEzNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384587136", "body": "\"check if `coldstorage:coldContent`\"\r\nor\r\n\"check if the `coldstorage:coldContent` property\"", "bodyText": "\"check if coldstorage:coldContent\"\nor\n\"check if the coldstorage:coldContent property\"", "bodyHTML": "<p dir=\"auto\">\"check if <code>coldstorage:coldContent</code>\"<br>\nor<br>\n\"check if the <code>coldstorage:coldContent</code> property\"</p>", "author": "ataillefer", "createdAt": "2020-02-26T15:56:06Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.*;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Test\n+    public void shouldMoveBlobDocumentToColdStorage() throws IOException {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` contains the original file content", "originalCommit": "e585ff0fcd1caa2611225c18438671da15e6695e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 1fa64aa59a8..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -47,18 +72,29 @@ public class TestColdStorage {\n \n     protected static final String FILE_CONTENT = \"foo\";\n \n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n     @Inject\n     protected CoreSession session;\n \n     @Inject\n     protected TransactionalFeature transactionalFeature;\n \n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n     @Test\n-    public void shouldMoveBlobDocumentToColdStorage() throws IOException {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 1fa64aa59a8..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -66,42 +102,144 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n-        DocumentModel documentModel = createDocument(false);\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxNDk0NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384714944", "body": "Since we have a test contribution to dispatch a blob given it's xpath, could we add assertions to verify their blob provider?\r\nSomething based ont the blob keys, similar to what is done in `TestBlobDispatcher`.\r\nfile:content => default, coldstorage:coldContent => dummy", "bodyText": "Since we have a test contribution to dispatch a blob given it's xpath, could we add assertions to verify their blob provider?\nSomething based ont the blob keys, similar to what is done in TestBlobDispatcher.\nfile:content => default, coldstorage:coldContent => dummy", "bodyHTML": "<p dir=\"auto\">Since we have a test contribution to dispatch a blob given it's xpath, could we add assertions to verify their blob provider?<br>\nSomething based ont the blob keys, similar to what is done in <code>TestBlobDispatcher</code>.<br>\nfile:content =&gt; default, coldstorage:coldContent =&gt; dummy</p>", "author": "ataillefer", "createdAt": "2020-02-26T19:31:39Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.*;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Test\n+    public void shouldMoveBlobDocumentToColdStorage() throws IOException {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` contains the original file content\n+        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);", "originalCommit": "e585ff0fcd1caa2611225c18438671da15e6695e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyMDc5Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385120797", "bodyText": "initially I tested it, but after that i removed it, because I told myself the test part is the responsibility of the dispatcher and if we do the right configuration it will work.\nbut i can add the check on the dummy provider:\n assertEquals(\"dummy\", ((ManagedBlob) coldContent).getProviderId());\nfor the main content as it will be null i think we can avoid adding the assertion.", "author": "RSalem07", "createdAt": "2020-02-27T13:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxNDk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI2MDMzMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385260333", "bodyText": "The main content will have a blob provider id default in theory (or test I'm not sure if it takes the repo name)", "author": "efge", "createdAt": "2020-02-27T17:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxNDk0NA=="}], "type": "inlineReview", "revised_code": {"commit": "dda56369d6828f247071862ca23a34e0e29df79f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 1fa64aa59a8..12af6ef9f1d 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -72,7 +106,7 @@ public class TestColdStorage {\n \n     @Test\n     public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n-        DocumentModel documentModel = createDocument(true);\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 12af6ef9f1d..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -100,97 +102,103 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n                 moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n                 moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczODY2NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384738665", "body": "Maybe use a simpler name for readability as we know we're in the TestColdStorage class: \"shouldRequestRetrieval\"?", "bodyText": "Maybe use a simpler name for readability as we know we're in the TestColdStorage class: \"shouldRequestRetrieval\"?", "bodyHTML": "<p dir=\"auto\">Maybe use a simpler name for readability as we know we're in the TestColdStorage class: \"shouldRequestRetrieval\"?</p>", "author": "ataillefer", "createdAt": "2020-02-26T20:12:47Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -100,6 +111,61 @@ public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n         }\n     }\n \n+    @Test\n+    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {", "originalCommit": "3145ae2f7137d40730102cca07e5e13b48fd72b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dda56369d6828f247071862ca23a34e0e29df79f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 225d6e5236f..12af6ef9f1d 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -113,7 +136,7 @@ public class TestColdStorage {\n \n     @Test\n     public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n-        DocumentModel documentModel = createDocument(true);\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 12af6ef9f1d..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -100,97 +102,103 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n                 moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n                 moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczOTQ1NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384739455", "body": "\"shouldFailRequestRetrievalBeingRetrieved\"?", "bodyText": "\"shouldFailRequestRetrievalBeingRetrieved\"?", "bodyHTML": "<p dir=\"auto\">\"shouldFailRequestRetrievalBeingRetrieved\"?</p>", "author": "ataillefer", "createdAt": "2020-02-26T20:14:28Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -100,6 +111,61 @@ public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n         }\n     }\n \n+    @Test\n+    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(Boolean.TRUE.equals(\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+    }\n+\n+    @Test\n+    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {", "originalCommit": "3145ae2f7137d40730102cca07e5e13b48fd72b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dda56369d6828f247071862ca23a34e0e29df79f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 225d6e5236f..12af6ef9f1d 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -130,7 +153,7 @@ public class TestColdStorage {\n \n     @Test\n     public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n-        DocumentModel documentModel = createDocument(true);\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 12af6ef9f1d..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -100,97 +102,103 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n                 moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n                 moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczOTU4MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384739581", "body": "\"shouldFailRequestRetrievalNoContent\"?", "bodyText": "\"shouldFailRequestRetrievalNoContent\"?", "bodyHTML": "<p dir=\"auto\">\"shouldFailRequestRetrievalNoContent\"?</p>", "author": "ataillefer", "createdAt": "2020-02-26T20:14:45Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -100,6 +111,61 @@ public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n         }\n     }\n \n+    @Test\n+    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(Boolean.TRUE.equals(\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+    }\n+\n+    @Test\n+    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {", "originalCommit": "3145ae2f7137d40730102cca07e5e13b48fd72b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dda56369d6828f247071862ca23a34e0e29df79f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 225d6e5236f..12af6ef9f1d 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -153,7 +176,7 @@ public class TestColdStorage {\n \n     @Test\n     public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n-        DocumentModel documentModel = createDocument(true);\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n             // try a request retrieval from the cold storage content where the blob is not stored in it\n             ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 12af6ef9f1d..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -100,97 +102,103 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n                 moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n                 moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczOTg1MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384739851", "body": "shorter: \"shouldMoveToColdStorage\"", "bodyText": "shorter: \"shouldMoveToColdStorage\"", "bodyHTML": "<p dir=\"auto\">shorter: \"shouldMoveToColdStorage\"</p>", "author": "ataillefer", "createdAt": "2020-02-26T20:15:21Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.*;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Test\n+    public void shouldMoveBlobDocumentToColdStorage() throws IOException {", "originalCommit": "e585ff0fcd1caa2611225c18438671da15e6695e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dda56369d6828f247071862ca23a34e0e29df79f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 1fa64aa59a8..12af6ef9f1d 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -47,15 +71,25 @@ public class TestColdStorage {\n \n     protected static final String FILE_CONTENT = \"foo\";\n \n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n     @Inject\n     protected CoreSession session;\n \n     @Inject\n     protected TransactionalFeature transactionalFeature;\n \n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n     @Test\n     public void shouldMoveBlobDocumentToColdStorage() throws IOException {\n-        DocumentModel documentModel = createDocument(true);\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 12af6ef9f1d..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -88,11 +89,12 @@ public class TestColdStorage {\n     protected DownloadService downloadService;\n \n     @Test\n-    public void shouldMoveBlobDocumentToColdStorage() throws IOException {\n+    public void shouldMoveToColdStorage() throws IOException {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0MDc3MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384740771", "body": "\"shouldFailMoveAlreadyInColdStorage\"?", "bodyText": "\"shouldFailMoveAlreadyInColdStorage\"?", "bodyHTML": "<p dir=\"auto\">\"shouldFailMoveAlreadyInColdStorage\"?</p>", "author": "ataillefer", "createdAt": "2020-02-26T20:17:15Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveBlobDocumentToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` contains the original file content\n+        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {", "originalCommit": "baa94a4d093c1b512badb4ab68339f26e89ff3e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 12af6ef9f1d..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -100,97 +102,103 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n                 moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n                 moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0MTAxOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384741019", "body": "\"shouldFailMoveToColdStorageNoContent\"?", "bodyText": "\"shouldFailMoveToColdStorageNoContent\"?", "bodyHTML": "<p dir=\"auto\">\"shouldFailMoveToColdStorageNoContent\"?</p>", "author": "ataillefer", "createdAt": "2020-02-26T20:17:50Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveBlobDocumentToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` contains the original file content\n+        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {", "originalCommit": "baa94a4d093c1b512badb4ab68339f26e89ff3e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 12af6ef9f1d..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -100,97 +102,103 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n                 moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n                 moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0MTI2MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384741261", "body": "\"shouldCheckAvailability\"?", "bodyText": "\"shouldCheckAvailability\"?", "bodyHTML": "<p dir=\"auto\">\"shouldCheckAvailability\"?</p>", "author": "ataillefer", "createdAt": "2020-02-26T20:18:20Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveBlobDocumentToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` contains the original file content\n+        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(Boolean.TRUE.equals(\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+    }\n+\n+    @Test\n+    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage content where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailabilityOfColdStorageContent() {", "originalCommit": "baa94a4d093c1b512badb4ab68339f26e89ff3e5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 12af6ef9f1d..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -100,97 +102,103 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n                 moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n                 moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0MjMzNA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384742334", "body": "\"request a retrieval from the cold storage\"\r\nor\r\n\"request cold storage content retrieval\"", "bodyText": "\"request a retrieval from the cold storage\"\nor\n\"request cold storage content retrieval\"", "bodyHTML": "<p dir=\"auto\">\"request a retrieval from the cold storage\"<br>\nor<br>\n\"request cold storage content retrieval\"</p>", "author": "ataillefer", "createdAt": "2020-02-26T20:20:36Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -100,6 +111,61 @@ public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n         }\n     }\n \n+    @Test\n+    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // request a retrieval from the cold storage content", "originalCommit": "3145ae2f7137d40730102cca07e5e13b48fd72b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dda56369d6828f247071862ca23a34e0e29df79f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 225d6e5236f..12af6ef9f1d 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -113,7 +136,7 @@ public class TestColdStorage {\n \n     @Test\n     public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n-        DocumentModel documentModel = createDocument(true);\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 12af6ef9f1d..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -100,97 +102,103 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n                 moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n                 moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0NzA5MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384747091", "body": "```suggestion\r\n     *            restoring it\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *            restoring\n          \n          \n            \n                 *            restoring it", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span>            restoring</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span>            restoring<span class=\"x x-first x-last\"> it</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-26T20:30:31Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -75,6 +83,61 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring", "originalCommit": "3145ae2f7137d40730102cca07e5e13b48fd72b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 1907b98b0ce..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -88,19 +104,20 @@ public class ColdStorageHelper {\n      *\n      * @param session the core session\n      * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n      * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n      *          process doesn't mean you will get the blob's content.\n      * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n     public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n         DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n \n         if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1MjI3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384752272", "body": "\"Requests a retrieval from cold storage of the content\"", "bodyText": "\"Requests a retrieval from cold storage of the content\"", "bodyHTML": "<p dir=\"auto\">\"Requests a retrieval from cold storage of the content\"</p>", "author": "ataillefer", "createdAt": "2020-02-26T20:40:49Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Requests a retrieval from the cold storage content associated with the input {@link DocumentModel}. This operation", "originalCommit": "3145ae2f7137d40730102cca07e5e13b48fd72b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dda56369d6828f247071862ca23a34e0e29df79f", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nindex 09c816bae39..34019a2b0bf 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -28,13 +28,17 @@ import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n import org.nuxeo.ecm.core.api.Blob;\n import org.nuxeo.ecm.core.api.CoreSession;\n import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.api.Framework;\n \n /**\n  * Requests a retrieval from the cold storage content associated with the input {@link DocumentModel}. This operation\n  * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n  * get the blob's content.\n- *\n+ * \n  * @since 11.1\n  */\n @Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval of the cold storage content associated with the document.\")\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nindex 34019a2b0bf..ff037ccacda 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -35,13 +37,13 @@ import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n import org.nuxeo.runtime.api.Framework;\n \n /**\n- * Requests a retrieval from the cold storage content associated with the input {@link DocumentModel}. This operation\n+ * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n  * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n  * get the blob's content.\n- * \n+ *\n  * @since 11.1\n  */\n-@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval of the cold storage content associated with the document.\")\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n public class RequestRetrievalFromColdStorage {\n \n     public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\ndeleted file mode 100644\nindex ff037ccacda..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,79 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import java.time.Duration;\n-\n-import org.nuxeo.ecm.automation.core.Constants;\n-import org.nuxeo.ecm.automation.core.annotations.Context;\n-import org.nuxeo.ecm.automation.core.annotations.Operation;\n-import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n-import org.nuxeo.ecm.automation.core.annotations.Param;\n-import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n- * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n- * get the blob's content.\n- *\n- * @since 11.1\n- */\n-@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n-public class RequestRetrievalFromColdStorage {\n-\n-    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n-\n-    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n-    protected int numberOfDaysOfAvailability;\n-\n-    @Context\n-    protected CoreSession session;\n-\n-    @Param(name = \"save\", required = false, values = \"true\")\n-    protected boolean save = true;\n-\n-    @OperationMethod(collector = DocumentModelCollector.class)\n-    public DocumentModel run(DocumentModel doc) {\n-        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n-                Duration.ofDays(numberOfDaysOfAvailability));\n-\n-        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n-        NuxeoPrincipal principal = session.getPrincipal();\n-        String username = NotificationConstants.USER_PREFIX + principal.getName();\n-        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n-        notificationManager.addSubscription(username,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n-\n-        if (save) {\n-            documentModel = session.saveDocument(documentModel);\n-        }\n-\n-        return documentModel;\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nnew file mode 100644\nindex 00000000000..ff037ccacda\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -0,0 +1,79 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import java.time.Duration;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n+ *\n+ * @since 11.1\n+ */\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n+\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n+\n+    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n+    protected int numberOfDaysOfAvailability;\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @Param(name = \"save\", required = false, values = \"true\")\n+    protected boolean save = true;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n+                Duration.ofDays(numberOfDaysOfAvailability));\n+\n+        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n+        NuxeoPrincipal principal = session.getPrincipal();\n+        String username = NotificationConstants.USER_PREFIX + principal.getName();\n+        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n+        notificationManager.addSubscription(username,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n+\n+        if (save) {\n+            documentModel = session.saveDocument(documentModel);\n+        }\n+\n+        return documentModel;\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\ndeleted file mode 100644\nindex ff037ccacda..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,79 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import java.time.Duration;\n-\n-import org.nuxeo.ecm.automation.core.Constants;\n-import org.nuxeo.ecm.automation.core.annotations.Context;\n-import org.nuxeo.ecm.automation.core.annotations.Operation;\n-import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n-import org.nuxeo.ecm.automation.core.annotations.Param;\n-import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n- * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n- * get the blob's content.\n- *\n- * @since 11.1\n- */\n-@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n-public class RequestRetrievalFromColdStorage {\n-\n-    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n-\n-    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n-    protected int numberOfDaysOfAvailability;\n-\n-    @Context\n-    protected CoreSession session;\n-\n-    @Param(name = \"save\", required = false, values = \"true\")\n-    protected boolean save = true;\n-\n-    @OperationMethod(collector = DocumentModelCollector.class)\n-    public DocumentModel run(DocumentModel doc) {\n-        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n-                Duration.ofDays(numberOfDaysOfAvailability));\n-\n-        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n-        NuxeoPrincipal principal = session.getPrincipal();\n-        String username = NotificationConstants.USER_PREFIX + principal.getName();\n-        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n-        notificationManager.addSubscription(username,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n-\n-        if (save) {\n-            documentModel = session.saveDocument(documentModel);\n-        }\n-\n-        return documentModel;\n-    }\n-}\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nnew file mode 100644\nindex 00000000000..9d5b155d9ae\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -0,0 +1,68 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import java.time.Duration;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n+ *\n+ * @since 11.1\n+ */\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n+\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n+\n+    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n+    protected int numberOfDaysOfAvailability;\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @Param(name = \"save\", required = false, values = \"true\")\n+    protected boolean save = true;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n+                Duration.ofDays(numberOfDaysOfAvailability));\n+\n+        if (save) {\n+            documentModel = session.saveDocument(documentModel);\n+        }\n+\n+        return documentModel;\n+    }\n+\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1Mjg3OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r384752879", "body": "probably useless", "bodyText": "probably useless", "bodyHTML": "<p dir=\"auto\">probably useless</p>", "author": "ataillefer", "createdAt": "2020-02-26T20:41:57Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Requests a retrieval from the cold storage content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n+ *\n+ * @since 11.1\n+ */\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval of the cold storage content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n+\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n+\n+    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n+    protected int numberOfDaysOfAvailability;\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        // request a retrieval", "originalCommit": "3145ae2f7137d40730102cca07e5e13b48fd72b7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dda56369d6828f247071862ca23a34e0e29df79f", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nindex 09c816bae39..34019a2b0bf 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -51,6 +55,17 @@ public class RequestRetrievalFromColdStorage {\n     @OperationMethod(collector = DocumentModelCollector.class)\n     public DocumentModel run(DocumentModel doc) {\n         // request a retrieval\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(), numberOfDaysOfAvailability);\n+        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n+                numberOfDaysOfAvailability);\n+\n+        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n+        NuxeoPrincipal principal = session.getPrincipal();\n+        String username = NotificationConstants.USER_PREFIX + principal.getName();\n+        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n+        notificationManager.addSubscription(username,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n+\n+        return documentModel;\n     }\n }\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nindex 34019a2b0bf..ff037ccacda 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -66,6 +70,10 @@ public class RequestRetrievalFromColdStorage {\n                 ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n                 ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n \n+        if (save) {\n+            documentModel = session.saveDocument(documentModel);\n+        }\n+\n         return documentModel;\n     }\n }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\ndeleted file mode 100644\nindex ff037ccacda..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,79 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import java.time.Duration;\n-\n-import org.nuxeo.ecm.automation.core.Constants;\n-import org.nuxeo.ecm.automation.core.annotations.Context;\n-import org.nuxeo.ecm.automation.core.annotations.Operation;\n-import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n-import org.nuxeo.ecm.automation.core.annotations.Param;\n-import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n- * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n- * get the blob's content.\n- *\n- * @since 11.1\n- */\n-@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n-public class RequestRetrievalFromColdStorage {\n-\n-    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n-\n-    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n-    protected int numberOfDaysOfAvailability;\n-\n-    @Context\n-    protected CoreSession session;\n-\n-    @Param(name = \"save\", required = false, values = \"true\")\n-    protected boolean save = true;\n-\n-    @OperationMethod(collector = DocumentModelCollector.class)\n-    public DocumentModel run(DocumentModel doc) {\n-        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n-                Duration.ofDays(numberOfDaysOfAvailability));\n-\n-        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n-        NuxeoPrincipal principal = session.getPrincipal();\n-        String username = NotificationConstants.USER_PREFIX + principal.getName();\n-        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n-        notificationManager.addSubscription(username,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n-\n-        if (save) {\n-            documentModel = session.saveDocument(documentModel);\n-        }\n-\n-        return documentModel;\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nnew file mode 100644\nindex 00000000000..ff037ccacda\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -0,0 +1,79 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import java.time.Duration;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n+ *\n+ * @since 11.1\n+ */\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n+\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n+\n+    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n+    protected int numberOfDaysOfAvailability;\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @Param(name = \"save\", required = false, values = \"true\")\n+    protected boolean save = true;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n+                Duration.ofDays(numberOfDaysOfAvailability));\n+\n+        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n+        NuxeoPrincipal principal = session.getPrincipal();\n+        String username = NotificationConstants.USER_PREFIX + principal.getName();\n+        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n+        notificationManager.addSubscription(username,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n+\n+        if (save) {\n+            documentModel = session.saveDocument(documentModel);\n+        }\n+\n+        return documentModel;\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\ndeleted file mode 100644\nindex ff037ccacda..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,79 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import java.time.Duration;\n-\n-import org.nuxeo.ecm.automation.core.Constants;\n-import org.nuxeo.ecm.automation.core.annotations.Context;\n-import org.nuxeo.ecm.automation.core.annotations.Operation;\n-import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n-import org.nuxeo.ecm.automation.core.annotations.Param;\n-import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n- * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n- * get the blob's content.\n- *\n- * @since 11.1\n- */\n-@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n-public class RequestRetrievalFromColdStorage {\n-\n-    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n-\n-    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n-    protected int numberOfDaysOfAvailability;\n-\n-    @Context\n-    protected CoreSession session;\n-\n-    @Param(name = \"save\", required = false, values = \"true\")\n-    protected boolean save = true;\n-\n-    @OperationMethod(collector = DocumentModelCollector.class)\n-    public DocumentModel run(DocumentModel doc) {\n-        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n-                Duration.ofDays(numberOfDaysOfAvailability));\n-\n-        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n-        NuxeoPrincipal principal = session.getPrincipal();\n-        String username = NotificationConstants.USER_PREFIX + principal.getName();\n-        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n-        notificationManager.addSubscription(username,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n-\n-        if (save) {\n-            documentModel = session.saveDocument(documentModel);\n-        }\n-\n-        return documentModel;\n-    }\n-}\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nnew file mode 100644\nindex 00000000000..9d5b155d9ae\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -0,0 +1,68 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import java.time.Duration;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n+ *\n+ * @since 11.1\n+ */\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n+\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n+\n+    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n+    protected int numberOfDaysOfAvailability;\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @Param(name = \"save\", required = false, values = \"true\")\n+    protected boolean save = true;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n+                Duration.ofDays(numberOfDaysOfAvailability));\n+\n+        if (save) {\n+            documentModel = session.saveDocument(documentModel);\n+        }\n+\n+        return documentModel;\n+    }\n+\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "dda56369d6828f247071862ca23a34e0e29df79f", "url": "https://github.com/nuxeo/nuxeo/commit/dda56369d6828f247071862ca23a34e0e29df79f", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-02-27T08:50:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyMzQzMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385023432", "body": "`expectedAvailableDocIds.size()` can be extracted to a var", "bodyText": "expectedAvailableDocIds.size() can be extracted to a var", "bodyHTML": "<p dir=\"auto\"><code>expectedAvailableDocIds.size()</code> can be extracted to a var</p>", "author": "ataillefer", "createdAt": "2020-02-27T10:00:33Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -180,4 +238,50 @@ protected void checkBlobContent(DocumentModel documentModel, String xpath, Strin\n         assertNotNull(content);\n         assertEquals(expectedContent, content.getString());\n     }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            assertEquals(expectedAvailableDocIds.size(), coldStorageContentStatus.getTotalAvailable());", "originalCommit": "2be78d0e1338ae9924a5b41f9ebf363c43d3afb1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 216ec2f83d1..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -247,10 +261,10 @@ public class TestColdStorage {\n                     session);\n \n             assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(expectedAvailableDocIds.size(), coldStorageContentStatus.getTotalAvailable());\n-\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n             assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedAvailableDocIds.size(), listener.streamCapturedEvents().count());\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n \n             List<String> docEventIds = listener.streamCapturedEvents() //\n                                                .map(event -> {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAyODQxMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385028412", "body": "I would remove \"for a given repository\" since the session is actually handled by `checkColdStorageContentAvailability`.", "bodyText": "I would remove \"for a given repository\" since the session is actually handled by checkColdStorageContentAvailability.", "bodyHTML": "<p dir=\"auto\">I would remove \"for a given repository\" since the session is actually handled by <code>checkColdStorageContentAvailability</code>.</p>", "author": "ataillefer", "createdAt": "2020-02-27T10:09:40Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -138,6 +204,29 @@ protected static String getContentBlobKey(Blob coldContent) {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available for a given repository.", "originalCommit": "2be78d0e1338ae9924a5b41f9ebf363c43d3afb1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex a666fd82beb..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -205,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNDY3MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385034670", "body": "Unused", "bodyText": "Unused", "bodyHTML": "<p dir=\"auto\">Unused</p>", "author": "ataillefer", "createdAt": "2020-02-27T10:21:24Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java", "diffHunk": "@@ -52,6 +58,12 @@\n     @Inject\n     protected AutomationService automationService;\n \n+    @Inject\n+    protected NotificationManager notificationManager;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;", "originalCommit": "dda56369d6828f247071862ca23a34e0e29df79f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nindex 093cf81e1f6..920697790ad 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -55,17 +53,11 @@ public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorage\n     @Inject\n     protected CoreSession session;\n \n-    @Inject\n-    protected AutomationService automationService;\n-\n     @Inject\n     protected NotificationManager notificationManager;\n \n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n     @Test\n-    public void shouldRequestRetrievalFromColdStorage() throws OperationException, IOException {\n+    public void shouldRequestRetrieval() throws OperationException, IOException {\n         DocumentModel documentModel = createFileDocument(session, true);\n         // first make the move to cold storage\n         moveContentToColdStorage(session, documentModel);\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\ndeleted file mode 100644\nindex 920697790ad..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ /dev/null\n", "chunk": "@@ -1,114 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-\n-/**\n- * @since 11.1\n- */\n-@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n-public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n-\n-    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected NotificationManager notificationManager;\n-\n-    @Test\n-    public void shouldRequestRetrieval() throws OperationException, IOException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        // first make the move to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-\n-        // move the blob to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-\n-        // request a retrieval for a second time\n-        try {\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        try {\n-            // request a retrieval from the cold storage content\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-        }\n-    }\n-\n-    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n-            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n-                    RequestRetrievalFromColdStorage.ID, params);\n-            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n-            assertEquals(Boolean.TRUE,\n-                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n-            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n-                    updatedDocument);\n-            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n-        }\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nnew file mode 100644\nindex 00000000000..920697790ad\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -0,0 +1,114 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n+public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected NotificationManager notificationManager;\n+\n+    @Test\n+    public void shouldRequestRetrieval() throws OperationException, IOException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        // first make the move to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+        // request a retrieval from the cold storage content\n+        requestRetrievalContentFromColdStorage(documentModel);\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+\n+        // move the blob to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+\n+        // request a retrieval from the cold storage content\n+        requestRetrievalContentFromColdStorage(documentModel);\n+\n+        // request a retrieval for a second time\n+        try {\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        try {\n+            // request a retrieval from the cold storage content\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+        }\n+    }\n+\n+    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n+                    RequestRetrievalFromColdStorage.ID, params);\n+            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n+            assertEquals(Boolean.TRUE,\n+                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n+            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n+                    updatedDocument);\n+            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n+        }\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\ndeleted file mode 100644\nindex 920697790ad..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ /dev/null\n", "chunk": "@@ -1,114 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-\n-/**\n- * @since 11.1\n- */\n-@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n-public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n-\n-    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected NotificationManager notificationManager;\n-\n-    @Test\n-    public void shouldRequestRetrieval() throws OperationException, IOException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        // first make the move to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-\n-        // move the blob to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-\n-        // request a retrieval for a second time\n-        try {\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        try {\n-            // request a retrieval from the cold storage content\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-        }\n-    }\n-\n-    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n-            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n-                    RequestRetrievalFromColdStorage.ID, params);\n-            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n-            assertEquals(Boolean.TRUE,\n-                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n-            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n-                    updatedDocument);\n-            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n-        }\n-    }\n-}\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nnew file mode 100644\nindex 00000000000..67040c021de\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Test\n+    public void shouldRequestRetrieval() throws OperationException, IOException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        // first make the move to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+        // request a retrieval from the cold storage\n+        requestRetrievalContentFromColdStorage(documentModel);\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+\n+        // move the blob to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+\n+        // request a retrieval from the cold storage\n+        requestRetrievalContentFromColdStorage(documentModel);\n+\n+        // request a retrieval for a second time\n+        try {\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        try {\n+            // request a retrieval from the cold storage\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+        }\n+    }\n+\n+    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n+                    RequestRetrievalFromColdStorage.ID, params);\n+            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n+            assertEquals(Boolean.TRUE,\n+                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+        }\n+    }\n+\n+}\n", "next_change": {"commit": "8494220b6af92225c79f9691f8fce5f49af7dded", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nindex 67040c021de..8f19eb65b87 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -96,6 +105,10 @@ public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorage\n             assertEquals(documentModel.getRef(), updatedDocument.getRef());\n             assertEquals(Boolean.TRUE,\n                     updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n+            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n+                    updatedDocument);\n+            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzNTQwOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385035409", "body": "Unused, should be removed along with https://github.com/nuxeo/nuxeo/pull/3666/commits/938191c373574825b97c76659cc5c57026ab8865", "bodyText": "Unused, should be removed along with 938191c", "bodyHTML": "<p dir=\"auto\">Unused, should be removed along with <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/nuxeo/nuxeo/commit/938191c373574825b97c76659cc5c57026ab8865/hovercard\" href=\"https://github.com/nuxeo/nuxeo/commit/938191c373574825b97c76659cc5c57026ab8865\"><tt>938191c</tt></a></p>", "author": "ataillefer", "createdAt": "2020-02-27T10:22:41Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java", "diffHunk": "@@ -52,6 +58,12 @@\n     @Inject\n     protected AutomationService automationService;", "originalCommit": "dda56369d6828f247071862ca23a34e0e29df79f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nindex 093cf81e1f6..920697790ad 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -55,17 +53,11 @@ public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorage\n     @Inject\n     protected CoreSession session;\n \n-    @Inject\n-    protected AutomationService automationService;\n-\n     @Inject\n     protected NotificationManager notificationManager;\n \n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n     @Test\n-    public void shouldRequestRetrievalFromColdStorage() throws OperationException, IOException {\n+    public void shouldRequestRetrieval() throws OperationException, IOException {\n         DocumentModel documentModel = createFileDocument(session, true);\n         // first make the move to cold storage\n         moveContentToColdStorage(session, documentModel);\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\ndeleted file mode 100644\nindex 920697790ad..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ /dev/null\n", "chunk": "@@ -1,114 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-\n-/**\n- * @since 11.1\n- */\n-@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n-public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n-\n-    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected NotificationManager notificationManager;\n-\n-    @Test\n-    public void shouldRequestRetrieval() throws OperationException, IOException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        // first make the move to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-\n-        // move the blob to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-\n-        // request a retrieval for a second time\n-        try {\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        try {\n-            // request a retrieval from the cold storage content\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-        }\n-    }\n-\n-    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n-            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n-                    RequestRetrievalFromColdStorage.ID, params);\n-            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n-            assertEquals(Boolean.TRUE,\n-                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n-            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n-                    updatedDocument);\n-            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n-        }\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nnew file mode 100644\nindex 00000000000..920697790ad\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -0,0 +1,114 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n+public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected NotificationManager notificationManager;\n+\n+    @Test\n+    public void shouldRequestRetrieval() throws OperationException, IOException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        // first make the move to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+        // request a retrieval from the cold storage content\n+        requestRetrievalContentFromColdStorage(documentModel);\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+\n+        // move the blob to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+\n+        // request a retrieval from the cold storage content\n+        requestRetrievalContentFromColdStorage(documentModel);\n+\n+        // request a retrieval for a second time\n+        try {\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        try {\n+            // request a retrieval from the cold storage content\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+        }\n+    }\n+\n+    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n+                    RequestRetrievalFromColdStorage.ID, params);\n+            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n+            assertEquals(Boolean.TRUE,\n+                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n+            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n+                    updatedDocument);\n+            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n+        }\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\ndeleted file mode 100644\nindex 920697790ad..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ /dev/null\n", "chunk": "@@ -1,114 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-\n-/**\n- * @since 11.1\n- */\n-@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n-public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n-\n-    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected NotificationManager notificationManager;\n-\n-    @Test\n-    public void shouldRequestRetrieval() throws OperationException, IOException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        // first make the move to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-\n-        // move the blob to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-\n-        // request a retrieval for a second time\n-        try {\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        try {\n-            // request a retrieval from the cold storage content\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-        }\n-    }\n-\n-    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n-            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n-                    RequestRetrievalFromColdStorage.ID, params);\n-            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n-            assertEquals(Boolean.TRUE,\n-                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n-            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n-                    updatedDocument);\n-            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n-        }\n-    }\n-}\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nnew file mode 100644\nindex 00000000000..67040c021de\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Test\n+    public void shouldRequestRetrieval() throws OperationException, IOException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        // first make the move to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+        // request a retrieval from the cold storage\n+        requestRetrievalContentFromColdStorage(documentModel);\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+\n+        // move the blob to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+\n+        // request a retrieval from the cold storage\n+        requestRetrievalContentFromColdStorage(documentModel);\n+\n+        // request a retrieval for a second time\n+        try {\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        try {\n+            // request a retrieval from the cold storage\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+        }\n+    }\n+\n+    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n+                    RequestRetrievalFromColdStorage.ID, params);\n+            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n+            assertEquals(Boolean.TRUE,\n+                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+        }\n+    }\n+\n+}\n", "next_change": {"commit": "8494220b6af92225c79f9691f8fce5f49af7dded", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nindex 67040c021de..8f19eb65b87 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -96,6 +105,10 @@ public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorage\n             assertEquals(documentModel.getRef(), updatedDocument.getRef());\n             assertEquals(Boolean.TRUE,\n                     updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n+            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n+                    updatedDocument);\n+            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzODYyMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385038621", "body": "Is concurrency needed? If yes, maybe a comment to explain why.", "bodyText": "Is concurrency needed? If yes, maybe a comment to explain why.", "bodyHTML": "<p dir=\"auto\">Is concurrency needed? If yes, maybe a comment to explain why.</p>", "author": "ataillefer", "createdAt": "2020-02-27T10:28:34Z", "path": "nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java", "diffHunk": "@@ -42,12 +44,16 @@\n \n     protected Map<String, byte[]> blobs;\n \n+    /** @since 11.1 **/\n+    protected Map<String, BlobStatus> blobsStatus;\n+\n     protected AtomicLong counter;\n \n     @Override\n     public void initialize(String blobProviderId, Map<String, String> properties) throws IOException {\n         super.initialize(blobProviderId, properties);\n         blobs = new HashMap<>();\n+        blobsStatus = new ConcurrentHashMap<>();", "originalCommit": "6098a8e97c6a60722259b6eea505d6e2ac1aa1ad", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java b/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\nindex 7fd684b4c2e..87c8c6a252d 100644\n--- a/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\n+++ b/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\n", "chunk": "@@ -53,7 +52,7 @@ public class DummyBlobProvider extends AbstractBlobProvider {\n     public void initialize(String blobProviderId, Map<String, String> properties) throws IOException {\n         super.initialize(blobProviderId, properties);\n         blobs = new HashMap<>();\n-        blobsStatus = new ConcurrentHashMap<>();\n+        blobsStatus = new HashMap<>();\n         counter = new AtomicLong();\n     }\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java b/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\nindex 87c8c6a252d..ec271c14bfb 100644\n--- a/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\n+++ b/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\n", "chunk": "@@ -43,16 +42,12 @@ public class DummyBlobProvider extends AbstractBlobProvider {\n \n     protected Map<String, byte[]> blobs;\n \n-    /** @since 11.1 **/\n-    protected Map<String, BlobStatus> blobsStatus;\n-\n     protected AtomicLong counter;\n \n     @Override\n     public void initialize(String blobProviderId, Map<String, String> properties) throws IOException {\n         super.initialize(blobProviderId, properties);\n         blobs = new HashMap<>();\n-        blobsStatus = new HashMap<>();\n         counter = new AtomicLong();\n     }\n \n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java b/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\nindex ec271c14bfb..87c8c6a252d 100644\n--- a/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\n+++ b/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\n", "chunk": "@@ -42,12 +43,16 @@ public class DummyBlobProvider extends AbstractBlobProvider {\n \n     protected Map<String, byte[]> blobs;\n \n+    /** @since 11.1 **/\n+    protected Map<String, BlobStatus> blobsStatus;\n+\n     protected AtomicLong counter;\n \n     @Override\n     public void initialize(String blobProviderId, Map<String, String> properties) throws IOException {\n         super.initialize(blobProviderId, properties);\n         blobs = new HashMap<>();\n+        blobsStatus = new HashMap<>();\n         counter = new AtomicLong();\n     }\n \n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java b/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\nindex 87c8c6a252d..ec271c14bfb 100644\n--- a/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\n+++ b/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\n", "chunk": "@@ -43,16 +42,12 @@ public class DummyBlobProvider extends AbstractBlobProvider {\n \n     protected Map<String, byte[]> blobs;\n \n-    /** @since 11.1 **/\n-    protected Map<String, BlobStatus> blobsStatus;\n-\n     protected AtomicLong counter;\n \n     @Override\n     public void initialize(String blobProviderId, Map<String, String> properties) throws IOException {\n         super.initialize(blobProviderId, properties);\n         blobs = new HashMap<>();\n-        blobsStatus = new HashMap<>();\n         counter = new AtomicLong();\n     }\n \n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java b/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\nindex ec271c14bfb..87c8c6a252d 100644\n--- a/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\n+++ b/nuxeo-core/nuxeo-core-test/src/main/java/org/nuxeo/ecm/core/DummyBlobProvider.java\n", "chunk": "@@ -42,12 +43,16 @@ public class DummyBlobProvider extends AbstractBlobProvider {\n \n     protected Map<String, byte[]> blobs;\n \n+    /** @since 11.1 **/\n+    protected Map<String, BlobStatus> blobsStatus;\n+\n     protected AtomicLong counter;\n \n     @Override\n     public void initialize(String blobProviderId, Map<String, String> properties) throws IOException {\n         super.initialize(blobProviderId, properties);\n         blobs = new HashMap<>();\n+        blobsStatus = new HashMap<>();\n         counter = new AtomicLong();\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI2MDk0OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385260949", "body": "Juste call the exception the traditional `e` if there's no chance of confusion (in several methods).", "bodyText": "Juste call the exception the traditional e if there's no chance of confusion (in several methods).", "bodyHTML": "<p dir=\"auto\">Juste call the exception the traditional <code>e</code> if there's no chance of confusion (in several methods).</p>", "author": "efge", "createdAt": "2020-02-27T17:30:14Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.*;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.*;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Test\n+    public void shouldMoveBlobDocumentToColdStorage() throws IOException {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` contains the original file content\n+        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException ne) {", "originalCommit": "0439203e669a8dfefa79745d262534c891993641", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 1fa64aa59a8..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -66,42 +102,144 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n-        DocumentModel documentModel = createDocument(false);\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI2NDUzOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385264538", "body": "It must be possible to skip the `saveDocument` step if the right param is set (as it helps having faster chained operations). Please see all the other operation classes that have `@Param(name = \"save\", required = false, values = \"true\")`", "bodyText": "It must be possible to skip the saveDocument step if the right param is set (as it helps having faster chained operations). Please see all the other operation classes that have @Param(name = \"save\", required = false, values = \"true\")", "bodyHTML": "<p dir=\"auto\">It must be possible to skip the <code>saveDocument</code> step if the right param is set (as it helps having faster chained operations). Please see all the other operation classes that have <code>@Param(name = \"save\", required = false, values = \"true\")</code></p>", "author": "efge", "createdAt": "2020-02-27T17:36:58Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import java.io.Serializable;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.thumbnail.ThumbnailService;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Moves the main content associated with the input {@link DocumentModel} to the cold storage.\n+ * \n+ * @since 11.1\n+ */\n+@Operation(id = MoveToColdStorage.ID, category = Constants.CAT_BLOB, label = \"Move to Cold Storage\", description = \"Move the main document content to the cold storage.\")\n+public class MoveToColdStorage {\n+\n+    public static final String ID = \"Document.MoveToColdStorage\";\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        // retrieve the thumbnail which will be used to replace the content, once the move done\n+        Blob thumbnail = Framework.getService(ThumbnailService.class).getThumbnail(doc, session);\n+\n+        // make the move\n+        DocumentModel documentModel = ColdStorageHelper.moveContentToColdStorage(session, doc.getRef());\n+\n+        // replace the file content document by the thumbnail\n+        documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY, (Serializable) thumbnail);\n+        return session.saveDocument(documentModel);", "originalCommit": "0439203e669a8dfefa79745d262534c891993641", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java\nindex 9040335e40d..d320f75dd53 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java\n", "chunk": "@@ -56,6 +60,10 @@ public class MoveToColdStorage {\n \n         // replace the file content document by the thumbnail\n         documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY, (Serializable) thumbnail);\n-        return session.saveDocument(documentModel);\n+        if (save) {\n+            documentModel = session.saveDocument(documentModel);\n+        }\n+\n+        return documentModel;\n     }\n }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java\ndeleted file mode 100644\nindex d320f75dd53..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,69 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import java.io.Serializable;\n-\n-import org.nuxeo.ecm.automation.core.Constants;\n-import org.nuxeo.ecm.automation.core.annotations.Context;\n-import org.nuxeo.ecm.automation.core.annotations.Operation;\n-import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n-import org.nuxeo.ecm.automation.core.annotations.Param;\n-import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.thumbnail.ThumbnailService;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Moves the main content associated with the input {@link DocumentModel} to the cold storage.\n- * \n- * @since 11.1\n- */\n-@Operation(id = MoveToColdStorage.ID, category = Constants.CAT_BLOB, label = \"Move to Cold Storage\", description = \"Move the main document content to the cold storage.\")\n-public class MoveToColdStorage {\n-\n-    public static final String ID = \"Document.MoveToColdStorage\";\n-\n-    @Context\n-    protected CoreSession session;\n-\n-    @Param(name = \"save\", required = false, values = \"true\")\n-    protected boolean save = true;\n-\n-    @OperationMethod(collector = DocumentModelCollector.class)\n-    public DocumentModel run(DocumentModel doc) {\n-        // retrieve the thumbnail which will be used to replace the content, once the move done\n-        Blob thumbnail = Framework.getService(ThumbnailService.class).getThumbnail(doc, session);\n-\n-        // make the move\n-        DocumentModel documentModel = ColdStorageHelper.moveContentToColdStorage(session, doc.getRef());\n-\n-        // replace the file content document by the thumbnail\n-        documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY, (Serializable) thumbnail);\n-        if (save) {\n-            documentModel = session.saveDocument(documentModel);\n-        }\n-\n-        return documentModel;\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java\nnew file mode 100644\nindex 00000000000..d320f75dd53\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java\n", "chunk": "@@ -0,0 +1,69 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import java.io.Serializable;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.thumbnail.ThumbnailService;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Moves the main content associated with the input {@link DocumentModel} to the cold storage.\n+ * \n+ * @since 11.1\n+ */\n+@Operation(id = MoveToColdStorage.ID, category = Constants.CAT_BLOB, label = \"Move to Cold Storage\", description = \"Move the main document content to the cold storage.\")\n+public class MoveToColdStorage {\n+\n+    public static final String ID = \"Document.MoveToColdStorage\";\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @Param(name = \"save\", required = false, values = \"true\")\n+    protected boolean save = true;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        // retrieve the thumbnail which will be used to replace the content, once the move done\n+        Blob thumbnail = Framework.getService(ThumbnailService.class).getThumbnail(doc, session);\n+\n+        // make the move\n+        DocumentModel documentModel = ColdStorageHelper.moveContentToColdStorage(session, doc.getRef());\n+\n+        // replace the file content document by the thumbnail\n+        documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY, (Serializable) thumbnail);\n+        if (save) {\n+            documentModel = session.saveDocument(documentModel);\n+        }\n+\n+        return documentModel;\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java\nindex d320f75dd53..524f02d818f 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/MoveToColdStorage.java\n", "chunk": "@@ -66,4 +66,5 @@ public class MoveToColdStorage {\n \n         return documentModel;\n     }\n+\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI2NjA3NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385266074", "body": "Let's make `numberOfDaysOfAvailability` a `Duration` directly in the signature instead of an `int`, and use durations everywhere we can.", "bodyText": "Let's make numberOfDaysOfAvailability a Duration directly in the signature instead of an int, and use durations everywhere we can.", "bodyHTML": "<p dir=\"auto\">Let's make <code>numberOfDaysOfAvailability</code> a <code>Duration</code> directly in the signature instead of an <code>int</code>, and use durations everywhere we can.</p>", "author": "efge", "createdAt": "2020-02-27T17:39:52Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -75,6 +83,61 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            int numberOfDaysOfAvailability) {", "originalCommit": "938191c373574825b97c76659cc5c57026ab8865", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 1907b98b0ce..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -88,19 +104,20 @@ public class ColdStorageHelper {\n      *\n      * @param session the core session\n      * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n      * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n      *          process doesn't mean you will get the blob's content.\n      * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n     public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n         DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n \n         if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI2NzA1MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385267050", "body": "`RESTORE_DURATION = Duration.ofDays(5)`", "bodyText": "RESTORE_DURATION = Duration.ofDays(5)", "bodyHTML": "<p dir=\"auto\"><code>RESTORE_DURATION = Duration.ofDays(5)</code></p>", "author": "efge", "createdAt": "2020-02-27T17:41:33Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -47,6 +56,8 @@\n \n     protected static final String FILE_CONTENT = \"foo\";\n \n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;", "originalCommit": "938191c373574825b97c76659cc5c57026ab8865", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 225d6e5236f..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -56,7 +72,9 @@ public class TestColdStorage {\n \n     protected static final String FILE_CONTENT = \"foo\";\n \n-    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n \n     @Inject\n     protected CoreSession session;\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI2NzY4MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385267680", "body": "`{} days` will change if we use durations everywhere. `{}` of a duration should be enough for debug.", "bodyText": "{} days will change if we use durations everywhere. {} of a duration should be enough for debug.", "bodyHTML": "<p dir=\"auto\"><code>{} days</code> will change if we use durations everywhere. <code>{}</code> of a duration should be enough for debug.</p>", "author": "efge", "createdAt": "2020-02-27T17:42:48Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -75,6 +83,61 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            int numberOfDaysOfAvailability) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,", "originalCommit": "938191c373574825b97c76659cc5c57026ab8865", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 1907b98b0ce..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -88,19 +104,20 @@ public class ColdStorageHelper {\n      *\n      * @param session the core session\n      * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n      * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n      *          process doesn't mean you will get the blob's content.\n      * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n     public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n         DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n \n         if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI2Nzg3MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385267870", "body": "`ioe` -> `e`", "bodyText": "ioe -> e", "bodyHTML": "<p dir=\"auto\"><code>ioe</code> -&gt; <code>e</code></p>", "author": "efge", "createdAt": "2020-02-27T17:43:11Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -75,6 +83,61 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            int numberOfDaysOfAvailability) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n+                numberOfDaysOfAvailability);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String coldContentKey = getContentBlobKey(coldContent);\n+            Duration duration = Duration.of(numberOfDaysOfAvailability, ChronoUnit.DAYS);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(coldContentKey).withRestoreForDuration(duration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException ioe) {", "originalCommit": "938191c373574825b97c76659cc5c57026ab8865", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 1907b98b0ce..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -118,15 +135,72 @@ public class ColdStorageHelper {\n \n         try {\n             Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String coldContentKey = getContentBlobKey(coldContent);\n-            Duration duration = Duration.of(numberOfDaysOfAvailability, ChronoUnit.DAYS);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(coldContentKey).withRestoreForDuration(duration);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n             Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException ioe) {\n-            throw new NuxeoException(ioe);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n         }\n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     protected static String getContentBlobKey(Blob coldContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3MDA1Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385270056", "body": "There's something we probably have to refactor a bit to make this easier on the caller here. Later.", "bodyText": "There's something we probably have to refactor a bit to make this easier on the caller here. Later.", "bodyHTML": "<p dir=\"auto\">There's something we probably have to refactor a bit to make this easier on the caller here. Later.</p>", "author": "efge", "createdAt": "2020-02-27T17:47:31Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -75,6 +83,61 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            int numberOfDaysOfAvailability) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n+                numberOfDaysOfAvailability);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String coldContentKey = getContentBlobKey(coldContent);\n+            Duration duration = Duration.of(numberOfDaysOfAvailability, ChronoUnit.DAYS);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(coldContentKey).withRestoreForDuration(duration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);", "originalCommit": "938191c373574825b97c76659cc5c57026ab8865", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NzczMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r386367730", "bodyText": "You mean later / other ticket(s) ?", "author": "RSalem07", "createdAt": "2020-03-02T12:37:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3MDA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxMTI5NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r386411294", "bodyText": "Yes we'll do it later, that was just FYI.", "author": "efge", "createdAt": "2020-03-02T14:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3MDA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 1907b98b0ce..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -118,15 +135,72 @@ public class ColdStorageHelper {\n \n         try {\n             Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String coldContentKey = getContentBlobKey(coldContent);\n-            Duration duration = Duration.of(numberOfDaysOfAvailability, ChronoUnit.DAYS);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(coldContentKey).withRestoreForDuration(duration);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n             Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException ioe) {\n-            throw new NuxeoException(ioe);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n         }\n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     protected static String getContentBlobKey(Blob coldContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3MDk3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385270972", "body": "Not sure we want to call `saveDocument` here, that probably should be an option in the operation too. Again, to avoid doing redundant saves.", "bodyText": "Not sure we want to call saveDocument here, that probably should be an option in the operation too. Again, to avoid doing redundant saves.", "bodyHTML": "<p dir=\"auto\">Not sure we want to call <code>saveDocument</code> here, that probably should be an option in the operation too. Again, to avoid doing redundant saves.</p>", "author": "efge", "createdAt": "2020-02-27T17:49:12Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -75,6 +83,61 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            int numberOfDaysOfAvailability) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n+                numberOfDaysOfAvailability);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String coldContentKey = getContentBlobKey(coldContent);\n+            Duration duration = Duration.of(numberOfDaysOfAvailability, ChronoUnit.DAYS);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(coldContentKey).withRestoreForDuration(duration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException ioe) {\n+            throw new NuxeoException(ioe);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return session.saveDocument(documentModel);", "originalCommit": "938191c373574825b97c76659cc5c57026ab8865", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI3NjMzNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r386276337", "bodyText": "ok, I will remove the call to the saveDocument here, and it will be the responsibility of the caller to make the save (for example in my tests I saved it explicitly) and I will add the save param on the operations.", "author": "RSalem07", "createdAt": "2020-03-02T09:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3MDk3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 1907b98b0ce..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -118,15 +135,72 @@ public class ColdStorageHelper {\n \n         try {\n             Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String coldContentKey = getContentBlobKey(coldContent);\n-            Duration duration = Duration.of(numberOfDaysOfAvailability, ChronoUnit.DAYS);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(coldContentKey).withRestoreForDuration(duration);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n             Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException ioe) {\n-            throw new NuxeoException(ioe);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n         }\n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     protected static String getContentBlobKey(Blob coldContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3MTU5Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385271592", "body": "`assertEquals(Boolean.TRUE, ...)`", "bodyText": "assertEquals(Boolean.TRUE, ...)", "bodyHTML": "<p dir=\"auto\"><code>assertEquals(Boolean.TRUE, ...)</code></p>", "author": "efge", "createdAt": "2020-02-27T17:50:15Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -100,6 +111,61 @@ public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n         }\n     }\n \n+    @Test\n+    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(Boolean.TRUE.equals(\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));", "originalCommit": "938191c373574825b97c76659cc5c57026ab8865", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 225d6e5236f..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -77,97 +102,144 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n-        DocumentModel documentModel = createDocument(false);\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3MTcwNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385271707", "body": "`ne` -> `e`", "bodyText": "ne -> e", "bodyHTML": "<p dir=\"auto\"><code>ne</code> -&gt; <code>e</code></p>", "author": "efge", "createdAt": "2020-02-27T17:50:29Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -100,6 +111,61 @@ public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n         }\n     }\n \n+    @Test\n+    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(Boolean.TRUE.equals(\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+    }\n+\n+    @Test\n+    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException ne) {", "originalCommit": "938191c373574825b97c76659cc5c57026ab8865", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 225d6e5236f..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -77,97 +102,144 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n-        DocumentModel documentModel = createDocument(false);\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3MjUxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385272516", "body": "Add optional `saveDocument` here too (and not in helper)", "bodyText": "Add optional saveDocument here too (and not in helper)", "bodyHTML": "<p dir=\"auto\">Add optional <code>saveDocument</code> here too (and not in helper)</p>", "author": "efge", "createdAt": "2020-02-27T17:51:57Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Requests a retrieval from the cold storage content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n+ *\n+ * @since 11.1\n+ */\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval of the cold storage content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n+\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n+\n+    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n+    protected int numberOfDaysOfAvailability;\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        // request a retrieval\n+        return ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(), numberOfDaysOfAvailability);", "originalCommit": "938191c373574825b97c76659cc5c57026ab8865", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nindex 09c816bae39..ff037ccacda 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -48,9 +54,26 @@ public class RequestRetrievalFromColdStorage {\n     @Context\n     protected CoreSession session;\n \n+    @Param(name = \"save\", required = false, values = \"true\")\n+    protected boolean save = true;\n+\n     @OperationMethod(collector = DocumentModelCollector.class)\n     public DocumentModel run(DocumentModel doc) {\n-        // request a retrieval\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(), numberOfDaysOfAvailability);\n+        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n+                Duration.ofDays(numberOfDaysOfAvailability));\n+\n+        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n+        NuxeoPrincipal principal = session.getPrincipal();\n+        String username = NotificationConstants.USER_PREFIX + principal.getName();\n+        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n+        notificationManager.addSubscription(username,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n+\n+        if (save) {\n+            documentModel = session.saveDocument(documentModel);\n+        }\n+\n+        return documentModel;\n     }\n }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\ndeleted file mode 100644\nindex ff037ccacda..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,79 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import java.time.Duration;\n-\n-import org.nuxeo.ecm.automation.core.Constants;\n-import org.nuxeo.ecm.automation.core.annotations.Context;\n-import org.nuxeo.ecm.automation.core.annotations.Operation;\n-import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n-import org.nuxeo.ecm.automation.core.annotations.Param;\n-import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n- * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n- * get the blob's content.\n- *\n- * @since 11.1\n- */\n-@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n-public class RequestRetrievalFromColdStorage {\n-\n-    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n-\n-    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n-    protected int numberOfDaysOfAvailability;\n-\n-    @Context\n-    protected CoreSession session;\n-\n-    @Param(name = \"save\", required = false, values = \"true\")\n-    protected boolean save = true;\n-\n-    @OperationMethod(collector = DocumentModelCollector.class)\n-    public DocumentModel run(DocumentModel doc) {\n-        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n-                Duration.ofDays(numberOfDaysOfAvailability));\n-\n-        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n-        NuxeoPrincipal principal = session.getPrincipal();\n-        String username = NotificationConstants.USER_PREFIX + principal.getName();\n-        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n-        notificationManager.addSubscription(username,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n-\n-        if (save) {\n-            documentModel = session.saveDocument(documentModel);\n-        }\n-\n-        return documentModel;\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nnew file mode 100644\nindex 00000000000..ff037ccacda\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -0,0 +1,79 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import java.time.Duration;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n+ *\n+ * @since 11.1\n+ */\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n+\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n+\n+    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n+    protected int numberOfDaysOfAvailability;\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @Param(name = \"save\", required = false, values = \"true\")\n+    protected boolean save = true;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n+                Duration.ofDays(numberOfDaysOfAvailability));\n+\n+        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n+        NuxeoPrincipal principal = session.getPrincipal();\n+        String username = NotificationConstants.USER_PREFIX + principal.getName();\n+        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n+        notificationManager.addSubscription(username,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n+\n+        if (save) {\n+            documentModel = session.saveDocument(documentModel);\n+        }\n+\n+        return documentModel;\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\ndeleted file mode 100644\nindex ff037ccacda..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,79 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import java.time.Duration;\n-\n-import org.nuxeo.ecm.automation.core.Constants;\n-import org.nuxeo.ecm.automation.core.annotations.Context;\n-import org.nuxeo.ecm.automation.core.annotations.Operation;\n-import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n-import org.nuxeo.ecm.automation.core.annotations.Param;\n-import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n- * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n- * get the blob's content.\n- *\n- * @since 11.1\n- */\n-@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n-public class RequestRetrievalFromColdStorage {\n-\n-    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n-\n-    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n-    protected int numberOfDaysOfAvailability;\n-\n-    @Context\n-    protected CoreSession session;\n-\n-    @Param(name = \"save\", required = false, values = \"true\")\n-    protected boolean save = true;\n-\n-    @OperationMethod(collector = DocumentModelCollector.class)\n-    public DocumentModel run(DocumentModel doc) {\n-        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n-                Duration.ofDays(numberOfDaysOfAvailability));\n-\n-        // auto-subscribe the user, this way they will receive the mail notification when the content is available\n-        NuxeoPrincipal principal = session.getPrincipal();\n-        String username = NotificationConstants.USER_PREFIX + principal.getName();\n-        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n-        notificationManager.addSubscription(username,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, documentModel, false, principal,\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n-\n-        if (save) {\n-            documentModel = session.saveDocument(documentModel);\n-        }\n-\n-        return documentModel;\n-    }\n-}\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\nnew file mode 100644\nindex 00000000000..9d5b155d9ae\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/main/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -0,0 +1,68 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import java.time.Duration;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Requests a retrieval from cold storage of the content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n+ *\n+ * @since 11.1\n+ */\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval from cold storage of the content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n+\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n+\n+    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n+    protected int numberOfDaysOfAvailability;\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @Param(name = \"save\", required = false, values = \"true\")\n+    protected boolean save = true;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        DocumentModel documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(),\n+                Duration.ofDays(numberOfDaysOfAvailability));\n+\n+        if (save) {\n+            documentModel = session.saveDocument(documentModel);\n+        }\n+\n+        return documentModel;\n+    }\n+\n+}\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3MzA1NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385273054", "body": "`ne` -> `e`", "bodyText": "ne -> e", "bodyHTML": "<p dir=\"auto\"><code>ne</code> -&gt; <code>e</code></p>", "author": "efge", "createdAt": "2020-02-27T17:52:57Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected AutomationService automationService;\n+\n+    @Test\n+    public void shouldRequestRetrievalFromColdStorage() throws OperationException, IOException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        // first make the move to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+        // request a retrieval from the cold storage content\n+        requestRetrievalContentFromColdStorage(documentModel);\n+    }\n+\n+    @Test\n+    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved()\n+            throws IOException, OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+\n+        // move the blob to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+\n+        // request a retrieval from the cold storage content\n+        requestRetrievalContentFromColdStorage(documentModel);\n+\n+        // request a retrieval for a second time\n+        try {\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException ne) {", "originalCommit": "938191c373574825b97c76659cc5c57026ab8865", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nindex 4d6e93dc6bb..920697790ad 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -76,20 +79,20 @@ public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorage\n         try {\n             requestRetrievalContentFromColdStorage(documentModel);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobWithoutColdStorageContent() throws OperationException {\n+    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n         DocumentModel documentModel = createFileDocument(session, true);\n         try {\n             // request a retrieval from the cold storage content\n             requestRetrievalContentFromColdStorage(documentModel);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n         }\n     }\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\ndeleted file mode 100644\nindex 920697790ad..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ /dev/null\n", "chunk": "@@ -1,114 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-\n-/**\n- * @since 11.1\n- */\n-@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n-public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n-\n-    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected NotificationManager notificationManager;\n-\n-    @Test\n-    public void shouldRequestRetrieval() throws OperationException, IOException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        // first make the move to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-\n-        // move the blob to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-\n-        // request a retrieval for a second time\n-        try {\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        try {\n-            // request a retrieval from the cold storage content\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-        }\n-    }\n-\n-    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n-            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n-                    RequestRetrievalFromColdStorage.ID, params);\n-            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n-            assertEquals(Boolean.TRUE,\n-                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n-            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n-                    updatedDocument);\n-            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n-        }\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nnew file mode 100644\nindex 00000000000..920697790ad\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -0,0 +1,114 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n+public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected NotificationManager notificationManager;\n+\n+    @Test\n+    public void shouldRequestRetrieval() throws OperationException, IOException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        // first make the move to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+        // request a retrieval from the cold storage content\n+        requestRetrievalContentFromColdStorage(documentModel);\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+\n+        // move the blob to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+\n+        // request a retrieval from the cold storage content\n+        requestRetrievalContentFromColdStorage(documentModel);\n+\n+        // request a retrieval for a second time\n+        try {\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        try {\n+            // request a retrieval from the cold storage content\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+        }\n+    }\n+\n+    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n+                    RequestRetrievalFromColdStorage.ID, params);\n+            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n+            assertEquals(Boolean.TRUE,\n+                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n+            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n+                    updatedDocument);\n+            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n+        }\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\ndeleted file mode 100644\nindex 920697790ad..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ /dev/null\n", "chunk": "@@ -1,114 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.coldstorage;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-\n-/**\n- * @since 11.1\n- */\n-@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n-public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n-\n-    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected NotificationManager notificationManager;\n-\n-    @Test\n-    public void shouldRequestRetrieval() throws OperationException, IOException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        // first make the move to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-\n-        // move the blob to cold storage\n-        moveContentToColdStorage(session, documentModel);\n-\n-        // request a retrieval from the cold storage content\n-        requestRetrievalContentFromColdStorage(documentModel);\n-\n-        // request a retrieval for a second time\n-        try {\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n-        DocumentModel documentModel = createFileDocument(session, true);\n-        try {\n-            // request a retrieval from the cold storage content\n-            requestRetrievalContentFromColdStorage(documentModel);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-        }\n-    }\n-\n-    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n-            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n-                    RequestRetrievalFromColdStorage.ID, params);\n-            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n-            assertEquals(Boolean.TRUE,\n-                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n-            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n-                    updatedDocument);\n-            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n-        }\n-    }\n-}\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nnew file mode 100644\nindex 00000000000..67040c021de\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.coldstorage;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorageOperation {\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Test\n+    public void shouldRequestRetrieval() throws OperationException, IOException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        // first make the move to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+        // request a retrieval from the cold storage\n+        requestRetrievalContentFromColdStorage(documentModel);\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() throws IOException, OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+\n+        // move the blob to cold storage\n+        moveContentToColdStorage(session, documentModel);\n+\n+        // request a retrieval from the cold storage\n+        requestRetrievalContentFromColdStorage(documentModel);\n+\n+        // request a retrieval for a second time\n+        try {\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() throws OperationException {\n+        DocumentModel documentModel = createFileDocument(session, true);\n+        try {\n+            // request a retrieval from the cold storage\n+            requestRetrievalContentFromColdStorage(documentModel);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+        }\n+    }\n+\n+    protected void requestRetrievalContentFromColdStorage(DocumentModel documentModel) throws OperationException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            DocumentModel updatedDocument = (DocumentModel) automationService.run(context,\n+                    RequestRetrievalFromColdStorage.ID, params);\n+            assertEquals(documentModel.getRef(), updatedDocument.getRef());\n+            assertEquals(Boolean.TRUE,\n+                    updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+        }\n+    }\n+\n+}\n", "next_change": {"commit": "8494220b6af92225c79f9691f8fce5f49af7dded", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\nindex 67040c021de..8f19eb65b87 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-features/src/test/java/org/nuxeo/ecm/automation/core/operations/coldstorage/RequestRetrievalFromColdStorageTest.java\n", "chunk": "@@ -96,6 +105,10 @@ public class RequestRetrievalFromColdStorageTest extends AbstractTestColdStorage\n             assertEquals(documentModel.getRef(), updatedDocument.getRef());\n             assertEquals(Boolean.TRUE,\n                     updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+            String username = NotificationConstants.USER_PREFIX + session.getPrincipal().getName();\n+            List<String> subscriptions = notificationManager.getSubscriptionsForUserOnDocument(username,\n+                    updatedDocument);\n+            assertTrue(subscriptions.contains(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME));\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3NDQ2MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r385274460", "body": "`ioe` -> `e`", "bodyText": "ioe -> e", "bodyHTML": "<p dir=\"auto\"><code>ioe</code> -&gt; <code>e</code></p>", "author": "efge", "createdAt": "2020-02-27T17:55:37Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -129,6 +140,61 @@ public static DocumentModel requestRetrievalFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException ioe) {", "originalCommit": "2be78d0e1338ae9924a5b41f9ebf363c43d3afb1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex a666fd82beb..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -158,6 +163,7 @@ public class ColdStorageHelper {\n         int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n         for (DocumentModel doc : documents) {\n             Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n             BlobStatus blobStatus;\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex a666fd82beb..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -165,9 +171,9 @@ public class ColdStorageHelper {\n                 blobStatus = Framework.getService(BlobManager.class)\n                                       .getBlobProvider(coldContent)\n                                       .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException ioe) {\n+            } catch (IOException e) {\n                 // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, ioe);\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n                 continue;\n             }\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "3921c544589eed9e16b666e57822f4e562ce5cca", "url": "https://github.com/nuxeo/nuxeo/commit/3921c544589eed9e16b666e57822f4e562ce5cca", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-03-02T11:41:54Z", "type": "forcePushed"}, {"oid": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "url": "https://github.com/nuxeo/nuxeo/commit/94fc5de9abd337fa96bb19956d2dcf13678df6c3", "message": "NXP-28424: Cleanup / Format", "committedDate": "2020-03-02T11:47:24Z", "type": "commit"}, {"oid": "e2a5f21ebd983a892f776bbdbb1d19f0cc4a2db6", "url": "https://github.com/nuxeo/nuxeo/commit/e2a5f21ebd983a892f776bbdbb1d19f0cc4a2db6", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-03-02T11:47:24Z", "type": "commit"}, {"oid": "7f6187645f29f572048e25b83e3146b439371aab", "url": "https://github.com/nuxeo/nuxeo/commit/7f6187645f29f572048e25b83e3146b439371aab", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-03-02T11:47:24Z", "type": "forcePushed"}, {"oid": "4e8922cc4602dcb71f119c038d59ab16144f9511", "url": "https://github.com/nuxeo/nuxeo/commit/4e8922cc4602dcb71f119c038d59ab16144f9511", "message": "NXP-28425: Add MoveToColdStorage operation", "committedDate": "2020-03-02T12:55:24Z", "type": "commit"}, {"oid": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "url": "https://github.com/nuxeo/nuxeo/commit/95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "message": "NXP-28427: Add RetrieveBlobFromColdStorage operation", "committedDate": "2020-03-02T12:57:03Z", "type": "commit"}, {"oid": "dad01caec1995a3ab7f20f998088cf6a74473643", "url": "https://github.com/nuxeo/nuxeo/commit/dad01caec1995a3ab7f20f998088cf6a74473643", "message": "NXP-28428: Add a scheduled job to check if cold storage content are available", "committedDate": "2020-03-02T12:57:03Z", "type": "commit"}, {"oid": "8494220b6af92225c79f9691f8fce5f49af7dded", "url": "https://github.com/nuxeo/nuxeo/commit/8494220b6af92225c79f9691f8fce5f49af7dded", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-03-02T12:57:03Z", "type": "commit"}, {"oid": "8494220b6af92225c79f9691f8fce5f49af7dded", "url": "https://github.com/nuxeo/nuxeo/commit/8494220b6af92225c79f9691f8fce5f49af7dded", "message": "NXP-28429: Add a listener to send mail when cold storage content becomes available", "committedDate": "2020-03-02T12:57:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyOTUzOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r366329539", "body": "The document content will be stored **in a** cold (cool) storage, this is the case **when** the content represents:", "bodyText": "The document content will be stored in a cold (cool) storage, this is the case when the content represents:", "bodyHTML": "<p dir=\"auto\">The document content will be stored <strong>in a</strong> cold (cool) storage, this is the case <strong>when</strong> the content represents:</p>", "author": "NourNuxeo", "createdAt": "2020-01-14T13:13:21Z", "path": "nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java", "diffHunk": "@@ -105,6 +105,14 @@\n      */\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n+    /**\n+     * The document content will be stored as a cold (cool) storage, this is the case where the content represents:", "originalCommit": "acced913d575ce620b911db066247e83a226de53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgwODA3Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r366808073", "bodyText": "my idea here is to explain that this facet had the purpose of indicating that the content is stored as archive ... -> he document content will be stored as a cold (cool) storage\nthis is the case where the content here i talk about the case ... where this facet had a purpose", "author": "RSalem07", "createdAt": "2020-01-15T10:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjMyOTUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex 5dd847a2246..c0e0b38d6d1 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -106,9 +106,8 @@ public final class FacetNames {\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n     /**\n-     * The document content will be stored as a cold (cool) storage, this is the case where the content represents:\n-     * archiving, compliance...\n-     * \n+     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n+     *\n      * @since 11.1\n      */\n     public static final String COLD_STORAGE = \"ColdStorage\";\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex c0e0b38d6d1..9a4bbb787f5 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -105,13 +105,6 @@ public final class FacetNames {\n      */\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n-    /**\n-     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n-     *\n-     * @since 11.1\n-     */\n-    public static final String COLD_STORAGE = \"ColdStorage\";\n-\n     private FacetNames() {\n     }\n \n", "next_change": {"commit": "e2a5f21ebd983a892f776bbdbb1d19f0cc4a2db6", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex 9a4bbb787f5..c0e0b38d6d1 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -105,6 +105,13 @@ public final class FacetNames {\n      */\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n+    /**\n+     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n+     *\n+     * @since 11.1\n+     */\n+    public static final String COLD_STORAGE = \"ColdStorage\";\n+\n     private FacetNames() {\n     }\n \n", "next_change": {"commit": "c84580918340ba6ffb229600e46542bdd7bf04d0", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex c0e0b38d6d1..5dd847a2246 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -106,8 +106,9 @@ public final class FacetNames {\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n     /**\n-     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n-     *\n+     * The document content will be stored as a cold (cool) storage, this is the case where the content represents:\n+     * archiving, compliance...\n+     * \n      * @since 11.1\n      */\n     public static final String COLD_STORAGE = \"ColdStorage\";\n", "next_change": {"commit": "c8a3652e46edefddce177f605689914c07f02ade", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex 5dd847a2246..9947c8d2a37 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -106,8 +106,8 @@ public final class FacetNames {\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n     /**\n-     * The document content will be stored as a cold (cool) storage, this is the case where the content represents:\n-     * archiving, compliance...\n+     * The document content will be stored as a cold storage, this is the case where the content represents: archiving,\n+     * compliance...\n      * \n      * @since 11.1\n      */\n", "next_change": {"commit": "3f1814f7ff20c279176ef29548ec7b5807fc9b8e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex 9947c8d2a37..52afcf060f6 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -106,9 +106,9 @@ public final class FacetNames {\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n     /**\n-     * The document content will be stored as a cold storage, this is the case where the content represents: archiving,\n-     * compliance...\n-     * \n+     * Facet used to indicate that a given document can have his content stored as a cold storage, this is the case for\n+     * example where the content represents: archiving, compliance...\n+     *\n      * @since 11.1\n      */\n     public static final String COLD_STORAGE = \"ColdStorage\";\n", "next_change": {"commit": "b0014376c49dafa4bd70c33031fe8c2e2a37c349", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex 52afcf060f6..c0e0b38d6d1 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -106,8 +106,7 @@ public final class FacetNames {\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n     /**\n-     * Facet used to indicate that a given document can have his content stored as a cold storage, this is the case for\n-     * example where the content represents: archiving, compliance...\n+     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n      *\n      * @since 11.1\n      */\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MjEwNA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r366342104", "body": "What is the purpose of this test class?", "bodyText": "What is the purpose of this test class?", "bodyHTML": "<p dir=\"auto\">What is the purpose of this test class?</p>", "author": "kevinleturc", "createdAt": "2020-01-14T13:39:50Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestFacet.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.nuxeo.ecm.core.schema.FacetNames.COMMENTABLE;\n+import static org.nuxeo.ecm.core.schema.FacetNames.DOWNLOADABLE;\n+import static org.nuxeo.ecm.core.schema.FacetNames.FOLDERISH;\n+import static org.nuxeo.ecm.core.schema.FacetNames.HAS_RELATED_TEXT;\n+import static org.nuxeo.ecm.core.schema.FacetNames.HIDDEN_IN_NAVIGATION;\n+import static org.nuxeo.ecm.core.schema.FacetNames.MASTER_PUBLISH_SPACE;\n+import static org.nuxeo.ecm.core.schema.FacetNames.NOT_FULLTEXT_INDEXABLE;\n+import static org.nuxeo.ecm.core.schema.FacetNames.ORDERABLE;\n+import static org.nuxeo.ecm.core.schema.FacetNames.PUBLISHABLE;\n+import static org.nuxeo.ecm.core.schema.FacetNames.PUBLISH_SPACE;\n+import static org.nuxeo.ecm.core.schema.FacetNames.SUPER_SPACE;\n+import static org.nuxeo.ecm.core.schema.FacetNames.SYSTEM_DOCUMENT;\n+import static org.nuxeo.ecm.core.schema.FacetNames.VERSIONABLE;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.schema.SchemaManager;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+public class TestFacet {", "originalCommit": "fca5bdd2dbff63f4f69f500c8a4c9dd4b35f33cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NzEzOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r366347138", "bodyText": "i added it because i didn't find a test that ensure that the new added facet are correctly loaded. this the reason why i added the check on others tests (FacetJsonWriterTest.java...) before i added this new class test and i let the others", "author": "RSalem07", "createdAt": "2020-01-14T13:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MjEwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0OTA5Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r366349096", "bodyText": "Ok, that's the responsibility of TestSchemaManager to test the mecanism of that. I'm in favor of removing it for the maintenance reason I expressed on another comment.", "author": "kevinleturc", "createdAt": "2020-01-14T13:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MjEwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM1MDAzOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r366350039", "bodyText": "yes i agree it what i tried to do at the beginning but the test fails on TestSchemaManager because some feature are missed... on this class test after that i move it to this new test for example CoreFeature is not available in TestSchemaManager ... initially i didn't went to change the pom dependencies ... if you agree i will do it and move the whole to the testSchema... as i went initially", "author": "RSalem07", "createdAt": "2020-01-14T13:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MjEwNA=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestFacet.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestFacet.java\ndeleted file mode 100644\nindex e7e19198daf..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestFacet.java\n+++ /dev/null\n", "chunk": "@@ -1,66 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static org.junit.Assert.assertNotNull;\n-import static org.nuxeo.ecm.core.schema.FacetNames.COMMENTABLE;\n-import static org.nuxeo.ecm.core.schema.FacetNames.DOWNLOADABLE;\n-import static org.nuxeo.ecm.core.schema.FacetNames.FOLDERISH;\n-import static org.nuxeo.ecm.core.schema.FacetNames.HAS_RELATED_TEXT;\n-import static org.nuxeo.ecm.core.schema.FacetNames.HIDDEN_IN_NAVIGATION;\n-import static org.nuxeo.ecm.core.schema.FacetNames.MASTER_PUBLISH_SPACE;\n-import static org.nuxeo.ecm.core.schema.FacetNames.NOT_FULLTEXT_INDEXABLE;\n-import static org.nuxeo.ecm.core.schema.FacetNames.ORDERABLE;\n-import static org.nuxeo.ecm.core.schema.FacetNames.PUBLISHABLE;\n-import static org.nuxeo.ecm.core.schema.FacetNames.PUBLISH_SPACE;\n-import static org.nuxeo.ecm.core.schema.FacetNames.SUPER_SPACE;\n-import static org.nuxeo.ecm.core.schema.FacetNames.SYSTEM_DOCUMENT;\n-import static org.nuxeo.ecm.core.schema.FacetNames.VERSIONABLE;\n-\n-import java.util.List;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.schema.SchemaManager;\n-import org.nuxeo.ecm.core.test.CoreFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(CoreFeature.class)\n-public class TestFacet {\n-\n-    @Inject\n-    public SchemaManager schemaManager;\n-\n-    @Test\n-    public void shouldGetFacets() {\n-        var facets = List.of(FOLDERISH, VERSIONABLE, ORDERABLE, DOWNLOADABLE, SUPER_SPACE, PUBLISHABLE, PUBLISH_SPACE,\n-                MASTER_PUBLISH_SPACE, COMMENTABLE, HIDDEN_IN_NAVIGATION, SYSTEM_DOCUMENT, NOT_FULLTEXT_INDEXABLE,\n-                HAS_RELATED_TEXT);\n-\n-        facets.forEach(fn -> assertNotNull(String.format(\"Facet %s should exist\", fn), schemaManager.getFacet(fn)));\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0MzcyNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r366343726", "body": "Not sure about this test, I think it tests that we can write a facet but not a specific one. I'm in favor of reverting change to not make this test more complex.", "bodyText": "Not sure about this test, I think it tests that we can write a facet but not a specific one. I'm in favor of reverting change to not make this test more complex.", "bodyHTML": "<p dir=\"auto\">Not sure about this test, I think it tests that we can write a facet but not a specific one. I'm in favor of reverting change to not make this test more complex.</p>", "author": "kevinleturc", "createdAt": "2020-01-14T13:42:47Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/io/marshallers/json/types/FacetJsonWriterTest.java", "diffHunk": "@@ -53,14 +56,17 @@ public void testFacetWithoutSchema() throws Exception {\n \n     @Test\n     public void testFacetWithSchema() throws Exception {\n-        CompositeType type = schemaManager.getFacet(HAS_RELATED_TEXT);\n-        JsonAssert json = jsonAssert(type);\n-        json.properties(3);\n-        json.has(\"entity-type\").isEquals(\"facet\");\n-        json.has(\"name\").isEquals(HAS_RELATED_TEXT);\n-        json = json.has(\"schemas\").length(1).has(0);\n-        json.has(\"entity-type\").isEquals(\"schema\");\n-        json.has(\"name\").isEquals(\"relatedtext\");\n+        var schemaByFacetName = Map.of(HAS_RELATED_TEXT, \"relatedtext\", COLD_STORAGE, \"coldstorage\");\n+        for (Map.Entry<String, String> entry : schemaByFacetName.entrySet()) {\n+            CompositeType type = schemaManager.getFacet(entry.getKey());\n+            JsonAssert json = jsonAssert(type);\n+            json.properties(3);\n+            json.has(\"entity-type\").isEquals(\"facet\");\n+            json.has(\"name\").isEquals(entry.getKey());\n+            json = json.has(\"schemas\").length(1).has(0);\n+            json.has(\"entity-type\").isEquals(\"schema\");\n+            json.has(\"name\").isEquals(entry.getValue());\n+        }", "originalCommit": "acced913d575ce620b911db066247e83a226de53", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/io/marshallers/json/types/FacetJsonWriterTest.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/io/marshallers/json/types/FacetJsonWriterTest.java\nindex 51655746dd3..99416450afb 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/io/marshallers/json/types/FacetJsonWriterTest.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/io/marshallers/json/types/FacetJsonWriterTest.java\n", "chunk": "@@ -47,26 +41,23 @@ public class FacetJsonWriterTest extends AbstractJsonWriterTest.Local<FacetJsonW\n \n     @Test\n     public void testFacetWithoutSchema() throws Exception {\n-        CompositeType type = schemaManager.getFacet(FOLDERISH);\n+        CompositeType type = schemaManager.getFacet(\"Folderish\");\n         JsonAssert json = jsonAssert(type);\n         json.properties(2);\n         json.has(\"entity-type\").isEquals(\"facet\");\n-        json.has(\"name\").isEquals(FOLDERISH);\n+        json.has(\"name\").isEquals(\"Folderish\");\n     }\n \n     @Test\n     public void testFacetWithSchema() throws Exception {\n-        var schemaByFacetName = Map.of(HAS_RELATED_TEXT, \"relatedtext\", COLD_STORAGE, \"coldstorage\");\n-        for (Map.Entry<String, String> entry : schemaByFacetName.entrySet()) {\n-            CompositeType type = schemaManager.getFacet(entry.getKey());\n-            JsonAssert json = jsonAssert(type);\n-            json.properties(3);\n-            json.has(\"entity-type\").isEquals(\"facet\");\n-            json.has(\"name\").isEquals(entry.getKey());\n-            json = json.has(\"schemas\").length(1).has(0);\n-            json.has(\"entity-type\").isEquals(\"schema\");\n-            json.has(\"name\").isEquals(entry.getValue());\n-        }\n+        CompositeType type = schemaManager.getFacet(\"HasRelatedText\");\n+        JsonAssert json = jsonAssert(type);\n+        json.properties(3);\n+        json.has(\"entity-type\").isEquals(\"facet\");\n+        json.has(\"name\").isEquals(\"HasRelatedText\");\n+        json = json.has(\"schemas\").length(1).has(0);\n+        json.has(\"entity-type\").isEquals(\"schema\");\n+        json.has(\"name\").isEquals(\"relatedtext\");\n     }\n \n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjM0NDkxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r366344916", "body": "This is not the responsibility of this test to assert that, otherwise this means we need to have this kind of assertion for all facets which is a lot of assertions + difficult to maintain for no real gain (I assume reading facet from json is tested elsewhere). I'm in favor of reverting it.", "bodyText": "This is not the responsibility of this test to assert that, otherwise this means we need to have this kind of assertion for all facets which is a lot of assertions + difficult to maintain for no real gain (I assume reading facet from json is tested elsewhere). I'm in favor of reverting it.", "bodyHTML": "<p dir=\"auto\">This is not the responsibility of this test to assert that, otherwise this means we need to have this kind of assertion for all facets which is a lot of assertions + difficult to maintain for no real gain (I assume reading facet from json is tested elsewhere). I'm in favor of reverting it.</p>", "author": "kevinleturc", "createdAt": "2020-01-14T13:45:13Z", "path": "nuxeo-features/nuxeo-elasticsearch/nuxeo-elasticsearch-core/src/test/java/org/nuxeo/elasticsearch/test/io/TestDocumentModelReader.java", "diffHunk": "@@ -102,6 +103,7 @@ public void ICanReadADocModelFromJson() {\n         assertFalse(doc.isFolder());\n         assertFalse(doc.isVersion());\n         assertFalse(doc.isLocked());\n+        assertTrue(doc.hasFacet(COLD_STORAGE));", "originalCommit": "acced913d575ce620b911db066247e83a226de53", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-elasticsearch/nuxeo-elasticsearch-core/src/test/java/org/nuxeo/elasticsearch/test/io/TestDocumentModelReader.java b/nuxeo-features/nuxeo-elasticsearch/nuxeo-elasticsearch-core/src/test/java/org/nuxeo/elasticsearch/test/io/TestDocumentModelReader.java\nindex d8174f757b9..d539d497186 100644\n--- a/nuxeo-features/nuxeo-elasticsearch/nuxeo-elasticsearch-core/src/test/java/org/nuxeo/elasticsearch/test/io/TestDocumentModelReader.java\n+++ b/nuxeo-features/nuxeo-elasticsearch/nuxeo-elasticsearch-core/src/test/java/org/nuxeo/elasticsearch/test/io/TestDocumentModelReader.java\n", "chunk": "@@ -92,34 +86,34 @@ public class TestDocumentModelReader {\n                 + \"\\\"ecm:isVersion\\\":false,\\\"uid:minor_version\\\":\\\"0\\\",\\\"dc:issued\\\":null,\"\n                 + \"\\\"ecm:title\\\":\\\"File Title\\\",\\\"dc:modified\\\":null,\\\"dc:expired\\\":null,\\\"dc:coverage\\\":null,\\\"dc:language\\\":null}\";\n         DocumentModel doc = DocumentModelReaders.fromJson(json).getDocumentModel();\n-        assertNotNull(doc);\n-        assertEquals(\"56ca3935-c6c9-4cd4-ac23-d9df5ebf340a\", doc.getId());\n-        assertEquals(\"project\", doc.getCurrentLifeCycleState());\n-        assertEquals(\"file0\", doc.getName());\n-        assertEquals(\"/root/my/path/file0\", doc.getPathAsString());\n-        assertEquals(\"test\", doc.getRepositoryName());\n-        assertNull(doc.getSessionId());\n-        assertFalse(doc.isProxy());\n-        assertFalse(doc.isFolder());\n-        assertFalse(doc.isVersion());\n-        assertFalse(doc.isLocked());\n-        assertTrue(doc.hasFacet(COLD_STORAGE));\n-        assertEquals(\"File Title\", doc.getTitle());\n-        assertNotNull(doc.getParentRef());\n-        assertTrue(doc.isImmutable());\n-        assertEquals(\"File\", doc.getType());\n+        Assert.assertNotNull(doc);\n+        Assert.assertEquals(\"56ca3935-c6c9-4cd4-ac23-d9df5ebf340a\", doc.getId());\n+        Assert.assertEquals(\"project\", doc.getCurrentLifeCycleState());\n+        Assert.assertEquals(\"file0\", doc.getName());\n+        Assert.assertEquals(\"/root/my/path/file0\", doc.getPathAsString());\n+        Assert.assertEquals(\"test\", doc.getRepositoryName());\n+        Assert.assertNull(doc.getSessionId());\n+        Assert.assertFalse(doc.isProxy());\n+        Assert.assertFalse(doc.isFolder());\n+        Assert.assertFalse(doc.isVersion());\n+        Assert.assertFalse(doc.isLocked());\n+        Assert.assertEquals(\"File Title\", doc.getTitle());\n+        // Assert.assertEquals(\"Failure\", doc.getLifeCyclePolicy());\n+        Assert.assertNotNull(doc.getParentRef());\n+        Assert.assertTrue(doc.isImmutable());\n+        Assert.assertEquals(\"File\", doc.getType());\n     }\n \n     @Test\n-    public void ICanReadADocModelFromSource() {\n+    public void ICanReadADocModelFromSource() throws Exception {\n         Map<String, Object> source = new HashMap<>();\n         source.put(\"ecm:uuid\", \"001\");\n         source.put(\"ecm:primaryType\", \"File\");\n         DocumentModel doc = DocumentModelReaders.fromSource(source).getDocumentModel();\n-        assertNotNull(doc);\n-        assertEquals(doc.getId(), \"001\");\n-        assertEquals(\"File\", doc.getType());\n-        assertFalse(doc.isFolder());\n+        Assert.assertNotNull(doc);\n+        Assert.assertEquals(doc.getId(), \"001\");\n+        Assert.assertEquals(\"File\", doc.getType());\n+        Assert.assertFalse(doc.isFolder());\n     }\n \n     @Test\n", "next_change": null}]}}, {"oid": "c84580918340ba6ffb229600e46542bdd7bf04d0", "url": "https://github.com/nuxeo/nuxeo/commit/c84580918340ba6ffb229600e46542bdd7bf04d0", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-01-15T10:29:34Z", "type": "forcePushed"}, {"oid": "a1cbfd09ce7899245c1427255a41c5fe88e8e538", "url": "https://github.com/nuxeo/nuxeo/commit/a1cbfd09ce7899245c1427255a41c5fe88e8e538", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-01-15T11:09:00Z", "type": "forcePushed"}, {"oid": "e1f601c61ae164cd43eab546ac66d7e381501213", "url": "https://github.com/nuxeo/nuxeo/commit/e1f601c61ae164cd43eab546ac66d7e381501213", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-01-16T13:49:01Z", "type": "forcePushed"}, {"oid": "a293c470efb3426f0a126f15e7cda8e048ccd0f9", "url": "https://github.com/nuxeo/nuxeo/commit/a293c470efb3426f0a126f15e7cda8e048ccd0f9", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-01-17T13:18:28Z", "type": "forcePushed"}, {"oid": "a778e76c9dc7b3067b63aaa65a713d4f1822876e", "url": "https://github.com/nuxeo/nuxeo/commit/a778e76c9dc7b3067b63aaa65a713d4f1822876e", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-01-17T13:24:37Z", "type": "forcePushed"}, {"oid": "39d2703c7d8c2f1c51ce4c5c7b7e89c53cff8481", "url": "https://github.com/nuxeo/nuxeo/commit/39d2703c7d8c2f1c51ce4c5c7b7e89c53cff8481", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-01-17T13:27:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1MTE0NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368451144", "body": "(cool) seems unneeded here, cold is enough no?\r\nAlso, I'd go for a sentence explaining that the document **can have** its content stored as cold storage, because if a document has this facet, it doesn't necessarily mean that its content **is** stored as cold storage.", "bodyText": "(cool) seems unneeded here, cold is enough no?\nAlso, I'd go for a sentence explaining that the document can have its content stored as cold storage, because if a document has this facet, it doesn't necessarily mean that its content is stored as cold storage.", "bodyHTML": "<p dir=\"auto\">(cool) seems unneeded here, cold is enough no?<br>\nAlso, I'd go for a sentence explaining that the document <strong>can have</strong> its content stored as cold storage, because if a document has this facet, it doesn't necessarily mean that its content <strong>is</strong> stored as cold storage.</p>", "author": "ataillefer", "createdAt": "2020-01-20T09:44:58Z", "path": "nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java", "diffHunk": "@@ -105,6 +105,14 @@\n      */\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n+    /**\n+     * The document content will be stored as a cold (cool) storage, this is the case where the content represents:\n+     * archiving, compliance...", "originalCommit": "39d2703c7d8c2f1c51ce4c5c7b7e89c53cff8481", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2MTY2NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368461665", "bodyText": "(cool) seems unneeded here, cold is enough no?\nI agree ;)\n\n\nAlso, I'd go for a sentence explaining that the document can have its content stored as cold storage, because if a document has this facet, it doesn't necessarily mean that its content is stored as cold storage.\n\ni was thinking that this facet was only for cold storage but if we say that is not automatically yes i will change it ;)", "author": "RSalem07", "createdAt": "2020-01-20T10:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1MTE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2NTY3NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368465675", "bodyText": "That's a good question in fact, will it only be added dynamically when storing a content in cold storage? Or can we have some \"cold storable content\" documents, possibly stored in cold storage but not nevessarily?\n@efge WDYT\nAlso, if at some point we decide that some content can be put back from cold to regular storage, then I guess that the facet won't be a synonym of \"coldly stored\"...", "author": "ataillefer", "createdAt": "2020-01-20T10:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1MTE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5ODYyMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368498621", "bodyText": "@ataillefer @RSalem07\nMy idea was to have it added dynamically only when a user/process decides to move to cold storage. But you're right that we could very well have doctypes that have this facet permanently. So the presence of the facet alone shouldn't be an indicator that something is in cold storage.\nIt's only when coldstorage:coldContent is not null then there's something in cold storage.", "author": "efge", "createdAt": "2020-01-20T11:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1MTE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU0MTIzNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368541236", "bodyText": "Florent when you said coldstorage:coldContent is not null then there's something in cold storage. -> that means we should call document.getPropertyValue(coldstorage:coldContent) and i am wondering if this call will not throw an exception as we try to retrieve a cold storage or is there a thing that hold it to return not not value without trying to get the real content from cold storage\nthx", "author": "RSalem07", "createdAt": "2020-01-20T13:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1MTE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU2NTcxNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368565715", "bodyText": "From what I understand, if there is indeed a blob in this property, calling getPropertyValue will return a Blob, then we know that the content is in cold storage.\nIt is only when we try to get the binary content, by calling getStream, that the retrieval should happen, or an exception should be thrown, depending on how we want to handle the retrieval.\nBut @efge  will confirm.", "author": "ataillefer", "createdAt": "2020-01-20T14:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1MTE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU4MjgyOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368582828", "bodyText": "@ataillefer yes exactly. It's only when you call blob.getStream() that a request goes to S3 (and will fail if the blob retrieval has not been requested or is not finished or is expired)", "author": "efge", "createdAt": "2020-01-20T14:43:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1MTE0NA=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex 5dd847a2246..c0e0b38d6d1 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -106,9 +106,8 @@ public final class FacetNames {\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n     /**\n-     * The document content will be stored as a cold (cool) storage, this is the case where the content represents:\n-     * archiving, compliance...\n-     * \n+     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n+     *\n      * @since 11.1\n      */\n     public static final String COLD_STORAGE = \"ColdStorage\";\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex c0e0b38d6d1..9a4bbb787f5 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -105,13 +105,6 @@ public final class FacetNames {\n      */\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n-    /**\n-     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n-     *\n-     * @since 11.1\n-     */\n-    public static final String COLD_STORAGE = \"ColdStorage\";\n-\n     private FacetNames() {\n     }\n \n", "next_change": {"commit": "e2a5f21ebd983a892f776bbdbb1d19f0cc4a2db6", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex 9a4bbb787f5..c0e0b38d6d1 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -105,6 +105,13 @@ public final class FacetNames {\n      */\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n+    /**\n+     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n+     *\n+     * @since 11.1\n+     */\n+    public static final String COLD_STORAGE = \"ColdStorage\";\n+\n     private FacetNames() {\n     }\n \n", "next_change": {"commit": "c8a3652e46edefddce177f605689914c07f02ade", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex c0e0b38d6d1..9947c8d2a37 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -106,8 +106,9 @@ public final class FacetNames {\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n     /**\n-     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n-     *\n+     * The document content will be stored as a cold storage, this is the case where the content represents: archiving,\n+     * compliance...\n+     * \n      * @since 11.1\n      */\n     public static final String COLD_STORAGE = \"ColdStorage\";\n", "next_change": {"commit": "3f1814f7ff20c279176ef29548ec7b5807fc9b8e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex 9947c8d2a37..52afcf060f6 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -106,9 +106,9 @@ public final class FacetNames {\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n     /**\n-     * The document content will be stored as a cold storage, this is the case where the content represents: archiving,\n-     * compliance...\n-     * \n+     * Facet used to indicate that a given document can have his content stored as a cold storage, this is the case for\n+     * example where the content represents: archiving, compliance...\n+     *\n      * @since 11.1\n      */\n     public static final String COLD_STORAGE = \"ColdStorage\";\n", "next_change": {"commit": "b0014376c49dafa4bd70c33031fe8c2e2a37c349", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex 52afcf060f6..c0e0b38d6d1 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -106,8 +106,7 @@ public final class FacetNames {\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n     /**\n-     * Facet used to indicate that a given document can have his content stored as a cold storage, this is the case for\n-     * example where the content represents: archiving, compliance...\n+     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n      *\n      * @since 11.1\n      */\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1NTI2MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368455261", "body": "As you're testing `SchemaManager#getFacet`, maybe you only need to add one facet and schema in `CoreTestExtensions.xml` and don't need to iterate?\r\nOr would you like to test `SchemaManager#getFacets`?", "bodyText": "As you're testing SchemaManager#getFacet, maybe you only need to add one facet and schema in CoreTestExtensions.xml and don't need to iterate?\nOr would you like to test SchemaManager#getFacets?", "bodyHTML": "<p dir=\"auto\">As you're testing <code>SchemaManager#getFacet</code>, maybe you only need to add one facet and schema in <code>CoreTestExtensions.xml</code> and don't need to iterate?<br>\nOr would you like to test <code>SchemaManager#getFacets</code>?</p>", "author": "ataillefer", "createdAt": "2020-01-20T09:53:05Z", "path": "nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java", "diffHunk": "@@ -445,4 +446,18 @@ public void testExtendsAppendTypes() {\n         assertEquals(t.getAllowedSubtypes(), Set.of(\"myDoc2\", \"myDoc3\", \"myDoc4\"));\n     }\n \n+    @Test\n+    @Deploy(\"org.nuxeo.ecm.core.schema.tests:OSGI-INF/CoreTestExtensions.xml\")\n+    public void shouldGetFacets() {\n+        var facets = Map.of( //\n+                \"fakeFacet1\", \"facetSchema1\", //\n+                \"fakeFacet2\", \"facetSchema2\");\n+        for (var entry : facets.entrySet()) {\n+            CompositeType component = schemaManager.getFacet(entry.getKey());", "originalCommit": "39d2703c7d8c2f1c51ce4c5c7b7e89c53cff8481", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2MjUyNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368462526", "bodyText": "when i started this ticket i didn't find an easy test on SchemaManager which is responsible about just testing loading a schema / facet is why i added it and i told my self why not adding more facet and schema with once like the relatedtext", "author": "RSalem07", "createdAt": "2020-01-20T10:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1NTI2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ2ODAyMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368468021", "bodyText": "OK about adding a test for fetching facets \ud83d\udc4d\nBut again, why do you need 2?\nUnless you explicitly want to test SchemaManager#getFacets (plural form), which you are not here.\nAs for relatedtext, what is the added value of testing such a complex schema? I believe that fetching a facet and its schema doesn't really depend on the complex nature of the schema itself. IMHO, this test should be kept as simple as possible.", "author": "ataillefer", "createdAt": "2020-01-20T10:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ1NTI2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\nindex c601b8ebb0f..2f03bf14d28 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n", "chunk": "@@ -448,16 +447,11 @@ public class TestSchemaManager {\n \n     @Test\n     @Deploy(\"org.nuxeo.ecm.core.schema.tests:OSGI-INF/CoreTestExtensions.xml\")\n-    public void shouldGetFacets() {\n-        var facets = Map.of( //\n-                \"fakeFacet1\", \"facetSchema1\", //\n-                \"fakeFacet2\", \"facetSchema2\");\n-        for (var entry : facets.entrySet()) {\n-            CompositeType component = schemaManager.getFacet(entry.getKey());\n-            assertNotNull(String.format(\"Facet %s should exist\", entry.getKey()), component);\n-            assertEquals(1, component.getSchemas().size());\n-            assertEquals(entry.getValue(), component.getSchemaNames()[0]);\n-        }\n+    public void testGetFacet() {\n+        CompositeType component = schemaManager.getFacet(\"fakeFacet1\");\n+        assertNotNull(String.format(\"Facet %s should exist\", \"fakeFacet1\"), component);\n+        assertEquals(1, component.getSchemas().size());\n+        assertEquals(\"facetSchema1\", component.getSchemaNames()[0]);\n     }\n \n }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\nindex 2f03bf14d28..086192380eb 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n", "chunk": "@@ -445,13 +445,4 @@ public class TestSchemaManager {\n         assertEquals(t.getAllowedSubtypes(), Set.of(\"myDoc2\", \"myDoc3\", \"myDoc4\"));\n     }\n \n-    @Test\n-    @Deploy(\"org.nuxeo.ecm.core.schema.tests:OSGI-INF/CoreTestExtensions.xml\")\n-    public void testGetFacet() {\n-        CompositeType component = schemaManager.getFacet(\"fakeFacet1\");\n-        assertNotNull(String.format(\"Facet %s should exist\", \"fakeFacet1\"), component);\n-        assertEquals(1, component.getSchemas().size());\n-        assertEquals(\"facetSchema1\", component.getSchemaNames()[0]);\n-    }\n-\n }\n", "next_change": {"commit": "e2a5f21ebd983a892f776bbdbb1d19f0cc4a2db6", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\nindex 086192380eb..2f03bf14d28 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n", "chunk": "@@ -445,4 +445,13 @@ public class TestSchemaManager {\n         assertEquals(t.getAllowedSubtypes(), Set.of(\"myDoc2\", \"myDoc3\", \"myDoc4\"));\n     }\n \n+    @Test\n+    @Deploy(\"org.nuxeo.ecm.core.schema.tests:OSGI-INF/CoreTestExtensions.xml\")\n+    public void testGetFacet() {\n+        CompositeType component = schemaManager.getFacet(\"fakeFacet1\");\n+        assertNotNull(String.format(\"Facet %s should exist\", \"fakeFacet1\"), component);\n+        assertEquals(1, component.getSchemas().size());\n+        assertEquals(\"facetSchema1\", component.getSchemaNames()[0]);\n+    }\n+\n }\n", "next_change": {"commit": "c8a3652e46edefddce177f605689914c07f02ade", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\nindex 2f03bf14d28..6ce7f93cfc2 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n", "chunk": "@@ -447,7 +447,7 @@ public class TestSchemaManager {\n \n     @Test\n     @Deploy(\"org.nuxeo.ecm.core.schema.tests:OSGI-INF/CoreTestExtensions.xml\")\n-    public void testGetFacet() {\n+    public void shouldGetFacet() {\n         CompositeType component = schemaManager.getFacet(\"fakeFacet1\");\n         assertNotNull(String.format(\"Facet %s should exist\", \"fakeFacet1\"), component);\n         assertEquals(1, component.getSchemas().size());\n", "next_change": {"commit": "3f1814f7ff20c279176ef29548ec7b5807fc9b8e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\nindex 6ce7f93cfc2..2f03bf14d28 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n", "chunk": "@@ -447,7 +447,7 @@ public class TestSchemaManager {\n \n     @Test\n     @Deploy(\"org.nuxeo.ecm.core.schema.tests:OSGI-INF/CoreTestExtensions.xml\")\n-    public void shouldGetFacet() {\n+    public void testGetFacet() {\n         CompositeType component = schemaManager.getFacet(\"fakeFacet1\");\n         assertNotNull(String.format(\"Facet %s should exist\", \"fakeFacet1\"), component);\n         assertEquals(1, component.getSchemas().size());\n", "next_change": null}]}}]}}]}}]}}]}}, {"oid": "c8a3652e46edefddce177f605689914c07f02ade", "url": "https://github.com/nuxeo/nuxeo/commit/c8a3652e46edefddce177f605689914c07f02ade", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-01-20T10:41:44Z", "type": "forcePushed"}, {"oid": "614b9662c1bf374393758e6d43be7f925ec24bec", "url": "https://github.com/nuxeo/nuxeo/commit/614b9662c1bf374393758e6d43be7f925ec24bec", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-01-20T10:47:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ5NTMyNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368495326", "body": "Maybe `testGetFacet`, to comply with the other tests in this class.", "bodyText": "Maybe testGetFacet, to comply with the other tests in this class.", "bodyHTML": "<p dir=\"auto\">Maybe <code>testGetFacet</code>, to comply with the other tests in this class.</p>", "author": "ataillefer", "createdAt": "2020-01-20T11:18:36Z", "path": "nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java", "diffHunk": "@@ -445,4 +445,13 @@ public void testExtendsAppendTypes() {\n         assertEquals(t.getAllowedSubtypes(), Set.of(\"myDoc2\", \"myDoc3\", \"myDoc4\"));\n     }\n \n+    @Test\n+    @Deploy(\"org.nuxeo.ecm.core.schema.tests:OSGI-INF/CoreTestExtensions.xml\")\n+    public void shouldGetFacet() {", "originalCommit": "614b9662c1bf374393758e6d43be7f925ec24bec", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\nindex 6ce7f93cfc2..2f03bf14d28 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n", "chunk": "@@ -447,7 +447,7 @@ public class TestSchemaManager {\n \n     @Test\n     @Deploy(\"org.nuxeo.ecm.core.schema.tests:OSGI-INF/CoreTestExtensions.xml\")\n-    public void shouldGetFacet() {\n+    public void testGetFacet() {\n         CompositeType component = schemaManager.getFacet(\"fakeFacet1\");\n         assertNotNull(String.format(\"Facet %s should exist\", \"fakeFacet1\"), component);\n         assertEquals(1, component.getSchemas().size());\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\nindex 2f03bf14d28..086192380eb 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n", "chunk": "@@ -445,13 +445,4 @@ public class TestSchemaManager {\n         assertEquals(t.getAllowedSubtypes(), Set.of(\"myDoc2\", \"myDoc3\", \"myDoc4\"));\n     }\n \n-    @Test\n-    @Deploy(\"org.nuxeo.ecm.core.schema.tests:OSGI-INF/CoreTestExtensions.xml\")\n-    public void testGetFacet() {\n-        CompositeType component = schemaManager.getFacet(\"fakeFacet1\");\n-        assertNotNull(String.format(\"Facet %s should exist\", \"fakeFacet1\"), component);\n-        assertEquals(1, component.getSchemas().size());\n-        assertEquals(\"facetSchema1\", component.getSchemaNames()[0]);\n-    }\n-\n }\n", "next_change": {"commit": "e2a5f21ebd983a892f776bbdbb1d19f0cc4a2db6", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\nindex 086192380eb..2f03bf14d28 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/test/java/org/nuxeo/ecm/core/schema/TestSchemaManager.java\n", "chunk": "@@ -445,4 +445,13 @@ public class TestSchemaManager {\n         assertEquals(t.getAllowedSubtypes(), Set.of(\"myDoc2\", \"myDoc3\", \"myDoc4\"));\n     }\n \n+    @Test\n+    @Deploy(\"org.nuxeo.ecm.core.schema.tests:OSGI-INF/CoreTestExtensions.xml\")\n+    public void testGetFacet() {\n+        CompositeType component = schemaManager.getFacet(\"fakeFacet1\");\n+        assertNotNull(String.format(\"Facet %s should exist\", \"fakeFacet1\"), component);\n+        assertEquals(1, component.getSchemas().size());\n+        assertEquals(\"facetSchema1\", component.getSchemaNames()[0]);\n+    }\n+\n }\n", "next_change": null}]}}]}}]}}, {"oid": "3f1814f7ff20c279176ef29548ec7b5807fc9b8e", "url": "https://github.com/nuxeo/nuxeo/commit/3f1814f7ff20c279176ef29548ec7b5807fc9b8e", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-01-20T13:09:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU2ODAxMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368568013", "body": "Why not keep the pattern used for the other facets?\r\nSomething like: \"The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\"", "bodyText": "Why not keep the pattern used for the other facets?\nSomething like: \"The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\"", "bodyHTML": "<p dir=\"auto\">Why not keep the pattern used for the other facets?<br>\nSomething like: \"The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\"</p>", "author": "ataillefer", "createdAt": "2020-01-20T14:13:32Z", "path": "nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java", "diffHunk": "@@ -105,6 +105,14 @@\n      */\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n+    /**\n+     * Facet used to indicate that a given document can have his content stored as a cold storage, this is the case for\n+     * example where the content represents: archiving, compliance...", "originalCommit": "3f1814f7ff20c279176ef29548ec7b5807fc9b8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU3MTk3Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r368571977", "bodyText": "yep, on some facet they used the pattern Facet to be used fo..... for example HAS_RELATED_TEXT  this is the reason why i changed it :), but yes why not i will make the modification ;)", "author": "RSalem07", "createdAt": "2020-01-20T14:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODU2ODAxMw=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex 52afcf060f6..c0e0b38d6d1 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -106,8 +106,7 @@ public final class FacetNames {\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n     /**\n-     * Facet used to indicate that a given document can have his content stored as a cold storage, this is the case for\n-     * example where the content represents: archiving, compliance...\n+     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n      *\n      * @since 11.1\n      */\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex c0e0b38d6d1..9a4bbb787f5 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -105,13 +105,6 @@ public final class FacetNames {\n      */\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n-    /**\n-     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n-     *\n-     * @since 11.1\n-     */\n-    public static final String COLD_STORAGE = \"ColdStorage\";\n-\n     private FacetNames() {\n     }\n \n", "next_change": {"commit": "e2a5f21ebd983a892f776bbdbb1d19f0cc4a2db6", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\nindex 9a4bbb787f5..c0e0b38d6d1 100644\n--- a/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n+++ b/nuxeo-core/nuxeo-core-schema/src/main/java/org/nuxeo/ecm/core/schema/FacetNames.java\n", "chunk": "@@ -105,6 +105,13 @@ public final class FacetNames {\n      */\n     public static final String HAS_RELATED_TEXT = \"HasRelatedText\";\n \n+    /**\n+     * The document can have its main content stored as cold storage. This can be needed for archiving, compliance, etc.\n+     *\n+     * @since 11.1\n+     */\n+    public static final String COLD_STORAGE = \"ColdStorage\";\n+\n     private FacetNames() {\n     }\n \n", "next_change": null}]}}]}}]}}, {"oid": "b0014376c49dafa4bd70c33031fe8c2e2a37c349", "url": "https://github.com/nuxeo/nuxeo/commit/b0014376c49dafa4bd70c33031fe8c2e2a37c349", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-01-20T15:13:42Z", "type": "forcePushed"}, {"oid": "ca0c3232400e13d4b232578370027418b685dae1", "url": "https://github.com/nuxeo/nuxeo/commit/ca0c3232400e13d4b232578370027418b685dae1", "message": "NXP-28424: Define the ColdStorage facet", "committedDate": "2020-01-20T15:18:32Z", "type": "forcePushed"}, {"oid": "927be78223982257ea41f588a67fd2cc23937362", "url": "https://github.com/nuxeo/nuxeo/commit/927be78223982257ea41f588a67fd2cc23937362", "message": "NXP-28428: Add a scheduled job to check if cold storage content are available", "committedDate": "2020-01-23T09:18:47Z", "type": "forcePushed"}, {"oid": "1ecc3c6ec4f211c0f60138be0219cf8a25f40664", "url": "https://github.com/nuxeo/nuxeo/commit/1ecc3c6ec4f211c0f60138be0219cf8a25f40664", "message": "NXP-28428: Add a scheduled job to check if cold storage content are available", "committedDate": "2020-01-23T09:48:19Z", "type": "forcePushed"}, {"oid": "fb11aba9ca4e199bd1a78a1d65023e0d84815d74", "url": "https://github.com/nuxeo/nuxeo/commit/fb11aba9ca4e199bd1a78a1d65023e0d84815d74", "message": "NXP-28428: Add a scheduled job to check if cold storage content are available", "committedDate": "2020-01-23T12:39:33Z", "type": "forcePushed"}, {"oid": "51372af9522532b5963051d756213b3ccb437a4c", "url": "https://github.com/nuxeo/nuxeo/commit/51372af9522532b5963051d756213b3ccb437a4c", "message": "NXP-28428: Add a scheduled job to check if cold storage content are available", "committedDate": "2020-01-23T12:46:02Z", "type": "forcePushed"}, {"oid": "bfe4923f4de9f824ea340db9f96ef8169c2321a7", "url": "https://github.com/nuxeo/nuxeo/commit/bfe4923f4de9f824ea340db9f96ef8169c2321a7", "message": "NXP-28428: Add a scheduled job to check if cold storage content are available", "committedDate": "2020-01-23T12:51:57Z", "type": "forcePushed"}, {"oid": "ec4fee6aa944b95b4dfa99ae23a33ebd3eda99e9", "url": "https://github.com/nuxeo/nuxeo/commit/ec4fee6aa944b95b4dfa99ae23a33ebd3eda99e9", "message": "NXP-28428: Add a scheduled job to check if cold storage content are available", "committedDate": "2020-01-23T12:57:56Z", "type": "forcePushed"}, {"oid": "a3c8309705b38716e2357e3df345116e82fc2c07", "url": "https://github.com/nuxeo/nuxeo/commit/a3c8309705b38716e2357e3df345116e82fc2c07", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-01-27T10:19:29Z", "type": "forcePushed"}, {"oid": "f8c54244dba4c62e91e2a0c95711b498395e757a", "url": "https://github.com/nuxeo/nuxeo/commit/f8c54244dba4c62e91e2a0c95711b498395e757a", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-01-28T14:36:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5OTc3NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r371899774", "body": "I don't think it should be the helper's role to decide that the replacement content comes from a thumbnail. I'm convinced we'll have other use cases where we want replacements computed differently. Could you move this to the caller, in the operation?", "bodyText": "I don't think it should be the helper's role to decide that the replacement content comes from a thumbnail. I'm convinced we'll have other use cases where we want replacements computed differently. Could you move this to the caller, in the operation?", "bodyHTML": "<p dir=\"auto\">I don't think it should be the helper's role to decide that the replacement content comes from a thumbnail. I'm convinced we'll have other use cases where we want replacements computed differently. Could you move this to the caller, in the operation?</p>", "author": "efge", "createdAt": "2020-01-28T16:08:43Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.Serializable;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.thumbnail.ThumbnailService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     * \n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if there is no main content associated with the given document, or if the main content is\n+     *             already in the cold storage\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        Blob thumbnail = Framework.getService(ThumbnailService.class).getThumbnail(documentModel, session);", "originalCommit": "01cca943458550a611b66a8bcb4b6123cbdc09b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE4MDgzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374180830", "bodyText": "I agree, yet in the latest implementation, the moveContentToColdStorage doesn' perform a move but a copy.\nShouldn't we set the \"file:content\" property to null to perform an actual move? Then let the caller eventually put something else in \"file:content\"...", "author": "ataillefer", "createdAt": "2020-02-03T15:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg5OTc3NA=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b246de37c0c..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -72,13 +80,136 @@ public class ColdStorageHelper {\n                     SC_CONFLICT);\n         }\n \n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n         documentModel.addFacet(FacetNames.COLD_STORAGE);\n         documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        Blob thumbnail = Framework.getService(ThumbnailService.class).getThumbnail(documentModel, session);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, (Serializable) thumbnail);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n+    // it will trigger the restoration request too\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            int numberOfDaysOfAvailability) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n+                numberOfDaysOfAvailability);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     */\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available for a given repository.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "43b8c60a94f68a5f54c507036315370c6e7e7623", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..5f6d0e25daa 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -125,110 +122,101 @@ public class ColdStorageHelper {\n             throw new NuxeoException(\n                     String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n                             documentModel),\n-                    SC_FORBIDDEN);\n+                    SC_CONFLICT);\n         }\n \n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n+        return session.saveDocument(documentModel);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage contents are available for download.\n+     * Checks if the retrieved cold storage content are available for downloading.\n      *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n+     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n+     *            available for downloading. In which case then it will fire an event with name\n+     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n      */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                // mark the cold storage content of document as retrieved\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                Map<String, Serializable> properties = new HashMap<>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"https://www.nuxeo.com/\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n+     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n+     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Gives status about the cold storage content being retrieved or are available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 5f6d0e25daa..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -186,33 +193,25 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Gives status about the cold storage content being retrieved or are available for a given repository.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkwMjE3Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r371902177", "body": "You should make this an abstract class that the tests inherit from, instead of a static helper. Then methods don't need to be static, and call me called directly without a static invocation.", "bodyText": "You should make this an abstract class that the tests inherit from, instead of a static helper. Then methods don't need to be static, and call me called directly without a static invocation.", "bodyHTML": "<p dir=\"auto\">You should make this an abstract class that the tests inherit from, instead of a static helper. Then methods don't need to be static, and call me called directly without a static invocation.</p>", "author": "efge", "createdAt": "2020-01-28T16:12:38Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/util/ColdStorageOperationTestUtils.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.util;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.automation.core.operations.document.MoveToColdStorage;\n+import org.nuxeo.ecm.automation.core.operations.document.RetrieveFromColdStorage;\n+import org.nuxeo.ecm.core.DummyThumbnailFactory;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class ColdStorageOperationTestUtils {", "originalCommit": "3e69a0a55c1df3254c4092da32bfe30af9b91f6a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/util/ColdStorageOperationTestUtils.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\nsimilarity index 59%\nrename from nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/util/ColdStorageOperationTestUtils.java\nrename to nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\nindex 4b6cbe22c07..eab75e0cc87 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/util/ColdStorageOperationTestUtils.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n", "chunk": "@@ -38,23 +39,30 @@ import org.nuxeo.ecm.core.api.CoreSession;\n import org.nuxeo.ecm.core.api.DocumentModel;\n import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n \n /**\n  * @since 11.1\n  */\n-public class ColdStorageOperationTestUtils {\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@Deploy(\"org.nuxeo.ecm.automation.core\")\n+@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-dummy-thumbnail-factory-contrib.xml\")\n+public abstract class AbstractTestColdStorageOperation {\n \n-    public static final String FILE_CONTENT = \"foo and boo\";\n+    protected static final String FILE_CONTENT = \"foo and boo\";\n \n-    public static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+    @Inject\n+    protected AutomationService automationService;\n \n-    public static void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n+    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n             throws OperationException, IOException {\n         try (OperationContext context = new OperationContext(session)) {\n             context.setInput(documentModel);\n-            DocumentModel updatedDocModel = (DocumentModel) Framework.getService(AutomationService.class)\n-                                                                     .run(context, MoveToColdStorage.ID);\n+            DocumentModel updatedDocModel = (DocumentModel) automationService.run(context, MoveToColdStorage.ID);\n             Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n             Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n                     ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkwMjk5Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r371902992", "body": "This should be expanded to explain what \"retrieve\" means: that's it's a _request_ for retrieval, and is not immediate.", "bodyText": "This should be expanded to explain what \"retrieve\" means: that's it's a request for retrieval, and is not immediate.", "bodyHTML": "<p dir=\"auto\">This should be expanded to explain what \"retrieve\" means: that's it's a <em>request</em> for retrieval, and is not immediate.</p>", "author": "efge", "createdAt": "2020-01-28T16:13:50Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Retrieve the cold storage content associated with the input {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+@Operation(id = RetrieveFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Retrieve from Cold Storage\", description = \"Retrieve the cold storage content associated with the document.\")", "originalCommit": "3e69a0a55c1df3254c4092da32bfe30af9b91f6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk2OTE1MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r372969151", "bodyText": "i did it on the helper method see here, i will provide more information on java doc of the retrieve operation", "author": "RSalem07", "createdAt": "2020-01-30T14:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkwMjk5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nsimilarity index 50%\nrename from nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\nrename to nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nindex 6add9308431..47f1835baef 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -25,19 +25,26 @@ import org.nuxeo.ecm.automation.core.annotations.Operation;\n import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n import org.nuxeo.ecm.automation.core.annotations.Param;\n import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n import org.nuxeo.ecm.core.api.CoreSession;\n import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.api.Framework;\n \n /**\n- * Retrieve the cold storage content associated with the input {@link DocumentModel}.\n- *\n+ * Requests a retrieval from the cold storage content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n+ * \n  * @since 11.1\n  */\n-@Operation(id = RetrieveFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Retrieve from Cold Storage\", description = \"Retrieve the cold storage content associated with the document.\")\n-public class RetrieveFromColdStorage {\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval of the cold storage content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n \n-    public static final String ID = \"Document.RetrieveFromColdStorage\";\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n \n     @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n     protected int numberOfDaysOfAvailability;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkwNDMzMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r371904331", "body": "You'll probably want to add an index for this in `MongoDBRepository` (until the day where we have a more configurable way to do this).", "bodyText": "You'll probably want to add an index for this in MongoDBRepository (until the day where we have a more configurable way to do this).", "bodyHTML": "<p dir=\"auto\">You'll probably want to add an index for this in <code>MongoDBRepository</code> (until the day where we have a more configurable way to do this).</p>", "author": "efge", "createdAt": "2020-01-28T16:15:46Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -50,6 +54,10 @@\n \n     public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n \n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = \"SELECT * FROM Document WHERE coldstorage:beingRetrieved = 1\";", "originalCommit": "1ee19c37a9bfc69a19dad7a7a93ca4f6adcbeb3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAyMzk1Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r373023952", "bodyText": "\ud83d\udc4d and what about the VCS repository you think we should add it on postgresSql", "author": "RSalem07", "createdAt": "2020-01-30T15:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkwNDMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzAzMTc5Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r373031793", "bodyText": "Yes probably. In SQLInfo.initHierarchySQL", "author": "efge", "createdAt": "2020-01-30T15:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkwNDMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA3MDU2NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r373070565", "bodyText": "for VCS i think i will create a new method as it is done here because we will have a new table named coldstorage as we create a new specific xsd to hold the coldstorage information if your agree i will add this new method and i will create a new index on beingretrieved column", "author": "RSalem07", "createdAt": "2020-01-30T16:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkwNDMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAxMzg3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374013872", "bodyText": "as discussed on Slack we will not add an index on VCS, only on Mongo. If needed the customer will add it on PostgresSQL... directly on the DB", "author": "RSalem07", "createdAt": "2020-02-03T10:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkwNDMzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex cbd2c21e01c..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -54,27 +48,31 @@ public class ColdStorageHelper {\n \n     public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n \n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = \"SELECT * FROM Document WHERE coldstorage:beingRetrieved = 1\";\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n \n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentBecomeAvailable\";\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n+\n+    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n+\n+    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n+    public static final String TO_DEFINE = \"This information needs to be defined\";\n \n     /**\n      * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     * \n+     *\n      * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if there is no main content associated with the given document, or if the main content is\n-     *             already in the cold storage\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n      */\n     public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n         DocumentModel documentModel = session.getDocument(documentRef);\n         log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n \n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n         if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n             throw new NuxeoException(\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "43b8c60a94f68a5f54c507036315370c6e7e7623", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..5f6d0e25daa 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -125,110 +122,101 @@ public class ColdStorageHelper {\n             throw new NuxeoException(\n                     String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n                             documentModel),\n-                    SC_FORBIDDEN);\n+                    SC_CONFLICT);\n         }\n \n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n+        return session.saveDocument(documentModel);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage contents are available for download.\n+     * Checks if the retrieved cold storage content are available for downloading.\n      *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n+     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n+     *            available for downloading. In which case then it will fire an event with name\n+     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n      */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                // mark the cold storage content of document as retrieved\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                Map<String, Serializable> properties = new HashMap<>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"https://www.nuxeo.com/\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n+     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n+     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Gives status about the cold storage content being retrieved or are available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 5f6d0e25daa..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -186,33 +193,25 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Gives status about the cold storage content being retrieved or are available for a given repository.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkwNDUzOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r371904539", "body": "Become -> Became, but just `coldStorageContentAvailable` is probably enough.\r\n", "bodyText": "Become -> Became, but just coldStorageContentAvailable is probably enough.", "bodyHTML": "<p dir=\"auto\">Become -&gt; Became, but just <code>coldStorageContentAvailable</code> is probably enough.</p>", "author": "efge", "createdAt": "2020-01-28T16:16:04Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -50,6 +54,10 @@\n \n     public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n \n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = \"SELECT * FROM Document WHERE coldstorage:beingRetrieved = 1\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentBecomeAvailable\";", "originalCommit": "1ee19c37a9bfc69a19dad7a7a93ca4f6adcbeb3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex cbd2c21e01c..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -54,27 +48,31 @@ public class ColdStorageHelper {\n \n     public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n \n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = \"SELECT * FROM Document WHERE coldstorage:beingRetrieved = 1\";\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n \n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentBecomeAvailable\";\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n+\n+    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n+\n+    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n+    public static final String TO_DEFINE = \"This information needs to be defined\";\n \n     /**\n      * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     * \n+     *\n      * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if there is no main content associated with the given document, or if the main content is\n-     *             already in the cold storage\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n      */\n     public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n         DocumentModel documentModel = session.getDocument(documentRef);\n         log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n \n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n         if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n             throw new NuxeoException(\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "43b8c60a94f68a5f54c507036315370c6e7e7623", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..5f6d0e25daa 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -125,110 +122,101 @@ public class ColdStorageHelper {\n             throw new NuxeoException(\n                     String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n                             documentModel),\n-                    SC_FORBIDDEN);\n+                    SC_CONFLICT);\n         }\n \n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n+        return session.saveDocument(documentModel);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage contents are available for download.\n+     * Checks if the retrieved cold storage content are available for downloading.\n      *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n+     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n+     *            available for downloading. In which case then it will fire an event with name\n+     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n      */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                // mark the cold storage content of document as retrieved\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                Map<String, Serializable> properties = new HashMap<>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"https://www.nuxeo.com/\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n+     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n+     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Gives status about the cold storage content being retrieved or are available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 5f6d0e25daa..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -186,33 +193,25 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Gives status about the cold storage content being retrieved or are available for a given repository.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "43b8c60a94f68a5f54c507036315370c6e7e7623", "url": "https://github.com/nuxeo/nuxeo/commit/43b8c60a94f68a5f54c507036315370c6e7e7623", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-01-30T15:50:26Z", "type": "forcePushed"}, {"oid": "daea2067c5fc41afcdcbe6f93a3b181b3de4bdae", "url": "https://github.com/nuxeo/nuxeo/commit/daea2067c5fc41afcdcbe6f93a3b181b3de4bdae", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-01-30T15:51:40Z", "type": "forcePushed"}, {"oid": "a0177d8443163f8db77eec605f9f5fa55dd083e0", "url": "https://github.com/nuxeo/nuxeo/commit/a0177d8443163f8db77eec605f9f5fa55dd083e0", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-01-31T09:14:54Z", "type": "forcePushed"}, {"oid": "52c037cdde2d781876aa7f406792a201f0f25631", "url": "https://github.com/nuxeo/nuxeo/commit/52c037cdde2d781876aa7f406792a201f0f25631", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-01-31T14:58:58Z", "type": "forcePushed"}, {"oid": "4581752a41feed5984e802623a26fc746c7886ae", "url": "https://github.com/nuxeo/nuxeo/commit/4581752a41feed5984e802623a26fc746c7886ae", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-01-31T17:29:04Z", "type": "forcePushed"}, {"oid": "6d1ba3deabbaaa26f956c09916894788a69013f2", "url": "https://github.com/nuxeo/nuxeo/commit/6d1ba3deabbaaa26f956c09916894788a69013f2", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-01-31T17:48:56Z", "type": "forcePushed"}, {"oid": "84492a629809ce548300151bda7f1a4394d13137", "url": "https://github.com/nuxeo/nuxeo/commit/84492a629809ce548300151bda7f1a4394d13137", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-01-31T17:55:06Z", "type": "forcePushed"}, {"oid": "7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "url": "https://github.com/nuxeo/nuxeo/commit/7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-03T08:35:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE4Nzk4Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374187982", "body": "You could inject `AutomationService`.", "bodyText": "You could inject AutomationService.", "bodyHTML": "<p dir=\"auto\">You could inject <code>AutomationService</code>.</p>", "author": "ataillefer", "createdAt": "2020-02-03T16:01:57Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.DummyThumbnailFactory;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@Deploy(\"org.nuxeo.ecm.automation.core\")\n+@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-coldstorage-contrib.xml\")\n+public abstract class AbstractTestColdStorageOperation {\n+\n+    public static final String FILE_CONTENT = \"foo and boo\";\n+\n+    public static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n+            throws OperationException, IOException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            DocumentModel updatedDocModel = (DocumentModel) Framework.getService(AutomationService.class)", "originalCommit": "7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\nindex fcc46bc2e63..eab75e0cc87 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n", "chunk": "@@ -49,19 +50,19 @@ import org.nuxeo.runtime.test.runner.FeaturesRunner;\n @RunWith(FeaturesRunner.class)\n @Features(CoreFeature.class)\n @Deploy(\"org.nuxeo.ecm.automation.core\")\n-@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-coldstorage-contrib.xml\")\n+@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-dummy-thumbnail-factory-contrib.xml\")\n public abstract class AbstractTestColdStorageOperation {\n \n-    public static final String FILE_CONTENT = \"foo and boo\";\n+    protected static final String FILE_CONTENT = \"foo and boo\";\n \n-    public static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+    @Inject\n+    protected AutomationService automationService;\n \n     protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n             throws OperationException, IOException {\n         try (OperationContext context = new OperationContext(session)) {\n             context.setInput(documentModel);\n-            DocumentModel updatedDocModel = (DocumentModel) Framework.getService(AutomationService.class)\n-                                                                     .run(context, MoveToColdStorage.ID);\n+            DocumentModel updatedDocModel = (DocumentModel) automationService.run(context, MoveToColdStorage.ID);\n             Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n             Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n                     ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\ndeleted file mode 100644\nindex eab75e0cc87..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n+++ /dev/null\n", "chunk": "@@ -1,84 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.document;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.automation.AutomationService;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.core.DummyThumbnailFactory;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.CoreFeature;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(CoreFeature.class)\n-@Deploy(\"org.nuxeo.ecm.automation.core\")\n-@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-dummy-thumbnail-factory-contrib.xml\")\n-public abstract class AbstractTestColdStorageOperation {\n-\n-    protected static final String FILE_CONTENT = \"foo and boo\";\n-\n-    @Inject\n-    protected AutomationService automationService;\n-\n-    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n-            throws OperationException, IOException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            DocumentModel updatedDocModel = (DocumentModel) automationService.run(context, MoveToColdStorage.ID);\n-            Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n-            Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n-                    ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-            assertEquals(documentModel.getRef(), updatedDocModel.getRef());\n-            assertTrue(updatedDocModel.hasFacet(FacetNames.COLD_STORAGE));\n-            assertEquals(DummyThumbnailFactory.DUMMY_THUMBNAIL_CONTENT, fileContent.getString());\n-            assertEquals(FILE_CONTENT, coldStorageContent.getString());\n-        }\n-    }\n-\n-    protected DocumentModel createFileDocument(CoreSession session, boolean withBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"MyFile\", \"File\");\n-        if (withBlobContent) {\n-            documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY,\n-                    (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-}\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\nnew file mode 100644\nindex 00000000000..eab75e0cc87\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n", "chunk": "@@ -0,0 +1,84 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.DummyThumbnailFactory;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@Deploy(\"org.nuxeo.ecm.automation.core\")\n+@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-dummy-thumbnail-factory-contrib.xml\")\n+public abstract class AbstractTestColdStorageOperation {\n+\n+    protected static final String FILE_CONTENT = \"foo and boo\";\n+\n+    @Inject\n+    protected AutomationService automationService;\n+\n+    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n+            throws OperationException, IOException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            DocumentModel updatedDocModel = (DocumentModel) automationService.run(context, MoveToColdStorage.ID);\n+            Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n+            Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n+                    ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+            assertEquals(documentModel.getRef(), updatedDocModel.getRef());\n+            assertTrue(updatedDocModel.hasFacet(FacetNames.COLD_STORAGE));\n+            assertEquals(DummyThumbnailFactory.DUMMY_THUMBNAIL_CONTENT, fileContent.getString());\n+            assertEquals(FILE_CONTENT, coldStorageContent.getString());\n+        }\n+    }\n+\n+    protected DocumentModel createFileDocument(CoreSession session, boolean withBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"MyFile\", \"File\");\n+        if (withBlobContent) {\n+            documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY,\n+                    (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE4ODExOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374188119", "body": "Same remark as above.", "bodyText": "Same remark as above.", "bodyHTML": "<p dir=\"auto\">Same remark as above.</p>", "author": "ataillefer", "createdAt": "2020-02-03T16:02:10Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.DummyThumbnailFactory;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@Deploy(\"org.nuxeo.ecm.automation.core\")\n+@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-coldstorage-contrib.xml\")\n+public abstract class AbstractTestColdStorageOperation {\n+\n+    public static final String FILE_CONTENT = \"foo and boo\";\n+\n+    public static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n+            throws OperationException, IOException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            DocumentModel updatedDocModel = (DocumentModel) Framework.getService(AutomationService.class)\n+                                                                     .run(context, MoveToColdStorage.ID);\n+            Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n+            Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n+                    ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+            assertEquals(documentModel.getRef(), updatedDocModel.getRef());\n+            assertTrue(updatedDocModel.hasFacet(FacetNames.COLD_STORAGE));\n+            assertEquals(DummyThumbnailFactory.DUMMY_THUMBNAIL_CONTENT, fileContent.getString());\n+            assertEquals(FILE_CONTENT, coldStorageContent.getString());\n+        }\n+    }\n+\n+    protected void retrieveContentFromColdStorage(CoreSession session, DocumentModel documentModel)\n+            throws OperationException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            context.setInput(documentModel);\n+            AutomationService automationService = Framework.getService(AutomationService.class);", "originalCommit": "7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\nindex fcc46bc2e63..eab75e0cc87 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n", "chunk": "@@ -72,21 +73,7 @@ public abstract class AbstractTestColdStorageOperation {\n         }\n     }\n \n-    protected void retrieveContentFromColdStorage(CoreSession session, DocumentModel documentModel)\n-            throws OperationException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            context.setInput(documentModel);\n-            AutomationService automationService = Framework.getService(AutomationService.class);\n-            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n-            DocumentModel updatedDocument = (DocumentModel) automationService.run(context, RetrieveFromColdStorage.ID,\n-                    params);\n-            assertTrue((boolean) updatedDocument.getPropertyValue(\n-                    ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-        }\n-    }\n-\n-    protected DocumentModel createDocument(CoreSession session, boolean withBlobContent) {\n+    protected DocumentModel createFileDocument(CoreSession session, boolean withBlobContent) {\n         DocumentModel documentModel = session.createDocumentModel(\"/\", \"MyFile\", \"File\");\n         if (withBlobContent) {\n             documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY,\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\ndeleted file mode 100644\nindex eab75e0cc87..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n+++ /dev/null\n", "chunk": "@@ -1,84 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.document;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.automation.AutomationService;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.core.DummyThumbnailFactory;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.CoreFeature;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(CoreFeature.class)\n-@Deploy(\"org.nuxeo.ecm.automation.core\")\n-@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-dummy-thumbnail-factory-contrib.xml\")\n-public abstract class AbstractTestColdStorageOperation {\n-\n-    protected static final String FILE_CONTENT = \"foo and boo\";\n-\n-    @Inject\n-    protected AutomationService automationService;\n-\n-    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n-            throws OperationException, IOException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            DocumentModel updatedDocModel = (DocumentModel) automationService.run(context, MoveToColdStorage.ID);\n-            Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n-            Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n-                    ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-            assertEquals(documentModel.getRef(), updatedDocModel.getRef());\n-            assertTrue(updatedDocModel.hasFacet(FacetNames.COLD_STORAGE));\n-            assertEquals(DummyThumbnailFactory.DUMMY_THUMBNAIL_CONTENT, fileContent.getString());\n-            assertEquals(FILE_CONTENT, coldStorageContent.getString());\n-        }\n-    }\n-\n-    protected DocumentModel createFileDocument(CoreSession session, boolean withBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"MyFile\", \"File\");\n-        if (withBlobContent) {\n-            documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY,\n-                    (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-}\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\nnew file mode 100644\nindex 00000000000..eab75e0cc87\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n", "chunk": "@@ -0,0 +1,84 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.DummyThumbnailFactory;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@Deploy(\"org.nuxeo.ecm.automation.core\")\n+@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-dummy-thumbnail-factory-contrib.xml\")\n+public abstract class AbstractTestColdStorageOperation {\n+\n+    protected static final String FILE_CONTENT = \"foo and boo\";\n+\n+    @Inject\n+    protected AutomationService automationService;\n+\n+    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n+            throws OperationException, IOException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            DocumentModel updatedDocModel = (DocumentModel) automationService.run(context, MoveToColdStorage.ID);\n+            Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n+            Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n+                    ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+            assertEquals(documentModel.getRef(), updatedDocModel.getRef());\n+            assertTrue(updatedDocModel.hasFacet(FacetNames.COLD_STORAGE));\n+            assertEquals(DummyThumbnailFactory.DUMMY_THUMBNAIL_CONTENT, fileContent.getString());\n+            assertEquals(FILE_CONTENT, coldStorageContent.getString());\n+        }\n+    }\n+\n+    protected DocumentModel createFileDocument(CoreSession session, boolean withBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"MyFile\", \"File\");\n+        if (withBlobContent) {\n+            documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY,\n+                    (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU5Mzg3MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374593870", "body": "```suggestion\r\n * Retrieves the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Retrieve the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a\n          \n          \n            \n             * Retrieves the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi x x-first x-last\">Retrieve</span> the cold storage content associated with the input {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">DocumentModel</span>}<span class=\"pl-c1\">.</span> <span class=\"pl-smi\">This</span> operation will initiate a</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi x x-first x-last\">Retrieves</span> the cold storage content associated with the input {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">DocumentModel</span>}<span class=\"pl-c1\">.</span> <span class=\"pl-smi\">This</span> operation will initiate a</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-04T10:37:43Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Retrieve the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a", "originalCommit": "7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nsimilarity index 51%\nrename from nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\nrename to nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nindex c4e8aafe2de..47f1835baef 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -28,19 +28,23 @@ import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n import org.nuxeo.ecm.core.api.Blob;\n import org.nuxeo.ecm.core.api.CoreSession;\n import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.api.Framework;\n \n /**\n- * Retrieve the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a\n- * request restore, calling the {@link Blob#getStream()} during this process doesn't mean you will get the blob content\n- * immediately.\n+ * Requests a retrieval from the cold storage content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n  * \n  * @since 11.1\n  */\n-@Operation(id = RetrieveFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request a retrieve from Cold Storage\", description = \"Request a cold storage content retrieval associated with the document. \")\n-public class RetrieveFromColdStorage {\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval of the cold storage content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n \n-    public static final String ID = \"Document.RetrieveFromColdStorage\";\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n \n     @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n     protected int numberOfDaysOfAvailability;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU5NDI2OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374594269", "body": "```suggestion\r\n * restore request, calling the {@link Blob#getStream()} during this process doesn't mean you will get the blob's content.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * request restore, calling the {@link Blob#getStream()} during this process doesn't mean you will get the blob content\n          \n          \n            \n             * restore request, calling the {@link Blob#getStream()} during this process doesn't mean you will get the blob's content.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span> <span class=\"x x-first x-last\">request </span>restore, calling the {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Blob</span>#getStream()} during <span class=\"pl-c1\">this</span> process doesn<span class=\"pl-s\"><span class=\"pl-pds\">'</span>t mean you will get the blob content</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> restore<span class=\"x x-first x-last\"> request</span>, calling the {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Blob</span>#getStream()} during <span class=\"pl-c1\">this</span> process doesn<span class=\"pl-s\"><span class=\"pl-pds\">'</span>t mean you will get the blob<span class=\"pl-pds x x-first\">'</span></span><span class=\"x x-last\">s</span> content<span class=\"x x-first x-last\">.</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-04T10:38:33Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Retrieve the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a\n+ * request restore, calling the {@link Blob#getStream()} during this process doesn't mean you will get the blob content", "originalCommit": "7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nsimilarity index 51%\nrename from nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\nrename to nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nindex c4e8aafe2de..47f1835baef 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -28,19 +28,23 @@ import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n import org.nuxeo.ecm.core.api.Blob;\n import org.nuxeo.ecm.core.api.CoreSession;\n import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.api.Framework;\n \n /**\n- * Retrieve the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a\n- * request restore, calling the {@link Blob#getStream()} during this process doesn't mean you will get the blob content\n- * immediately.\n+ * Requests a retrieval from the cold storage content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n  * \n  * @since 11.1\n  */\n-@Operation(id = RetrieveFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request a retrieve from Cold Storage\", description = \"Request a cold storage content retrieval associated with the document. \")\n-public class RetrieveFromColdStorage {\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval of the cold storage content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n \n-    public static final String ID = \"Document.RetrieveFromColdStorage\";\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n \n     @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n     protected int numberOfDaysOfAvailability;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYwODgzNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374608836", "body": "As said in https://github.com/nuxeo/nuxeo/pull/3666#discussion_r371899774 (maybe drowned in the resolved comment):\r\n\r\nThe `moveContentToColdStorage` doesn't perform a move but a copy.\r\nShouldn't we set the \"file:content\" property to `null` to perform an actual move? Then let the caller eventually put something else in \"file:content\"...", "bodyText": "As said in #3666 (comment) (maybe drowned in the resolved comment):\nThe moveContentToColdStorage doesn't perform a move but a copy.\nShouldn't we set the \"file:content\" property to null to perform an actual move? Then let the caller eventually put something else in \"file:content\"...", "bodyHTML": "<p dir=\"auto\">As said in <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"549547030\" data-permission-text=\"Title is private\" data-url=\"https://github.com/nuxeo/nuxeo/issues/3666\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/nuxeo/nuxeo/pull/3666/hovercard?comment_id=371899774&amp;comment_type=review_comment\" href=\"https://github.com/nuxeo/nuxeo/pull/3666#discussion_r371899774\">#3666 (comment)</a> (maybe drowned in the resolved comment):</p>\n<p dir=\"auto\">The <code>moveContentToColdStorage</code> doesn't perform a move but a copy.<br>\nShouldn't we set the \"file:content\" property to <code>null</code> to perform an actual move? Then let the caller eventually put something else in \"file:content\"...</p>", "author": "ataillefer", "createdAt": "2020-02-04T11:09:16Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.Serializable;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     * \n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if there is no main content associated with the given document, or if the main content is\n+     *             already in the cold storage\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);", "originalCommit": "96efca371fa4143e9aa1d42e0e04aedc36e0956f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 527ec8e86ae..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -69,11 +80,136 @@ public class ColdStorageHelper {\n                     SC_CONFLICT);\n         }\n \n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n         documentModel.addFacet(FacetNames.COLD_STORAGE);\n         documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n+    // it will trigger the restoration request too\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            int numberOfDaysOfAvailability) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n+                numberOfDaysOfAvailability);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     */\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available for a given repository.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxNjM5NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374616395", "body": "```suggestion\r\n     * @apiNote This method will initiate a restore request, calling the {@link Blob#getStream()} during this process\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @apiNote This method will initiate a request restore, calling the {@link Blob#getStream()} during this process\n          \n          \n            \n                 * @apiNote This method will initiate a restore request, calling the {@link Blob#getStream()} during this process", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@apiNote</span> <span class=\"pl-smi\">This</span> method will initiate a <span class=\"x x-first x-last\">request </span>restore, calling the {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Blob</span>#getStream()} during <span class=\"pl-c1\">this</span> process</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@apiNote</span> <span class=\"pl-smi\">This</span> method will initiate a restore<span class=\"x x-first x-last\"> request</span>, calling the {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Blob</span>#getStream()} during <span class=\"pl-c1\">this</span> process</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-04T11:27:10Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -74,6 +77,43 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Retrieves the cold storage content associated with the document of the given {@link DocumentRef}.\n+     * \n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a request restore, calling the {@link Blob#getStream()} during this process", "originalCommit": "254d274d5d6fd2bc9e70780eb02ec1e6210fc35e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 184fea74564..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -72,29 +80,38 @@ public class ColdStorageHelper {\n                     SC_CONFLICT);\n         }\n \n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n         documentModel.addFacet(FacetNames.COLD_STORAGE);\n         documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n         return session.saveDocument(documentModel);\n     }\n \n     /**\n-     * Retrieves the cold storage content associated with the document of the given {@link DocumentRef}.\n-     * \n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n      * @param session the core session\n      * @param documentRef the document reference\n      * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n      *            restoring\n-     * @apiNote This method will initiate a request restore, calling the {@link Blob#getStream()} during this process\n-     *          doesn't mean you will get the blob content immediately.\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n      * @return the updated document model if the retrieve succeeds\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n-    public static DocumentModel retrieveContentFromColdStorage(CoreSession session, DocumentRef documentRef,\n+    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n+    // it will trigger the restoration request too\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n             int numberOfDaysOfAvailability) {\n         DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", () -> documentModel,\n-                () -> numberOfDaysOfAvailability);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n+                numberOfDaysOfAvailability);\n \n         if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -97,21 +104,20 @@ public class ColdStorageHelper {\n      *\n      * @param session the core session\n      * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n      * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n      *          process doesn't mean you will get the blob's content.\n      * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n     public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n         DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n \n         if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxODUxOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374618519", "body": "I would remove these 2 assertions since the retrieval only updates the boolean field.", "bodyText": "I would remove these 2 assertions since the retrieval only updates the boolean field.", "bodyHTML": "<p dir=\"auto\">I would remove these 2 assertions since the retrieval only updates the boolean field.</p>", "author": "ataillefer", "createdAt": "2020-02-04T11:32:44Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -108,6 +110,66 @@ public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n         }\n     }\n \n+    @Test\n+    public void shouldRetrieveDocumentBlobFromColdStorage() throws IOException {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // retrieve, which means initiate a request to restore the blob from cold storage\n+        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        transactionalFeature.nextTransaction();\n+        documentModel = session.getDocument(documentModel.getRef());\n+\n+        assertTrue((Boolean) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+\n+        // check that `file:content` still contains the main content blob\n+        checkBlobContent(documentModel, ColdStorageHelper.FILE_CONTENT_PROPERTY, FILE_CONTENT);\n+\n+        // check that `coldstorage:coldContent` still contains the original file content\n+        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);", "originalCommit": "254d274d5d6fd2bc9e70780eb02ec1e6210fc35e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 7256276d269..4ce71ef21de 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -111,56 +110,51 @@ public class TestColdStorage {\n     }\n \n     @Test\n-    public void shouldRetrieveDocumentBlobFromColdStorage() throws IOException {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n \n-        // retrieve, which means initiate a request to restore the blob from cold storage\n-        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n         transactionalFeature.nextTransaction();\n-        documentModel = session.getDocument(documentModel.getRef());\n-\n-        assertTrue((Boolean) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+        documentModel.refresh();\n \n-        // check that `file:content` still contains the main content blob\n-        checkBlobContent(documentModel, ColdStorageHelper.FILE_CONTENT_PROPERTY, FILE_CONTENT);\n-\n-        // check that `coldstorage:coldContent` still contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        assertTrue(Boolean.TRUE.equals(\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n     }\n \n     @Test\n-    public void shouldFailWhenRetrievingDocumentBlobFromColdStorageBeingRetrieved() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n \n-        // retrieve, which means initiate a request to restore the blob from cold storage\n-        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n \n-        // try to retrieve a second time\n+        // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                     NUMBER_OF_DAYS_OF_AVAILABILITY);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n         } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n                     documentModel), ne.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenRetrievingDocumentBlobWithoutColdStorageContent() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try to retrieve from cold storage where the blob is not stored in it\n-            ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+            // try a request retrieval from the cold storage content where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                     NUMBER_OF_DAYS_OF_AVAILABILITY);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n         } catch (NuxeoException ne) {\n", "next_change": {"commit": "e79e79cf3b52c7ae075339c8e07e3812e6b75910", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 4ce71ef21de..96eb4d537aa 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -151,7 +161,7 @@ public class TestColdStorage {\n \n     @Test\n     public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n-        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n             // try a request retrieval from the cold storage content where the blob is not stored in it\n             ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 96eb4d537aa..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -85,132 +102,140 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n-                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n-                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n         transactionalFeature.nextTransaction();\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n \n-            // all cold storage contents being retrieved are now available\n-            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n \n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(3, listener.streamCapturedEvents().count());\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n \n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n \n-            documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEventIds);\n-        }\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n     }\n \n-    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n         DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n     }\n \n     protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 89eff27a524..848b2fa9790 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -263,28 +200,30 @@ public class TestColdStorage {\n                                                .sorted() //\n                                                .collect(Collectors.toList());\n \n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-            });\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEventIds);\n         }\n+    }\n \n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n \n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxOTA2OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374619069", "body": "Maybe add a TODO here to explain that for now it only sets a boolean property but later on it will actually trigger the restore request to the cold storage?", "bodyText": "Maybe add a TODO here to explain that for now it only sets a boolean property but later on it will actually trigger the restore request to the cold storage?", "bodyHTML": "<p dir=\"auto\">Maybe add a TODO here to explain that for now it only sets a boolean property but later on it will actually trigger the restore request to the cold storage?</p>", "author": "ataillefer", "createdAt": "2020-02-04T11:34:07Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -74,6 +77,43 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Retrieves the cold storage content associated with the document of the given {@link DocumentRef}.\n+     * \n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a request restore, calling the {@link Blob#getStream()} during this process\n+     *          doesn't mean you will get the blob content immediately.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */", "originalCommit": "254d274d5d6fd2bc9e70780eb02ec1e6210fc35e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 184fea74564..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -72,29 +80,38 @@ public class ColdStorageHelper {\n                     SC_CONFLICT);\n         }\n \n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n         documentModel.addFacet(FacetNames.COLD_STORAGE);\n         documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n         return session.saveDocument(documentModel);\n     }\n \n     /**\n-     * Retrieves the cold storage content associated with the document of the given {@link DocumentRef}.\n-     * \n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n      * @param session the core session\n      * @param documentRef the document reference\n      * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n      *            restoring\n-     * @apiNote This method will initiate a request restore, calling the {@link Blob#getStream()} during this process\n-     *          doesn't mean you will get the blob content immediately.\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n      * @return the updated document model if the retrieve succeeds\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n-    public static DocumentModel retrieveContentFromColdStorage(CoreSession session, DocumentRef documentRef,\n+    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n+    // it will trigger the restoration request too\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n             int numberOfDaysOfAvailability) {\n         DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", () -> documentModel,\n-                () -> numberOfDaysOfAvailability);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n+                numberOfDaysOfAvailability);\n \n         if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -97,21 +104,20 @@ public class ColdStorageHelper {\n      *\n      * @param session the core session\n      * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n      * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n      *          process doesn't mean you will get the blob's content.\n      * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n     public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n         DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n \n         if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyMDMyNA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374620324", "body": "I would replace these 2 lines by `documentModel = session.save()` since we are not waiting for any asynchronous work, the retrieval is indeed a synchronous process.", "bodyText": "I would replace these 2 lines by documentModel = session.save() since we are not waiting for any asynchronous work, the retrieval is indeed a synchronous process.", "bodyHTML": "<p dir=\"auto\">I would replace these 2 lines by <code>documentModel = session.save()</code> since we are not waiting for any asynchronous work, the retrieval is indeed a synchronous process.</p>", "author": "ataillefer", "createdAt": "2020-02-04T11:37:26Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -108,6 +110,66 @@ public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n         }\n     }\n \n+    @Test\n+    public void shouldRetrieveDocumentBlobFromColdStorage() throws IOException {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // retrieve, which means initiate a request to restore the blob from cold storage\n+        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        transactionalFeature.nextTransaction();\n+        documentModel = session.getDocument(documentModel.getRef());", "originalCommit": "254d274d5d6fd2bc9e70780eb02ec1e6210fc35e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTEzNjE4MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375136180", "bodyText": "as explained on slack this is done to ensure that we will not have a false positive it's why i made transactionalFeature.nextTransaction(); and i reload the document. we can replace\ntransactionalFeature.nextTransaction(); by session.save() but as usual we use transactionalFeature.nextTransaction(); i used it. but if you think the use session.save is better i will modify it\nor perhaps i missed something because session.save() has a void returned type", "author": "RSalem07", "createdAt": "2020-02-05T09:15:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyMDMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1ODg3OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375158879", "bodyText": "Sorry, yes I meant just\ndocumentModel = session.getDocument(documentModel.getRef());\nsession.save()\n\nBut OK for  transactionalFeature.nextTransaction() \ud83d\udc4d", "author": "ataillefer", "createdAt": "2020-02-05T09:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyMDMyNA=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 7256276d269..4ce71ef21de 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -111,56 +110,51 @@ public class TestColdStorage {\n     }\n \n     @Test\n-    public void shouldRetrieveDocumentBlobFromColdStorage() throws IOException {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n \n-        // retrieve, which means initiate a request to restore the blob from cold storage\n-        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n         transactionalFeature.nextTransaction();\n-        documentModel = session.getDocument(documentModel.getRef());\n-\n-        assertTrue((Boolean) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+        documentModel.refresh();\n \n-        // check that `file:content` still contains the main content blob\n-        checkBlobContent(documentModel, ColdStorageHelper.FILE_CONTENT_PROPERTY, FILE_CONTENT);\n-\n-        // check that `coldstorage:coldContent` still contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        assertTrue(Boolean.TRUE.equals(\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n     }\n \n     @Test\n-    public void shouldFailWhenRetrievingDocumentBlobFromColdStorageBeingRetrieved() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n \n-        // retrieve, which means initiate a request to restore the blob from cold storage\n-        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n \n-        // try to retrieve a second time\n+        // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                     NUMBER_OF_DAYS_OF_AVAILABILITY);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n         } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n                     documentModel), ne.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenRetrievingDocumentBlobWithoutColdStorageContent() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try to retrieve from cold storage where the blob is not stored in it\n-            ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+            // try a request retrieval from the cold storage content where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                     NUMBER_OF_DAYS_OF_AVAILABILITY);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n         } catch (NuxeoException ne) {\n", "next_change": {"commit": "e79e79cf3b52c7ae075339c8e07e3812e6b75910", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 4ce71ef21de..96eb4d537aa 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -151,7 +161,7 @@ public class TestColdStorage {\n \n     @Test\n     public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n-        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n             // try a request retrieval from the cold storage content where the blob is not stored in it\n             ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 96eb4d537aa..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -85,132 +102,140 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n-                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n-                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n         transactionalFeature.nextTransaction();\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n \n-            // all cold storage contents being retrieved are now available\n-            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n \n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(3, listener.streamCapturedEvents().count());\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n \n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n \n-            documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEventIds);\n-        }\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n     }\n \n-    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n         DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n     }\n \n     protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 89eff27a524..848b2fa9790 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -263,28 +200,30 @@ public class TestColdStorage {\n                                                .sorted() //\n                                                .collect(Collectors.toList());\n \n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-            });\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEventIds);\n         }\n+    }\n \n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n \n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyMTkzMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374621931", "body": "I think you don't need the lambdas here.", "bodyText": "I think you don't need the lambdas here.", "bodyHTML": "<p dir=\"auto\">I think you don't need the lambdas here.</p>", "author": "ataillefer", "createdAt": "2020-02-04T11:41:20Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -74,6 +77,43 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Retrieves the cold storage content associated with the document of the given {@link DocumentRef}.\n+     * \n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a request restore, calling the {@link Blob#getStream()} during this process\n+     *          doesn't mean you will get the blob content immediately.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel retrieveContentFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            int numberOfDaysOfAvailability) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", () -> documentModel,", "originalCommit": "254d274d5d6fd2bc9e70780eb02ec1e6210fc35e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 184fea74564..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -72,29 +80,38 @@ public class ColdStorageHelper {\n                     SC_CONFLICT);\n         }\n \n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n         documentModel.addFacet(FacetNames.COLD_STORAGE);\n         documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n         return session.saveDocument(documentModel);\n     }\n \n     /**\n-     * Retrieves the cold storage content associated with the document of the given {@link DocumentRef}.\n-     * \n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n      * @param session the core session\n      * @param documentRef the document reference\n      * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n      *            restoring\n-     * @apiNote This method will initiate a request restore, calling the {@link Blob#getStream()} during this process\n-     *          doesn't mean you will get the blob content immediately.\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n      * @return the updated document model if the retrieve succeeds\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n-    public static DocumentModel retrieveContentFromColdStorage(CoreSession session, DocumentRef documentRef,\n+    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n+    // it will trigger the restoration request too\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n             int numberOfDaysOfAvailability) {\n         DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", () -> documentModel,\n-                () -> numberOfDaysOfAvailability);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n+                numberOfDaysOfAvailability);\n \n         if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -97,21 +104,20 @@ public class ColdStorageHelper {\n      *\n      * @param session the core session\n      * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n      * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n      *          process doesn't mean you will get the blob's content.\n      * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n     public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n         DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n \n         if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyMzMzMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374623333", "body": "We should try to be consistent: if we consider that the \"retrieve\" operation/helper performs a restore (restoration?) request, let's always use these terms.", "bodyText": "We should try to be consistent: if we consider that the \"retrieve\" operation/helper performs a restore (restoration?) request, let's always use these terms.", "bodyHTML": "<p dir=\"auto\">We should try to be consistent: if we consider that the \"retrieve\" operation/helper performs a restore (restoration?) request, let's always use these terms.</p>", "author": "ataillefer", "createdAt": "2020-02-04T11:44:50Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Retrieve the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a\n+ * request restore, calling the {@link Blob#getStream()} during this process doesn't mean you will get the blob content\n+ * immediately.\n+ * \n+ * @since 11.1\n+ */\n+@Operation(id = RetrieveFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request a retrieve from Cold Storage\", description = \"Request a cold storage content retrieval associated with the document. \")", "originalCommit": "254d274d5d6fd2bc9e70780eb02ec1e6210fc35e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE0MDk1OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375140959", "bodyText": "yep, i asked on slack initially when i started the devs on this ticket and i introduced the term restore to be closer with the S3 documentation where mainly they used the term restore.\n\nwhat if the rename the retrieve operation/helper -> restore operation/helper\nor if we want to keep the word retrieve i will update the label/description of the operation", "author": "RSalem07", "createdAt": "2020-02-05T09:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyMzMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE2MDYyMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375160622", "bodyText": "I would keep retrieve and update the operation label to \"Request restoration from cold storage\" and description \"Request a cold storage content restoration associated with the document\".", "author": "ataillefer", "createdAt": "2020-02-05T10:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyMzMzMw=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nsimilarity index 51%\nrename from nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\nrename to nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nindex c4e8aafe2de..47f1835baef 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -28,19 +28,23 @@ import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n import org.nuxeo.ecm.core.api.Blob;\n import org.nuxeo.ecm.core.api.CoreSession;\n import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.api.Framework;\n \n /**\n- * Retrieve the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a\n- * request restore, calling the {@link Blob#getStream()} during this process doesn't mean you will get the blob content\n- * immediately.\n+ * Requests a retrieval from the cold storage content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n  * \n  * @since 11.1\n  */\n-@Operation(id = RetrieveFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request a retrieve from Cold Storage\", description = \"Request a cold storage content retrieval associated with the document. \")\n-public class RetrieveFromColdStorage {\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval of the cold storage content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n \n-    public static final String ID = \"Document.RetrieveFromColdStorage\";\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n \n     @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n     protected int numberOfDaysOfAvailability;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyNDI5MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374624290", "body": "duplicate :)", "bodyText": "duplicate :)", "bodyHTML": "<p dir=\"auto\">duplicate :)</p>", "author": "ataillefer", "createdAt": "2020-02-04T11:47:14Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.DummyThumbnailFactory;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@Deploy(\"org.nuxeo.ecm.automation.core\")\n+@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-coldstorage-contrib.xml\")\n+public abstract class AbstractTestColdStorageOperation {\n+\n+    public static final String FILE_CONTENT = \"foo and boo\";\n+\n+    public static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n+            throws OperationException, IOException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            DocumentModel updatedDocModel = (DocumentModel) Framework.getService(AutomationService.class)\n+                                                                     .run(context, MoveToColdStorage.ID);\n+            Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n+            Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n+                    ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+            assertEquals(documentModel.getRef(), updatedDocModel.getRef());\n+            assertTrue(updatedDocModel.hasFacet(FacetNames.COLD_STORAGE));\n+            assertEquals(DummyThumbnailFactory.DUMMY_THUMBNAIL_CONTENT, fileContent.getString());\n+            assertEquals(FILE_CONTENT, coldStorageContent.getString());\n+        }\n+    }\n+\n+    protected void retrieveContentFromColdStorage(CoreSession session, DocumentModel documentModel)\n+            throws OperationException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            context.setInput(documentModel);", "originalCommit": "254d274d5d6fd2bc9e70780eb02ec1e6210fc35e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\nindex fcc46bc2e63..eab75e0cc87 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n", "chunk": "@@ -72,21 +73,7 @@ public abstract class AbstractTestColdStorageOperation {\n         }\n     }\n \n-    protected void retrieveContentFromColdStorage(CoreSession session, DocumentModel documentModel)\n-            throws OperationException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            context.setInput(documentModel);\n-            AutomationService automationService = Framework.getService(AutomationService.class);\n-            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n-            DocumentModel updatedDocument = (DocumentModel) automationService.run(context, RetrieveFromColdStorage.ID,\n-                    params);\n-            assertTrue((boolean) updatedDocument.getPropertyValue(\n-                    ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-        }\n-    }\n-\n-    protected DocumentModel createDocument(CoreSession session, boolean withBlobContent) {\n+    protected DocumentModel createFileDocument(CoreSession session, boolean withBlobContent) {\n         DocumentModel documentModel = session.createDocumentModel(\"/\", \"MyFile\", \"File\");\n         if (withBlobContent) {\n             documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY,\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\ndeleted file mode 100644\nindex eab75e0cc87..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n+++ /dev/null\n", "chunk": "@@ -1,84 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.document;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.automation.AutomationService;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.core.DummyThumbnailFactory;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.CoreFeature;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(CoreFeature.class)\n-@Deploy(\"org.nuxeo.ecm.automation.core\")\n-@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-dummy-thumbnail-factory-contrib.xml\")\n-public abstract class AbstractTestColdStorageOperation {\n-\n-    protected static final String FILE_CONTENT = \"foo and boo\";\n-\n-    @Inject\n-    protected AutomationService automationService;\n-\n-    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n-            throws OperationException, IOException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            DocumentModel updatedDocModel = (DocumentModel) automationService.run(context, MoveToColdStorage.ID);\n-            Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n-            Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n-                    ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-            assertEquals(documentModel.getRef(), updatedDocModel.getRef());\n-            assertTrue(updatedDocModel.hasFacet(FacetNames.COLD_STORAGE));\n-            assertEquals(DummyThumbnailFactory.DUMMY_THUMBNAIL_CONTENT, fileContent.getString());\n-            assertEquals(FILE_CONTENT, coldStorageContent.getString());\n-        }\n-    }\n-\n-    protected DocumentModel createFileDocument(CoreSession session, boolean withBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"MyFile\", \"File\");\n-        if (withBlobContent) {\n-            documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY,\n-                    (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-}\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\nnew file mode 100644\nindex 00000000000..eab75e0cc87\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n", "chunk": "@@ -0,0 +1,84 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.DummyThumbnailFactory;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@Deploy(\"org.nuxeo.ecm.automation.core\")\n+@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-dummy-thumbnail-factory-contrib.xml\")\n+public abstract class AbstractTestColdStorageOperation {\n+\n+    protected static final String FILE_CONTENT = \"foo and boo\";\n+\n+    @Inject\n+    protected AutomationService automationService;\n+\n+    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n+            throws OperationException, IOException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            DocumentModel updatedDocModel = (DocumentModel) automationService.run(context, MoveToColdStorage.ID);\n+            Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n+            Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n+                    ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+            assertEquals(documentModel.getRef(), updatedDocModel.getRef());\n+            assertTrue(updatedDocModel.hasFacet(FacetNames.COLD_STORAGE));\n+            assertEquals(DummyThumbnailFactory.DUMMY_THUMBNAIL_CONTENT, fileContent.getString());\n+            assertEquals(FILE_CONTENT, coldStorageContent.getString());\n+        }\n+    }\n+\n+    protected DocumentModel createFileDocument(CoreSession session, boolean withBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"MyFile\", \"File\");\n+        if (withBlobContent) {\n+            documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY,\n+                    (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyNTA5NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374625095", "body": "why not check the returned doc:\r\n```\r\nassertEquals(documentModel.getRef(), updatedDocModel.getRef())\r\n```", "bodyText": "why not check the returned doc:\nassertEquals(documentModel.getRef(), updatedDocModel.getRef())", "bodyHTML": "<p dir=\"auto\">why not check the returned doc:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"assertEquals(documentModel.getRef(), updatedDocModel.getRef())\"><pre><code>assertEquals(documentModel.getRef(), updatedDocModel.getRef())\n</code></pre></div>", "author": "ataillefer", "createdAt": "2020-02-04T11:49:22Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.DummyThumbnailFactory;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@Deploy(\"org.nuxeo.ecm.automation.core\")\n+@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-coldstorage-contrib.xml\")\n+public abstract class AbstractTestColdStorageOperation {\n+\n+    public static final String FILE_CONTENT = \"foo and boo\";\n+\n+    public static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n+            throws OperationException, IOException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            DocumentModel updatedDocModel = (DocumentModel) Framework.getService(AutomationService.class)\n+                                                                     .run(context, MoveToColdStorage.ID);\n+            Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n+            Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n+                    ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+            assertEquals(documentModel.getRef(), updatedDocModel.getRef());\n+            assertTrue(updatedDocModel.hasFacet(FacetNames.COLD_STORAGE));\n+            assertEquals(DummyThumbnailFactory.DUMMY_THUMBNAIL_CONTENT, fileContent.getString());\n+            assertEquals(FILE_CONTENT, coldStorageContent.getString());\n+        }\n+    }\n+\n+    protected void retrieveContentFromColdStorage(CoreSession session, DocumentModel documentModel)\n+            throws OperationException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            context.setInput(documentModel);\n+            AutomationService automationService = Framework.getService(AutomationService.class);\n+            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            DocumentModel updatedDocument = (DocumentModel) automationService.run(context, RetrieveFromColdStorage.ID,\n+                    params);\n+            assertTrue((boolean) updatedDocument.getPropertyValue(", "originalCommit": "254d274d5d6fd2bc9e70780eb02ec1e6210fc35e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\nindex fcc46bc2e63..eab75e0cc87 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n", "chunk": "@@ -72,21 +73,7 @@ public abstract class AbstractTestColdStorageOperation {\n         }\n     }\n \n-    protected void retrieveContentFromColdStorage(CoreSession session, DocumentModel documentModel)\n-            throws OperationException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            context.setInput(documentModel);\n-            AutomationService automationService = Framework.getService(AutomationService.class);\n-            Map<String, Integer> params = Map.of(\"numberOfDaysOfAvailability\", NUMBER_OF_DAYS_OF_AVAILABILITY);\n-            DocumentModel updatedDocument = (DocumentModel) automationService.run(context, RetrieveFromColdStorage.ID,\n-                    params);\n-            assertTrue((boolean) updatedDocument.getPropertyValue(\n-                    ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-        }\n-    }\n-\n-    protected DocumentModel createDocument(CoreSession session, boolean withBlobContent) {\n+    protected DocumentModel createFileDocument(CoreSession session, boolean withBlobContent) {\n         DocumentModel documentModel = session.createDocumentModel(\"/\", \"MyFile\", \"File\");\n         if (withBlobContent) {\n             documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY,\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\ndeleted file mode 100644\nindex eab75e0cc87..00000000000\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n+++ /dev/null\n", "chunk": "@@ -1,84 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.automation.core.operations.document;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.automation.AutomationService;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.core.DummyThumbnailFactory;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.CoreFeature;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(CoreFeature.class)\n-@Deploy(\"org.nuxeo.ecm.automation.core\")\n-@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-dummy-thumbnail-factory-contrib.xml\")\n-public abstract class AbstractTestColdStorageOperation {\n-\n-    protected static final String FILE_CONTENT = \"foo and boo\";\n-\n-    @Inject\n-    protected AutomationService automationService;\n-\n-    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n-            throws OperationException, IOException {\n-        try (OperationContext context = new OperationContext(session)) {\n-            context.setInput(documentModel);\n-            DocumentModel updatedDocModel = (DocumentModel) automationService.run(context, MoveToColdStorage.ID);\n-            Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n-            Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n-                    ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-            assertEquals(documentModel.getRef(), updatedDocModel.getRef());\n-            assertTrue(updatedDocModel.hasFacet(FacetNames.COLD_STORAGE));\n-            assertEquals(DummyThumbnailFactory.DUMMY_THUMBNAIL_CONTENT, fileContent.getString());\n-            assertEquals(FILE_CONTENT, coldStorageContent.getString());\n-        }\n-    }\n-\n-    protected DocumentModel createFileDocument(CoreSession session, boolean withBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"MyFile\", \"File\");\n-        if (withBlobContent) {\n-            documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY,\n-                    (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-}\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\nnew file mode 100644\nindex 00000000000..eab75e0cc87\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/test/java/org/nuxeo/ecm/automation/core/operations/document/AbstractTestColdStorageOperation.java\n", "chunk": "@@ -0,0 +1,84 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.core.DummyThumbnailFactory;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+@Deploy(\"org.nuxeo.ecm.automation.core\")\n+@Deploy(\"org.nuxeo.ecm.core.test.tests:OSGI-INF/test-dummy-thumbnail-factory-contrib.xml\")\n+public abstract class AbstractTestColdStorageOperation {\n+\n+    protected static final String FILE_CONTENT = \"foo and boo\";\n+\n+    @Inject\n+    protected AutomationService automationService;\n+\n+    protected void moveContentToColdStorage(CoreSession session, DocumentModel documentModel)\n+            throws OperationException, IOException {\n+        try (OperationContext context = new OperationContext(session)) {\n+            context.setInput(documentModel);\n+            DocumentModel updatedDocModel = (DocumentModel) automationService.run(context, MoveToColdStorage.ID);\n+            Blob fileContent = (Blob) updatedDocModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY);\n+            Blob coldStorageContent = (Blob) updatedDocModel.getPropertyValue(\n+                    ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+            assertEquals(documentModel.getRef(), updatedDocModel.getRef());\n+            assertTrue(updatedDocModel.hasFacet(FacetNames.COLD_STORAGE));\n+            assertEquals(DummyThumbnailFactory.DUMMY_THUMBNAIL_CONTENT, fileContent.getString());\n+            assertEquals(FILE_CONTENT, coldStorageContent.getString());\n+        }\n+    }\n+\n+    protected DocumentModel createFileDocument(CoreSession session, boolean withBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"MyFile\", \"File\");\n+        if (withBlobContent) {\n+            documentModel.setPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY,\n+                    (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyNzcxOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374627718", "body": "Id rather see:\r\n```\r\n        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\r\n        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\r\n                NUMBER_OF_DAYS_OF_AVAILABILITY);\r\n```\r\nSince the methods return the DocumentModel we may as well use it.", "bodyText": "Id rather see:\n        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n                NUMBER_OF_DAYS_OF_AVAILABILITY);\n\nSince the methods return the DocumentModel we may as well use it.", "bodyHTML": "<p dir=\"auto\">Id rather see:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n                NUMBER_OF_DAYS_OF_AVAILABILITY);\"><pre><code>        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n                NUMBER_OF_DAYS_OF_AVAILABILITY);\n</code></pre></div>\n<p dir=\"auto\">Since the methods return the DocumentModel we may as well use it.</p>", "author": "ataillefer", "createdAt": "2020-02-04T11:55:49Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -170,8 +178,49 @@ public void shouldFailWhenRetrievingDocumentBlobWithoutColdStorageContent() {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldCheckAvailabilityOfColdStorageContent() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n+                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n+                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+        transactionalFeature.nextTransaction();\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkAvailabilityOfColdStorageContent(\n+                    session);\n+            assertEquals(session.getRepositoryName(), coldStorageContentStatus.getRepositoryName());\n+\n+            // all cold storage contents being retrieved are now available\n+            assertEquals(documents.size(), coldStorageContentStatus.getTotalBeingRetrieved());\n+            assertEquals(documents.size(), coldStorageContentStatus.getTotalContentAvailable());\n+\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(3, listener.streamCapturedEvents().count());\n+\n+            List<String> docEvents = listener.streamCapturedEvents() //\n+                                             .map(event -> {\n+                                                 DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                 return docCtx.getSourceDocument().getId();\n+                                             }) //\n+                                             .sorted() //\n+                                             .collect(Collectors.toList());\n+\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEvents);\n+        }\n+    }\n+\n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        return documentModel;", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE0NTI5NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375145294", "bodyText": "yes, i did it to avoid any false positive test assertion. as the helper set the value if i check only the returned doc as it set only this boolean, necessarily it will be true it's why i reload the doc and wait until the commit of TX", "author": "RSalem07", "createdAt": "2020-02-05T09:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyNzcxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE2MjM1Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375162356", "bodyText": "As you wish, you can keep the next transaction call in the caller to ensure false positive detection, but it still feels weird in this method to return the initial document passed as a parameter instead of the updated one.", "author": "ataillefer", "createdAt": "2020-02-05T10:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyNzcxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMjkyMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375202922", "bodyText": "i agree  sorry i will return directly the document in this case", "author": "RSalem07", "createdAt": "2020-02-05T11:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyNzcxOA=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex df45aa167f7..4ce71ef21de 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -187,36 +173,34 @@ public class TestColdStorage {\n         transactionalFeature.nextTransaction();\n         try (CapturingEventListener listener = new CapturingEventListener(\n                 ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkAvailabilityOfColdStorageContent(\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n                     session);\n-            assertEquals(session.getRepositoryName(), coldStorageContentStatus.getRepositoryName());\n \n             // all cold storage contents being retrieved are now available\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalContentAvailable());\n+            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n+            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n \n             assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n             assertEquals(3, listener.streamCapturedEvents().count());\n \n-            List<String> docEvents = listener.streamCapturedEvents() //\n-                                             .map(event -> {\n-                                                 DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                 return docCtx.getSourceDocument().getId();\n-                                             }) //\n-                                             .sorted() //\n-                                             .collect(Collectors.toList());\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n \n             documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEvents);\n+            assertEquals(documents, docEventIds);\n         }\n     }\n \n     protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n         DocumentModel documentModel = createDocument(documentName, true);\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n-        return documentModel;\n     }\n \n     protected DocumentModel createDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "e79e79cf3b52c7ae075339c8e07e3812e6b75910", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 4ce71ef21de..96eb4d537aa 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -197,13 +207,13 @@ public class TestColdStorage {\n     }\n \n     protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n-        DocumentModel documentModel = createDocument(documentName, true);\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n         return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n         DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 96eb4d537aa..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -85,132 +102,140 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n-                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n-                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n         transactionalFeature.nextTransaction();\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n \n-            // all cold storage contents being retrieved are now available\n-            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n \n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(3, listener.streamCapturedEvents().count());\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n \n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n \n-            documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEventIds);\n-        }\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n     }\n \n-    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n         DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n     }\n \n     protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 89eff27a524..848b2fa9790 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -263,28 +200,30 @@ public class TestColdStorage {\n                                                .sorted() //\n                                                .collect(Collectors.toList());\n \n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-            });\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEventIds);\n         }\n+    }\n \n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n \n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyODEyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374628125", "body": "Isn't this a use case for `List.of()`?", "bodyText": "Isn't this a use case for List.of()?", "bodyHTML": "<p dir=\"auto\">Isn't this a use case for <code>List.of()</code>?</p>", "author": "ataillefer", "createdAt": "2020-02-04T11:56:45Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -170,8 +178,49 @@ public void shouldFailWhenRetrievingDocumentBlobWithoutColdStorageContent() {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldCheckAvailabilityOfColdStorageContent() {\n+        List<String> documents = Arrays.asList( //", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1MzkzOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375153939", "bodyText": "List.of() is a really immutable type of list: no adding, no removing, no update ...which is not the case of Arrays.asList and as i perform a sort to compare:\ndocuments.sort(Comparator.naturalOrder());\n            assertEquals(documents, docEvents);\n\nwith ListOf it will fail because the list will change duing to the sort.", "author": "RSalem07", "createdAt": "2020-02-05T09:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyODEyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "434ed557ac5ddc81e3493bd67148941167b1fded", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex df45aa167f7..4f3519d0010 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -182,44 +186,28 @@ public class TestColdStorage {\n     public void shouldCheckAvailabilityOfColdStorageContent() {\n         List<String> documents = Arrays.asList( //\n                 moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n+                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(),\n                 moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n-        transactionalFeature.nextTransaction();\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkAvailabilityOfColdStorageContent(\n-                    session);\n-            assertEquals(session.getRepositoryName(), coldStorageContentStatus.getRepositoryName());\n \n-            // all cold storage contents being retrieved are now available\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalContentAvailable());\n+        transactionalFeature.nextTransaction();\n+        addColdStorageContentBlobStatus(documents.get(0), new BlobStatus().withDownloadable(false));\n+        addColdStorageContentBlobStatus(documents.get(1), new BlobStatus().withDownloadable(false));\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(2)), 2);\n \n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(3, listener.streamCapturedEvents().count());\n-\n-            List<String> docEvents = listener.streamCapturedEvents() //\n-                                             .map(event -> {\n-                                                 DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                 return docCtx.getSourceDocument().getId();\n-                                             }) //\n-                                             .sorted() //\n-                                             .collect(Collectors.toList());\n-\n-            documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEvents);\n-        }\n+        transactionalFeature.nextTransaction();\n+        addColdStorageContentBlobStatus(documents.get(0), new BlobStatus().withDownloadable(true));\n+        addColdStorageContentBlobStatus(documents.get(1), new BlobStatus().withDownloadable(true));\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(0), documents.get(1)), 0);\n     }\n \n     protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n-        DocumentModel documentModel = createDocument(documentName, true);\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n-        return documentModel;\n     }\n \n-    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n         DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 4f3519d0010..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -93,118 +102,140 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n-                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n \n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n         transactionalFeature.nextTransaction();\n-        addColdStorageContentBlobStatus(documents.get(0), new BlobStatus().withDownloadable(false));\n-        addColdStorageContentBlobStatus(documents.get(1), new BlobStatus().withDownloadable(false));\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(2)), 2);\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n \n         transactionalFeature.nextTransaction();\n-        addColdStorageContentBlobStatus(documents.get(0), new BlobStatus().withDownloadable(true));\n-        addColdStorageContentBlobStatus(documents.get(1), new BlobStatus().withDownloadable(true));\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(0), documents.get(1)), 0);\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n     }\n \n-    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n         DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n     }\n \n     protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 89eff27a524..848b2fa9790 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -263,28 +200,30 @@ public class TestColdStorage {\n                                                .sorted() //\n                                                .collect(Collectors.toList());\n \n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-            });\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEventIds);\n         }\n+    }\n \n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n \n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyODI3MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374628271", "body": "not strictly needed", "bodyText": "not strictly needed", "bodyHTML": "<p dir=\"auto\">not strictly needed</p>", "author": "ataillefer", "createdAt": "2020-02-04T11:57:07Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -170,8 +178,49 @@ public void shouldFailWhenRetrievingDocumentBlobWithoutColdStorageContent() {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldCheckAvailabilityOfColdStorageContent() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n+                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n+                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+        transactionalFeature.nextTransaction();", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1NjA1NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375156055", "bodyText": "you mean transactionalFeature.nextTransaction(); ? if it is the case. unfortunately this is required otherwise the test fail because\nColdStorageHelper.checkAvailabilityOfColdStorageContent(\n                    session);\n\nwill perform a query and we should commit the tx.", "author": "RSalem07", "createdAt": "2020-02-05T09:53:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyODI3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE2MjY3OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375162679", "bodyText": "Yes, OK \ud83d\udc4d", "author": "ataillefer", "createdAt": "2020-02-05T10:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyODI3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex df45aa167f7..4ce71ef21de 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -187,36 +173,34 @@ public class TestColdStorage {\n         transactionalFeature.nextTransaction();\n         try (CapturingEventListener listener = new CapturingEventListener(\n                 ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkAvailabilityOfColdStorageContent(\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n                     session);\n-            assertEquals(session.getRepositoryName(), coldStorageContentStatus.getRepositoryName());\n \n             // all cold storage contents being retrieved are now available\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalContentAvailable());\n+            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n+            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n \n             assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n             assertEquals(3, listener.streamCapturedEvents().count());\n \n-            List<String> docEvents = listener.streamCapturedEvents() //\n-                                             .map(event -> {\n-                                                 DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                 return docCtx.getSourceDocument().getId();\n-                                             }) //\n-                                             .sorted() //\n-                                             .collect(Collectors.toList());\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n \n             documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEvents);\n+            assertEquals(documents, docEventIds);\n         }\n     }\n \n     protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n         DocumentModel documentModel = createDocument(documentName, true);\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n-        return documentModel;\n     }\n \n     protected DocumentModel createDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "e79e79cf3b52c7ae075339c8e07e3812e6b75910", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 4ce71ef21de..96eb4d537aa 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -197,13 +207,13 @@ public class TestColdStorage {\n     }\n \n     protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n-        DocumentModel documentModel = createDocument(documentName, true);\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n         return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n         DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 96eb4d537aa..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -85,132 +102,140 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n-                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n-                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n         transactionalFeature.nextTransaction();\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n \n-            // all cold storage contents being retrieved are now available\n-            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n \n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(3, listener.streamCapturedEvents().count());\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n \n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n \n-            documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEventIds);\n-        }\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n     }\n \n-    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n         DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n     }\n \n     protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 89eff27a524..848b2fa9790 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -263,28 +200,30 @@ public class TestColdStorage {\n                                                .sorted() //\n                                                .collect(Collectors.toList());\n \n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-            });\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEventIds);\n         }\n+    }\n \n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n \n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYyODYzMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374628632", "body": "```suggestion\r\n    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\r\n```\r\ntiny less verbose", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n          \n          \n            \n                public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n          \n      \n    \n    \n  \n\ntiny less verbose", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-smi\">ColdStorageContentStatus</span> <span class=\"x x-first x-last\">checkAvailabilityOfColdStorageContent</span>(<span class=\"pl-smi\">CoreSession</span> session) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-smi\">ColdStorageContentStatus</span> <span class=\"x x-first x-last\">checkColdStorageContentAvailability</span>(<span class=\"pl-smi\">CoreSession</span> session) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">tiny less verbose</p>", "author": "ataillefer", "createdAt": "2020-02-04T11:58:05Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -114,6 +126,83 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage content are available for downloading.\n+     *\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n+     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n+     *            available for downloading. In which case then it will fire an event with name\n+     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     */\n+    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -127,44 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzMDU1OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374630558", "body": "Do we need these for now? What's their purpose?\r\nI understand it's for testing, in which case I find it confusing since there's no real usage..", "bodyText": "Do we need these for now? What's their purpose?\nI understand it's for testing, in which case I find it confusing since there's no real usage..", "bodyHTML": "<p dir=\"auto\">Do we need these for now? What's their purpose?<br>\nI understand it's for testing, in which case I find it confusing since there's no real usage..</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:02:44Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -114,6 +126,83 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage content are available for downloading.\n+     *\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n+     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n+     *            available for downloading. In which case then it will fire an event with name\n+     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     */\n+    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n+\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n+     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n+     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n+    }\n+\n+    /**\n+     * Gives status about the cold storage content being retrieved or are available for a given repository.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final String repositoryName;\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalContentAvailable;\n+\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE1NzkxNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375157915", "bodyText": "for now the only use is in the test but my idea is to have the status of scheduled job available for more logging ...", "author": "RSalem07", "createdAt": "2020-02-05T09:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzMDU1OA=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -173,33 +188,25 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Gives status about the cold storage content being retrieved or are available for a given repository.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNDUwMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374634500", "body": "If we want to keep `getTotalBeingRetrieved` (see https://github.com/nuxeo/nuxeo/pull/3666/commits/aa516a7728bc3b0ff6adf1b73cbe788845a41f8e#r374630558), I would expect the future retrieval process to set the \"beingRetrieved\" boolean to false, right?\r\nWaiting for this, maybe we could decrement the beingRetrived counter in `checkAvailabilityOfColdStorageContent` along with `available++`, WDYT?\r\nJust feels funny here to have as many documents available as the ones being retrieved.", "bodyText": "If we want to keep getTotalBeingRetrieved (see aa516a7#r374630558), I would expect the future retrieval process to set the \"beingRetrieved\" boolean to false, right?\nWaiting for this, maybe we could decrement the beingRetrived counter in checkAvailabilityOfColdStorageContent along with available++, WDYT?\nJust feels funny here to have as many documents available as the ones being retrieved.", "bodyHTML": "<p dir=\"auto\">If we want to keep <code>getTotalBeingRetrieved</code> (see <a class=\"commit-link\" href=\"https://github.com/nuxeo/nuxeo/commit/aa516a7728bc3b0ff6adf1b73cbe788845a41f8e#r374630558\"><tt>aa516a7</tt>#r374630558</a>), I would expect the future retrieval process to set the \"beingRetrieved\" boolean to false, right?<br>\nWaiting for this, maybe we could decrement the beingRetrived counter in <code>checkAvailabilityOfColdStorageContent</code> along with <code>available++</code>, WDYT?<br>\nJust feels funny here to have as many documents available as the ones being retrieved.</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:12:26Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -170,8 +178,49 @@ public void shouldFailWhenRetrievingDocumentBlobWithoutColdStorageContent() {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldCheckAvailabilityOfColdStorageContent() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n+                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n+                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+        transactionalFeature.nextTransaction();\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkAvailabilityOfColdStorageContent(\n+                    session);\n+            assertEquals(session.getRepositoryName(), coldStorageContentStatus.getRepositoryName());\n+\n+            // all cold storage contents being retrieved are now available\n+            assertEquals(documents.size(), coldStorageContentStatus.getTotalBeingRetrieved());", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MDE4MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374640180", "bodyText": "OK, so the boolean field is reset here: 7a25db5#diff-ead64399e0b98c4a84e7b8cef49b5444R158.\nSo, I would definitley decrement the \"beingRetrieved\" counter just after.", "author": "ataillefer", "createdAt": "2020-02-04T12:25:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNDUwMA=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex df45aa167f7..4ce71ef21de 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -187,36 +173,34 @@ public class TestColdStorage {\n         transactionalFeature.nextTransaction();\n         try (CapturingEventListener listener = new CapturingEventListener(\n                 ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkAvailabilityOfColdStorageContent(\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n                     session);\n-            assertEquals(session.getRepositoryName(), coldStorageContentStatus.getRepositoryName());\n \n             // all cold storage contents being retrieved are now available\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalContentAvailable());\n+            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n+            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n \n             assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n             assertEquals(3, listener.streamCapturedEvents().count());\n \n-            List<String> docEvents = listener.streamCapturedEvents() //\n-                                             .map(event -> {\n-                                                 DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                 return docCtx.getSourceDocument().getId();\n-                                             }) //\n-                                             .sorted() //\n-                                             .collect(Collectors.toList());\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n \n             documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEvents);\n+            assertEquals(documents, docEventIds);\n         }\n     }\n \n     protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n         DocumentModel documentModel = createDocument(documentName, true);\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n-        return documentModel;\n     }\n \n     protected DocumentModel createDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "e79e79cf3b52c7ae075339c8e07e3812e6b75910", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 4ce71ef21de..96eb4d537aa 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -197,13 +207,13 @@ public class TestColdStorage {\n     }\n \n     protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n-        DocumentModel documentModel = createDocument(documentName, true);\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n         return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n         DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 96eb4d537aa..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -85,132 +102,140 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n-                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n-                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n         transactionalFeature.nextTransaction();\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n \n-            // all cold storage contents being retrieved are now available\n-            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n \n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(3, listener.streamCapturedEvents().count());\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n \n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n \n-            documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEventIds);\n-        }\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n     }\n \n-    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n         DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n     }\n \n     protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 89eff27a524..848b2fa9790 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -263,28 +200,30 @@ public class TestColdStorage {\n                                                .sorted() //\n                                                .collect(Collectors.toList());\n \n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-            });\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEventIds);\n         }\n+    }\n \n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n \n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYzNTI2Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374635263", "body": "```suggestion\r\n            List<String> docEventIds = listener.streamCapturedEvents() //\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<String> docEvents = listener.streamCapturedEvents() //\n          \n          \n            \n                        List<String> docEventIds = listener.streamCapturedEvents() //", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">List&lt;<span class=\"pl-smi\">String</span>&gt;</span> <span class=\"x x-first x-last\">docEvents</span> <span class=\"pl-k\">=</span> listener<span class=\"pl-k\">.</span>streamCapturedEvents() <span class=\"pl-c\"><span class=\"pl-c\">//</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">List&lt;<span class=\"pl-smi\">String</span>&gt;</span> <span class=\"x x-first x-last\">docEventIds</span> <span class=\"pl-k\">=</span> listener<span class=\"pl-k\">.</span>streamCapturedEvents() <span class=\"pl-c\"><span class=\"pl-c\">//</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-04T12:14:09Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -170,8 +178,49 @@ public void shouldFailWhenRetrievingDocumentBlobWithoutColdStorageContent() {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldCheckAvailabilityOfColdStorageContent() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n+                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n+                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+        transactionalFeature.nextTransaction();\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkAvailabilityOfColdStorageContent(\n+                    session);\n+            assertEquals(session.getRepositoryName(), coldStorageContentStatus.getRepositoryName());\n+\n+            // all cold storage contents being retrieved are now available\n+            assertEquals(documents.size(), coldStorageContentStatus.getTotalBeingRetrieved());\n+            assertEquals(documents.size(), coldStorageContentStatus.getTotalContentAvailable());\n+\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(3, listener.streamCapturedEvents().count());\n+\n+            List<String> docEvents = listener.streamCapturedEvents() //", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex df45aa167f7..4ce71ef21de 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -187,36 +173,34 @@ public class TestColdStorage {\n         transactionalFeature.nextTransaction();\n         try (CapturingEventListener listener = new CapturingEventListener(\n                 ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkAvailabilityOfColdStorageContent(\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n                     session);\n-            assertEquals(session.getRepositoryName(), coldStorageContentStatus.getRepositoryName());\n \n             // all cold storage contents being retrieved are now available\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalContentAvailable());\n+            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n+            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n \n             assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n             assertEquals(3, listener.streamCapturedEvents().count());\n \n-            List<String> docEvents = listener.streamCapturedEvents() //\n-                                             .map(event -> {\n-                                                 DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                 return docCtx.getSourceDocument().getId();\n-                                             }) //\n-                                             .sorted() //\n-                                             .collect(Collectors.toList());\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n \n             documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEvents);\n+            assertEquals(documents, docEventIds);\n         }\n     }\n \n     protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n         DocumentModel documentModel = createDocument(documentName, true);\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n-        return documentModel;\n     }\n \n     protected DocumentModel createDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "e79e79cf3b52c7ae075339c8e07e3812e6b75910", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 4ce71ef21de..96eb4d537aa 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -197,13 +207,13 @@ public class TestColdStorage {\n     }\n \n     protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n-        DocumentModel documentModel = createDocument(documentName, true);\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n         return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n         DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 96eb4d537aa..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -85,132 +102,140 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n-                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n-                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n         transactionalFeature.nextTransaction();\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n \n-            // all cold storage contents being retrieved are now available\n-            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n \n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(3, listener.streamCapturedEvents().count());\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n \n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n \n-            documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEventIds);\n-        }\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n     }\n \n-    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n         DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n     }\n \n     protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 89eff27a524..848b2fa9790 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -263,28 +200,30 @@ public class TestColdStorage {\n                                                .sorted() //\n                                                .collect(Collectors.toList());\n \n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-            });\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEventIds);\n         }\n+    }\n \n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n \n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MDcwMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374640702", "body": "\"content is\" or \"contents are\"", "bodyText": "\"content is\" or \"contents are\"", "bodyHTML": "<p dir=\"auto\">\"content is\" or \"contents are\"</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:26:39Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -114,6 +126,83 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage content are available for downloading.", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -119,7 +124,7 @@ public class ColdStorageHelper {\n             throw new NuxeoException(\n                     String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n                             documentModel),\n-                    SC_CONFLICT);\n+                    SC_FORBIDDEN);\n         }\n \n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -127,6 +132,15 @@ public class ColdStorageHelper {\n                     SC_FORBIDDEN);\n         }\n \n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String coldContentKey = ((ManagedBlob) coldContent).getKey();\n+            Duration duration = Duration.of(numberOfDaysOfAvailability, ChronoUnit.DAYS);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(coldContentKey).withRestoreForDuration(duration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException ioe) {\n+            throw new NuxeoException(ioe);\n+        }\n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n         return session.saveDocument(documentModel);\n     }\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -134,15 +135,14 @@ public class ColdStorageHelper {\n \n         try {\n             Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String coldContentKey = ((ManagedBlob) coldContent).getKey();\n-            Duration duration = Duration.of(numberOfDaysOfAvailability, ChronoUnit.DAYS);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(coldContentKey).withRestoreForDuration(duration);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n             Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException ioe) {\n-            throw new NuxeoException(ioe);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n         }\n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n+        return documentModel;\n     }\n \n     /**\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -127,44 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MDkyMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374640920", "body": "Do we also want to filter versions?", "bodyText": "Do we also want to filter versions?", "bodyHTML": "<p dir=\"auto\">Do we also want to filter versions?</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:27:07Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -48,6 +54,12 @@\n \n     public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n \n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document WHERE %s = 1 and %s = 0\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY,\n+            NXQL.ECM_ISTRASHED);", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwNzUyMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375207523", "bodyText": "good question but i don't really hav an answer :) but i am wondering if the check on beingretrieved is good enough and sufficient on S3 moving to Glacier will create a new version but i don't know exactly if there is an effect on the query", "author": "RSalem07", "createdAt": "2020-02-05T11:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MDkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5MzA2Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375393063", "bodyText": "@efge WDYT?", "author": "ataillefer", "createdAt": "2020-02-05T17:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MDkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA2MDEzOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377060139", "bodyText": "I don't see why you would filter on anything, it's not this query's job to decide where coldstorage can be used. You should do SELECT * FROM Document, Relation WHERE coldstorage:beingRetrieved = 1 and that's it. The presence of the index on coldstorage:beingRetrieved will make sure this is fast anyway.", "author": "efge", "createdAt": "2020-02-10T13:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MDkyMA=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -55,28 +49,30 @@ public class ColdStorageHelper {\n     public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n \n     public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document WHERE %s = 1 and %s = 0\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY,\n-            NXQL.ECM_ISTRASHED);\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n \n     public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n \n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n+\n+    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n+\n+    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n+    public static final String TO_DEFINE = \"This information needs to be defined\";\n+\n     /**\n      * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     * \n+     *\n      * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if there is no main content associated with the given document, or if the main content is\n-     *             already in the cold storage\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n      */\n     public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n         DocumentModel documentModel = session.getDocument(documentRef);\n         log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n \n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n         if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n             throw new NuxeoException(\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MTY4Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374641682", "body": "```suggestion\r\n     * @implSpec: Queries all documents with a cold storage content being retrieved,\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n          \n          \n            \n                 * @implSpec: Queries all documents with a cold storage content being retrieved,", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@implSpec</span><span class=\"pl-k\">:</span> <span class=\"pl-smi x x-first\">This</span><span class=\"x x-last\"> method will query </span>all documents with a cold storage content <span class=\"x x-first x-last\">which are </span>being retrieved</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">@implSpec</span><span class=\"pl-k\">:</span> <span class=\"pl-smi x x-first\">Queries</span><span class=\"x x-last\"> </span>all documents with a cold storage content being retrieved<span class=\"x x-first x-last\">,</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-04T12:28:55Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -114,6 +126,83 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage content are available for downloading.\n+     *\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -127,44 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MjUyMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374642522", "body": "```suggestion\r\n     *            meaning {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true},\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n          \n          \n            \n                 *            meaning {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true},", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span>            {<span class=\"pl-k\">@value</span> <span class=\"pl-c1\">COLD_STORAGE_BEING_RETRIEVED_PROPERTY</span>},</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span>            <span class=\"x x-first x-last\">meaning </span>{<span class=\"pl-k\">@value</span> <span class=\"pl-c1\">COLD_STORAGE_BEING_RETRIEVED_PROPERTY</span><span class=\"x x-first\">} is {</span><span class=\"pl-k x\">@code</span><span class=\"x\"> </span><span class=\"pl-c1 x x-last\">true</span>},</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-04T12:30:50Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -114,6 +126,83 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage content are available for downloading.\n+     *\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -127,44 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MjkwMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374642900", "body": "Maybe remove the reference to `retrieveContentFromColdStorage` and put in in a `@see`? It's not clear within the sentence.", "bodyText": "Maybe remove the reference to retrieveContentFromColdStorage and put in in a @see? It's not clear within the sentence.", "bodyHTML": "<p dir=\"auto\">Maybe remove the reference to <code>retrieveContentFromColdStorage</code> and put in in a <code>@see</code>? It's not clear within the sentence.</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:31:42Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -114,6 +126,83 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage content are available for downloading.\n+     *\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n+     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -127,44 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MzI5OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374643299", "body": "```suggestion\r\n     *            available for download. In which case then it fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *            available for downloading. In which case then it will fire an event with name\n          \n          \n            \n                 *            available for download. In which case then it fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span>            available <span class=\"pl-k\">for</span> <span class=\"x x-first x-last\">downloading</span>. <span class=\"pl-smi\">In</span> which <span class=\"pl-k\">case</span> then it <span class=\"x x-first x-last\">will fire an event with name</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span>            available <span class=\"pl-k\">for</span> <span class=\"x x-first x-last\">download</span>. <span class=\"pl-smi\">In</span> which <span class=\"pl-k\">case</span> then it <span class=\"x x-first\">fires a {</span><span class=\"pl-k x\">@value</span><span class=\"x\"> </span><span class=\"pl-c1 x\">COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME</span><span class=\"x x-last\">} event.</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-04T12:32:41Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -114,6 +126,83 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage content are available for downloading.\n+     *\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n+     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n+     *            available for downloading. In which case then it will fire an event with name", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -127,44 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0NDY3NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374644675", "body": "I wonder if we want/need to store the numberOfDaysOfAvailability, or if this information will come from the cold storage when checking for availability, see https://github.com/nuxeo/nuxeo/pull/3666/commits/aa516a7728bc3b0ff6adf1b73cbe788845a41f8e#diff-ead64399e0b98c4a84e7b8cef49b5444R169, in which case it can then be passed dynamically to the fired event.", "bodyText": "I wonder if we want/need to store the numberOfDaysOfAvailability, or if this information will come from the cold storage when checking for availability, see aa516a7#diff-ead64399e0b98c4a84e7b8cef49b5444R169, in which case it can then be passed dynamically to the fired event.", "bodyHTML": "<p dir=\"auto\">I wonder if we want/need to store the numberOfDaysOfAvailability, or if this information will come from the cold storage when checking for availability, see <a class=\"commit-link\" href=\"https://github.com/nuxeo/nuxeo/commit/aa516a7728bc3b0ff6adf1b73cbe788845a41f8e#diff-ead64399e0b98c4a84e7b8cef49b5444R169\"><tt>aa516a7</tt>#diff-ead64399e0b98c4a84e7b8cef49b5444R169</a>, in which case it can then be passed dynamically to the fired event.</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:35:48Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -74,6 +77,43 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Retrieves the cold storage content associated with the document of the given {@link DocumentRef}.\n+     * \n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a request restore, calling the {@link Blob#getStream()} during this process\n+     *          doesn't mean you will get the blob content immediately.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel retrieveContentFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            int numberOfDaysOfAvailability) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", () -> documentModel,\n+                () -> numberOfDaysOfAvailability);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return session.saveDocument(documentModel);", "originalCommit": "254d274d5d6fd2bc9e70780eb02ec1e6210fc35e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE2NjczNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375166736", "bodyText": "i agree i asked myself the same question, i think we will store when the content is really available and this information will be in the mail. but as i don't know how to get this information i didn't do it perhaps i will add a TODO wdyt", "author": "RSalem07", "createdAt": "2020-02-05T10:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0NDY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyNTY2NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375425665", "bodyText": "yep, go for the TODO", "author": "ataillefer", "createdAt": "2020-02-05T18:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0NDY3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 184fea74564..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -107,13 +124,92 @@ public class ColdStorageHelper {\n             throw new NuxeoException(\n                     String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n                             documentModel),\n-                    SC_CONFLICT);\n+                    SC_FORBIDDEN);\n         }\n \n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     */\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available for a given repository.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0NTI2Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374645267", "body": "```suggestion\r\n     * Checks if the retrieved cold storage content associated with the given document is available for download.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n          \n          \n            \n                 * Checks if the retrieved cold storage content associated with the given document is available for download.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Checks</span> <span class=\"pl-k\">if</span> the retrieved cold storage content associated with the given document is available <span class=\"pl-k\">for</span> <span class=\"x x-first x-last\">downloading</span>.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi\">Checks</span> <span class=\"pl-k\">if</span> the retrieved cold storage content associated with the given document is available <span class=\"pl-k\">for</span> <span class=\"x x-first x-last\">download</span>.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-04T12:37:08Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -114,6 +126,83 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage content are available for downloading.\n+     *\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n+     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n+     *            available for downloading. In which case then it will fire an event with name\n+     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     */\n+    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n+\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for downloading.", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -127,44 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0NTQ3Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374645473", "body": "`@see` maybe?", "bodyText": "@see maybe?", "bodyHTML": "<p dir=\"auto\"><code>@see</code> maybe?</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:37:36Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -114,6 +126,83 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage content are available for downloading.\n+     *\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n+     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n+     *            available for downloading. In which case then it will fire an event with name\n+     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     */\n+    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n+\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n+     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n+     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -127,44 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0NTc5Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374645796", "body": "```suggestion\r\n     * Status about the cold storage content being retrieved or available for a given repository.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Gives status about the cold storage content being retrieved or are available for a given repository.\n          \n          \n            \n                 * Status about the cold storage content being retrieved or available for a given repository.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi x x-first\">Gives</span><span class=\"x x-last\"> status </span>about the cold storage content being retrieved or<span class=\"x x-first x-last\"> are</span> available <span class=\"pl-k\">for</span> a given repository.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-smi x x-first\">Status</span><span class=\"x x-last\"> </span>about the cold storage content being retrieved or available <span class=\"pl-k\">for</span> a given repository.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-04T12:38:24Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -114,6 +126,83 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage content are available for downloading.\n+     *\n+     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n+     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n+     *            available for downloading. In which case then it will fire an event with name\n+     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     */\n+    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n+\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n+     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n+     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n+    }\n+\n+    /**\n+     * Gives status about the cold storage content being retrieved or are available for a given repository.", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex bfeb3a6405d..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -173,33 +188,25 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Gives status about the cold storage content being retrieved or are available for a given repository.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0NjMyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374646325", "body": "```suggestion\r\n        log.debug(\"Start checking the available cold storage content\");\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    log.debug(\"Start checking the available cold storage content which are being retrieved\");\n          \n          \n            \n                    log.debug(\"Start checking the available cold storage content\");", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        log<span class=\"pl-k\">.</span>debug(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Start checking the available cold storage content<span class=\"x x-first x-last\"> which are being retrieved</span><span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        log<span class=\"pl-k\">.</span>debug(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Start checking the available cold storage content<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-04T12:39:26Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.coldstorage;\n+\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CloseableCoreSession;\n+import org.nuxeo.ecm.core.api.CoreInstance;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventListener;\n+import org.nuxeo.ecm.core.repository.RepositoryService;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * An asynchronous listener that checks if the contents being retrieved form cold storage are available.\n+ *\n+ * @apiNote: This listener is designed to be called from a scheduler.\n+ * @since 11.1\n+ */\n+public class CheckAvailabilityOfColdStorageContentListener implements EventListener {\n+\n+    private static final Logger log = LogManager.getLogger(CheckAvailabilityOfColdStorageContentListener.class);\n+\n+    @Override\n+    public void handleEvent(final Event event) {\n+        log.debug(\"Start checking the available cold storage content which are being retrieved\");", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckColdStorageContentAvailabilityListener.java\nsimilarity index 83%\nrename from nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java\nrename to nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckColdStorageContentAvailabilityListener.java\nindex 1801caa07aa..2e40ae664aa 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckColdStorageContentAvailabilityListener.java\n", "chunk": "@@ -32,22 +32,22 @@ import org.nuxeo.ecm.core.repository.RepositoryService;\n import org.nuxeo.runtime.api.Framework;\n \n /**\n- * An asynchronous listener that checks if the contents being retrieved form cold storage are available.\n+ * A synchronous listener that checks if the contents being retrieved form cold storage are available.\n  *\n  * @apiNote: This listener is designed to be called from a scheduler.\n  * @since 11.1\n  */\n-public class CheckAvailabilityOfColdStorageContentListener implements EventListener {\n+public class CheckColdStorageContentAvailabilityListener implements EventListener {\n \n-    private static final Logger log = LogManager.getLogger(CheckAvailabilityOfColdStorageContentListener.class);\n+    private static final Logger log = LogManager.getLogger(CheckColdStorageContentAvailabilityListener.class);\n \n     @Override\n     public void handleEvent(final Event event) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved\");\n+        log.debug(\"Start checking the available cold storage content\");\n         List<String> repositoryNames = Framework.getService(RepositoryService.class).getRepositoryNames();\n         for (String repository : repositoryNames) {\n             try (CloseableCoreSession coreSession = CoreInstance.openCoreSession(repository)) {\n-                ColdStorageHelper.checkAvailabilityOfColdStorageContent(coreSession);\n+                ColdStorageHelper.checkColdStorageContentAvailability(coreSession);\n             }\n         }\n         log.debug(\"End checking the available cold storage content\");\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0OTgwNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374649807", "body": "I believe you want a **synchronous** listener right? Since it's triggered by a scheduler that is already asynchronous.\r\n@efge can you please confirm?\r\n\r\nIn fact, since it's implementing `EventListener`, it is synchronous, no matter what attributes you put in the listener's contribution.", "bodyText": "I believe you want a synchronous listener right? Since it's triggered by a scheduler that is already asynchronous.\n@efge can you please confirm?\nIn fact, since it's implementing EventListener, it is synchronous, no matter what attributes you put in the listener's contribution.", "bodyHTML": "<p dir=\"auto\">I believe you want a <strong>synchronous</strong> listener right? Since it's triggered by a scheduler that is already asynchronous.<br>\n<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/efge/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/efge\">@efge</a> can you please confirm?</p>\n<p dir=\"auto\">In fact, since it's implementing <code>EventListener</code>, it is synchronous, no matter what attributes you put in the listener's contribution.</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:46:15Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.coldstorage;\n+\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CloseableCoreSession;\n+import org.nuxeo.ecm.core.api.CoreInstance;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventListener;\n+import org.nuxeo.ecm.core.repository.RepositoryService;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * An asynchronous listener that checks if the contents being retrieved form cold storage are available.", "originalCommit": "aa516a7728bc3b0ff6adf1b73cbe788845a41f8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3MTUzNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375171536", "bodyText": "i see i added because i define my listener as:\n<listener name=\"checkAvailabilityOfBlobsBeingRetrieved\" async=\"true\"...\n\nasync=\"true\".", "author": "RSalem07", "createdAt": "2020-02-05T10:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0OTgwNw=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckColdStorageContentAvailabilityListener.java\nsimilarity index 83%\nrename from nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java\nrename to nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckColdStorageContentAvailabilityListener.java\nindex 1801caa07aa..2e40ae664aa 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckColdStorageContentAvailabilityListener.java\n", "chunk": "@@ -32,22 +32,22 @@ import org.nuxeo.ecm.core.repository.RepositoryService;\n import org.nuxeo.runtime.api.Framework;\n \n /**\n- * An asynchronous listener that checks if the contents being retrieved form cold storage are available.\n+ * A synchronous listener that checks if the contents being retrieved form cold storage are available.\n  *\n  * @apiNote: This listener is designed to be called from a scheduler.\n  * @since 11.1\n  */\n-public class CheckAvailabilityOfColdStorageContentListener implements EventListener {\n+public class CheckColdStorageContentAvailabilityListener implements EventListener {\n \n-    private static final Logger log = LogManager.getLogger(CheckAvailabilityOfColdStorageContentListener.class);\n+    private static final Logger log = LogManager.getLogger(CheckColdStorageContentAvailabilityListener.class);\n \n     @Override\n     public void handleEvent(final Event event) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved\");\n+        log.debug(\"Start checking the available cold storage content\");\n         List<String> repositoryNames = Framework.getService(RepositoryService.class).getRepositoryNames();\n         for (String repository : repositoryNames) {\n             try (CloseableCoreSession coreSession = CoreInstance.openCoreSession(repository)) {\n-                ColdStorageHelper.checkAvailabilityOfColdStorageContent(coreSession);\n+                ColdStorageHelper.checkColdStorageContentAvailability(coreSession);\n             }\n         }\n         log.debug(\"End checking the available cold storage content\");\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1MjgyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374652825", "body": "Probaly want to decrement the beingRetrieved counter.", "bodyText": "Probaly want to decrement the beingRetrieved counter.", "bodyHTML": "<p dir=\"auto\">Probaly want to decrement the beingRetrieved counter.</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:53:33Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -148,7 +154,17 @@ public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(Cor\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                // mark the cold storage content of document as retrieved\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);", "originalCommit": "7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 350b4712b75..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -133,54 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                // mark the cold storage content of document as retrieved\n+                beingRetrieved--;\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n-\n-                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Map<String, Serializable> properties = new HashMap<>();\n-                // FIXME: wait for NXP-28417\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO DEFINE\");\n-                properties.put(ARCHIVE_LOCATION_KEY, \"https://www.nuxeo.com/\");\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n                 ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NDA5NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374654094", "body": "We might need a `session.save()` here, though the transactional context might be enough (we're in a synchronous listener called by a scheduled event), not sure.\r\n@efge WDYT?", "bodyText": "We might need a session.save() here, though the transactional context might be enough (we're in a synchronous listener called by a scheduled event), not sure.\n@efge WDYT?", "bodyHTML": "<p dir=\"auto\">We might need a <code>session.save()</code> here, though the transactional context might be enough (we're in a synchronous listener called by a scheduled event), not sure.<br>\n<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/efge/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/efge\">@efge</a> WDYT?</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:56:30Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -148,7 +154,17 @@ public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(Cor\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                // mark the cold storage content of document as retrieved\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);", "originalCommit": "7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 350b4712b75..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -133,54 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                // mark the cold storage content of document as retrieved\n+                beingRetrieved--;\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n-\n-                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Map<String, Serializable> properties = new HashMap<>();\n-                // FIXME: wait for NXP-28417\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO DEFINE\");\n-                properties.put(ARCHIVE_LOCATION_KEY, \"https://www.nuxeo.com/\");\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n                 ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NDYwMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374654602", "body": "Is this a use case for `var`?", "bodyText": "Is this a use case for var?", "bodyHTML": "<p dir=\"auto\">Is this a use case for <code>var</code>?</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:57:39Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -148,7 +154,17 @@ public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(Cor\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                // mark the cold storage content of document as retrieved\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Map<String, Serializable> properties = new HashMap<>();", "originalCommit": "7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 350b4712b75..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -133,54 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                // mark the cold storage content of document as retrieved\n+                beingRetrieved--;\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n-\n-                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Map<String, Serializable> properties = new HashMap<>();\n-                // FIXME: wait for NXP-28417\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO DEFINE\");\n-                properties.put(ARCHIVE_LOCATION_KEY, \"https://www.nuxeo.com/\");\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n                 ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NDgzOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374654839", "body": "Maybe something generic like \"TO_DEFINE\" as well?", "bodyText": "Maybe something generic like \"TO_DEFINE\" as well?", "bodyHTML": "<p dir=\"auto\">Maybe something generic like \"TO_DEFINE\" as well?</p>", "author": "ataillefer", "createdAt": "2020-02-04T12:58:11Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -148,7 +154,17 @@ public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(Cor\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n+                // mark the cold storage content of document as retrieved\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Map<String, Serializable> properties = new HashMap<>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"https://www.nuxeo.com/\");", "originalCommit": "7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3Njc5MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375176790", "bodyText": "you means just adding TO_DEFINE instead of \"https://www.nuxeo.com/\" or a new class filed TO_DEFINE = \"This will be defined\" and use it on the same", "author": "RSalem07", "createdAt": "2020-02-05T10:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NDgzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTI2MTkyOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375261929", "bodyText": "second option could be fine", "author": "ataillefer", "createdAt": "2020-02-05T13:44:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NDgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 350b4712b75..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -133,54 +132,54 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content are available for downloading.\n+     * Checks if the retrieved cold storage contents are available for download.\n      *\n-     * @implSpec: This method will query all documents with a cold storage content which are being retrieved\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY},\n-     *            {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)} and it checks if it is\n-     *            available for downloading. In which case then it will fire an event with name\n-     *            {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME}\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    public static ColdStorageContentStatus checkAvailabilityOfColdStorageContent(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n-                session::getRepositoryName);\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n             if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                // mark the cold storage content of document as retrieved\n+                beingRetrieved--;\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n-\n-                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Map<String, Serializable> properties = new HashMap<>();\n-                // FIXME: wait for NXP-28417\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO DEFINE\");\n-                properties.put(ARCHIVE_LOCATION_KEY, \"https://www.nuxeo.com/\");\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n                 ctx.setProperties(properties);\n                 Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n                 eventService.fireEvent(event);\n             }\n         }\n \n-        int total = documents.size();\n-        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n-                session.getRepositoryName(), available, total);\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n     /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for downloading.\n-     * {@link #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)}\n-     * {@link #checkAvailabilityOfColdStorageContent(CoreSession)}\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n      */\n     public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n         // FIXME to be reworked depending on how we will check the availability on low level\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -175,18 +202,6 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "960e6c655858499f414887fda04e08d3262c19ee", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..20d0b901151 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -202,6 +203,15 @@ public class ColdStorageHelper {\n         return new ColdStorageContentStatus(beingRetrieved, available);\n     }\n \n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     /**\n      * Status about the cold storage content being retrieved or available for a given repository.\n      */\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 20d0b901151..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -213,7 +213,7 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n+     * Status about the cold storage content being retrieved or available.\n      */\n     public static class ColdStorageContentStatus {\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..e6a655cf109 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -146,89 +140,88 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+        log.debug(\"Start checking the available cold storage content which are being retrieved for repository: {}\",\n+                session::getRepositoryName);\n \n         // as the volume of result will be small, we don't use BAF\n         DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n \n         // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n         int available = 0;\n         EventService eventService = Framework.getService(EventService.class);\n         for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n+            if (isColdStorageContentAvailable(doc)) {\n                 available++;\n-                beingRetrieved--;\n-\n+                // mark the cold storage content of document as retrieved\n                 doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n                 session.saveDocument(doc);\n \n+                // create and fire the event\n                 DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+                var properties = new HashMap<String, Serializable>();\n+                // FIXME: wait for NXP-28417\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, \"TO_DEFINE\");\n+                properties.put(ARCHIVE_LOCATION_KEY, \"TO_DEFINE\");\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n             }\n         }\n \n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n+        int total = documents.size();\n+        log.debug(\"End checking the available cold storage content for repository: {}, found: {}/{}\",\n+                session.getRepositoryName(), available, total);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), total, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex e6a655cf109..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -195,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NzQwNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374657406", "body": "Does this means that the user is automatically subscribed to the `ColdStorageContentAvailable` notification?\r\nThough, the attribute is set to `false` in the contribution.\r\nSo when is the user actually subscribed?\r\n", "bodyText": "Does this means that the user is automatically subscribed to the ColdStorageContentAvailable notification?\nThough, the attribute is set to false in the contribution.\nSo when is the user actually subscribed?", "bodyHTML": "<p dir=\"auto\">Does this means that the user is automatically subscribed to the <code>ColdStorageContentAvailable</code> notification?<br>\nThough, the attribute is set to <code>false</code> in the contribution.<br>\nSo when is the user actually subscribed?</p>", "author": "ataillefer", "createdAt": "2020-02-04T13:04:16Z", "path": "nuxeo-features/nuxeo-platform-notification/nuxeo-platform-notification-core/src/test/java/org/nuxeo/ecm/platform/ec/notification/operations/SubscribeAndUnsubscribeTest.java", "diffHunk": "@@ -112,7 +112,7 @@ public void testSubscribeAndUnsubscribeOperations() throws OperationException {\n \n         for (DocumentModel doc : listDocModel) {\n             List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertEquals(4, docSubscriptions.size());\n+            assertEquals(5, docSubscriptions.size());", "originalCommit": "7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE5MjY3NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375192675", "bodyText": "Does this means that the user is automatically subscribed to the ColdStorageContentAvailable notification?\nNo there is not auto-subscribing for this notification\n\nHere is a call to the operation:\n@Test\n    public void testSubscribeAndUnsubscribeOperations() throws OperationException {\n        OperationChain chain = new OperationChain(\"test-chain\");\n        chain.add(SubscribeOperation.ID);\n        ctx.setInput(listDocModel);\n        String username = NotificationConstants.USER_PREFIX + \n        ctx.getPrincipal().getName();\n.....\n\nand the  chain.add(SubscribeOperation.ID);  will subscribe all notifications available for a given document and now see here\n\nThough, the attribute is set to false in the contribution.\nSo when is the user actually subscribed?\n\nyes i asked this question on our private slack channel, the PO need to subscribe automatically (without user action) when he asked for a retrieval. but i encounter the limitation of the fact that at core/operation level we don't have  access to the core-notification module which responsible of subscribing.", "author": "RSalem07", "createdAt": "2020-02-05T11:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NzQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzODUzOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375438538", "bodyText": "We talked about adding a dependency to nuxeo-platform-notification-core in nuxeo-automation-core but this will induce a dependency cycle because nuxeo-automation-core depends on nuxeo-platform-notification-core...\nIn fact, the only reason for this is because of the SubscribeOperation and UnsubscribeOperation!\nSo I would suggest:\n\nYou move these 2 operations from nuxeo-platform-notification-core to nuxeo-automation-features that already depends on nuxeo-platform-notification-core for the mail operations to it should be smooth.\nYou remove the dependency to nuxeo-automation-core in nuxeo-platform-notification-core.\nYou add a dependency to nuxeo-platform-notification-core in nuxeo-automation-core.\nYou add the auto-subscribe code in the RetrieveFromColdStorage operation.", "author": "ataillefer", "createdAt": "2020-02-05T18:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NzQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgxMTYyMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375811623", "bodyText": "yep, i will do / try it as soon as possible :)\nthanks", "author": "RSalem07", "createdAt": "2020-02-06T12:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NzQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg0ODc5Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375848796", "bodyText": "yep i completely agree that adding the nuxeo-platform-notification-core to nuxeo-automation-core will introduce a cyclic dependency because already the nuxeo-platform-notification-core import the nuxeo-automation-core dependency and yes this is due to SubscribeOperation and UnsubscribeOperation and yes they should be part of the nuxeo-automation-features. I think it's a good idea to move theses operation to nuxeo-automation-features and change the maven dependencies. i started tried it, for instant it works correctly moving the operation + there related tests... but i have some questions/interrogations:\n\n\nI am wondering if moving these operations will not break the backward compatibility as they are public we don't should remove them ?\n\n\nI don't know if theses two operations can be referenced in a customer code i which case this will break changes\n\n\ni will continue the devs/checks and keep you updated", "author": "RSalem07", "createdAt": "2020-02-06T13:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NzQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg2ODk3Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375868976", "bodyText": "It won't break anything since we are just moving them from one jar to another, that is always deployed in the server.\nThe only question is, do we need to keep the Java package org.nuxeo.ecm.platform.ec.notification.automation in case someone would extend these operations, which is usually not the case, or can we afford to change it to org.nuxeo.ecm.automation.core.operations.notification with its other operation friends.", "author": "ataillefer", "createdAt": "2020-02-06T14:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NzQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg3MTExMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375871113", "bodyText": "It won't break anything since we are just moving them from one jar to another, that is always deployed in the server.\n\nyes sorry i meant moving, but yep and as discuss theses changes will be internally, and if it is not inherited that will be fine and we can move it without breaking anything", "author": "RSalem07", "createdAt": "2020-02-06T14:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NzQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NzU0Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377187546", "bodyText": "as discuss this once is done on: #3731", "author": "RSalem07", "createdAt": "2020-02-10T16:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY1NzQwNg=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-platform-notification/nuxeo-platform-notification-core/src/test/java/org/nuxeo/ecm/platform/ec/notification/operations/SubscribeAndUnsubscribeTest.java b/nuxeo-features/nuxeo-platform-notification/nuxeo-platform-notification-core/src/test/java/org/nuxeo/ecm/platform/ec/notification/operations/SubscribeAndUnsubscribeTest.java\ndeleted file mode 100644\nindex 11128682596..00000000000\n--- a/nuxeo-features/nuxeo-platform-notification/nuxeo-platform-notification-core/src/test/java/org/nuxeo/ecm/platform/ec/notification/operations/SubscribeAndUnsubscribeTest.java\n+++ /dev/null\n", "chunk": "@@ -1,178 +0,0 @@\n-/*\n- * (C) Copyright 2016 Nuxeo SA (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Miguel Nixo\n- */\n-package org.nuxeo.ecm.platform.ec.notification.operations;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.automation.AutomationService;\n-import org.nuxeo.ecm.automation.OperationChain;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.automation.core.util.StringList;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.impl.DocumentModelListImpl;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.ec.notification.SubscriptionAdapter;\n-import org.nuxeo.ecm.platform.ec.notification.automation.SubscribeOperation;\n-import org.nuxeo.ecm.platform.ec.notification.automation.UnsubscribeOperation;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.ecm.platform.test.PlatformFeature;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-\n-/**\n- * @since 8.10\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(PlatformFeature.class)\n-@Deploy(\"org.nuxeo.ecm.automation.core\")\n-@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n-public class SubscribeAndUnsubscribeTest {\n-\n-    protected DocumentModel testWorkspace;\n-\n-    protected DocumentModelList listDocModel;\n-\n-    @Inject\n-    protected CoreSession coreSession;\n-\n-    @Inject\n-    protected NotificationManager notificationManager;\n-\n-    @Inject\n-    protected AutomationService automationService;\n-\n-    protected OperationContext ctx;\n-\n-    @Before\n-    public void setUp() {\n-        testWorkspace = coreSession.createDocumentModel(\"/default-domain/workspaces\", \"testWorkspace\", \"Workspace\");\n-        testWorkspace = coreSession.createDocument(testWorkspace);\n-        String testWorkspacePath = testWorkspace.getPath().toString();\n-        List<DocumentModel> listDocs = new ArrayList<>();\n-        for (int i = 1; i <= 5; i++) {\n-            DocumentModel testFile = coreSession.createDocumentModel(testWorkspacePath, \"testFile\" + i, \"File\");\n-            testFile = coreSession.createDocument(testFile);\n-            listDocs.add(testFile);\n-        }\n-        listDocModel = new DocumentModelListImpl(listDocs);\n-        ctx = new OperationContext(coreSession);\n-    }\n-\n-    @After\n-    public void closeOperationContext() {\n-        ctx.close();\n-    }\n-\n-    @Test\n-    public void testSubscribeAndUnsubscribeOperations() throws OperationException {\n-        OperationChain chain = new OperationChain(\"test-chain\");\n-        chain.add(SubscribeOperation.ID);\n-        ctx.setInput(listDocModel);\n-        String username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertTrue(docSubscriptions.isEmpty());\n-        }\n-\n-        // subscribe all documents\n-        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertEquals(5, docSubscriptions.size());\n-            assertTrue(docSubscriptions.contains(\"Creation\"));\n-            assertTrue(docSubscriptions.contains(\"Modification\"));\n-            assertTrue(docSubscriptions.contains(\"Workflow Change\"));\n-            assertTrue(docSubscriptions.contains(\"Approbation review started\"));\n-        }\n-\n-        chain = new OperationChain(\"test-chain\");\n-        chain.add(UnsubscribeOperation.ID);\n-        ctx.clear();\n-        ctx.setInput(listDocModel);\n-        username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n-\n-        // unsubscribe all documents\n-        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertTrue(docSubscriptions.isEmpty());\n-        }\n-    }\n-\n-    @Test\n-    public void testSelectiveSubscribeAndUnsubscribeOperations() throws OperationException {\n-        Map<String, Object> params = new HashMap<>();\n-        params.put(\"notifications\", new StringList(new ArrayList<String>() {private static final long serialVersionUID = 1L;\n-\n-        { add(\"Creation\"); }}));\n-\n-        OperationChain chain = new OperationChain(\"test-chain\");\n-        chain.add(SubscribeOperation.ID).from(params);\n-        ctx.setInput(listDocModel);\n-        String username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertTrue(docSubscriptions.isEmpty());\n-        }\n-\n-        // subscribe all documents\n-        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertEquals(1, docSubscriptions.size());\n-            assertTrue(docSubscriptions.contains(\"Creation\"));\n-        }\n-\n-        chain = new OperationChain(\"test-chain\");\n-        chain.add(UnsubscribeOperation.ID).from(params);\n-        ctx.clear();\n-        ctx.setInput(listDocModel);\n-        username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n-\n-        // unsubscribe all documents\n-        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertTrue(docSubscriptions.isEmpty());\n-        }\n-    }\n-\n-}\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-platform-notification/nuxeo-platform-notification-core/src/test/java/org/nuxeo/ecm/platform/ec/notification/operations/SubscribeAndUnsubscribeTest.java b/nuxeo-features/nuxeo-platform-notification/nuxeo-platform-notification-core/src/test/java/org/nuxeo/ecm/platform/ec/notification/operations/SubscribeAndUnsubscribeTest.java\nnew file mode 100644\nindex 00000000000..11128682596\n--- /dev/null\n+++ b/nuxeo-features/nuxeo-platform-notification/nuxeo-platform-notification-core/src/test/java/org/nuxeo/ecm/platform/ec/notification/operations/SubscribeAndUnsubscribeTest.java\n", "chunk": "@@ -0,0 +1,178 @@\n+/*\n+ * (C) Copyright 2016 Nuxeo SA (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Miguel Nixo\n+ */\n+package org.nuxeo.ecm.platform.ec.notification.operations;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationChain;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.automation.core.util.StringList;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.impl.DocumentModelListImpl;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.ec.notification.SubscriptionAdapter;\n+import org.nuxeo.ecm.platform.ec.notification.automation.SubscribeOperation;\n+import org.nuxeo.ecm.platform.ec.notification.automation.UnsubscribeOperation;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.ecm.platform.test.PlatformFeature;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 8.10\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(PlatformFeature.class)\n+@Deploy(\"org.nuxeo.ecm.automation.core\")\n+@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n+public class SubscribeAndUnsubscribeTest {\n+\n+    protected DocumentModel testWorkspace;\n+\n+    protected DocumentModelList listDocModel;\n+\n+    @Inject\n+    protected CoreSession coreSession;\n+\n+    @Inject\n+    protected NotificationManager notificationManager;\n+\n+    @Inject\n+    protected AutomationService automationService;\n+\n+    protected OperationContext ctx;\n+\n+    @Before\n+    public void setUp() {\n+        testWorkspace = coreSession.createDocumentModel(\"/default-domain/workspaces\", \"testWorkspace\", \"Workspace\");\n+        testWorkspace = coreSession.createDocument(testWorkspace);\n+        String testWorkspacePath = testWorkspace.getPath().toString();\n+        List<DocumentModel> listDocs = new ArrayList<>();\n+        for (int i = 1; i <= 5; i++) {\n+            DocumentModel testFile = coreSession.createDocumentModel(testWorkspacePath, \"testFile\" + i, \"File\");\n+            testFile = coreSession.createDocument(testFile);\n+            listDocs.add(testFile);\n+        }\n+        listDocModel = new DocumentModelListImpl(listDocs);\n+        ctx = new OperationContext(coreSession);\n+    }\n+\n+    @After\n+    public void closeOperationContext() {\n+        ctx.close();\n+    }\n+\n+    @Test\n+    public void testSubscribeAndUnsubscribeOperations() throws OperationException {\n+        OperationChain chain = new OperationChain(\"test-chain\");\n+        chain.add(SubscribeOperation.ID);\n+        ctx.setInput(listDocModel);\n+        String username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n+\n+        for (DocumentModel doc : listDocModel) {\n+            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n+            assertTrue(docSubscriptions.isEmpty());\n+        }\n+\n+        // subscribe all documents\n+        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n+\n+        for (DocumentModel doc : listDocModel) {\n+            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n+            assertEquals(5, docSubscriptions.size());\n+            assertTrue(docSubscriptions.contains(\"Creation\"));\n+            assertTrue(docSubscriptions.contains(\"Modification\"));\n+            assertTrue(docSubscriptions.contains(\"Workflow Change\"));\n+            assertTrue(docSubscriptions.contains(\"Approbation review started\"));\n+        }\n+\n+        chain = new OperationChain(\"test-chain\");\n+        chain.add(UnsubscribeOperation.ID);\n+        ctx.clear();\n+        ctx.setInput(listDocModel);\n+        username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n+\n+        // unsubscribe all documents\n+        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n+\n+        for (DocumentModel doc : listDocModel) {\n+            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n+            assertTrue(docSubscriptions.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    public void testSelectiveSubscribeAndUnsubscribeOperations() throws OperationException {\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"notifications\", new StringList(new ArrayList<String>() {private static final long serialVersionUID = 1L;\n+\n+        { add(\"Creation\"); }}));\n+\n+        OperationChain chain = new OperationChain(\"test-chain\");\n+        chain.add(SubscribeOperation.ID).from(params);\n+        ctx.setInput(listDocModel);\n+        String username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n+\n+        for (DocumentModel doc : listDocModel) {\n+            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n+            assertTrue(docSubscriptions.isEmpty());\n+        }\n+\n+        // subscribe all documents\n+        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n+\n+        for (DocumentModel doc : listDocModel) {\n+            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n+            assertEquals(1, docSubscriptions.size());\n+            assertTrue(docSubscriptions.contains(\"Creation\"));\n+        }\n+\n+        chain = new OperationChain(\"test-chain\");\n+        chain.add(UnsubscribeOperation.ID).from(params);\n+        ctx.clear();\n+        ctx.setInput(listDocModel);\n+        username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n+\n+        // unsubscribe all documents\n+        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n+\n+        for (DocumentModel doc : listDocModel) {\n+            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n+            assertTrue(docSubscriptions.isEmpty());\n+        }\n+    }\n+\n+}\n", "next_change": {"commit": "2c19e9955d64f190701e3e2e0a4509b19c9ba11e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-platform-notification/nuxeo-platform-notification-core/src/test/java/org/nuxeo/ecm/platform/ec/notification/operations/SubscribeAndUnsubscribeTest.java b/nuxeo-features/nuxeo-platform-notification/nuxeo-platform-notification-core/src/test/java/org/nuxeo/ecm/platform/ec/notification/operations/SubscribeAndUnsubscribeTest.java\ndeleted file mode 100644\nindex 11128682596..00000000000\n--- a/nuxeo-features/nuxeo-platform-notification/nuxeo-platform-notification-core/src/test/java/org/nuxeo/ecm/platform/ec/notification/operations/SubscribeAndUnsubscribeTest.java\n+++ /dev/null\n", "chunk": "@@ -1,178 +0,0 @@\n-/*\n- * (C) Copyright 2016 Nuxeo SA (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Miguel Nixo\n- */\n-package org.nuxeo.ecm.platform.ec.notification.operations;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.automation.AutomationService;\n-import org.nuxeo.ecm.automation.OperationChain;\n-import org.nuxeo.ecm.automation.OperationContext;\n-import org.nuxeo.ecm.automation.OperationException;\n-import org.nuxeo.ecm.automation.core.util.StringList;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.impl.DocumentModelListImpl;\n-import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n-import org.nuxeo.ecm.platform.ec.notification.SubscriptionAdapter;\n-import org.nuxeo.ecm.platform.ec.notification.automation.SubscribeOperation;\n-import org.nuxeo.ecm.platform.ec.notification.automation.UnsubscribeOperation;\n-import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n-import org.nuxeo.ecm.platform.test.PlatformFeature;\n-import org.nuxeo.runtime.test.runner.Deploy;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-\n-/**\n- * @since 8.10\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(PlatformFeature.class)\n-@Deploy(\"org.nuxeo.ecm.automation.core\")\n-@Deploy(\"org.nuxeo.ecm.platform.notification.core\")\n-public class SubscribeAndUnsubscribeTest {\n-\n-    protected DocumentModel testWorkspace;\n-\n-    protected DocumentModelList listDocModel;\n-\n-    @Inject\n-    protected CoreSession coreSession;\n-\n-    @Inject\n-    protected NotificationManager notificationManager;\n-\n-    @Inject\n-    protected AutomationService automationService;\n-\n-    protected OperationContext ctx;\n-\n-    @Before\n-    public void setUp() {\n-        testWorkspace = coreSession.createDocumentModel(\"/default-domain/workspaces\", \"testWorkspace\", \"Workspace\");\n-        testWorkspace = coreSession.createDocument(testWorkspace);\n-        String testWorkspacePath = testWorkspace.getPath().toString();\n-        List<DocumentModel> listDocs = new ArrayList<>();\n-        for (int i = 1; i <= 5; i++) {\n-            DocumentModel testFile = coreSession.createDocumentModel(testWorkspacePath, \"testFile\" + i, \"File\");\n-            testFile = coreSession.createDocument(testFile);\n-            listDocs.add(testFile);\n-        }\n-        listDocModel = new DocumentModelListImpl(listDocs);\n-        ctx = new OperationContext(coreSession);\n-    }\n-\n-    @After\n-    public void closeOperationContext() {\n-        ctx.close();\n-    }\n-\n-    @Test\n-    public void testSubscribeAndUnsubscribeOperations() throws OperationException {\n-        OperationChain chain = new OperationChain(\"test-chain\");\n-        chain.add(SubscribeOperation.ID);\n-        ctx.setInput(listDocModel);\n-        String username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertTrue(docSubscriptions.isEmpty());\n-        }\n-\n-        // subscribe all documents\n-        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertEquals(5, docSubscriptions.size());\n-            assertTrue(docSubscriptions.contains(\"Creation\"));\n-            assertTrue(docSubscriptions.contains(\"Modification\"));\n-            assertTrue(docSubscriptions.contains(\"Workflow Change\"));\n-            assertTrue(docSubscriptions.contains(\"Approbation review started\"));\n-        }\n-\n-        chain = new OperationChain(\"test-chain\");\n-        chain.add(UnsubscribeOperation.ID);\n-        ctx.clear();\n-        ctx.setInput(listDocModel);\n-        username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n-\n-        // unsubscribe all documents\n-        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertTrue(docSubscriptions.isEmpty());\n-        }\n-    }\n-\n-    @Test\n-    public void testSelectiveSubscribeAndUnsubscribeOperations() throws OperationException {\n-        Map<String, Object> params = new HashMap<>();\n-        params.put(\"notifications\", new StringList(new ArrayList<String>() {private static final long serialVersionUID = 1L;\n-\n-        { add(\"Creation\"); }}));\n-\n-        OperationChain chain = new OperationChain(\"test-chain\");\n-        chain.add(SubscribeOperation.ID).from(params);\n-        ctx.setInput(listDocModel);\n-        String username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertTrue(docSubscriptions.isEmpty());\n-        }\n-\n-        // subscribe all documents\n-        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertEquals(1, docSubscriptions.size());\n-            assertTrue(docSubscriptions.contains(\"Creation\"));\n-        }\n-\n-        chain = new OperationChain(\"test-chain\");\n-        chain.add(UnsubscribeOperation.ID).from(params);\n-        ctx.clear();\n-        ctx.setInput(listDocModel);\n-        username = NotificationConstants.USER_PREFIX + ctx.getPrincipal().getName();\n-\n-        // unsubscribe all documents\n-        listDocModel = (DocumentModelList) automationService.run(ctx, chain);\n-\n-        for (DocumentModel doc : listDocModel) {\n-            List<?> docSubscriptions = doc.getAdapter(SubscriptionAdapter.class).getUserSubscriptions(username);\n-            assertTrue(docSubscriptions.isEmpty());\n-        }\n-    }\n-\n-}\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcwNDM0MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r374704340", "body": "Could be `CheckColdStorageContentAvailabilityListener`.", "bodyText": "Could be CheckColdStorageContentAvailabilityListener.", "bodyHTML": "<p dir=\"auto\">Could be <code>CheckColdStorageContentAvailabilityListener</code>.</p>", "author": "ataillefer", "createdAt": "2020-02-04T14:33:06Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*", "originalCommit": "7a25db5e1ed9270eebdd065e36a1ff12c5dce4f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java\ndeleted file mode 100644\nindex 1801caa07aa..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/coldstorage/CheckAvailabilityOfColdStorageContentListener.java\n+++ /dev/null\n", "chunk": "@@ -1,55 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *  \n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.coldstorage;\n-\n-import java.util.List;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.CloseableCoreSession;\n-import org.nuxeo.ecm.core.api.CoreInstance;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventListener;\n-import org.nuxeo.ecm.core.repository.RepositoryService;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * An asynchronous listener that checks if the contents being retrieved form cold storage are available.\n- *\n- * @apiNote: This listener is designed to be called from a scheduler.\n- * @since 11.1\n- */\n-public class CheckAvailabilityOfColdStorageContentListener implements EventListener {\n-\n-    private static final Logger log = LogManager.getLogger(CheckAvailabilityOfColdStorageContentListener.class);\n-\n-    @Override\n-    public void handleEvent(final Event event) {\n-        log.debug(\"Start checking the available cold storage content which are being retrieved\");\n-        List<String> repositoryNames = Framework.getService(RepositoryService.class).getRepositoryNames();\n-        for (String repository : repositoryNames) {\n-            try (CloseableCoreSession coreSession = CoreInstance.openCoreSession(repository)) {\n-                ColdStorageHelper.checkAvailabilityOfColdStorageContent(coreSession);\n-            }\n-        }\n-        log.debug(\"End checking the available cold storage content\");\n-    }\n-}\n", "next_change": null}]}}, {"oid": "1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "url": "https://github.com/nuxeo/nuxeo/commit/1a85ce1bef0550788cf8a65d0afd3fbcfc9b43dc", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-05T11:29:59Z", "type": "forcePushed"}, {"oid": "44116cdbc0274194af259907af2cce0e5df1e5f4", "url": "https://github.com/nuxeo/nuxeo/commit/44116cdbc0274194af259907af2cce0e5df1e5f4", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-05T14:33:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5MzU5MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375393590", "body": "```suggestion\r\n    // TODO currently this method only sets the \"coldstorage:beingRetrieved\" property, once NXP-28417 is done,\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // TODO actually this method set only the \"coldstorage:beingRetrieved\", once the NXP-28417 done,\n          \n          \n            \n                // TODO currently this method only sets the \"coldstorage:beingRetrieved\" property, once NXP-28417 is done,", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-c\"><span class=\"pl-c\">//</span> TODO <span class=\"x x-first x-last\">actually</span> this method <span class=\"x x-first x-last\">set </span>only the \"coldstorage:beingRetrieved\", once <span class=\"x x-first x-last\">the </span>NXP-28417 done,</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-c\"><span class=\"pl-c\">//</span> TODO <span class=\"x x-first x-last\">currently</span> this method only <span class=\"x x-first x-last\">sets </span>the \"coldstorage:beingRetrieved\"<span class=\"x x-first x-last\"> property</span>, once NXP-28417<span class=\"x x-first x-last\"> is</span> done,</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-05T17:16:50Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.query.sql.NXQL;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document WHERE %s = 1 and %s = 0\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY,\n+            NXQL.ECM_ISTRASHED);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n+\n+    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n+\n+    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n+    public static final String TO_DEFINE = \"This information is need to be defined\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    /**\n+     * Retrieves the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a restore request, calling the {@link Blob#getStream()} during this process\n+     *          doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    // TODO actually this method set only the \"coldstorage:beingRetrieved\", once the NXP-28417 done,", "originalCommit": "44116cdbc0274194af259907af2cce0e5df1e5f4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 2946189fadc..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,21 +93,21 @@ public class ColdStorageHelper {\n     }\n \n     /**\n-     * Retrieves the cold storage content associated with the document of the given {@link DocumentRef}.\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n      *\n      * @param session the core session\n      * @param documentRef the document reference\n      * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n      *            restoring\n-     * @apiNote This method will initiate a restore request, calling the {@link Blob#getStream()} during this process\n-     *          doesn't mean you will get the blob's content.\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n      * @return the updated document model if the retrieve succeeds\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n-    // TODO actually this method set only the \"coldstorage:beingRetrieved\", once the NXP-28417 done,\n-    // it will trigger the restore request too\n-    public static DocumentModel retrieveContentFromColdStorage(CoreSession session, DocumentRef documentRef,\n+    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n+    // it will trigger the restoration request too\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n             int numberOfDaysOfAvailability) {\n         DocumentModel documentModel = session.getDocument(documentRef);\n         log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -105,8 +112,6 @@ public class ColdStorageHelper {\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n     public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n             int numberOfDaysOfAvailability) {\n         DocumentModel documentModel = session.getDocument(documentRef);\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -104,19 +104,20 @@ public class ColdStorageHelper {\n      *\n      * @param session the core session\n      * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n      * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n      *          process doesn't mean you will get the blob's content.\n      * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n      * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n      *             retrieved\n      */\n     public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n         DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n \n         if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n                 || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "82b1167c00128633de58f315ddf38d4ee7bbee64", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..7591778f6cd 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -192,43 +174,53 @@ public class ColdStorageHelper {\n                 \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n                 session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), beingRetrieved, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 7591778f6cd..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -194,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM5NjcwOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375396708", "body": "Here also I would put `documentModel = ColdStorageHelper.moveContentToColdStorage`, just to always use the same pattern.", "bodyText": "Here also I would put documentModel = ColdStorageHelper.moveContentToColdStorage, just to always use the same pattern.", "bodyHTML": "<p dir=\"auto\">Here also I would put <code>documentModel = ColdStorageHelper.moveContentToColdStorage</code>, just to always use the same pattern.</p>", "author": "ataillefer", "createdAt": "2020-02-05T17:22:21Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Test\n+    public void shouldMoveBlobDocumentToColdStorage() throws IOException {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        transactionalFeature.nextTransaction();\n+        documentModel = session.getDocument(documentModel.getRef());\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` contains the original file content\n+        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRetrieveDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // retrieve, which means initiate a request to restore the blob from cold storage\n+        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        transactionalFeature.nextTransaction();\n+        documentModel = session.getDocument(documentModel.getRef());\n+\n+        assertTrue((Boolean) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailWhenRetrievingDocumentBlobFromColdStorageBeingRetrieved() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // retrieve, which means initiate a request to restore the blob from cold storage\n+        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+\n+        // try to retrieve a second time\n+        try {\n+            ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailWhenRetrievingDocumentBlobWithoutColdStorageContent() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try to retrieve from cold storage where the blob is not stored in it\n+            ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailabilityOfColdStorageContent() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n+                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n+                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+        transactionalFeature.nextTransaction();\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+            assertEquals(session.getRepositoryName(), coldStorageContentStatus.getRepositoryName());\n+\n+            // all cold storage contents being retrieved are now available\n+            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n+            assertEquals(documents.size(), coldStorageContentStatus.getTotalContentAvailable());\n+\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(3, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEventIds);\n+        }\n+    }\n+\n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());", "originalCommit": "44116cdbc0274194af259907af2cce0e5df1e5f4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex f69fdb46401..4ce71ef21de 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -207,8 +198,8 @@ public class TestColdStorage {\n \n     protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n         DocumentModel documentModel = createDocument(documentName, true);\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n", "next_change": {"commit": "e79e79cf3b52c7ae075339c8e07e3812e6b75910", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 4ce71ef21de..96eb4d537aa 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -197,13 +207,13 @@ public class TestColdStorage {\n     }\n \n     protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n-        DocumentModel documentModel = createDocument(documentName, true);\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n         return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n         DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 96eb4d537aa..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -85,132 +102,140 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n-                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n-                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n         transactionalFeature.nextTransaction();\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n \n-            // all cold storage contents being retrieved are now available\n-            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n \n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(3, listener.streamCapturedEvents().count());\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n \n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n \n-            documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEventIds);\n-        }\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n     }\n \n-    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n         DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n     }\n \n     protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": {"commit": "82b1167c00128633de58f315ddf38d4ee7bbee64", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 89eff27a524..11f4528fa51 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -263,28 +200,30 @@ public class TestColdStorage {\n                                                .sorted() //\n                                                .collect(Collectors.toList());\n \n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-            });\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEventIds);\n         }\n+    }\n \n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n \n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQyOTUzNA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r375429534", "body": "```suggestion\r\n    public static final String TO_DEFINE = \"This information needs to be defined\";\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String TO_DEFINE = \"This information is need to be defined\";\n          \n          \n            \n                public static final String TO_DEFINE = \"This information needs to be defined\";", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">String</span> <span class=\"pl-c1\">TO_DEFINE</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>This information <span class=\"x x-first x-last\">is need</span> to be defined<span class=\"pl-pds\">\"</span></span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">String</span> <span class=\"pl-c1\">TO_DEFINE</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>This information <span class=\"x x-first x-last\">needs</span> to be defined<span class=\"pl-pds\">\"</span></span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ataillefer", "createdAt": "2020-02-05T18:26:53Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.query.sql.NXQL;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document WHERE %s = 1 and %s = 0\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY,\n+            NXQL.ECM_ISTRASHED);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n+\n+    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n+\n+    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n+    public static final String TO_DEFINE = \"This information is need to be defined\";", "originalCommit": "44116cdbc0274194af259907af2cce0e5df1e5f4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 2946189fadc..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -56,17 +49,18 @@ public class ColdStorageHelper {\n     public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n \n     public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document WHERE %s = 1 and %s = 0\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY,\n-            NXQL.ECM_ISTRASHED);\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n \n     public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n \n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n     public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n \n     public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n \n     /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information is need to be defined\";\n+    public static final String TO_DEFINE = \"This information needs to be defined\";\n \n     /**\n      * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -53,15 +63,12 @@ public class ColdStorageHelper {\n \n     public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n \n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL = \"coldStorageAvailableUntil\";\n \n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n \n     public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n \n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n     /**\n      * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n      *\n", "next_change": {"commit": "e79e79cf3b52c7ae075339c8e07e3812e6b75910", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..cea6423cbfb 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -63,11 +63,11 @@ public class ColdStorageHelper {\n \n     public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n \n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL = \"coldStorageAvailableUntil\";\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n \n     public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n \n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n \n     /**\n      * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex cea6423cbfb..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,232 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String coldContentKey = ((ManagedBlob) coldContent).getKey();\n-            Duration duration = Duration.of(numberOfDaysOfAvailability, ChronoUnit.DAYS);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(coldContentKey).withRestoreForDuration(duration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException ioe) {\n-            throw new NuxeoException(ioe);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException ioe) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, ioe);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "82b1167c00128633de58f315ddf38d4ee7bbee64", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..7591778f6cd 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -192,43 +174,53 @@ public class ColdStorageHelper {\n                 \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n                 session.getRepositoryName(), beingRetrieved, available);\n \n-        return new ColdStorageContentStatus(beingRetrieved, available);\n+        return new ColdStorageContentStatus(session.getRepositoryName(), beingRetrieved, available);\n     }\n \n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n     }\n \n     /**\n-     * Status about the cold storage content being retrieved or available.\n+     * Status about the cold storage content being retrieved or available for a given repository.\n      */\n     public static class ColdStorageContentStatus {\n \n+        protected final String repositoryName;\n+\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalAvailable;\n+        protected final int totalContentAvailable;\n \n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalAvailable() {\n-            return totalAvailable;\n+        public int getTotalContentAvailable() {\n+            return totalContentAvailable;\n         }\n     }\n \n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 7591778f6cd..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -194,29 +197,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "82b1167c00128633de58f315ddf38d4ee7bbee64", "url": "https://github.com/nuxeo/nuxeo/commit/82b1167c00128633de58f315ddf38d4ee7bbee64", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-06T12:35:05Z", "type": "forcePushed"}, {"oid": "973f4810bf14e89c5dddf7b41335d270c139df8c", "url": "https://github.com/nuxeo/nuxeo/commit/973f4810bf14e89c5dddf7b41335d270c139df8c", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-06T12:41:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA0OTMzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377049330", "body": "`documentModel.refresh()` is simpler.", "bodyText": "documentModel.refresh() is simpler.", "bodyHTML": "<p dir=\"auto\"><code>documentModel.refresh()</code> is simpler.</p>", "author": "efge", "createdAt": "2020-02-10T13:04:29Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -108,6 +110,60 @@ public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n         }\n     }\n \n+    @Test\n+    public void shouldRetrieveDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createDocument(true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // retrieve, which means initiate a request to restore the blob from cold storage\n+        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        transactionalFeature.nextTransaction();\n+        documentModel = session.getDocument(documentModel.getRef());", "originalCommit": "18323496bfd2be3784897f68816d196a76874462", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3MjgzNA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377072834", "bodyText": "You mean instead of re-fetching the document, but keeping transactionalFeature.nextTransaction() ?\nThough it is not strictly needed since there aren't any asynchronous works behind, at some point we talked about always calling it to make sure and be consistent.", "author": "ataillefer", "createdAt": "2020-02-10T13:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA0OTMzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4Mjc4MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377082781", "bodyText": "Yes I mean documentModel.refresh() is a shorter way to write documentModel = session.getDocument(documentModel.getRef())\nBut if it's not needed then don't call it at all.", "author": "efge", "createdAt": "2020-02-10T14:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA0OTMzMA=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex ab3fec2a894..4ce71ef21de 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -111,50 +110,51 @@ public class TestColdStorage {\n     }\n \n     @Test\n-    public void shouldRetrieveDocumentBlobFromColdStorage() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n \n-        // retrieve, which means initiate a request to restore the blob from cold storage\n-        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n         transactionalFeature.nextTransaction();\n-        documentModel = session.getDocument(documentModel.getRef());\n+        documentModel.refresh();\n \n-        assertTrue((Boolean) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+        assertTrue(Boolean.TRUE.equals(\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n     }\n \n     @Test\n-    public void shouldFailWhenRetrievingDocumentBlobFromColdStorageBeingRetrieved() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n \n-        // retrieve, which means initiate a request to restore the blob from cold storage\n-        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n \n-        // try to retrieve a second time\n+        // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                     NUMBER_OF_DAYS_OF_AVAILABILITY);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n         } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n                     documentModel), ne.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenRetrievingDocumentBlobWithoutColdStorageContent() {\n-        DocumentModel documentModel = createDocument(true);\n+    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try to retrieve from cold storage where the blob is not stored in it\n-            ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+            // try a request retrieval from the cold storage content where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                     NUMBER_OF_DAYS_OF_AVAILABILITY);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n         } catch (NuxeoException ne) {\n", "next_change": {"commit": "e79e79cf3b52c7ae075339c8e07e3812e6b75910", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 4ce71ef21de..96eb4d537aa 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -151,7 +161,7 @@ public class TestColdStorage {\n \n     @Test\n     public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n-        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n             // try a request retrieval from the cold storage content where the blob is not stored in it\n             ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 96eb4d537aa..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -85,132 +102,140 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+    public void shouldFailMoveAlreadyInColdStorage() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+    public void shouldFailMoveToColdStorageNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrieval() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n+    public void shouldFailRequestRetrievalNoContent() {\n         DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n-                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n-                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n         transactionalFeature.nextTransaction();\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n \n-            // all cold storage contents being retrieved are now available\n-            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n \n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(3, listener.streamCapturedEvents().count());\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n \n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n \n-            documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEventIds);\n-        }\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n     }\n \n-    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n         DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n     }\n \n     protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 89eff27a524..8b592b42ca2 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -263,28 +201,30 @@ public class TestColdStorage {\n                                                .sorted() //\n                                                .collect(Collectors.toList());\n \n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-            });\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEventIds);\n         }\n+    }\n \n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n \n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1MTI5Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377051293", "body": "In other places you use\r\n\r\n    (Boolean) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)\r\n\r\nand\r\n\r\n    (boolean) updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)\r\n\r\nPlease be consistent.", "bodyText": "In other places you use\n(Boolean) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)\n\nand\n(boolean) updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)\n\nPlease be consistent.", "bodyHTML": "<p dir=\"auto\">In other places you use</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"(Boolean) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)\"><pre><code>(Boolean) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)\n</code></pre></div>\n<p dir=\"auto\">and</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"(boolean) updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)\"><pre><code>(boolean) updatedDocument.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)\n</code></pre></div>\n<p dir=\"auto\">Please be consistent.</p>", "author": "efge", "createdAt": "2020-02-10T13:08:50Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -75,6 +78,45 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Retrieves the cold storage content associated with the document of the given {@link DocumentRef}.\n+     * \n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a restore request, calling the {@link Blob#getStream()} during this process\n+     *          doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n+    // it will trigger the restore request too\n+    public static DocumentModel retrieveContentFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            int numberOfDaysOfAvailability) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n+                numberOfDaysOfAvailability);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {", "originalCommit": "18323496bfd2be3784897f68816d196a76874462", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 196e5141dba..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -110,13 +124,92 @@ public class ColdStorageHelper {\n             throw new NuxeoException(\n                     String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n                             documentModel),\n-                    SC_CONFLICT);\n+                    SC_FORBIDDEN);\n         }\n \n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     */\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available for a given repository.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -230,5 +218,4 @@ public class ColdStorageHelper {\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1NDkxOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377054919", "body": "Not sure about this HTTP status code, as this been discussed? I would see instead 403 or 404 or 412.\r\n\r\nAWS itself returns\r\n\r\n\t\tHTTP/1.1 403 Forbidden\r\n\t\t<Error>\r\n\t\t   <Code>InvalidObjectState</Code>\r\n\t\t   <Message>The operation is not valid for the object's storage class</Message>\r\n\t\t</Error>\r\n", "bodyText": "Not sure about this HTTP status code, as this been discussed? I would see instead 403 or 404 or 412.\nAWS itself returns\n\tHTTP/1.1 403 Forbidden\n\t<Error>\n\t   <Code>InvalidObjectState</Code>\n\t   <Message>The operation is not valid for the object's storage class</Message>\n\t</Error>", "bodyHTML": "<p dir=\"auto\">Not sure about this HTTP status code, as this been discussed? I would see instead 403 or 404 or 412.</p>\n<p dir=\"auto\">AWS itself returns</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\tHTTP/1.1 403 Forbidden\n\t&lt;Error&gt;\n\t   &lt;Code&gt;InvalidObjectState&lt;/Code&gt;\n\t   &lt;Message&gt;The operation is not valid for the object's storage class&lt;/Message&gt;\n\t&lt;/Error&gt;\"><pre><code>\tHTTP/1.1 403 Forbidden\n\t&lt;Error&gt;\n\t   &lt;Code&gt;InvalidObjectState&lt;/Code&gt;\n\t   &lt;Message&gt;The operation is not valid for the object's storage class&lt;/Message&gt;\n\t&lt;/Error&gt;\n</code></pre></div>", "author": "efge", "createdAt": "2020-02-10T13:16:30Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -75,6 +78,45 @@ public static DocumentModel moveContentToColdStorage(CoreSession session, Docume\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Retrieves the cold storage content associated with the document of the given {@link DocumentRef}.\n+     * \n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n+     *            restoring\n+     * @apiNote This method will initiate a restore request, calling the {@link Blob#getStream()} during this process\n+     *          doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n+    // it will trigger the restore request too\n+    public static DocumentModel retrieveContentFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            int numberOfDaysOfAvailability) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n+                numberOfDaysOfAvailability);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_CONFLICT);", "originalCommit": "18323496bfd2be3784897f68816d196a76874462", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 196e5141dba..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -110,13 +124,92 @@ public class ColdStorageHelper {\n             throw new NuxeoException(\n                     String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n                             documentModel),\n-                    SC_CONFLICT);\n+                    SC_FORBIDDEN);\n         }\n \n         documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     */\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                beingRetrieved--;\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                var properties = new HashMap<String, Serializable>();\n+                // TODO: should be reworked, once the NXP-28417 is done\n+                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n+                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n+                ctx.setProperties(properties);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     *\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available for a given repository.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -230,5 +218,4 @@ public class ColdStorageHelper {\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1Nzg1NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377057855", "body": "I feel that the operation name and classname (and other method names) is misleading. People will expect \"retrieve\" to return the blob and not be async. AWS S3 calls it \"restore\". But this is in fact a request to restore the blob at a later point in time. ", "bodyText": "I feel that the operation name and classname (and other method names) is misleading. People will expect \"retrieve\" to return the blob and not be async. AWS S3 calls it \"restore\". But this is in fact a request to restore the blob at a later point in time.", "bodyHTML": "<p dir=\"auto\">I feel that the operation name and classname (and other method names) is misleading. People will expect \"retrieve\" to return the blob and not be async. AWS S3 calls it \"restore\". But this is in fact a request to restore the blob at a later point in time.</p>", "author": "efge", "createdAt": "2020-02-10T13:22:08Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Retrieves the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a\n+ * restore request, calling the {@link Blob#getStream()} during this process doesn't mean you will get the blob's\n+ * content.\n+ * \n+ * @since 11.1\n+ */\n+@Operation(id = RetrieveFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request restoration from cold storage\", description = \"Request a cold storage content restoration associated with the document.\")\n+public class RetrieveFromColdStorage {\n+\n+    public static final String ID = \"Document.RetrieveFromColdStorage\";", "originalCommit": "18323496bfd2be3784897f68816d196a76874462", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE1MTUwMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377151502", "bodyText": "yes, please see #3666 (comment) and if we want we change the jira ticket/validate with the PO to rename it.", "author": "RSalem07", "createdAt": "2020-02-10T15:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1Nzg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nsimilarity index 51%\nrename from nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\nrename to nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nindex 96d2504fe97..47f1835baef 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -28,19 +28,23 @@ import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n import org.nuxeo.ecm.core.api.Blob;\n import org.nuxeo.ecm.core.api.CoreSession;\n import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.ecm.platform.notification.api.NotificationManager;\n+import org.nuxeo.runtime.api.Framework;\n \n /**\n- * Retrieves the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a\n- * restore request, calling the {@link Blob#getStream()} during this process doesn't mean you will get the blob's\n- * content.\n+ * Requests a retrieval from the cold storage content associated with the input {@link DocumentModel}. This operation\n+ * will initiate a restoration request, calling the {@link Blob#getStream()} during this process doesn't mean you will\n+ * get the blob's content.\n  * \n  * @since 11.1\n  */\n-@Operation(id = RetrieveFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request restoration from cold storage\", description = \"Request a cold storage content restoration associated with the document.\")\n-public class RetrieveFromColdStorage {\n+@Operation(id = RequestRetrievalFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request retrieval from cold storage\", description = \"Request a retrieval of the cold storage content associated with the document.\")\n+public class RequestRetrievalFromColdStorage {\n \n-    public static final String ID = \"Document.RetrieveFromColdStorage\";\n+    public static final String ID = \"Document.RequestRetrievalFromColdStorage\";\n \n     @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n     protected int numberOfDaysOfAvailability;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1ODE0NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377058144", "body": "I would return `void` given that the doc is unchanged and this operation is essentially async.", "bodyText": "I would return void given that the doc is unchanged and this operation is essentially async.", "bodyHTML": "<p dir=\"auto\">I would return <code>void</code> given that the doc is unchanged and this operation is essentially async.</p>", "author": "efge", "createdAt": "2020-02-10T13:22:49Z", "path": "nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *  \n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.automation.core.operations.document;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+\n+/**\n+ * Retrieves the cold storage content associated with the input {@link DocumentModel}. This operation will initiate a\n+ * restore request, calling the {@link Blob#getStream()} during this process doesn't mean you will get the blob's\n+ * content.\n+ * \n+ * @since 11.1\n+ */\n+@Operation(id = RetrieveFromColdStorage.ID, category = Constants.CAT_BLOB, label = \"Request restoration from cold storage\", description = \"Request a cold storage content restoration associated with the document.\")\n+public class RetrieveFromColdStorage {\n+\n+    public static final String ID = \"Document.RetrieveFromColdStorage\";\n+\n+    @Param(name = \"numberOfDaysOfAvailability\", description = \"The number of days that you want your cold storage content to be accessible.\")\n+    protected int numberOfDaysOfAvailability;\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        return ColdStorageHelper.retrieveContentFromColdStorage(session, doc.getRef(), numberOfDaysOfAvailability);", "originalCommit": "18323496bfd2be3784897f68816d196a76874462", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3NTE2MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377075160", "bodyText": "The helper updates a boolean property and calls saveDocument, so even if it triggers some underlying asynchronous work, shouldn't we return the updated document (also, for piping operations)?", "author": "ataillefer", "createdAt": "2020-02-10T13:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1ODE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4MzIzMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377083233", "bodyText": "Ok yes as there's this update then keep it, also for piping.", "author": "efge", "createdAt": "2020-02-10T14:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA1ODE0NA=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nsimilarity index 51%\nrename from nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\nrename to nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\nindex 96d2504fe97..47f1835baef 100644\n--- a/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RetrieveFromColdStorage.java\n+++ b/nuxeo-features/nuxeo-automation/nuxeo-automation-core/src/main/java/org/nuxeo/ecm/automation/core/operations/document/RequestRetrievalFromColdStorage.java\n", "chunk": "@@ -50,6 +54,14 @@ public class RetrieveFromColdStorage {\n \n     @OperationMethod(collector = DocumentModelCollector.class)\n     public DocumentModel run(DocumentModel doc) {\n-        return ColdStorageHelper.retrieveContentFromColdStorage(session, doc.getRef(), numberOfDaysOfAvailability);\n+        // auto-subscribe the user, this way he will receive the mail notification when the content is available\n+        NuxeoPrincipal principal = session.getPrincipal();\n+        String username = NotificationConstants.USER_PREFIX + principal.getName();\n+        NotificationManager notificationManager = Framework.getService(NotificationManager.class);\n+        notificationManager.addSubscription(username,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME, doc, false, principal,\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME);\n+\n+        return ColdStorageHelper.requestRetrievalFromColdStorage(session, doc.getRef(), numberOfDaysOfAvailability);\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA2MTY3Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377061676", "body": "Not what would be the point of storing numberOfDaysOfAvailability or the effective end date, because we don't know it exactly (it's advisory to S3, and we don't know precisely the timezone mechanics used (or they could change)). What usage would there be for it?\r\nThere will be a blob status query to check restore / availability that will return this info from S3 anyway.", "bodyText": "Not what would be the point of storing numberOfDaysOfAvailability or the effective end date, because we don't know it exactly (it's advisory to S3, and we don't know precisely the timezone mechanics used (or they could change)). What usage would there be for it?\nThere will be a blob status query to check restore / availability that will return this info from S3 anyway.", "bodyHTML": "<p dir=\"auto\">Not what would be the point of storing numberOfDaysOfAvailability or the effective end date, because we don't know it exactly (it's advisory to S3, and we don't know precisely the timezone mechanics used (or they could change)). What usage would there be for it?<br>\nThere will be a blob status query to check restore / availability that will return this info from S3 anyway.</p>", "author": "efge", "createdAt": "2020-02-10T13:29:32Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -117,6 +129,86 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     */\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema", "originalCommit": "f1b2705b4153de9be173a24a03de90f7fc010c51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3NzEzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377077130", "bodyText": "This was only an assumption we made, not knowing how the low-level implementation would handle it. Good if it's not needed.", "author": "ataillefer", "createdAt": "2020-02-10T13:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA2MTY3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE2MDUwOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377160508", "bodyText": "i will remove the unneeded javadoc comments once we will have the low level implementation", "author": "RSalem07", "createdAt": "2020-02-10T16:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA2MTY3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 69a812e7154..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -135,7 +137,7 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n     // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n     // retrieved numberOfDaysOfAvailability in cold storage schema\n", "next_change": {"commit": "38f8aea272f782bad3391f557f53efea9c3b5e0f", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2d5b5d5841..3cb3aac5d30 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -139,8 +153,6 @@ public class ColdStorageHelper {\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n      * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n      */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n         log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n \n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 3cb3aac5d30..d2569dc2d0e 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -151,7 +151,7 @@ public class ColdStorageHelper {\n      * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n      *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n      *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n      */\n     public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n         log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2569dc2d0e..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,241 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Objects;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.DocumentModelList;\n-import org.nuxeo.ecm.core.api.DocumentRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -230,5 +218,4 @@ public class ColdStorageHelper {\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA2Mjg5NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377062894", "body": "Why is there `content` in the name of this method? It's not in the other method, and I don't think it brings anything.", "bodyText": "Why is there content in the name of this method? It's not in the other method, and I don't think it brings anything.", "bodyHTML": "<p dir=\"auto\">Why is there <code>content</code> in the name of this method? It's not in the other method, and I don't think it brings anything.</p>", "author": "efge", "createdAt": "2020-02-10T13:31:56Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -117,6 +129,86 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     */\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                beingRetrieved--;\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(session.getRepositoryName(), beingRetrieved, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available for a given repository.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final String repositoryName;\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalContentAvailable;\n+\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {\n+            return repositoryName;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalContentAvailable() {", "originalCommit": "f1b2705b4153de9be173a24a03de90f7fc010c51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 69a812e7154..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -183,29 +192,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -230,5 +218,4 @@ public class ColdStorageHelper {\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA2MzE5NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377063195", "body": "Remove `final` on parameters, it's not our code style.", "bodyText": "Remove final on parameters, it's not our code style.", "bodyHTML": "<p dir=\"auto\">Remove <code>final</code> on parameters, it's not our code style.</p>", "author": "efge", "createdAt": "2020-02-10T13:32:31Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -117,6 +129,86 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     */\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                beingRetrieved--;\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(session.getRepositoryName(), beingRetrieved, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available for a given repository.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final String repositoryName;\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalContentAvailable;\n+\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {", "originalCommit": "f1b2705b4153de9be173a24a03de90f7fc010c51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 69a812e7154..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -183,29 +192,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -230,5 +218,4 @@ public class ColdStorageHelper {\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA2MzQzNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377063436", "body": "There's no point in this, the caller should have this information.", "bodyText": "There's no point in this, the caller should have this information.", "bodyHTML": "<p dir=\"auto\">There's no point in this, the caller should have this information.</p>", "author": "efge", "createdAt": "2020-02-10T13:33:02Z", "path": "nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java", "diffHunk": "@@ -117,6 +129,86 @@ public static DocumentModel retrieveContentFromColdStorage(CoreSession session,\n         return session.saveDocument(documentModel);\n     }\n \n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     */\n+    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n+    // retrieved numberOfDaysOfAvailability in cold storage schema\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        for (DocumentModel doc : documents) {\n+            if (isColdStorageContentAvailable(doc)) {\n+                available++;\n+                beingRetrieved--;\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n+                eventService.fireEvent(event);\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(session.getRepositoryName(), beingRetrieved, available);\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage content associated with the given document is available for download.\n+     * \n+     * @see #retrieveContentFromColdStorage(CoreSession, DocumentRef, int)\n+     * @see #checkColdStorageContentAvailability(CoreSession)\n+     */\n+    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n+        // FIXME to be reworked depending on how we will check the availability on low level\n+        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n+                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available for a given repository.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final String repositoryName;\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalContentAvailable;\n+\n+        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n+                final int totalContentAvailable) {\n+            this.repositoryName = repositoryName;\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalContentAvailable = totalContentAvailable;\n+        }\n+\n+        public String getRepositoryName() {", "originalCommit": "f1b2705b4153de9be173a24a03de90f7fc010c51", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 69a812e7154..d2d5b5d5841 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -183,29 +192,21 @@ public class ColdStorageHelper {\n      */\n     public static class ColdStorageContentStatus {\n \n-        protected final String repositoryName;\n-\n         protected final int totalBeingRetrieved;\n \n-        protected final int totalContentAvailable;\n+        protected final int totalAvailable;\n \n-        public ColdStorageContentStatus(final String repositoryName, final int totalBeingRetrieved,\n-                final int totalContentAvailable) {\n-            this.repositoryName = repositoryName;\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n             this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalContentAvailable = totalContentAvailable;\n-        }\n-\n-        public String getRepositoryName() {\n-            return repositoryName;\n+            this.totalAvailable = totalAvailable;\n         }\n \n         public int getTotalBeingRetrieved() {\n             return totalBeingRetrieved;\n         }\n \n-        public int getTotalContentAvailable() {\n-            return totalContentAvailable;\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n         }\n     }\n \n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\ndeleted file mode 100644\nindex d2d5b5d5841..00000000000\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core.blob;\n-\n-import static javax.servlet.http.HttpServletResponse.*;\n-\n-import java.io.Serializable;\n-import java.util.HashMap;\n-\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n-import org.nuxeo.ecm.core.api.*;\n-import org.nuxeo.ecm.core.event.Event;\n-import org.nuxeo.ecm.core.event.EventService;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.runtime.api.Framework;\n-\n-/**\n- * Manages the cold storage of the main content of a {@link DocumentModel}.\n- *\n- * @since 11.1\n- */\n-public class ColdStorageHelper {\n-\n-    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n-\n-    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n-\n-    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n-\n-    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n-\n-    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n-            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n-\n-    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n-\n-    public static final String NUMBER_OF_DAYS_OF_AVAILABILITY_KEY = \"numberOfDaysOfAvailability\";\n-\n-    public static final String ARCHIVE_LOCATION_KEY = \"archiveLocation\";\n-\n-    /** Used in the mail context to put the unknown information until NXP-28417 will be done **/\n-    public static final String TO_DEFINE = \"This information needs to be defined\";\n-\n-    /**\n-     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n-     *\n-     * @return the updated document model if the move succeeds\n-     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n-     *             associated with the given document\n-     */\n-    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n-\n-        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n-            throw new NuxeoException(\n-                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    SC_CONFLICT);\n-        }\n-\n-        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n-        if (mainContent == null) {\n-            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        documentModel.addFacet(FacetNames.COLD_STORAGE);\n-        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n-        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param numberOfDaysOfAvailability number of days that you want your cold storage content to be accessible after\n-     *            restoring\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    // TODO currently this method sets only the \"coldstorage:beingRetrieved\" property, once the NXP-28417 is done,\n-    // it will trigger the restoration request too\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            int numberOfDaysOfAvailability) {\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for: {} days\", documentModel,\n-                numberOfDaysOfAvailability);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     */\n-    // TODO once the cold storage content is available for download (wait for XP-28417 to be done), we should store the\n-    // retrieved numberOfDaysOfAvailability in cold storage schema\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        for (DocumentModel doc : documents) {\n-            if (isColdStorageContentAvailable(doc)) {\n-                available++;\n-                beingRetrieved--;\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                var properties = new HashMap<String, Serializable>();\n-                // TODO: should be reworked, once the NXP-28417 is done\n-                properties.put(NUMBER_OF_DAYS_OF_AVAILABILITY_KEY, TO_DEFINE);\n-                properties.put(ARCHIVE_LOCATION_KEY, TO_DEFINE);\n-                ctx.setProperties(properties);\n-                Event event = ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME);\n-                eventService.fireEvent(event);\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage content associated with the given document is available for download.\n-     *\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, int)\n-     * @see #checkColdStorageContentAvailability(CoreSession)\n-     */\n-    public static boolean isColdStorageContentAvailable(DocumentModel documentModel) {\n-        // FIXME to be reworked depending on how we will check the availability on low level\n-        return documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null\n-                && documentModel.hasFacet(FacetNames.COLD_STORAGE);\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available for a given repository.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n-    private ColdStorageHelper() {\n-        // no instance allowed\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nnew file mode 100644\nindex 00000000000..d2569dc2d0e\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -0,0 +1,241 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core.blob;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentModelList;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Manages the cold storage of the main content of a {@link DocumentModel}.\n+ *\n+ * @since 11.1\n+ */\n+public class ColdStorageHelper {\n+\n+    private static final Logger log = LogManager.getLogger(ColdStorageHelper.class);\n+\n+    public static final String FILE_CONTENT_PROPERTY = \"file:content\";\n+\n+    public static final String COLD_STORAGE_CONTENT_PROPERTY = \"coldstorage:coldContent\";\n+\n+    public static final String COLD_STORAGE_BEING_RETRIEVED_PROPERTY = \"coldstorage:beingRetrieved\";\n+\n+    public static final String GET_DOCUMENTS_TO_CHECK_QUERY = String.format(\n+            \"SELECT * FROM Document, Relation WHERE %s = 1\", COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME = \"coldStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY = \"coldStorageAvailableUntil\";\n+\n+    public static final String COLD_STORAGE_CONTENT_AVAILABLE_NOTIFICATION_NAME = \"ColdStorageContentAvailable\";\n+\n+    public static final String COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY = \"archiveLocation\";\n+\n+    /**\n+     * Moves the main content associated with the document of the given {@link DocumentRef} to a cold storage.\n+     *\n+     * @return the updated document model if the move succeeds\n+     * @throws NuxeoException if the main content is already in the cold storage, or if there is no main content\n+     *             associated with the given document\n+     */\n+    public static DocumentModel moveContentToColdStorage(CoreSession session, DocumentRef documentRef) {\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Move to cold storage the main content of document: {}\", documentModel);\n+\n+        if (documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                && documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) != null) {\n+            throw new NuxeoException(\n+                    String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    SC_CONFLICT);\n+        }\n+\n+        Serializable mainContent = documentModel.getPropertyValue(FILE_CONTENT_PROPERTY);\n+        if (mainContent == null) {\n+            throw new NuxeoException(String.format(\"There is no main content for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        documentModel.addFacet(FacetNames.COLD_STORAGE);\n+        documentModel.setPropertyValue(COLD_STORAGE_CONTENT_PROPERTY, mainContent);\n+        documentModel.setPropertyValue(FILE_CONTENT_PROPERTY, null);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    /**\n+     * Checks if the retrieved cold storage contents are available for download.\n+     *\n+     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n+     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n+     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n+     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n+     */\n+    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n+        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n+\n+        // as the volume of result will be small, we don't use BAF\n+        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n+\n+        // for every available content we will fire an event\n+        int beingRetrieved = documents.size();\n+        int available = 0;\n+        EventService eventService = Framework.getService(EventService.class);\n+        DownloadService downloadService = Framework.getService(DownloadService.class);\n+        for (DocumentModel doc : documents) {\n+            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            BlobStatus blobStatus;\n+            try {\n+                blobStatus = Framework.getService(BlobManager.class)\n+                                      .getBlobProvider(coldContent)\n+                                      .getStatus((ManagedBlob) coldContent);\n+            } catch (IOException e) {\n+                // log the failure and continue the check process\n+                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n+                continue;\n+            }\n+\n+            if (blobStatus.downloadable) {\n+                available++;\n+                beingRetrieved--;\n+\n+                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n+                session.saveDocument(doc);\n+\n+                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+                Instant downloadableUntil = blobStatus.downloadableUntil;\n+                if (downloadableUntil != null) {\n+                    ctx.getProperties()\n+                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n+                }\n+                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n+                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n+                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            }\n+        }\n+\n+        log.debug(\n+                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n+                session.getRepositoryName(), beingRetrieved, available);\n+\n+        return new ColdStorageContentStatus(beingRetrieved, available);\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n+    private ColdStorageHelper() {\n+        // no instance allowed\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex d2569dc2d0e..b50f83f6d9a 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -99,143 +75,8 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n-    /**\n-     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n-     *\n-     * @param session the core session\n-     * @param documentRef the document reference\n-     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n-     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n-     *          process doesn't mean you will get the blob's content.\n-     * @return the updated document model if the retrieve succeeds\n-     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n-     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n-     *             retrieved\n-     */\n-    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n-            Duration restoreDuration) {\n-        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n-        DocumentModel documentModel = session.getDocument(documentRef);\n-        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n-                restoreDuration);\n-\n-        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n-                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n-            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    SC_NOT_FOUND);\n-        }\n-\n-        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n-        if (Boolean.TRUE.equals(beingRetrieved)) {\n-            throw new NuxeoException(\n-                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                            documentModel),\n-                    SC_FORBIDDEN);\n-        }\n-\n-        try {\n-            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            String key = getContentBlobKey(coldContent);\n-            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n-            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n-        } catch (IOException e) {\n-            throw new NuxeoException(e);\n-        }\n-        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n-        return documentModel;\n-    }\n-\n-    /**\n-     * Checks if the retrieved cold storage contents are available for download.\n-     *\n-     * @implSpec: Queries all documents with a cold storage content which are being retrieved, meaning\n-     *            {@value COLD_STORAGE_BEING_RETRIEVED_PROPERTY} is {@code true}, and it checks if it is available for\n-     *            download. In which case its fires a {@value COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME} event.\n-     * @see #requestRetrievalFromColdStorage(CoreSession, DocumentRef, Duration)\n-     */\n-    public static ColdStorageContentStatus checkColdStorageContentAvailability(CoreSession session) {\n-        log.debug(\"Start checking the available cold storage content for repository: {}\", session::getRepositoryName);\n-\n-        // as the volume of result will be small, we don't use BAF\n-        DocumentModelList documents = session.query(GET_DOCUMENTS_TO_CHECK_QUERY);\n-\n-        // for every available content we will fire an event\n-        int beingRetrieved = documents.size();\n-        int available = 0;\n-        EventService eventService = Framework.getService(EventService.class);\n-        DownloadService downloadService = Framework.getService(DownloadService.class);\n-        for (DocumentModel doc : documents) {\n-            Blob coldContent = (Blob) doc.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n-            BlobStatus blobStatus;\n-            try {\n-                blobStatus = Framework.getService(BlobManager.class)\n-                                      .getBlobProvider(coldContent)\n-                                      .getStatus((ManagedBlob) coldContent);\n-            } catch (IOException e) {\n-                // log the failure and continue the check process\n-                log.error(\"Unable to get the cold storage blob status for document: {}\", doc, e);\n-                continue;\n-            }\n-\n-            if (blobStatus.downloadable) {\n-                available++;\n-                beingRetrieved--;\n-\n-                doc.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, false);\n-                session.saveDocument(doc);\n-\n-                DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n-                Instant downloadableUntil = blobStatus.downloadableUntil;\n-                if (downloadableUntil != null) {\n-                    ctx.getProperties()\n-                       .put(COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY, downloadableUntil.toString());\n-                }\n-                String downloadUrl = downloadService.getDownloadUrl(doc, COLD_STORAGE_CONTENT_PROPERTY, null);\n-                ctx.getProperties().put(COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY, downloadUrl);\n-                eventService.fireEvent(ctx.newEvent(COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            }\n-        }\n-\n-        log.debug(\n-                \"End checking the available cold storage content for repository: {}, beingRetrieved: {}, available: {}\",\n-                session.getRepositoryName(), beingRetrieved, available);\n-\n-        return new ColdStorageContentStatus(beingRetrieved, available);\n-    }\n-\n-    protected static String getContentBlobKey(Blob coldContent) {\n-        String key = ((ManagedBlob) coldContent).getKey();\n-        int colon = key.indexOf(':');\n-        if (colon >= 0) {\n-            key = key.substring(colon + 1);\n-        }\n-        return key;\n-    }\n-\n-    /**\n-     * Status about the cold storage content being retrieved or available.\n-     */\n-    public static class ColdStorageContentStatus {\n-\n-        protected final int totalBeingRetrieved;\n-\n-        protected final int totalAvailable;\n-\n-        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n-            this.totalBeingRetrieved = totalBeingRetrieved;\n-            this.totalAvailable = totalAvailable;\n-        }\n-\n-        public int getTotalBeingRetrieved() {\n-            return totalBeingRetrieved;\n-        }\n-\n-        public int getTotalAvailable() {\n-            return totalAvailable;\n-        }\n-    }\n-\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n+\n }\n", "next_change": {"commit": "95b3ec31ae835f55bb5530d4983c4d105f7e05cc", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex b50f83f6d9a..c2a24c6730b 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -75,6 +83,61 @@ public class ColdStorageHelper {\n         return documentModel;\n     }\n \n+    /**\n+     * Requests a retrieval of the cold storage content associated with the document of the given {@link DocumentRef}.\n+     *\n+     * @param session the core session\n+     * @param documentRef the document reference\n+     * @param restoreDuration the duration that you want your cold storage content to be accessible after restoring it\n+     * @apiNote This method will initiate a restoration request, calling the {@link Blob#getStream()} during this\n+     *          process doesn't mean you will get the blob's content.\n+     * @return the updated document model if the retrieve succeeds\n+     * @throws NullPointerException if the {@code restoreDuration} parameter is {@code null}\n+     * @throws NuxeoException if there is no cold storage content associated with the given document, or if it is being\n+     *             retrieved\n+     */\n+    public static DocumentModel requestRetrievalFromColdStorage(CoreSession session, DocumentRef documentRef,\n+            Duration restoreDuration) {\n+        Objects.requireNonNull(restoreDuration, \"Restore duration is required\");\n+        DocumentModel documentModel = session.getDocument(documentRef);\n+        log.debug(\"Retrieve from cold storage the content of document: {} for a duration: {}\", documentModel,\n+                restoreDuration);\n+\n+        if (!documentModel.hasFacet(FacetNames.COLD_STORAGE)\n+                || documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY) == null) {\n+            throw new NuxeoException(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    SC_NOT_FOUND);\n+        }\n+\n+        Serializable beingRetrieved = documentModel.getPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY);\n+        if (Boolean.TRUE.equals(beingRetrieved)) {\n+            throw new NuxeoException(\n+                    String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                            documentModel),\n+                    SC_FORBIDDEN);\n+        }\n+\n+        try {\n+            Blob coldContent = (Blob) documentModel.getPropertyValue(COLD_STORAGE_CONTENT_PROPERTY);\n+            String key = getContentBlobKey(coldContent);\n+            BlobUpdateContext updateContext = new BlobUpdateContext(key).withRestoreForDuration(restoreDuration);\n+            Framework.getService(BlobManager.class).getBlobProvider(coldContent).updateBlob(updateContext);\n+        } catch (IOException e) {\n+            throw new NuxeoException(e);\n+        }\n+        documentModel.setPropertyValue(COLD_STORAGE_BEING_RETRIEVED_PROPERTY, true);\n+        return documentModel;\n+    }\n+\n+    protected static String getContentBlobKey(Blob coldContent) {\n+        String key = ((ManagedBlob) coldContent).getKey();\n+        int colon = key.indexOf(':');\n+        if (colon >= 0) {\n+            key = key.substring(colon + 1);\n+        }\n+        return key;\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex c2a24c6730b..4bd82205b17 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -138,6 +204,29 @@ public class ColdStorageHelper {\n         return key;\n     }\n \n+    /**\n+     * Status about the cold storage content being retrieved or available.\n+     */\n+    public static class ColdStorageContentStatus {\n+\n+        protected final int totalBeingRetrieved;\n+\n+        protected final int totalAvailable;\n+\n+        public ColdStorageContentStatus(int totalBeingRetrieved, int totalAvailable) {\n+            this.totalBeingRetrieved = totalBeingRetrieved;\n+            this.totalAvailable = totalAvailable;\n+        }\n+\n+        public int getTotalBeingRetrieved() {\n+            return totalBeingRetrieved;\n+        }\n+\n+        public int getTotalAvailable() {\n+            return totalAvailable;\n+        }\n+    }\n+\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n", "next_change": {"commit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\nindex 4bd82205b17..456af451f59 100644\n--- a/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n+++ b/nuxeo-core/nuxeo-core/src/main/java/org/nuxeo/ecm/core/blob/ColdStorageHelper.java\n", "chunk": "@@ -230,5 +218,4 @@ public class ColdStorageHelper {\n     private ColdStorageHelper() {\n         // no instance allowed\n     }\n-\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"oid": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "url": "https://github.com/nuxeo/nuxeo/commit/0a7cccb76bee819b7ed702a74cb552960b8c6d59", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-10T16:44:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3Mzc2NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377473764", "body": "So, finally, don't we want to use `refresh` instead of `session.getDocument`?", "bodyText": "So, finally, don't we want to use refresh instead of session.getDocument?", "bodyHTML": "<p dir=\"auto\">So, finally, don't we want to use <code>refresh</code> instead of <code>session.getDocument</code>?</p>", "author": "ataillefer", "createdAt": "2020-02-11T07:24:20Z", "path": "nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(CoreFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final int NUMBER_OF_DAYS_OF_AVAILABILITY = 5;\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Test\n+    public void shouldMoveBlobDocumentToColdStorage() throws IOException {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        transactionalFeature.nextTransaction();\n+        documentModel = session.getDocument(documentModel.getRef());\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` contains the original file content\n+        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException ne) {\n+            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRetrieveDocumentBlobFromColdStorage() {\n+        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+\n+        // retrieve, which means initiate a request to restore the blob from cold storage\n+        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        transactionalFeature.nextTransaction();\n+        documentModel = session.getDocument(documentModel.getRef());", "originalCommit": "0a7cccb76bee819b7ed702a74cb552960b8c6d59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ5Mjg0Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3666#discussion_r377492842", "bodyText": "Let me try again, because initially (after the first review) i tried it and i had an exception.", "author": "RSalem07", "createdAt": "2020-02-11T08:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ3Mzc2NA=="}], "type": "inlineReview", "revised_code": {"commit": "2d4a4762b11e0f2aa23371f3bfd279b70978bd5e", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 8b592b42ca2..4ce71ef21de 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -120,36 +110,36 @@ public class TestColdStorage {\n     }\n \n     @Test\n-    public void shouldRetrieveDocumentBlobFromColdStorage() {\n+    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n         DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n \n-        // retrieve, which means initiate a request to restore the blob from cold storage\n-        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n         transactionalFeature.nextTransaction();\n-        documentModel = session.getDocument(documentModel.getRef());\n+        documentModel.refresh();\n \n         assertTrue(Boolean.TRUE.equals(\n                 documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n     }\n \n     @Test\n-    public void shouldFailWhenRetrievingDocumentBlobFromColdStorageBeingRetrieved() {\n+    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n         DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n         ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n \n-        // retrieve, which means initiate a request to restore the blob from cold storage\n-        documentModel = ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+        // request a retrieval from the cold storage content\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                 NUMBER_OF_DAYS_OF_AVAILABILITY);\n \n-        // try to retrieve a second time\n+        // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n                     NUMBER_OF_DAYS_OF_AVAILABILITY);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n         } catch (NuxeoException ne) {\n", "next_change": {"commit": "3921c544589eed9e16b666e57822f4e562ce5cca", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 4ce71ef21de..fb97f62a3da 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -75,135 +102,143 @@ public class TestColdStorage {\n \n         assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n \n-        // check if the `coldstorage:coldContent` contains the original file content\n-        checkBlobContent(documentModel, ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, FILE_CONTENT);\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n     }\n \n     @Test\n-    public void shouldFailWhenMovingDocumentBlobAlreadyInColdStorage() {\n-        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move for the first time\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n         // try to make another move\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_CONFLICT, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n             assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWhenMovingToColdStorageDocumentWithoutContent() {\n-        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, false);\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n         try {\n             ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n             fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), ne.getMessage());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldRequestRetrievalDocumentBlobFromColdStorage() {\n-        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n         transactionalFeature.nextTransaction();\n         documentModel.refresh();\n \n-        assertTrue(Boolean.TRUE.equals(\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY)));\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n     }\n \n     @Test\n-    public void shouldFailWhenRequestRetrievalDocumentBlobFromColdStorageBeingRetrieved() {\n-        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n \n         // move the blob to cold storage\n-        ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n \n-        // request a retrieval from the cold storage content\n+        // request a retrieval from the cold storage\n         documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n \n         // try to request a retrieval for a second time\n         try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_FORBIDDEN, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n             assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), ne.getMessage());\n+                    documentModel), e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldFailWheRequestRetrievalDocumentBlobWithoutColdStorageContent() {\n-        DocumentModel documentModel = createDocument(DEFAULT_DOC_NAME, true);\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n         try {\n-            // try a request retrieval from the cold storage content where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                    NUMBER_OF_DAYS_OF_AVAILABILITY);\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n             fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException ne) {\n-            assertEquals(SC_NOT_FOUND, ne.getStatusCode());\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n             assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    ne.getMessage());\n+                    e.getMessage());\n         }\n     }\n \n     @Test\n-    public void shouldCheckAvailabilityOfColdStorageContent() {\n+    public void shouldCheckAvailability() {\n         List<String> documents = Arrays.asList( //\n-                moveAndRetrieveColdStorageContent(DEFAULT_DOC_NAME).getId(),\n-                moveAndRetrieveColdStorageContent(\"anyFile2\").getId(), //\n-                moveAndRetrieveColdStorageContent(\"anyFile3\").getId());\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n         transactionalFeature.nextTransaction();\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n \n-            // all cold storage contents being retrieved are now available\n-            assertEquals(0, coldStorageContentStatus.getTotalBeingRetrieved());\n-            assertEquals(documents.size(), coldStorageContentStatus.getTotalAvailable());\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n \n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(3, listener.streamCapturedEvents().count());\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n \n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n \n-            documents.sort(Comparator.naturalOrder());\n-            assertEquals(documents, docEventIds);\n-        }\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n     }\n \n-    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n-        DocumentModel documentModel = createDocument(documentName, true);\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n         documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        return ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                NUMBER_OF_DAYS_OF_AVAILABILITY);\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n     }\n \n-    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n         DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n", "next_change": {"commit": "94fc5de9abd337fa96bb19956d2dcf13678df6c3", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\ndeleted file mode 100644\nindex fb97f62a3da..00000000000\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ /dev/null\n", "chunk": "@@ -1,307 +0,0 @@\n-/*\n- * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- *\n- * Contributors:\n- *     Salem Aouana\n- */\n-\n-package org.nuxeo.ecm.core;\n-\n-import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n-import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n-import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n-\n-import java.io.IOException;\n-import java.io.Serializable;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.time.temporal.ChronoUnit;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import javax.inject.Inject;\n-\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.nuxeo.ecm.core.api.Blob;\n-import org.nuxeo.ecm.core.api.Blobs;\n-import org.nuxeo.ecm.core.api.CoreSession;\n-import org.nuxeo.ecm.core.api.DocumentModel;\n-import org.nuxeo.ecm.core.api.IdRef;\n-import org.nuxeo.ecm.core.api.NuxeoException;\n-import org.nuxeo.ecm.core.blob.BlobManager;\n-import org.nuxeo.ecm.core.blob.BlobStatus;\n-import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n-import org.nuxeo.ecm.core.blob.ManagedBlob;\n-import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n-import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n-import org.nuxeo.ecm.core.io.download.DownloadService;\n-import org.nuxeo.ecm.core.schema.FacetNames;\n-import org.nuxeo.ecm.core.test.ColdStorageFeature;\n-import org.nuxeo.runtime.test.runner.Features;\n-import org.nuxeo.runtime.test.runner.FeaturesRunner;\n-import org.nuxeo.runtime.test.runner.TransactionalFeature;\n-\n-/**\n- * @since 11.1\n- */\n-@RunWith(FeaturesRunner.class)\n-@Features(ColdStorageFeature.class)\n-public class TestColdStorage {\n-\n-    protected static final String FILE_CONTENT = \"foo\";\n-\n-    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n-\n-    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n-\n-    @Inject\n-    protected CoreSession session;\n-\n-    @Inject\n-    protected TransactionalFeature transactionalFeature;\n-\n-    @Inject\n-    protected BlobManager blobManager;\n-\n-    @Inject\n-    protected DownloadService downloadService;\n-\n-    @Test\n-    public void shouldMoveToColdStorage() throws IOException {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n-\n-        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n-\n-        // check if the `coldstorage:coldContent` property contains the original file content\n-        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-        assertNotNull(content);\n-        assertEquals(FILE_CONTENT, content.getString());\n-        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n-    }\n-\n-    @Test\n-    public void shouldFailMoveAlreadyInColdStorage() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move for the first time\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // try to make another move\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because the content is already in cold storage\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_CONFLICT, e.getStatusCode());\n-            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailMoveToColdStorageNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n-        try {\n-            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-            fail(\"Should fail because there is no main content associated with the document\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n-        if (addBlobContent) {\n-            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n-        }\n-        return session.createDocument(documentModel);\n-    }\n-\n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n-}\n", "next_change": {"commit": "7f6187645f29f572048e25b83e3146b439371aab", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nnew file mode 100644\nindex 00000000000..fb97f62a3da\n--- /dev/null\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -0,0 +1,307 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Salem Aouana\n+ */\n+\n+package org.nuxeo.ecm.core;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_CONFLICT;\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.Blob;\n+import org.nuxeo.ecm.core.api.Blobs;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.blob.BlobManager;\n+import org.nuxeo.ecm.core.blob.BlobStatus;\n+import org.nuxeo.ecm.core.blob.ColdStorageHelper;\n+import org.nuxeo.ecm.core.blob.ManagedBlob;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.event.test.CapturingEventListener;\n+import org.nuxeo.ecm.core.io.download.DownloadService;\n+import org.nuxeo.ecm.core.schema.FacetNames;\n+import org.nuxeo.ecm.core.test.ColdStorageFeature;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features(ColdStorageFeature.class)\n+public class TestColdStorage {\n+\n+    protected static final String FILE_CONTENT = \"foo\";\n+\n+    protected static final Duration RESTORE_DURATION = Duration.ofDays(5);\n+\n+    protected static final String DEFAULT_DOC_NAME = \"anyFile\";\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected TransactionalFeature transactionalFeature;\n+\n+    @Inject\n+    protected BlobManager blobManager;\n+\n+    @Inject\n+    protected DownloadService downloadService;\n+\n+    @Test\n+    public void shouldMoveToColdStorage() throws IOException {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertTrue(documentModel.hasFacet(FacetNames.COLD_STORAGE));\n+\n+        assertNull(documentModel.getPropertyValue(ColdStorageHelper.FILE_CONTENT_PROPERTY));\n+\n+        // check if the `coldstorage:coldContent` property contains the original file content\n+        Blob content = (Blob) documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+        assertNotNull(content);\n+        assertEquals(FILE_CONTENT, content.getString());\n+        assertEquals(\"dummy\", ((ManagedBlob) content).getProviderId());\n+    }\n+\n+    @Test\n+    public void shouldFailMoveAlreadyInColdStorage() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move for the first time\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // try to make another move\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because the content is already in cold storage\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_CONFLICT, e.getStatusCode());\n+            assertEquals(String.format(\"The main content for document: %s is already in cold storage.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailMoveToColdStorageNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, false);\n+        try {\n+            ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+            fail(\"Should fail because there is no main content associated with the document\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"There is no main content for document: %s.\", documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n+\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n+    }\n+\n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+\n+                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n+                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n+                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n+                        expectedDownloadUrl,\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n+}\n", "next_change": {"commit": "4e8922cc4602dcb71f119c038d59ab16144f9511", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex fb97f62a3da..a86dc2faa8b 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -140,168 +114,12 @@ public class TestColdStorage {\n         }\n     }\n \n-    @Test\n-    public void shouldRequestRetrieval() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-        transactionalFeature.nextTransaction();\n-        documentModel.refresh();\n-\n-        assertEquals(Boolean.TRUE,\n-                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalBeingRetrieved() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-\n-        // move the blob to cold storage\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-\n-        // request a retrieval from the cold storage\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        session.saveDocument(documentModel);\n-\n-        // try to request a retrieval for a second time\n-        try {\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because the cold storage content is being retrieved.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n-            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n-                    documentModel), e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldFailRequestRetrievalNoContent() {\n-        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n-        try {\n-            // try a request retrieval from the cold storage where the blob is not stored in it\n-            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n-            fail(\"Should fail because there no cold storage content associated to this document.\");\n-        } catch (NuxeoException e) {\n-            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n-            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n-                    e.getMessage());\n-        }\n-    }\n-\n-    @Test\n-    public void shouldCheckAvailability() {\n-        List<String> documents = Arrays.asList( //\n-                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n-                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n-\n-        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n-        transactionalFeature.nextTransaction();\n-\n-        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n-                                                              .withDownloadableUntil(downloadableUntil);\n-        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n-\n-        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n-\n-        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n-        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n-\n-        // only cold content of 'anyFile' is available\n-        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n-\n-        transactionalFeature.nextTransaction();\n-\n-        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n-\n-        // the others 'anyFile2' and 'anyFile3' are now available too\n-        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n-    }\n-\n-    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n-        DocumentModel documentModel = createFileDocument(documentName, true);\n-        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n-        session.saveDocument(documentModel);\n-        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n-                RESTORE_DURATION);\n-        return session.saveDocument(documentModel);\n-    }\n-\n-    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+    protected DocumentModel createDocument(boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n-    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n-            throws IOException {\n-        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n-        assertNotNull(content);\n-        assertEquals(expectedContent, content.getString());\n-    }\n-\n-    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n-            int totalBeingRetrieved) {\n-        try (CapturingEventListener listener = new CapturingEventListener(\n-                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n-            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n-                    session);\n-\n-            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n-            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n-            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n-            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n-            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n-\n-            List<String> docEventIds = listener.streamCapturedEvents() //\n-                                               .map(event -> {\n-                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                                                   return docCtx.getSourceDocument().getId();\n-                                               }) //\n-                                               .sorted() //\n-                                               .collect(Collectors.toList());\n-\n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-\n-                String expectedDownloadUrl = downloadService.getDownloadUrl(documentModel,\n-                        ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY, null);\n-                assertEquals(String.format(\"An unexpected downloadable url for document: %s\", documentModel), //\n-                        expectedDownloadUrl,\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_ARCHIVE_LOCATION_MAIL_TEMPLATE_KEY));\n-            });\n-        }\n-\n-    }\n-\n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n-\n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n-    }\n }\n", "next_change": {"commit": "dad01caec1995a3ab7f20f998088cf6a74473643", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex a86dc2faa8b..89eff27a524 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -114,12 +136,155 @@ public class TestColdStorage {\n         }\n     }\n \n-    protected DocumentModel createDocument(boolean addBlobContent) {\n-        DocumentModel documentModel = session.createDocumentModel(\"/\", \"anyFile\", \"File\");\n+    @Test\n+    public void shouldRequestRetrieval() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+        transactionalFeature.nextTransaction();\n+        documentModel.refresh();\n+\n+        assertEquals(Boolean.TRUE,\n+                documentModel.getPropertyValue(ColdStorageHelper.COLD_STORAGE_BEING_RETRIEVED_PROPERTY));\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalBeingRetrieved() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+\n+        // move the blob to cold storage\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+\n+        // request a retrieval from the cold storage\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        session.saveDocument(documentModel);\n+\n+        // try to request a retrieval for a second time\n+        try {\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because the cold storage content is being retrieved.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertEquals(String.format(\"The cold storage content associated with the document: %s is being retrieved.\",\n+                    documentModel), e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldFailRequestRetrievalNoContent() {\n+        DocumentModel documentModel = createFileDocument(DEFAULT_DOC_NAME, true);\n+        try {\n+            // try a request retrieval from the cold storage where the blob is not stored in it\n+            ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(), RESTORE_DURATION);\n+            fail(\"Should fail because there no cold storage content associated to this document.\");\n+        } catch (NuxeoException e) {\n+            assertEquals(SC_NOT_FOUND, e.getStatusCode());\n+            assertEquals(String.format(\"No cold storage content defined for document: %s.\", documentModel),\n+                    e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCheckAvailability() {\n+        List<String> documents = Arrays.asList( //\n+                moveAndRequestRetrievalFromColdStorage(DEFAULT_DOC_NAME).getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile2\").getId(),\n+                moveAndRequestRetrievalFromColdStorage(\"anyFile3\").getId());\n+\n+        Instant downloadableUntil = Instant.now().plus(7, ChronoUnit.DAYS);\n+        transactionalFeature.nextTransaction();\n+\n+        BlobStatus coldContentStatusOfFile1 = new BlobStatus().withDownloadable(true)\n+                                                              .withDownloadableUntil(downloadableUntil);\n+        addColdStorageContentBlobStatus(documents.get(0), coldContentStatusOfFile1);\n+\n+        BlobStatus coldContentStatusOfFile2 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(1), coldContentStatusOfFile2);\n+\n+        BlobStatus coldContentStatusOfFile3 = new BlobStatus().withDownloadable(false);\n+        addColdStorageContentBlobStatus(documents.get(2), coldContentStatusOfFile3);\n+\n+        // only cold content of 'anyFile' is available\n+        checkAvailabilityOfDocuments(Collections.singletonList(documents.get(0)), downloadableUntil, 2);\n+\n+        transactionalFeature.nextTransaction();\n+\n+        coldContentStatusOfFile2.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+        coldContentStatusOfFile3.withDownloadable(true).withDownloadableUntil(downloadableUntil);\n+\n+        // the others 'anyFile2' and 'anyFile3' are now available too\n+        checkAvailabilityOfDocuments(Arrays.asList(documents.get(1), documents.get(2)), downloadableUntil, 0);\n+    }\n+\n+    protected DocumentModel moveAndRequestRetrievalFromColdStorage(String documentName) {\n+        DocumentModel documentModel = createFileDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        session.saveDocument(documentModel);\n+        documentModel = ColdStorageHelper.requestRetrievalFromColdStorage(session, documentModel.getRef(),\n+                RESTORE_DURATION);\n+        return session.saveDocument(documentModel);\n+    }\n+\n+    protected DocumentModel createFileDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n         if (addBlobContent) {\n             documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n         }\n         return session.createDocument(documentModel);\n     }\n \n+    protected void checkAvailabilityOfDocuments(List<String> expectedAvailableDocIds, Instant downloadableUntil,\n+            int totalBeingRetrieved) {\n+        try (CapturingEventListener listener = new CapturingEventListener(\n+                ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME)) {\n+            ColdStorageHelper.ColdStorageContentStatus coldStorageContentStatus = ColdStorageHelper.checkColdStorageContentAvailability(\n+                    session);\n+\n+            assertEquals(totalBeingRetrieved, coldStorageContentStatus.getTotalBeingRetrieved());\n+            var expectedSizeOfDocs = expectedAvailableDocIds.size();\n+            assertEquals(expectedSizeOfDocs, coldStorageContentStatus.getTotalAvailable());\n+            assertTrue(listener.hasBeenFired(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_EVENT_NAME));\n+            assertEquals(expectedSizeOfDocs, listener.streamCapturedEvents().count());\n+\n+            List<String> docEventIds = listener.streamCapturedEvents() //\n+                                               .map(event -> {\n+                                                   DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                                                   return docCtx.getSourceDocument().getId();\n+                                               }) //\n+                                               .sorted() //\n+                                               .collect(Collectors.toList());\n+\n+            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n+            assertEquals(expectedAvailableDocIds, docEventIds);\n+\n+            listener.streamCapturedEvents().forEach(event -> {\n+                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n+                Map<String, Serializable> properties = docCtx.getProperties();\n+\n+                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n+                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n+                        downloadableUntil.toString(),\n+                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n+            });\n+        }\n+\n+    }\n+\n+    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n+        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n+                                                       .getPropertyValue(\n+                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+\n+        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n+        blobProvider.addStatus(coldContent, blobStatus);\n+    }\n }\n", "next_change": {"commit": "1234456bbef19d1d81e2785f4370377d1faed226", "changed_code": [{"header": "diff --git a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\nindex 89eff27a524..efb8230791c 100644\n--- a/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n+++ b/nuxeo-core/nuxeo-core-test/src/test/java/org/nuxeo/ecm/core/TestColdStorage.java\n", "chunk": "@@ -263,28 +191,30 @@ public class TestColdStorage {\n                                                .sorted() //\n                                                .collect(Collectors.toList());\n \n-            expectedAvailableDocIds.sort(Comparator.naturalOrder());\n-            assertEquals(expectedAvailableDocIds, docEventIds);\n-\n-            listener.streamCapturedEvents().forEach(event -> {\n-                DocumentEventContext docCtx = (DocumentEventContext) event.getContext();\n-                Map<String, Serializable> properties = docCtx.getProperties();\n-\n-                DocumentModel documentModel = session.getDocument(new IdRef(docCtx.getSourceDocument().getId()));\n-                assertEquals(String.format(\"An unexpected deadline for cold storage of document: %s\", documentModel), //\n-                        downloadableUntil.toString(),\n-                        properties.get(ColdStorageHelper.COLD_STORAGE_CONTENT_AVAILABLE_UNTIL_MAIL_TEMPLATE_KEY));\n-            });\n+            documents.sort(Comparator.naturalOrder());\n+            assertEquals(documents, docEventIds);\n         }\n+    }\n \n+    protected DocumentModel moveAndRetrieveColdStorageContent(String documentName) {\n+        DocumentModel documentModel = createDocument(documentName, true);\n+        documentModel = ColdStorageHelper.moveContentToColdStorage(session, documentModel.getRef());\n+        return ColdStorageHelper.retrieveContentFromColdStorage(session, documentModel.getRef(),\n+                NUMBER_OF_DAYS_OF_AVAILABILITY);\n     }\n \n-    protected void addColdStorageContentBlobStatus(String docId, BlobStatus blobStatus) {\n-        ManagedBlob coldContent = (ManagedBlob) session.getDocument(new IdRef(docId))\n-                                                       .getPropertyValue(\n-                                                               ColdStorageHelper.COLD_STORAGE_CONTENT_PROPERTY);\n+    protected DocumentModel createDocument(String name, boolean addBlobContent) {\n+        DocumentModel documentModel = session.createDocumentModel(\"/\", name, \"File\");\n+        if (addBlobContent) {\n+            documentModel.setPropertyValue(\"file:content\", (Serializable) Blobs.createBlob(FILE_CONTENT));\n+        }\n+        return session.createDocument(documentModel);\n+    }\n \n-        DummyBlobProvider blobProvider = (DummyBlobProvider) blobManager.getBlobProvider(coldContent.getProviderId());\n-        blobProvider.addStatus(coldContent, blobStatus);\n+    protected void checkBlobContent(DocumentModel documentModel, String xpath, String expectedContent)\n+            throws IOException {\n+        Blob content = (Blob) documentModel.getPropertyValue(xpath);\n+        assertNotNull(content);\n+        assertEquals(expectedContent, content.getString());\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"oid": "1234456bbef19d1d81e2785f4370377d1faed226", "url": "https://github.com/nuxeo/nuxeo/commit/1234456bbef19d1d81e2785f4370377d1faed226", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-11T08:39:59Z", "type": "forcePushed"}, {"oid": "76a66666604c6bd813d835e1f11a42719c922874", "url": "https://github.com/nuxeo/nuxeo/commit/76a66666604c6bd813d835e1f11a42719c922874", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-11T14:13:43Z", "type": "forcePushed"}, {"oid": "2c19e9955d64f190701e3e2e0a4509b19c9ba11e", "url": "https://github.com/nuxeo/nuxeo/commit/2c19e9955d64f190701e3e2e0a4509b19c9ba11e", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-11T17:27:55Z", "type": "forcePushed"}, {"oid": "ea69ed9fe142fce13c9df4dc442a6b75671b23fa", "url": "https://github.com/nuxeo/nuxeo/commit/ea69ed9fe142fce13c9df4dc442a6b75671b23fa", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-11T17:37:25Z", "type": "forcePushed"}, {"oid": "0e7d93917e227514e5b9e28357512e55b406aeb7", "url": "https://github.com/nuxeo/nuxeo/commit/0e7d93917e227514e5b9e28357512e55b406aeb7", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-11T18:14:40Z", "type": "forcePushed"}, {"oid": "26dfaa4fad21549dae919315b2b439e536c7ff1c", "url": "https://github.com/nuxeo/nuxeo/commit/26dfaa4fad21549dae919315b2b439e536c7ff1c", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-12T10:53:56Z", "type": "forcePushed"}, {"oid": "22e185fe4284efb714c9d069a463d55b43bdcb36", "url": "https://github.com/nuxeo/nuxeo/commit/22e185fe4284efb714c9d069a463d55b43bdcb36", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-12T10:54:59Z", "type": "forcePushed"}, {"oid": "abe7383e379cf0a884ab40234f32469a64c09708", "url": "https://github.com/nuxeo/nuxeo/commit/abe7383e379cf0a884ab40234f32469a64c09708", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-12T15:01:16Z", "type": "forcePushed"}, {"oid": "add93de8af35168cd8f3fabaf071038d7db44891", "url": "https://github.com/nuxeo/nuxeo/commit/add93de8af35168cd8f3fabaf071038d7db44891", "message": "NXP-28429: Add a listener to send  mail when cold storage content becomes available", "committedDate": "2020-02-12T16:45:52Z", "type": "forcePushed"}]}