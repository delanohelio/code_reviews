{"pr_number": 1555, "pr_title": "Several changes to metrics collections (AlignmentSummaryMetrics and WgsMetrics) + some fluff", "pr_author": "yfarjoun", "pr_createdAt": "2020-07-31T21:04:26Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1555", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2MzA1Ng==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464463056", "body": "Is there any reason to not use `RuntimeException()` here?", "bodyText": "Is there any reason to not use RuntimeException() here?", "bodyHTML": "<p dir=\"auto\">Is there any reason to not use <code>RuntimeException()</code> here?</p>", "author": "pshapiro4broad", "createdAt": "2020-08-03T14:49:00Z", "path": "src/test/java/picard/cmdline/CommandLineProgramTest.java", "diffHunk": "@@ -15,6 +20,24 @@\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.\n+    final protected File TEMP_OUTPUT_DIR;\n+    {\n+        try {\n+            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n+            TEMP_OUTPUT_DIR.delete();\n+            TEMP_OUTPUT_DIR.mkdir();\n+        } catch (IOException e) {\n+            throw new PicardException(\"Couldn't create temp directory\") ;", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMjAwOQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465132009", "bodyText": "Well...PicardException is a RuntimeException...but this was it's more clear that it comes from Picard...I don't mind either way....what's the argument for RuntimeException?", "author": "yfarjoun", "createdAt": "2020-08-04T15:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2MzA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 5691e51cb..09d2d7578 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n", "chunk": "@@ -20,24 +15,6 @@ public abstract class CommandLineProgramTest {\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n-\n-    // A per-test-class directory that will be deleted after the tests are complete.\n-    final protected File TEMP_OUTPUT_DIR;\n-    {\n-        try {\n-            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n-            TEMP_OUTPUT_DIR.delete();\n-            TEMP_OUTPUT_DIR.mkdir();\n-        } catch (IOException e) {\n-            throw new PicardException(\"Couldn't create temp directory\") ;\n-        }\n-    }\n-\n-    @AfterClass\n-    final void cleanup_temp_dir() throws IOException {\n-        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n-    }\n-\n     public abstract String getCommandLineProgramName();\n \n     /**\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 09d2d7578..5691e51cb 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n", "chunk": "@@ -15,6 +20,24 @@ public abstract class CommandLineProgramTest {\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.\n+    final protected File TEMP_OUTPUT_DIR;\n+    {\n+        try {\n+            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n+            TEMP_OUTPUT_DIR.delete();\n+            TEMP_OUTPUT_DIR.mkdir();\n+        } catch (IOException e) {\n+            throw new PicardException(\"Couldn't create temp directory\") ;\n+        }\n+    }\n+\n+    @AfterClass\n+    final void cleanup_temp_dir() throws IOException {\n+        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n+    }\n+\n     public abstract String getCommandLineProgramName();\n \n     /**\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 5691e51cb..2fb521bd1 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n", "chunk": "@@ -22,20 +23,37 @@ public abstract class CommandLineProgramTest {\n \n \n     // A per-test-class directory that will be deleted after the tests are complete.\n-    final protected File TEMP_OUTPUT_DIR;\n-    {\n-        try {\n-            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n-            TEMP_OUTPUT_DIR.delete();\n-            TEMP_OUTPUT_DIR.mkdir();\n-        } catch (IOException e) {\n-            throw new PicardException(\"Couldn't create temp directory\") ;\n+    private File tempOutputDir;\n+\n+\n+    /**\n+     * returns an directory designated for output which will be deleted after the test class is tested\n+     */\n+    public File getTempOutputDir() {\n+        if (tempOutputDir == null) {\n+            try {\n+                tempOutputDir = Files.createTempDirectory(this.getClass().getName()).toFile();\n+            } catch (IOException e) {\n+                throw new PicardException(\"Couldn't create temp directory\");\n+            }\n         }\n+        return tempOutputDir;\n     }\n \n+    /**\n+     * returns an file designated for output which will be deleted (together with the entire subdirectory)\n+     * after the test class is tested\n+     * @throws IOException when there's a problem creating the file\n+     */\n+\n+    public File getTempOutputFile(final String prefix,final String extension) throws IOException {\n+        return File.createTempFile(prefix, extension, getTempOutputDir());\n+    }\n     @AfterClass\n     final void cleanup_temp_dir() throws IOException {\n-        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n+        if (tempOutputDir != null) {\n+            FileUtils.deleteDirectory(tempOutputDir);\n+        }\n     }\n \n     public abstract String getCommandLineProgramName();\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2NDQyNw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464464427", "body": "This is OK, an improvement would be to make this lazy, as not every test needs to create temp output. E.g.,\r\n```\r\nprotected File getTempDir() {\r\n    if (TEMP_OUTPUT_DIR == null) {\r\n    ...\r\n}\r\n```\r\n", "bodyText": "This is OK, an improvement would be to make this lazy, as not every test needs to create temp output. E.g.,\nprotected File getTempDir() {\n    if (TEMP_OUTPUT_DIR == null) {\n    ...\n}", "bodyHTML": "<p dir=\"auto\">This is OK, an improvement would be to make this lazy, as not every test needs to create temp output. E.g.,</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"protected File getTempDir() {\n    if (TEMP_OUTPUT_DIR == null) {\n    ...\n}\n\"><pre><code>protected File getTempDir() {\n    if (TEMP_OUTPUT_DIR == null) {\n    ...\n}\n</code></pre></div>", "author": "pshapiro4broad", "createdAt": "2020-08-03T14:51:08Z", "path": "src/test/java/picard/cmdline/CommandLineProgramTest.java", "diffHunk": "@@ -15,6 +20,24 @@\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 5691e51cb..09d2d7578 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n", "chunk": "@@ -20,24 +15,6 @@ public abstract class CommandLineProgramTest {\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n-\n-    // A per-test-class directory that will be deleted after the tests are complete.\n-    final protected File TEMP_OUTPUT_DIR;\n-    {\n-        try {\n-            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n-            TEMP_OUTPUT_DIR.delete();\n-            TEMP_OUTPUT_DIR.mkdir();\n-        } catch (IOException e) {\n-            throw new PicardException(\"Couldn't create temp directory\") ;\n-        }\n-    }\n-\n-    @AfterClass\n-    final void cleanup_temp_dir() throws IOException {\n-        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n-    }\n-\n     public abstract String getCommandLineProgramName();\n \n     /**\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 09d2d7578..5691e51cb 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n", "chunk": "@@ -15,6 +20,24 @@ public abstract class CommandLineProgramTest {\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.\n+    final protected File TEMP_OUTPUT_DIR;\n+    {\n+        try {\n+            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n+            TEMP_OUTPUT_DIR.delete();\n+            TEMP_OUTPUT_DIR.mkdir();\n+        } catch (IOException e) {\n+            throw new PicardException(\"Couldn't create temp directory\") ;\n+        }\n+    }\n+\n+    @AfterClass\n+    final void cleanup_temp_dir() throws IOException {\n+        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n+    }\n+\n     public abstract String getCommandLineProgramName();\n \n     /**\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 5691e51cb..2fb521bd1 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n", "chunk": "@@ -22,20 +23,37 @@ public abstract class CommandLineProgramTest {\n \n \n     // A per-test-class directory that will be deleted after the tests are complete.\n-    final protected File TEMP_OUTPUT_DIR;\n-    {\n-        try {\n-            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n-            TEMP_OUTPUT_DIR.delete();\n-            TEMP_OUTPUT_DIR.mkdir();\n-        } catch (IOException e) {\n-            throw new PicardException(\"Couldn't create temp directory\") ;\n+    private File tempOutputDir;\n+\n+\n+    /**\n+     * returns an directory designated for output which will be deleted after the test class is tested\n+     */\n+    public File getTempOutputDir() {\n+        if (tempOutputDir == null) {\n+            try {\n+                tempOutputDir = Files.createTempDirectory(this.getClass().getName()).toFile();\n+            } catch (IOException e) {\n+                throw new PicardException(\"Couldn't create temp directory\");\n+            }\n         }\n+        return tempOutputDir;\n     }\n \n+    /**\n+     * returns an file designated for output which will be deleted (together with the entire subdirectory)\n+     * after the test class is tested\n+     * @throws IOException when there's a problem creating the file\n+     */\n+\n+    public File getTempOutputFile(final String prefix,final String extension) throws IOException {\n+        return File.createTempFile(prefix, extension, getTempOutputDir());\n+    }\n     @AfterClass\n     final void cleanup_temp_dir() throws IOException {\n-        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n+        if (tempOutputDir != null) {\n+            FileUtils.deleteDirectory(tempOutputDir);\n+        }\n     }\n \n     public abstract String getCommandLineProgramName();\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NDQ1Nw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464474457", "body": "Why not\n```\nTEMP_OUTPUT_DIR = Files.createTempDirectory(getClass().getName()).toFile();\n```", "bodyText": "Why not\nTEMP_OUTPUT_DIR = Files.createTempDirectory(getClass().getName()).toFile();", "bodyHTML": "<p dir=\"auto\">Why not</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"TEMP_OUTPUT_DIR = Files.createTempDirectory(getClass().getName()).toFile();\n\"><pre><code>TEMP_OUTPUT_DIR = Files.createTempDirectory(getClass().getName()).toFile();\n</code></pre></div>", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:06:23Z", "path": "src/test/java/picard/cmdline/CommandLineProgramTest.java", "diffHunk": "@@ -15,6 +20,24 @@\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.\n+    final protected File TEMP_OUTPUT_DIR;\n+    {\n+        try {\n+            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNjkyOA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465136928", "bodyText": "\ud83d\udc4d", "author": "yfarjoun", "createdAt": "2020-08-04T15:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NDQ1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 5691e51cb..09d2d7578 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n", "chunk": "@@ -20,24 +15,6 @@ public abstract class CommandLineProgramTest {\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n-\n-    // A per-test-class directory that will be deleted after the tests are complete.\n-    final protected File TEMP_OUTPUT_DIR;\n-    {\n-        try {\n-            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n-            TEMP_OUTPUT_DIR.delete();\n-            TEMP_OUTPUT_DIR.mkdir();\n-        } catch (IOException e) {\n-            throw new PicardException(\"Couldn't create temp directory\") ;\n-        }\n-    }\n-\n-    @AfterClass\n-    final void cleanup_temp_dir() throws IOException {\n-        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n-    }\n-\n     public abstract String getCommandLineProgramName();\n \n     /**\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 09d2d7578..5691e51cb 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n", "chunk": "@@ -15,6 +20,24 @@ public abstract class CommandLineProgramTest {\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.\n+    final protected File TEMP_OUTPUT_DIR;\n+    {\n+        try {\n+            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n+            TEMP_OUTPUT_DIR.delete();\n+            TEMP_OUTPUT_DIR.mkdir();\n+        } catch (IOException e) {\n+            throw new PicardException(\"Couldn't create temp directory\") ;\n+        }\n+    }\n+\n+    @AfterClass\n+    final void cleanup_temp_dir() throws IOException {\n+        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n+    }\n+\n     public abstract String getCommandLineProgramName();\n \n     /**\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 5691e51cb..2fb521bd1 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n", "chunk": "@@ -22,20 +23,37 @@ public abstract class CommandLineProgramTest {\n \n \n     // A per-test-class directory that will be deleted after the tests are complete.\n-    final protected File TEMP_OUTPUT_DIR;\n-    {\n-        try {\n-            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n-            TEMP_OUTPUT_DIR.delete();\n-            TEMP_OUTPUT_DIR.mkdir();\n-        } catch (IOException e) {\n-            throw new PicardException(\"Couldn't create temp directory\") ;\n+    private File tempOutputDir;\n+\n+\n+    /**\n+     * returns an directory designated for output which will be deleted after the test class is tested\n+     */\n+    public File getTempOutputDir() {\n+        if (tempOutputDir == null) {\n+            try {\n+                tempOutputDir = Files.createTempDirectory(this.getClass().getName()).toFile();\n+            } catch (IOException e) {\n+                throw new PicardException(\"Couldn't create temp directory\");\n+            }\n         }\n+        return tempOutputDir;\n     }\n \n+    /**\n+     * returns an file designated for output which will be deleted (together with the entire subdirectory)\n+     * after the test class is tested\n+     * @throws IOException when there's a problem creating the file\n+     */\n+\n+    public File getTempOutputFile(final String prefix,final String extension) throws IOException {\n+        return File.createTempFile(prefix, extension, getTempOutputDir());\n+    }\n     @AfterClass\n     final void cleanup_temp_dir() throws IOException {\n-        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n+        if (tempOutputDir != null) {\n+            FileUtils.deleteDirectory(tempOutputDir);\n+        }\n     }\n \n     public abstract String getCommandLineProgramName();\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3OTUwNA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464479504", "body": "It looks like this is a common case. You could add `createTempFile` to `CommandLineProgramTest` to avoid some typing. ", "bodyText": "It looks like this is a common case. You could add createTempFile to CommandLineProgramTest to avoid some typing.", "bodyHTML": "<p dir=\"auto\">It looks like this is a common case. You could add <code>createTempFile</code> to <code>CommandLineProgramTest</code> to avoid some typing.</p>", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:14:45Z", "path": "src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java", "diffHunk": "@@ -51,8 +55,7 @@ public String getCommandLineProgramName() {\n     public void test() throws IOException {\n         final File input = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n         final File reference = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.fasta\");\n-        final File outfile = File.createTempFile(\"alignmentMetrics\", \".txt\");\n-        outfile.deleteOnExit();\n+        final File outfile = File.createTempFile(\"test\", \".txt\", TEMP_OUTPUT_DIR);", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDk4Ng==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465144986", "bodyText": "not much less typing...but OK.", "author": "yfarjoun", "createdAt": "2020-08-04T15:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3OTUwNA=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\nindex 00864efac..d5e132b3e 100644\n--- a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n", "chunk": "@@ -55,7 +51,8 @@ public class CollectAlignmentSummaryMetricsTest extends CommandLineProgramTest {\n     public void test() throws IOException {\n         final File input = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n         final File reference = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.fasta\");\n-        final File outfile = File.createTempFile(\"test\", \".txt\", TEMP_OUTPUT_DIR);\n+        final File outfile = File.createTempFile(\"alignmentMetrics\", \".txt\");\n+        outfile.deleteOnExit();\n         final String[] args = new String[]{\n                 \"INPUT=\" + input.getAbsolutePath(),\n                 \"OUTPUT=\" + outfile.getAbsolutePath(),\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\nindex d5e132b3e..00864efac 100644\n--- a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n", "chunk": "@@ -51,8 +55,7 @@ public class CollectAlignmentSummaryMetricsTest extends CommandLineProgramTest {\n     public void test() throws IOException {\n         final File input = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n         final File reference = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.fasta\");\n-        final File outfile = File.createTempFile(\"alignmentMetrics\", \".txt\");\n-        outfile.deleteOnExit();\n+        final File outfile = File.createTempFile(\"test\", \".txt\", TEMP_OUTPUT_DIR);\n         final String[] args = new String[]{\n                 \"INPUT=\" + input.getAbsolutePath(),\n                 \"OUTPUT=\" + outfile.getAbsolutePath(),\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\nindex 00864efac..2fe740cae 100644\n--- a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n", "chunk": "@@ -55,7 +55,7 @@ public class CollectAlignmentSummaryMetricsTest extends CommandLineProgramTest {\n     public void test() throws IOException {\n         final File input = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n         final File reference = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.fasta\");\n-        final File outfile = File.createTempFile(\"test\", \".txt\", TEMP_OUTPUT_DIR);\n+        final File outfile = getTempOutputFile(\"test\", \".txt\");\n         final String[] args = new String[]{\n                 \"INPUT=\" + input.getAbsolutePath(),\n                 \"OUTPUT=\" + outfile.getAbsolutePath(),\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4MjMyNg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464482326", "body": "unnecessary array `new`: `{{true}, {false}}` should work here", "bodyText": "unnecessary array new: {{true}, {false}} should work here", "bodyHTML": "<p dir=\"auto\">unnecessary array <code>new</code>: <code>{{true}, {false}}</code> should work here</p>", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:19:26Z", "path": "src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java", "diffHunk": "@@ -642,4 +645,79 @@ public void testAdapterReads() throws IOException {\n             }\n         }\n     }\n+\n+    @DataProvider()\n+    Object[][] TrueFalse() {\n+        return new Object[][]{\n+                new Object[]{true},", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\nindex 00864efac..d5e132b3e 100644\n--- a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n", "chunk": "@@ -645,79 +642,4 @@ public class CollectAlignmentSummaryMetricsTest extends CommandLineProgramTest {\n             }\n         }\n     }\n-\n-    @DataProvider()\n-    Object[][] TrueFalse() {\n-        return new Object[][]{\n-                new Object[]{true},\n-                new Object[]{false},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"TrueFalse\")\n-    public void testReadLengthHistogram(final boolean plotChart) throws IOException {\n-        final File input = new File(TEST_DATA_DIR, \"summary_alignment_stats_test3.sam\");\n-        final File outFile = File.createTempFile(\"testReadLengthHistogram\", \".txt\", TEMP_OUTPUT_DIR);\n-\n-        final List<String> argsList = new ArrayList<>();\n-        argsList.add(\"INPUT=\" + input.getAbsolutePath());\n-        argsList.add(\"OUTPUT=\" + outFile.getAbsolutePath());\n-        final File outHist;\n-\n-        if (plotChart) {\n-            outHist = File.createTempFile(\"testReadLengthHistogram\", \".pdf\", TEMP_OUTPUT_DIR);\n-            argsList.add(\"HISTOGRAM_FILE=\" + outHist);\n-        } else {\n-            outHist = null;\n-        }\n-\n-        final String[] args = argsList.toArray(new String[0]);\n-\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n-\n-        if (plotChart) {\n-            Assert.assertTrue(outHist.exists());\n-        }\n-\n-        final MetricsFile<AlignmentSummaryMetrics, Integer> output = new MetricsFile<>();\n-        try (FileReader reader = new FileReader(outFile)) {\n-            output.read(reader);\n-        }\n-\n-        Assert.assertFalse(output.getMetrics().isEmpty());\n-        for (final AlignmentSummaryMetrics metrics : output.getMetrics()) {\n-            if (metrics.CATEGORY != AlignmentSummaryMetrics.Category.SECOND_OF_PAIR) {\n-                Assert.assertEquals(metrics.PCT_HARDCLIP, 10 / (double) metrics.PF_ALIGNED_BASES,0.0001);\n-                Assert.assertEquals(metrics.PCT_SOFTCLIP, 23 / (double) metrics.PF_ALIGNED_BASES,0.0001);\n-            } else {\n-                Assert.assertEquals(metrics.PCT_HARDCLIP, 0D);\n-                Assert.assertEquals(metrics.PCT_SOFTCLIP, 0D);\n-            }\n-        }\n-\n-        Assert.assertFalse(output.getAllHistograms().isEmpty());\n-\n-        for (final Histogram<Integer> histogram : output.getAllHistograms()) {\n-\n-            Assert.assertFalse(histogram.isEmpty());\n-            if (histogram.getValueLabel().equals(\"PAIRED_TOTAL_LENGTH_COUNT\")) {\n-                for (int i = 0; i < histogram.getMax(); i++) {\n-                    switch (i) {\n-                        case 1:\n-                        case 2:\n-                        case 10:\n-                        case 11:\n-                        case 42:\n-                            Assert.assertEquals(histogram.get(i).getValue(), 1D);\n-                            break;\n-                        default:\n-                            Assert.assertTrue(\n-                                    histogram.get(i) == null ||\n-                                            histogram.get(i).getValue() == 0D);\n-                            break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n", "next_change": {"commit": "690fdc6532393877c3a6b04dffad0eee688223d6", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\nindex d5e132b3e..0c42db36b 100644\n--- a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n", "chunk": "@@ -642,4 +643,48 @@ public class CollectAlignmentSummaryMetricsTest extends CommandLineProgramTest {\n             }\n         }\n     }\n+\n+\n+    @Test\n+    public void testReadLengthHistogram() throws IOException {\n+        final File input = new File(TEST_DATA_DIR, \"summary_alignment_stats_test3.sam\");\n+        final File outfile = File.createTempFile(\"alignmentMetrics\", \".txt\");\n+        outfile.deleteOnExit();\n+        final String[] args = new String[]{\n+                \"INPUT=\" + input.getAbsolutePath(),\n+                \"OUTPUT=\" + outfile.getAbsolutePath(),\n+                \"COLLECT_ALIGNMENT_INFORMATION=false\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(args), 0);\n+\n+        final MetricsFile<AlignmentSummaryMetrics, Integer> output = new MetricsFile<>();\n+        try (FileReader reader = new FileReader(outfile)) {\n+            output.read(reader);\n+        }\n+        for (final AlignmentSummaryMetrics metrics : output.getMetrics()) {\n+            // test that it doesn't blow up\n+        }\n+        for (final Histogram<Integer> histogram : output.getAllHistograms()) {\n+            if (histogram.getValueLabel().equals(\"PAIRED_TOTAL_LENGTH_COUNT\")) {\n+                for (int i = 0; i < histogram.getMax(); i++){\n+                    switch(i) {\n+                        case 1:\n+                        case 2:\n+                        case 10:\n+                        case 11:\n+                        case 42:\n+                            Assert.assertEquals(histogram.get(i).getValue(), 1D);\n+                            break;\n+                        default:\n+                            Assert.assertTrue(\n+                                    histogram.get(i) == null ||\n+                                    histogram.get(i).getValue() == 9D);\n+                            break;\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n }\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\nindex 0c42db36b..00864efac 100644\n--- a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n", "chunk": "@@ -678,13 +713,11 @@ public class CollectAlignmentSummaryMetricsTest extends CommandLineProgramTest {\n                         default:\n                             Assert.assertTrue(\n                                     histogram.get(i) == null ||\n-                                    histogram.get(i).getValue() == 9D);\n+                                            histogram.get(i).getValue() == 0D);\n                             break;\n                     }\n                 }\n             }\n         }\n-\n     }\n-\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NjMwMw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464486303", "body": "unnecessary array creation\r\n```suggestion\r\n        final String[] args = {\r\n```", "bodyText": "unnecessary array creation\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String[] args = new String[] {\n          \n          \n            \n                    final String[] args = {", "bodyHTML": "<p dir=\"auto\">unnecessary array creation</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">final</span> <span class=\"pl-k\">String</span>[] args <span class=\"pl-k\">=</span> <span class=\"pl-k x x-first\">new</span><span class=\"x\"> </span><span class=\"pl-smi x\">String</span><span class=\"x x-last\">[] </span>{</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">final</span> <span class=\"pl-k\">String</span>[] args <span class=\"pl-k\">=</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:25:33Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -239,10 +300,49 @@ public void testLargeIntervals(final String useFastAlgorithm) throws IOException\n         }\n     }\n \n+    @Test(dataProvider = \"wgsDataProvider\")\n+    public void testSmallIntervals(final File input, final String reference_name,\n+                                   final String useFastAlgorithm) throws IOException {\n+        final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n+        final File ref = new File(reference_name);\n+        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n+        final int sampleSize = 1000;\n+        final String[] args = new String[] {", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NjEwNg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465146106", "bodyText": "\ud83e\udd2f", "author": "yfarjoun", "createdAt": "2020-08-04T15:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NjMwMw=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..e75d12191 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -300,49 +239,10 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         }\n     }\n \n-    @Test(dataProvider = \"wgsDataProvider\")\n-    public void testSmallIntervals(final File input, final String reference_name,\n-                                   final String useFastAlgorithm) throws IOException {\n-        final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n-        final File ref = new File(reference_name);\n-        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n-        final int sampleSize = 1000;\n-        final String[] args = new String[] {\n-                \"INPUT=\" + input.getAbsolutePath(),\n-                \"OUTPUT=\" + outfile.getAbsolutePath(),\n-                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n-                \"INTERVALS=\" + intervals.getAbsolutePath(),\n-                \"SAMPLE_SIZE=\" + sampleSize,\n-                // the fast and regular algorithms differ in how the cap coverage, so in order to avoid getting different result\n-                // due to that, the coverage cap is raise high for this test.\n-                \"COVERAGE_CAP=\" + 40000,\n-                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n-        };\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n-\n-        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n-        try (FileReader reader = new FileReader(outfile)) {\n-            output.read(reader);\n-        }\n-        for (final WgsMetrics metrics : output.getMetrics()) {\n-            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n-            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0.0);\n-            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0.0);\n-            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0.0);\n-            Assert.assertEquals(metrics.MEAN_COVERAGE, 1727.6, .1);\n-            Assert.assertEquals(metrics.SD_COVERAGE, 695.68, 0.1);\n-            Assert.assertEquals(metrics.FOLD_80_BASE_PENALTY, 1.59, 0.01);\n-            Assert.assertEquals(metrics.FOLD_90_BASE_PENALTY, 3.36, 0.01);\n-            Assert.assertTrue(Double.isNaN(metrics.FOLD_95_BASE_PENALTY));\n-        }\n-    }\n-\n-\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testExclusions(final String useFastAlgorithm) throws IOException {\n-        final File reference = new File(TEST_DIR, \"merger.fasta\");\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testExclusions\", \".bam\", TEMP_OUTPUT_DIR);\n+        final File reference = new File(\"testdata/picard/sam/merger.fasta\");\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"CollectWgsMetrics\", \".bam\");\n \n         final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(reference, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n \n", "next_change": {"commit": "6cc4f7e319f7b89abdfafe494e17930ceefcb659", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex e75d12191..ff2e3f3cd 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -239,6 +240,38 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         }\n     }\n \n+    @Test(dataProvider = \"wgsDataProvider\")\n+    public void testSmallIntervals(final File input, final File unused, final String refence_name,\n+                                   final String useFastAlgorithm) throws IOException {\n+        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\");\n+        outfile.deleteOnExit();\n+        final File ref = new File(refence_name);\n+        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n+        final int sampleSize = 1000;\n+        final String[] args = new String[]{\n+                \"INPUT=\" + input.getAbsolutePath(),\n+                \"OUTPUT=\" + outfile.getAbsolutePath(),\n+                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n+                \"INTERVALS=\" + intervals.getAbsolutePath(),\n+                \"SAMPLE_SIZE=\" + sampleSize,\n+                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n+        };\n+        Assert.assertEquals(runPicardCommandLine(args), 0);\n+\n+        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n+        try (FileReader reader = new FileReader(outfile)) {\n+            output.read(reader);\n+        }\n+        for (final WgsMetrics metrics : output.getMetrics()) {\n+            Assert.assertEquals(metrics.GENOME_TERRITORY, 404);\n+            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n+            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0.271403);\n+            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0.182149);\n+            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0.091075);\n+        }\n+    }\n+\n+\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testExclusions(final String useFastAlgorithm) throws IOException {\n         final File reference = new File(\"testdata/picard/sam/merger.fasta\");\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex ff2e3f3cd..195ff9465 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -263,19 +325,24 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n             output.read(reader);\n         }\n         for (final WgsMetrics metrics : output.getMetrics()) {\n-            Assert.assertEquals(metrics.GENOME_TERRITORY, 404);\n+            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n             Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0.271403);\n-            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0.182149);\n-            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0.091075);\n+            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0.0);\n+            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0.0);\n+            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0.0);\n+            Assert.assertEquals(metrics.MEAN_COVERAGE, 1727.6, .1);\n+            Assert.assertEquals(metrics.SD_COVERAGE, 695.68, 0.1);\n+            Assert.assertEquals(metrics.FOLD_80_BASE_PENALTY, 1.59, 0.01);\n+            Assert.assertEquals(metrics.FOLD_90_BASE_PENALTY, 3.36, 0.01);\n+            Assert.assertTrue(Double.isNaN(metrics.FOLD_95_BASE_PENALTY));\n         }\n     }\n \n \n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testExclusions(final String useFastAlgorithm) throws IOException {\n-        final File reference = new File(\"testdata/picard/sam/merger.fasta\");\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"CollectWgsMetrics\", \".bam\");\n+        final File reference = new File(TEST_DIR, \"merger.fasta\");\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testExclusions\", \".bam\", TEMP_OUTPUT_DIR);\n \n         final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(reference, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n \n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..933f672f8 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -342,7 +342,7 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testExclusions(final String useFastAlgorithm) throws IOException {\n         final File reference = new File(TEST_DIR, \"merger.fasta\");\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testExclusions\", \".bam\", TEMP_OUTPUT_DIR);\n+        final File tempSamFile = getTempOutputFile(\"testExclusions\", \".bam\");\n \n         final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(reference, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n \n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NjcwNg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464486706", "body": "whitespace\r\n```suggestion\r\n        final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\", TEMP_OUTPUT_DIR);\r\n```", "bodyText": "whitespace\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n          \n          \n            \n                    final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\", TEMP_OUTPUT_DIR);", "bodyHTML": "<p dir=\"auto\">whitespace</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">final</span> <span class=\"pl-smi\">File</span> outfile <span class=\"pl-k\">=</span> <span class=\"pl-smi\">File</span><span class=\"pl-k\">.</span>createTempFile(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>testSmallIntervals<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>.wgs_metrics<span class=\"pl-pds\">\"</span></span>,<span class=\"pl-c1\">TEMP_OUTPUT_DIR</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">final</span> <span class=\"pl-smi\">File</span> outfile <span class=\"pl-k\">=</span> <span class=\"pl-smi\">File</span><span class=\"pl-k\">.</span>createTempFile(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>testSmallIntervals<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>.wgs_metrics<span class=\"pl-pds\">\"</span></span>,<span class=\"x x-first x-last\"> </span><span class=\"pl-c1\">TEMP_OUTPUT_DIR</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:26:08Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -239,10 +300,49 @@ public void testLargeIntervals(final String useFastAlgorithm) throws IOException\n         }\n     }\n \n+    @Test(dataProvider = \"wgsDataProvider\")\n+    public void testSmallIntervals(final File input, final String reference_name,\n+                                   final String useFastAlgorithm) throws IOException {\n+        final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..e75d12191 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -300,49 +239,10 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         }\n     }\n \n-    @Test(dataProvider = \"wgsDataProvider\")\n-    public void testSmallIntervals(final File input, final String reference_name,\n-                                   final String useFastAlgorithm) throws IOException {\n-        final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n-        final File ref = new File(reference_name);\n-        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n-        final int sampleSize = 1000;\n-        final String[] args = new String[] {\n-                \"INPUT=\" + input.getAbsolutePath(),\n-                \"OUTPUT=\" + outfile.getAbsolutePath(),\n-                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n-                \"INTERVALS=\" + intervals.getAbsolutePath(),\n-                \"SAMPLE_SIZE=\" + sampleSize,\n-                // the fast and regular algorithms differ in how the cap coverage, so in order to avoid getting different result\n-                // due to that, the coverage cap is raise high for this test.\n-                \"COVERAGE_CAP=\" + 40000,\n-                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n-        };\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n-\n-        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n-        try (FileReader reader = new FileReader(outfile)) {\n-            output.read(reader);\n-        }\n-        for (final WgsMetrics metrics : output.getMetrics()) {\n-            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n-            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0.0);\n-            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0.0);\n-            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0.0);\n-            Assert.assertEquals(metrics.MEAN_COVERAGE, 1727.6, .1);\n-            Assert.assertEquals(metrics.SD_COVERAGE, 695.68, 0.1);\n-            Assert.assertEquals(metrics.FOLD_80_BASE_PENALTY, 1.59, 0.01);\n-            Assert.assertEquals(metrics.FOLD_90_BASE_PENALTY, 3.36, 0.01);\n-            Assert.assertTrue(Double.isNaN(metrics.FOLD_95_BASE_PENALTY));\n-        }\n-    }\n-\n-\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testExclusions(final String useFastAlgorithm) throws IOException {\n-        final File reference = new File(TEST_DIR, \"merger.fasta\");\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testExclusions\", \".bam\", TEMP_OUTPUT_DIR);\n+        final File reference = new File(\"testdata/picard/sam/merger.fasta\");\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"CollectWgsMetrics\", \".bam\");\n \n         final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(reference, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n \n", "next_change": {"commit": "6cc4f7e319f7b89abdfafe494e17930ceefcb659", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex e75d12191..ff2e3f3cd 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -239,6 +240,38 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         }\n     }\n \n+    @Test(dataProvider = \"wgsDataProvider\")\n+    public void testSmallIntervals(final File input, final File unused, final String refence_name,\n+                                   final String useFastAlgorithm) throws IOException {\n+        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\");\n+        outfile.deleteOnExit();\n+        final File ref = new File(refence_name);\n+        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n+        final int sampleSize = 1000;\n+        final String[] args = new String[]{\n+                \"INPUT=\" + input.getAbsolutePath(),\n+                \"OUTPUT=\" + outfile.getAbsolutePath(),\n+                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n+                \"INTERVALS=\" + intervals.getAbsolutePath(),\n+                \"SAMPLE_SIZE=\" + sampleSize,\n+                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n+        };\n+        Assert.assertEquals(runPicardCommandLine(args), 0);\n+\n+        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n+        try (FileReader reader = new FileReader(outfile)) {\n+            output.read(reader);\n+        }\n+        for (final WgsMetrics metrics : output.getMetrics()) {\n+            Assert.assertEquals(metrics.GENOME_TERRITORY, 404);\n+            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n+            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0.271403);\n+            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0.182149);\n+            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0.091075);\n+        }\n+    }\n+\n+\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testExclusions(final String useFastAlgorithm) throws IOException {\n         final File reference = new File(\"testdata/picard/sam/merger.fasta\");\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex ff2e3f3cd..195ff9465 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -263,19 +325,24 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n             output.read(reader);\n         }\n         for (final WgsMetrics metrics : output.getMetrics()) {\n-            Assert.assertEquals(metrics.GENOME_TERRITORY, 404);\n+            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n             Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0.271403);\n-            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0.182149);\n-            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0.091075);\n+            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0.0);\n+            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0.0);\n+            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0.0);\n+            Assert.assertEquals(metrics.MEAN_COVERAGE, 1727.6, .1);\n+            Assert.assertEquals(metrics.SD_COVERAGE, 695.68, 0.1);\n+            Assert.assertEquals(metrics.FOLD_80_BASE_PENALTY, 1.59, 0.01);\n+            Assert.assertEquals(metrics.FOLD_90_BASE_PENALTY, 3.36, 0.01);\n+            Assert.assertTrue(Double.isNaN(metrics.FOLD_95_BASE_PENALTY));\n         }\n     }\n \n \n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testExclusions(final String useFastAlgorithm) throws IOException {\n-        final File reference = new File(\"testdata/picard/sam/merger.fasta\");\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"CollectWgsMetrics\", \".bam\");\n+        final File reference = new File(TEST_DIR, \"merger.fasta\");\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testExclusions\", \".bam\", TEMP_OUTPUT_DIR);\n \n         final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(reference, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n \n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..933f672f8 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -342,7 +342,7 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testExclusions(final String useFastAlgorithm) throws IOException {\n         final File reference = new File(TEST_DIR, \"merger.fasta\");\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testExclusions\", \".bam\", TEMP_OUTPUT_DIR);\n+        final File tempSamFile = getTempOutputFile(\"testExclusions\", \".bam\");\n \n         final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(reference, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n \n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NzcxMw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464487713", "body": "whitespace\r\n```suggestion\r\n        setBuilder.addPair(\"all_in\", 0, 200, 200, false, false, \"100M\", \"100M\", true, false, 30);\r\n```", "bodyText": "whitespace\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n          \n          \n            \n                    setBuilder.addPair(\"all_in\", 0, 200, 200, false, false, \"100M\", \"100M\", true, false, 30);", "bodyHTML": "<p dir=\"auto\">whitespace</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        setBuilder<span class=\"pl-k\">.</span>addPair(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>all_in<span class=\"pl-pds\">\"</span></span>,<span class=\"pl-c1 x x-first\">0</span><span class=\"x x-last\">,</span><span class=\"pl-c1\">200</span>,<span class=\"pl-c1\">200</span>,<span class=\"pl-c1\">false</span>,<span class=\"pl-c1\">false</span>,<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>100M<span class=\"pl-pds\">\"</span></span>,<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>100M<span class=\"pl-pds\">\"</span></span>,<span class=\"pl-c1\">true</span>,<span class=\"pl-c1\">false</span>,<span class=\"pl-c1\">30</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        setBuilder<span class=\"pl-k\">.</span>addPair(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>all_in<span class=\"pl-pds\">\"</span></span>,<span class=\"x x-first\"> </span><span class=\"pl-c1 x\">0</span><span class=\"x x-last\">, </span><span class=\"pl-c1\">200</span>,<span class=\"x x-first x-last\"> </span><span class=\"pl-c1\">200</span>,<span class=\"x x-first x-last\"> </span><span class=\"pl-c1\">false</span>,<span class=\"x x-first x-last\"> </span><span class=\"pl-c1\">false</span>,<span class=\"x x-first x-last\"> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>100M<span class=\"pl-pds\">\"</span></span>,<span class=\"x x-first x-last\"> </span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>100M<span class=\"pl-pds\">\"</span></span>,<span class=\"x x-first x-last\"> </span><span class=\"pl-c1\">true</span>,<span class=\"x x-first x-last\"> </span><span class=\"pl-c1\">false</span>,<span class=\"x x-first x-last\"> </span><span class=\"pl-c1\">30</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:27:37Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -208,11 +214,66 @@ void setupBuilder() throws IOException {\n         };\n     }\n \n+    @Test(dataProvider = \"wgsAlgorithm\")\n+    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n+\n+        final File ref = CHR_M_REFERENCE;\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n+\n+        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n+\n+        setBuilder.setReadLength(100);\n+\n+        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..e75d12191 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -214,66 +208,11 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         };\n     }\n \n-    @Test(dataProvider = \"wgsAlgorithm\")\n-    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n-\n-        final File ref = CHR_M_REFERENCE;\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n-\n-        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n-\n-        setBuilder.setReadLength(100);\n-\n-        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"half_in\",0,950,950,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"just_out\",0,1001,1001,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"one_base_in\",0,1000,1000,false,false,\"100M\",\"100M\",true,false,30);\n-\n-        final SamReader samReader = setBuilder.getSamReader();\n-\n-        // Write SAM file\n-        try (SAMFileWriter writer = new SAMFileWriterFactory()\n-                .setCreateIndex(true)\n-                .makeBAMWriter(samReader.getFileHeader(), false, tempSamFile)) {\n-            for (final SAMRecord record : samReader) {\n-                writer.addAlignment(record);\n-            }\n-        }\n-\n-        final File outfile = File.createTempFile(\"testIntervalOneRead\", \".wgs_metrics\", TEMP_OUTPUT_DIR);\n-        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n-        final int sampleSize = 1000;\n-        final String[] args = new String[]{\n-                \"INPUT=\" + tempSamFile.getAbsolutePath(),\n-                \"OUTPUT=\" + outfile.getAbsolutePath(),\n-                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n-                \"INTERVALS=\" + intervals.getAbsolutePath(),\n-                \"SAMPLE_SIZE=\" + sampleSize,\n-                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n-        };\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n-\n-        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n-        try (FileReader reader = new FileReader(outfile)) {\n-            output.read(reader);\n-        }\n-        for (final WgsMetrics metrics : output.getMetrics()) {\n-            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n-            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0D);\n-            Assert.assertEquals(metrics.MEAN_COVERAGE, .152);\n-            Assert.assertEquals(metrics.SD_COVERAGE, .361977);\n-            Assert.assertEquals(metrics.PCT_1X, .151);\n-        }\n-    }\n-\n-\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testLargeIntervals(final String useFastAlgorithm) throws IOException {\n         final File input = new File(TEST_DIR, \"forMetrics.sam\");\n-        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n+        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\");\n+        outfile.deleteOnExit();\n         final File ref = new File(TEST_DIR, \"merger.fasta\");\n         final File intervals = new File(TEST_DIR, \"largeIntervals.interval_list\");\n         final int sampleSize = 1000;\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex e75d12191..195ff9465 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -208,11 +214,66 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         };\n     }\n \n+    @Test(dataProvider = \"wgsAlgorithm\")\n+    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n+\n+        final File ref = CHR_M_REFERENCE;\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n+\n+        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n+\n+        setBuilder.setReadLength(100);\n+\n+        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"half_in\",0,950,950,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"just_out\",0,1001,1001,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"one_base_in\",0,1000,1000,false,false,\"100M\",\"100M\",true,false,30);\n+\n+        final SamReader samReader = setBuilder.getSamReader();\n+\n+        // Write SAM file\n+        try (SAMFileWriter writer = new SAMFileWriterFactory()\n+                .setCreateIndex(true)\n+                .makeBAMWriter(samReader.getFileHeader(), false, tempSamFile)) {\n+            for (final SAMRecord record : samReader) {\n+                writer.addAlignment(record);\n+            }\n+        }\n+\n+        final File outfile = File.createTempFile(\"testIntervalOneRead\", \".wgs_metrics\", TEMP_OUTPUT_DIR);\n+        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n+        final int sampleSize = 1000;\n+        final String[] args = new String[]{\n+                \"INPUT=\" + tempSamFile.getAbsolutePath(),\n+                \"OUTPUT=\" + outfile.getAbsolutePath(),\n+                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n+                \"INTERVALS=\" + intervals.getAbsolutePath(),\n+                \"SAMPLE_SIZE=\" + sampleSize,\n+                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n+        };\n+        Assert.assertEquals(runPicardCommandLine(args), 0);\n+\n+        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n+        try (FileReader reader = new FileReader(outfile)) {\n+            output.read(reader);\n+        }\n+        for (final WgsMetrics metrics : output.getMetrics()) {\n+            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n+            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n+            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0D);\n+            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0D);\n+            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0D);\n+            Assert.assertEquals(metrics.MEAN_COVERAGE, .152);\n+            Assert.assertEquals(metrics.SD_COVERAGE, .361977);\n+            Assert.assertEquals(metrics.PCT_1X, .151);\n+        }\n+    }\n+\n+\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testLargeIntervals(final String useFastAlgorithm) throws IOException {\n         final File input = new File(TEST_DIR, \"forMetrics.sam\");\n-        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\");\n-        outfile.deleteOnExit();\n+        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n         final File ref = new File(TEST_DIR, \"merger.fasta\");\n         final File intervals = new File(TEST_DIR, \"largeIntervals.interval_list\");\n         final int sampleSize = 1000;\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..933f672f8 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -273,7 +273,7 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testLargeIntervals(final String useFastAlgorithm) throws IOException {\n         final File input = new File(TEST_DIR, \"forMetrics.sam\");\n-        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n+        final File outfile = getTempOutputFile(\"test\", \".wgs_metrics\");\n         final File ref = new File(TEST_DIR, \"merger.fasta\");\n         final File intervals = new File(TEST_DIR, \"largeIntervals.interval_list\");\n         final int sampleSize = 1000;\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4ODY5MA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464488690", "body": "unnecessary `new`\r\n```suggestion\r\n        final String[] args = {\r\n```", "bodyText": "unnecessary new\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String[] args = new String[]{\n          \n          \n            \n                    final String[] args = {", "bodyHTML": "<p dir=\"auto\">unnecessary <code>new</code></p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">final</span> <span class=\"pl-k\">String</span>[] args <span class=\"pl-k\">=</span> <span class=\"pl-k x x-first\">new</span><span class=\"x\"> </span><span class=\"pl-smi x\">String</span><span class=\"x x-last\">[]</span>{</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">final</span> <span class=\"pl-k\">String</span>[] args <span class=\"pl-k\">=</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:29:07Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -208,11 +214,66 @@ void setupBuilder() throws IOException {\n         };\n     }\n \n+    @Test(dataProvider = \"wgsAlgorithm\")\n+    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n+\n+        final File ref = CHR_M_REFERENCE;\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n+\n+        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n+\n+        setBuilder.setReadLength(100);\n+\n+        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"half_in\",0,950,950,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"just_out\",0,1001,1001,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"one_base_in\",0,1000,1000,false,false,\"100M\",\"100M\",true,false,30);\n+\n+        final SamReader samReader = setBuilder.getSamReader();\n+\n+        // Write SAM file\n+        try (SAMFileWriter writer = new SAMFileWriterFactory()\n+                .setCreateIndex(true)\n+                .makeBAMWriter(samReader.getFileHeader(), false, tempSamFile)) {\n+            for (final SAMRecord record : samReader) {\n+                writer.addAlignment(record);\n+            }\n+        }\n+\n+        final File outfile = File.createTempFile(\"testIntervalOneRead\", \".wgs_metrics\", TEMP_OUTPUT_DIR);\n+        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n+        final int sampleSize = 1000;\n+        final String[] args = new String[]{", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..e75d12191 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -214,66 +208,11 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         };\n     }\n \n-    @Test(dataProvider = \"wgsAlgorithm\")\n-    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n-\n-        final File ref = CHR_M_REFERENCE;\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n-\n-        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n-\n-        setBuilder.setReadLength(100);\n-\n-        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"half_in\",0,950,950,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"just_out\",0,1001,1001,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"one_base_in\",0,1000,1000,false,false,\"100M\",\"100M\",true,false,30);\n-\n-        final SamReader samReader = setBuilder.getSamReader();\n-\n-        // Write SAM file\n-        try (SAMFileWriter writer = new SAMFileWriterFactory()\n-                .setCreateIndex(true)\n-                .makeBAMWriter(samReader.getFileHeader(), false, tempSamFile)) {\n-            for (final SAMRecord record : samReader) {\n-                writer.addAlignment(record);\n-            }\n-        }\n-\n-        final File outfile = File.createTempFile(\"testIntervalOneRead\", \".wgs_metrics\", TEMP_OUTPUT_DIR);\n-        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n-        final int sampleSize = 1000;\n-        final String[] args = new String[]{\n-                \"INPUT=\" + tempSamFile.getAbsolutePath(),\n-                \"OUTPUT=\" + outfile.getAbsolutePath(),\n-                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n-                \"INTERVALS=\" + intervals.getAbsolutePath(),\n-                \"SAMPLE_SIZE=\" + sampleSize,\n-                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n-        };\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n-\n-        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n-        try (FileReader reader = new FileReader(outfile)) {\n-            output.read(reader);\n-        }\n-        for (final WgsMetrics metrics : output.getMetrics()) {\n-            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n-            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0D);\n-            Assert.assertEquals(metrics.MEAN_COVERAGE, .152);\n-            Assert.assertEquals(metrics.SD_COVERAGE, .361977);\n-            Assert.assertEquals(metrics.PCT_1X, .151);\n-        }\n-    }\n-\n-\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testLargeIntervals(final String useFastAlgorithm) throws IOException {\n         final File input = new File(TEST_DIR, \"forMetrics.sam\");\n-        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n+        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\");\n+        outfile.deleteOnExit();\n         final File ref = new File(TEST_DIR, \"merger.fasta\");\n         final File intervals = new File(TEST_DIR, \"largeIntervals.interval_list\");\n         final int sampleSize = 1000;\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex e75d12191..195ff9465 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -208,11 +214,66 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         };\n     }\n \n+    @Test(dataProvider = \"wgsAlgorithm\")\n+    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n+\n+        final File ref = CHR_M_REFERENCE;\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n+\n+        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n+\n+        setBuilder.setReadLength(100);\n+\n+        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"half_in\",0,950,950,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"just_out\",0,1001,1001,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"one_base_in\",0,1000,1000,false,false,\"100M\",\"100M\",true,false,30);\n+\n+        final SamReader samReader = setBuilder.getSamReader();\n+\n+        // Write SAM file\n+        try (SAMFileWriter writer = new SAMFileWriterFactory()\n+                .setCreateIndex(true)\n+                .makeBAMWriter(samReader.getFileHeader(), false, tempSamFile)) {\n+            for (final SAMRecord record : samReader) {\n+                writer.addAlignment(record);\n+            }\n+        }\n+\n+        final File outfile = File.createTempFile(\"testIntervalOneRead\", \".wgs_metrics\", TEMP_OUTPUT_DIR);\n+        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n+        final int sampleSize = 1000;\n+        final String[] args = new String[]{\n+                \"INPUT=\" + tempSamFile.getAbsolutePath(),\n+                \"OUTPUT=\" + outfile.getAbsolutePath(),\n+                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n+                \"INTERVALS=\" + intervals.getAbsolutePath(),\n+                \"SAMPLE_SIZE=\" + sampleSize,\n+                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n+        };\n+        Assert.assertEquals(runPicardCommandLine(args), 0);\n+\n+        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n+        try (FileReader reader = new FileReader(outfile)) {\n+            output.read(reader);\n+        }\n+        for (final WgsMetrics metrics : output.getMetrics()) {\n+            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n+            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n+            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0D);\n+            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0D);\n+            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0D);\n+            Assert.assertEquals(metrics.MEAN_COVERAGE, .152);\n+            Assert.assertEquals(metrics.SD_COVERAGE, .361977);\n+            Assert.assertEquals(metrics.PCT_1X, .151);\n+        }\n+    }\n+\n+\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testLargeIntervals(final String useFastAlgorithm) throws IOException {\n         final File input = new File(TEST_DIR, \"forMetrics.sam\");\n-        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\");\n-        outfile.deleteOnExit();\n+        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n         final File ref = new File(TEST_DIR, \"merger.fasta\");\n         final File intervals = new File(TEST_DIR, \"largeIntervals.interval_list\");\n         final int sampleSize = 1000;\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..933f672f8 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n", "chunk": "@@ -273,7 +273,7 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testLargeIntervals(final String useFastAlgorithm) throws IOException {\n         final File input = new File(TEST_DIR, \"forMetrics.sam\");\n-        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n+        final File outfile = getTempOutputFile(\"test\", \".wgs_metrics\");\n         final File ref = new File(TEST_DIR, \"merger.fasta\");\n         final File intervals = new File(TEST_DIR, \"largeIntervals.interval_list\");\n         final int sampleSize = 1000;\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5MTQwNw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464491407", "body": "This seems like it could lead to problems, if someone changed the file while editing the other test but didn't realize the file was used here as well. If you made a separate constant for each file shared like this (e.g., build the path to the file in `CollectAlignmentSummaryMetricsTest` as a constant), that would at least make it easier to find other tests that depended on that file.", "bodyText": "This seems like it could lead to problems, if someone changed the file while editing the other test but didn't realize the file was used here as well. If you made a separate constant for each file shared like this (e.g., build the path to the file in CollectAlignmentSummaryMetricsTest as a constant), that would at least make it easier to find other tests that depended on that file.", "bodyHTML": "<p dir=\"auto\">This seems like it could lead to problems, if someone changed the file while editing the other test but didn't realize the file was used here as well. If you made a separate constant for each file shared like this (e.g., build the path to the file in <code>CollectAlignmentSummaryMetricsTest</code> as a constant), that would at least make it easier to find other tests that depended on that file.</p>", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:33:19Z", "path": "src/test/java/picard/analysis/CollectOxoGMetricsTest.java", "diffHunk": "@@ -12,7 +12,7 @@\n \n public class CollectOxoGMetricsTest {\n     private static final File TEST_DATA_DIR = new File(\"testdata/picard/sam/\");\n-    private static final File SAM_FILE = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n+    private static final File SAM_FILE = new File(CollectAlignmentSummaryMetricsTest.TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0ODY3Mw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465148673", "bodyText": "This is no different than what it was (regarding someone changing the file) but at least now there's a variable that is traced to where it's being used...I fail to see how building the path from scratch helps...I moved the files into a subdirectory and suddenly other tests started failing....with this construction it will not happen...", "author": "yfarjoun", "createdAt": "2020-08-04T15:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5MTQwNw=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectOxoGMetricsTest.java b/src/test/java/picard/analysis/CollectOxoGMetricsTest.java\nindex 87fe9da77..c39504cea 100644\n--- a/src/test/java/picard/analysis/CollectOxoGMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectOxoGMetricsTest.java\n", "chunk": "@@ -12,7 +12,7 @@ import java.util.HashSet;\n \n public class CollectOxoGMetricsTest {\n     private static final File TEST_DATA_DIR = new File(\"testdata/picard/sam/\");\n-    private static final File SAM_FILE = new File(CollectAlignmentSummaryMetricsTest.TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n+    private static final File SAM_FILE = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n     private static final File REFERENCE_SEQUENCE = new File(TEST_DATA_DIR, \"merger.fasta\");\n \n     @Test\n", "next_change": {"commit": "c515e9b634464d0ef8943e2f95bf8097b849c7db", "changed_code": [{"header": "diff --git a/src/test/java/picard/analysis/CollectOxoGMetricsTest.java b/src/test/java/picard/analysis/CollectOxoGMetricsTest.java\nindex c39504cea..87fe9da77 100644\n--- a/src/test/java/picard/analysis/CollectOxoGMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectOxoGMetricsTest.java\n", "chunk": "@@ -12,7 +12,7 @@ import java.util.HashSet;\n \n public class CollectOxoGMetricsTest {\n     private static final File TEST_DATA_DIR = new File(\"testdata/picard/sam/\");\n-    private static final File SAM_FILE = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n+    private static final File SAM_FILE = new File(CollectAlignmentSummaryMetricsTest.TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n     private static final File REFERENCE_SEQUENCE = new File(TEST_DATA_DIR, \"merger.fasta\");\n \n     @Test\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5Mjc3NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464492774", "body": "Why remove this null check? If this is null, it will cause `TheoreticalSensitivity.normalizeHistogram` to throw a `PicardException`.", "bodyText": "Why remove this null check? If this is null, it will cause TheoreticalSensitivity.normalizeHistogram to throw a PicardException.", "bodyHTML": "<p dir=\"auto\">Why remove this null check? If this is null, it will cause <code>TheoreticalSensitivity.normalizeHistogram</code> to throw a <code>PicardException</code>.</p>", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:35:39Z", "path": "src/main/java/picard/analysis/WgsMetrics.java", "diffHunk": "@@ -290,23 +302,35 @@ public void calculateDerivedFields() {\n         MEDIAN_COVERAGE  = highQualityDepthHistogram.getMedian();\n         MAD_COVERAGE     = highQualityDepthHistogram.getMedianAbsoluteDeviation();\n \n-        PCT_1X    = MathUtil.sum(depthHistogramArray, 1, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n-        PCT_5X    = MathUtil.sum(depthHistogramArray, 5, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n-        PCT_10X   = MathUtil.sum(depthHistogramArray, 10, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_15X   = MathUtil.sum(depthHistogramArray, 15, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_20X   = MathUtil.sum(depthHistogramArray, 20, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_25X   = MathUtil.sum(depthHistogramArray, 25, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_30X   = MathUtil.sum(depthHistogramArray, 30, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_40X   = MathUtil.sum(depthHistogramArray, 40, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_50X   = MathUtil.sum(depthHistogramArray, 50, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_60X   = MathUtil.sum(depthHistogramArray, 60, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_70X   = MathUtil.sum(depthHistogramArray, 70, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_80X   = MathUtil.sum(depthHistogramArray, 80, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_90X   = MathUtil.sum(depthHistogramArray, 90, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_100X  = MathUtil.sum(depthHistogramArray, 100, depthHistogramArray.length) / (double) GENOME_TERRITORY;\n+        PCT_1X   = MathUtil.sum(depthHistogramArray, 1, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n+        PCT_5X   = MathUtil.sum(depthHistogramArray, 5, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n+        PCT_10X  = MathUtil.sum(depthHistogramArray, 10, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_15X  = MathUtil.sum(depthHistogramArray, 15, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_20X  = MathUtil.sum(depthHistogramArray, 20, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_25X  = MathUtil.sum(depthHistogramArray, 25, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_30X  = MathUtil.sum(depthHistogramArray, 30, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_40X  = MathUtil.sum(depthHistogramArray, 40, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_50X  = MathUtil.sum(depthHistogramArray, 50, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_60X  = MathUtil.sum(depthHistogramArray, 60, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_70X  = MathUtil.sum(depthHistogramArray, 70, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_80X  = MathUtil.sum(depthHistogramArray, 80, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_90X  = MathUtil.sum(depthHistogramArray, 90, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_100X = MathUtil.sum(depthHistogramArray, 100, depthHistogramArray.length) / (double) GENOME_TERRITORY;\n+\n+\n+        // This roughly measures by how much we must over-sequence so that xx% of bases have coverage at least as deep as the current mean coverage:\n+        if (highQualityDepthHistogram.getCount() > 0) {\n+            FOLD_80_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.2);\n+            FOLD_90_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.1);\n+            FOLD_95_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.05);\n+        } else {\n+            FOLD_80_BASE_PENALTY = 0;\n+            FOLD_90_BASE_PENALTY = 0;\n+            FOLD_95_BASE_PENALTY = 0;\n+        }\n \n         // Get Theoretical Het SNP Sensitivity\n-        if (unfilteredBaseQHistogram != null && unfilteredDepthHistogram != null) {\n+        if (unfilteredBaseQHistogram != null) {", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0OTUyMQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465149521", "bodyText": "", "author": "yfarjoun", "createdAt": "2020-08-04T15:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5Mjc3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0OTk1Ng==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465149956", "bodyText": "already checked in the first line of test", "author": "yfarjoun", "createdAt": "2020-08-04T15:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5Mjc3NA=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/WgsMetrics.java b/src/main/java/picard/analysis/WgsMetrics.java\nindex a6e6296ed..06732655b 100644\n--- a/src/main/java/picard/analysis/WgsMetrics.java\n+++ b/src/main/java/picard/analysis/WgsMetrics.java\n", "chunk": "@@ -319,15 +319,9 @@ public class WgsMetrics extends MergeableMetricBase {\n \n \n         // This roughly measures by how much we must over-sequence so that xx% of bases have coverage at least as deep as the current mean coverage:\n-        if (highQualityDepthHistogram.getCount() > 0) {\n-            FOLD_80_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.2);\n-            FOLD_90_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.1);\n-            FOLD_95_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.05);\n-        } else {\n-            FOLD_80_BASE_PENALTY = 0;\n-            FOLD_90_BASE_PENALTY = 0;\n-            FOLD_95_BASE_PENALTY = 0;\n-        }\n+        FOLD_80_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.2);\n+        FOLD_90_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.1);\n+        FOLD_95_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.05);\n \n         // Get Theoretical Het SNP Sensitivity\n         if (unfilteredBaseQHistogram != null) {\n", "next_change": {"commit": "c515e9b634464d0ef8943e2f95bf8097b849c7db", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/WgsMetrics.java b/src/main/java/picard/analysis/WgsMetrics.java\nindex 06732655b..a6e6296ed 100644\n--- a/src/main/java/picard/analysis/WgsMetrics.java\n+++ b/src/main/java/picard/analysis/WgsMetrics.java\n", "chunk": "@@ -319,9 +319,15 @@ public class WgsMetrics extends MergeableMetricBase {\n \n \n         // This roughly measures by how much we must over-sequence so that xx% of bases have coverage at least as deep as the current mean coverage:\n-        FOLD_80_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.2);\n-        FOLD_90_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.1);\n-        FOLD_95_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.05);\n+        if (highQualityDepthHistogram.getCount() > 0) {\n+            FOLD_80_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.2);\n+            FOLD_90_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.1);\n+            FOLD_95_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.05);\n+        } else {\n+            FOLD_80_BASE_PENALTY = 0;\n+            FOLD_90_BASE_PENALTY = 0;\n+            FOLD_95_BASE_PENALTY = 0;\n+        }\n \n         // Get Theoretical Het SNP Sensitivity\n         if (unfilteredBaseQHistogram != null) {\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/WgsMetrics.java b/src/main/java/picard/analysis/WgsMetrics.java\nindex a6e6296ed..0bec25e25 100644\n--- a/src/main/java/picard/analysis/WgsMetrics.java\n+++ b/src/main/java/picard/analysis/WgsMetrics.java\n", "chunk": "@@ -330,7 +330,7 @@ public class WgsMetrics extends MergeableMetricBase {\n         }\n \n         // Get Theoretical Het SNP Sensitivity\n-        if (unfilteredBaseQHistogram != null) {\n+        if (unfilteredBaseQHistogram != null && unfilteredDepthHistogram != null) {\n             final double[] depthDoubleArray = TheoreticalSensitivity.normalizeHistogram(unfilteredDepthHistogram);\n             final double[] baseQDoubleArray = TheoreticalSensitivity.normalizeHistogram(unfilteredBaseQHistogram);\n             HET_SNP_SENSITIVITY = TheoreticalSensitivity.hetSNPSensitivity(depthDoubleArray, baseQDoubleArray, theoreticalHetSensitivitySampleSize, LOG_ODDS_THRESHOLD);\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MTcxMQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464581711", "body": "`= 0` initializers unnecessary", "bodyText": "= 0 initializers unnecessary", "bodyHTML": "<p dir=\"auto\"><code>= 0</code> initializers unnecessary</p>", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:13:57Z", "path": "src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java", "diffHunk": "@@ -103,148 +104,206 @@ public GroupAlignmentSummaryMetricsPerUnitMetricCollector(final String sample, f\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex 89a9f8e63..f4a128ace 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n", "chunk": "@@ -104,206 +103,148 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n+            final SAMRecord rec         = args.getSamRecord();\n+            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (args.getSamRecord().getReadPairedFlag()) {\n-                if (args.getSamRecord().getFirstOfPairFlag()) {\n-                    firstOfPairCollector.acceptRecord(args);\n+            if (rec.getReadPairedFlag()) {\n+                if (rec.getFirstOfPairFlag()) {\n+                    firstOfPairCollector.addRecord(rec, ref);\n                 } else {\n-                    secondOfPairCollector.acceptRecord(args);\n+                    secondOfPairCollector.addRecord(rec, ref);\n                 }\n \n-                pairCollector.acceptRecord(args);\n+                pairCollector.addRecord(rec, ref);\n             } else {\n-                unpairedCollector.acceptRecord(args);\n+                unpairedCollector.addRecord(rec, ref);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.finish();\n-            firstOfPairCollector.finish();\n-            secondOfPairCollector.finish();\n-            pairCollector.finish();\n+            unpairedCollector.onComplete();\n+            firstOfPairCollector.onComplete();\n+            secondOfPairCollector.onComplete();\n+            pairCollector.onComplete();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                firstOfPairCollector.addMetricsToFile(file);\n-                secondOfPairCollector.addMetricsToFile(file);\n-                pairCollector.addMetricsToFile(file);\n+                file.addMetric(firstOfPairCollector.getMetrics());\n+                file.addMetric(secondOfPairCollector.getMetrics());\n+                file.addMetric(pairCollector.getMetrics());\n             }\n \n-            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                unpairedCollector.addMetricsToFile(file);\n+                file.addMetric(unpairedCollector.getMetrics());\n             }\n         }\n-    }\n-\n-    /**\n-     * Class that counts reads that match various conditions\n-     */\n-    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n-        private long numPositiveStrand = 0;\n-        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n-        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n-\n-        private AlignmentSummaryMetrics metrics;\n-        private long chimeras;\n-        private long chimerasDenominator;\n-        private long adapterReads;\n-        private long indels;\n-\n-        private long numSoftClipped;\n-        private long numHardClipped;\n-\n-        private long nonBisulfiteAlignedBases = 0;\n-        private long hqNonBisulfiteAlignedBases = 0;\n-        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                          final String sample,\n-                                                          final String library,\n-                                                          final String readGroup) {\n-            metrics = new AlignmentSummaryMetrics();\n-            metrics.CATEGORY = pairingCategory;\n-            metrics.SAMPLE = sample;\n-            metrics.LIBRARY = library;\n-            metrics.READ_GROUP = readGroup;\n-        }\n \n-        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n-            final SAMRecord record = samRecordAndReference.getSamRecord();\n-            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n-\n-            if (record.isSecondaryAlignment()) {\n-                // only want 1 count per read so skip non-primary alignments\n-                return;\n+        /**\n+         * Class that counts reads that match various conditions\n+         */\n+        private class IndividualAlignmentSummaryMetricsCollector {\n+            private long numPositiveStrand = 0;\n+            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n+            private AlignmentSummaryMetrics metrics;\n+            private long chimeras;\n+            private long chimerasDenominator;\n+            private long adapterReads;\n+            private long indels;\n+\n+            private long nonBisulfiteAlignedBases = 0;\n+            private long hqNonBisulfiteAlignedBases = 0;\n+            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                              final String sample,\n+                                                              final String library,\n+                                                              final String readGroup) {\n+                metrics = new AlignmentSummaryMetrics();\n+                metrics.CATEGORY = pairingCategory;\n+                metrics.SAMPLE = sample;\n+                metrics.LIBRARY = library;\n+                metrics.READ_GROUP = readGroup;\n             }\n \n-            collectReadData(record);\n-            collectQualityData(record, ref);\n-        }\n-\n-        @Override\n-        public void finish() {\n-            //summarize read data\n-            if (metrics.TOTAL_READS > 0) {\n-                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                //Calculate BAD_CYCLES\n-                metrics.BAD_CYCLES = 0;\n-                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                    if (badCyclePercentage >= 0.8) {\n-                        metrics.BAD_CYCLES++;\n-                    }\n+            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n+                if (record.getNotPrimaryAlignmentFlag()) {\n+                    // only want 1 count per read so skip non primary alignments\n+                    return;\n                 }\n \n-                if (doRefMetrics) {\n-                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                    metrics.PF_INDEL_RATE = MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                    metrics.PF_MISMATCH_RATE = MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                    metrics.PF_HQ_ERROR_RATE = MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                    metrics.PCT_HARDCLIP = this.numHardClipped / (double) metrics.PF_ALIGNED_BASES;\n-                    metrics.PCT_SOFTCLIP = this.numSoftClipped / (double) metrics.PF_ALIGNED_BASES;\n-\n-                    metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n-                }\n+                collectReadData(record);\n+                collectQualityData(record, ref);\n             }\n-        }\n-\n-        @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n-            file.addMetric(metrics);\n-        }\n \n-        /**\n-         * returns The number of read bases that are not clipped, from the cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @return Number of read bases that are not clipped\n-         */\n-        private int getUnclippedBaseCount(final Cigar cigar) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().consumesReadBases())\n-                    .filter(e -> !e.getOperator().isClipping())\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n-\n-        /**\n-         * returns The sum of lengths of a particular cigar operator in the provided cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @param op The operator that is being looked for\n-         * @return Sum of lengths of the Cigar elements in cigar that are of the operator op\n-         */\n-        private int getTotalCigarOperatorCount(final Cigar cigar, final CigarOperator op) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().equals(op))\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n+            public void onComplete() {\n+                //summarize read data\n+                if (metrics.TOTAL_READS > 0)\n+                {\n+                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                    //Calculate BAD_CYCLES\n+                    metrics.BAD_CYCLES = 0;\n+                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                        if (badCyclePercentage >= 0.8) {\n+                            metrics.BAD_CYCLES++;\n+                        }\n+                    }\n \n-        private void collectReadData(final SAMRecord record) {\n-            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n-            if (record.getSupplementaryAlignmentFlag()) {\n-                return;\n+                    if(doRefMetrics) {\n+                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n+                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n+                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n+                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n+\n+                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+                    }\n+                }\n             }\n \n-            metrics.TOTAL_READS++;\n-\n-            if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                metrics.PF_READS++;\n-                if (isNoiseRead(record)) {\n-                    metrics.PF_NOISE_READS++;\n-                }\n+            private void collectReadData(final SAMRecord record) {\n+                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+                if (record.getSupplementaryAlignmentFlag()) return;\n \n+                metrics.TOTAL_READS++;\n                 readLengthHistogram.increment(record.getReadBases().length);\n-                alignedReadLengthHistogram.increment(getUnclippedBaseCount(record.getCigar()));\n \n-                // See if the read is an adapter sequence\n-                if (adapterUtility.isAdapter(record)) {\n-                    this.adapterReads++;\n-                }\n-                // count clipped bases\n-                numHardClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.HARD_CLIP);\n+                if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                    metrics.PF_READS++;\n+                    if (isNoiseRead(record)) metrics.PF_NOISE_READS++;\n \n-                if (!record.getReadUnmappedFlag()) {\n-                    numSoftClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.SOFT_CLIP);\n-                    if (doRefMetrics) {\n+                    // See if the read is an adapter sequence\n+                    if (adapterUtility.isAdapter(record)) {\n+                        this.adapterReads++;\n+                    }\n \n+                    if (!record.getReadUnmappedFlag() && doRefMetrics) {\n                         metrics.PF_READS_ALIGNED++;\n-                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) {\n-                            metrics.PF_READS_IMPROPER_PAIRS++;\n-                        }\n-                        if (!record.getReadNegativeStrandFlag()) {\n-                            numPositiveStrand++;\n-                        }\n+                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) metrics.PF_READS_IMPROPER_PAIRS++;\n+                        if (!record.getReadNegativeStrandFlag()) numPositiveStrand++;\n                         if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n                             metrics.READS_ALIGNED_IN_PAIRS++;\n \n", "next_change": {"commit": "690fdc6532393877c3a6b04dffad0eee688223d6", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex f4a128ace..99379441b 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n", "chunk": "@@ -103,260 +104,306 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;\n+        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n+        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n+\n+        private AlignmentSummaryMetrics metrics;\n+        private long chimeras;\n+        private long chimerasDenominator;\n+        private long adapterReads;\n+        private long indels;\n+\n+        private long nonBisulfiteAlignedBases = 0;\n+        private long hqNonBisulfiteAlignedBases = 0;\n+        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                          final String sample,\n+                                                          final String library,\n+                                                          final String readGroup) {\n+            metrics = new AlignmentSummaryMetrics();\n+            metrics.CATEGORY = pairingCategory;\n+            metrics.SAMPLE = sample;\n+            metrics.LIBRARY = library;\n+            metrics.READ_GROUP = readGroup;\n+        }\n \n-            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n-                if (record.getNotPrimaryAlignmentFlag()) {\n-                    // only want 1 count per read so skip non primary alignments\n-                    return;\n-                }\n+        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n+            final SAMRecord record = samRecordAndReference.getSamRecord();\n+            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n \n-                collectReadData(record);\n-                collectQualityData(record, ref);\n+            if (record.isSecondaryAlignment()) {\n+                // only want 1 count per read so skip non-primary alignments\n+                return;\n             }\n \n-            public void onComplete() {\n-                //summarize read data\n-                if (metrics.TOTAL_READS > 0)\n-                {\n-                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                    //Calculate BAD_CYCLES\n-                    metrics.BAD_CYCLES = 0;\n-                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                        if (badCyclePercentage >= 0.8) {\n-                            metrics.BAD_CYCLES++;\n-                        }\n-                    }\n+            collectReadData(record);\n+            collectQualityData(record, ref);\n+        }\n \n-                    if(doRefMetrics) {\n-                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+        @Override\n+        public void finish() {\n+            //summarize read data\n+            if (metrics.TOTAL_READS > 0) {\n+                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                //Calculate BAD_CYCLES\n+                metrics.BAD_CYCLES = 0;\n+                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                    if (badCyclePercentage >= 0.8) {\n+                        metrics.BAD_CYCLES++;\n                     }\n                 }\n+\n+                if (doRefMetrics) {\n+                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n+                    metrics.PF_INDEL_RATE = MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n+                    metrics.PF_MISMATCH_RATE = MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n+                    metrics.PF_HQ_ERROR_RATE = MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n+\n+                    metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+                }\n             }\n+        }\n \n-            private void collectReadData(final SAMRecord record) {\n-                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n-                if (record.getSupplementaryAlignmentFlag()) return;\n+        @Override\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n+            file.addMetric(metrics);\n+        }\n+\n+        /**\n+         * returns The number of read bases that are not clipped, from the cigar\n+         *\n+         * @param cigar The input Cigar of the read\n+         * @return Number of read bases that are not clipped\n+         */\n+        private int getUnclippedBasCount(final Cigar cigar) {\n+            return cigar.getCigarElements().stream()\n+                    .filter(e -> e.getOperator().consumesReadBases())\n+                    .filter(e -> !e.getOperator().isClipping())\n+                    .mapToInt(CigarElement::getLength)\n+                    .reduce(Integer::sum).orElse(0);\n+        }\n+\n+        private void collectReadData(final SAMRecord record) {\n+            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+            if (record.getSupplementaryAlignmentFlag()) {\n+                return;\n+            }\n \n-                metrics.TOTAL_READS++;\n-                readLengthHistogram.increment(record.getReadBases().length);\n+            metrics.TOTAL_READS++;\n+            readLengthHistogram.increment(record.getReadBases().length);\n+            alignedReadLengthHistogram.increment(getUnclippedBasCount(record.getCigar()));\n \n-                if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                    metrics.PF_READS++;\n-                    if (isNoiseRead(record)) metrics.PF_NOISE_READS++;\n+            if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                metrics.PF_READS++;\n+                if (isNoiseRead(record)) {\n+                    metrics.PF_NOISE_READS++;\n+                }\n+\n+                // See if the read is an adapter sequence\n+                if (adapterUtility.isAdapter(record)) {\n+                    this.adapterReads++;\n+                }\n \n-                    // See if the read is an adapter sequence\n-                    if (adapterUtility.isAdapter(record)) {\n-                        this.adapterReads++;\n+                if (!record.getReadUnmappedFlag() && doRefMetrics) {\n+                    metrics.PF_READS_ALIGNED++;\n+                    if (record.getReadPairedFlag() && !record.getProperPairFlag()) {\n+                        metrics.PF_READS_IMPROPER_PAIRS++;\n+                    }\n+                    if (!record.getReadNegativeStrandFlag()) {\n+                        numPositiveStrand++;\n                     }\n+                    if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n+                        metrics.READS_ALIGNED_IN_PAIRS++;\n \n-                    if (!record.getReadUnmappedFlag() && doRefMetrics) {\n-                        metrics.PF_READS_ALIGNED++;\n-                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) metrics.PF_READS_IMPROPER_PAIRS++;\n-                        if (!record.getReadNegativeStrandFlag()) numPositiveStrand++;\n-                        if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n-                            metrics.READS_ALIGNED_IN_PAIRS++;\n-\n-                            // Check that both ends have mapq > minimum\n-                            final Integer mateMq = record.getIntegerAttribute(SAMTag.MQ.toString());\n-                            if (mateMq == null || mateMq >= MAPPING_QUALITY_THRESHOLD && record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n-                                ++this.chimerasDenominator;\n-\n-                                // With both reads mapped we can see if this pair is chimeric\n-                                if (ChimeraUtil.isChimeric(record, maxInsertSize, expectedOrientations)) {\n-                                    ++this.chimeras;\n-                                }\n+                        // Check that both ends have mapq > minimum\n+                        final Integer mateMq = record.getIntegerAttribute(SAMTag.MQ.toString());\n+                        if (mateMq == null || mateMq >= MAPPING_QUALITY_THRESHOLD && record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n+                            ++this.chimerasDenominator;\n+\n+                            // With both reads mapped we can see if this pair is chimeric\n+                            if (ChimeraUtil.isChimeric(record, maxInsertSize, expectedOrientations)) {\n+                                ++this.chimeras;\n                             }\n-                        } else { // fragment reads or read pairs with one end that maps\n-                            // Consider chimeras that occur *within* the read using the SA tag\n-                            if (record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n-                                ++this.chimerasDenominator;\n-                                if (record.getAttribute(SAMTag.SA.toString()) != null) ++this.chimeras;\n+                        }\n+                    } else { // fragment reads or read pairs with one end that maps\n+                        // Consider chimeras that occur *within* the read using the SA tag\n+                        if (record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n+                            ++this.chimerasDenominator;\n+                            if (record.getAttribute(SAMTag.SA.toString()) != null) {\n+                                ++this.chimeras;\n                             }\n                         }\n                     }\n                 }\n             }\n+        }\n \n-            private void collectQualityData(final SAMRecord record, final ReferenceSequence reference) {\n-                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+        private void collectQualityData(final SAMRecord record, final ReferenceSequence reference) {\n+            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n \n-                // If the read isn't an aligned PF read then look at the read for no-calls\n-                if (record.getReadUnmappedFlag() || record.getReadFailsVendorQualityCheckFlag() || !doRefMetrics) {\n-                    final byte[] readBases = record.getReadBases();\n-                    for (int i = 0; i < readBases.length; i++) {\n-                        if (SequenceUtil.isNoCall(readBases[i])) {\n-                            badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n-                        }\n+            // If the read isn't an aligned PF read then look at the read for no-calls\n+            if (record.getReadUnmappedFlag() || record.getReadFailsVendorQualityCheckFlag() || !doRefMetrics) {\n+                final byte[] readBases = record.getReadBases();\n+                for (int i = 0; i < readBases.length; i++) {\n+                    if (SequenceUtil.isNoCall(readBases[i])) {\n+                        badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n                     }\n-                } else if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                    final boolean highQualityMapping = isHighQualityMapping(record);\n-                    if (highQualityMapping && !record.getSupplementaryAlignmentFlag()) metrics.PF_HQ_ALIGNED_READS++;\n+                }\n+            } else if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                final boolean highQualityMapping = isHighQualityMapping(record);\n+                if (highQualityMapping && !record.getSupplementaryAlignmentFlag()) {\n+                    metrics.PF_HQ_ALIGNED_READS++;\n+                }\n \n-                    final byte[] readBases = record.getReadBases();\n-                    final byte[] refBases = reference == null ? null : reference.getBases();\n-                    final int refLength = reference == null ? Integer.MAX_VALUE : refBases.length;\n-                    final byte[] qualities = record.getBaseQualities();\n-                    long mismatchCount = 0;\n-                    long hqMismatchCount = 0;\n+                final byte[] readBases = record.getReadBases();\n+                final byte[] refBases = reference == null ? null : reference.getBases();\n+                final int refLength = reference == null ? Integer.MAX_VALUE : refBases.length;\n+                final byte[] qualities = record.getBaseQualities();\n+                long mismatchCount = 0;\n+                long hqMismatchCount = 0;\n \n-                    for (final AlignmentBlock alignmentBlock : record.getAlignmentBlocks()) {\n-                        final int readIndex = alignmentBlock.getReadStart() - 1;\n-                        final int refIndex = alignmentBlock.getReferenceStart() - 1;\n-                        final int length = alignmentBlock.getLength();\n+                for (final AlignmentBlock alignmentBlock : record.getAlignmentBlocks()) {\n+                    final int readIndex = alignmentBlock.getReadStart() - 1;\n+                    final int refIndex = alignmentBlock.getReferenceStart() - 1;\n+                    final int length = alignmentBlock.getLength();\n \n-                        for (int i = 0; i < length && refIndex + i < refLength; ++i) {\n-                            final int readBaseIndex = readIndex + i;\n-                            boolean mismatch = refBases != null && !SequenceUtil.basesEqual(readBases[readBaseIndex], refBases[refIndex + i]);\n+                    for (int i = 0; i < length && refIndex + i < refLength; ++i) {\n+                        final int readBaseIndex = readIndex + i;\n+                        boolean mismatch = refBases != null && !SequenceUtil.basesEqual(readBases[readBaseIndex], refBases[refIndex + i]);\n \n-                            final boolean bisulfiteMatch = refBases != null && isBisulfiteSequenced && SequenceUtil.bisulfiteBasesEqual(record.getReadNegativeStrandFlag(), readBases[readBaseIndex], refBases[readBaseIndex]);\n+                        final boolean bisulfiteMatch = refBases != null && isBisulfiteSequenced && SequenceUtil.bisulfiteBasesEqual(record.getReadNegativeStrandFlag(), readBases[readBaseIndex], refBases[readBaseIndex]);\n \n-                            final boolean bisulfiteBase = mismatch && bisulfiteMatch;\n-                            mismatch = mismatch && !bisulfiteMatch;\n+                        final boolean bisulfiteBase = mismatch && bisulfiteMatch;\n+                        mismatch = mismatch && !bisulfiteMatch;\n \n-                            if (mismatch) {\n-                                mismatchCount++;\n-                            }\n+                        if (mismatch) {\n+                            mismatchCount++;\n+                        }\n \n-                            metrics.PF_ALIGNED_BASES++;\n+                        metrics.PF_ALIGNED_BASES++;\n+                        if (!bisulfiteBase) {\n+                            nonBisulfiteAlignedBases++;\n+                        }\n+\n+                        if (highQualityMapping) {\n+                            metrics.PF_HQ_ALIGNED_BASES++;\n                             if (!bisulfiteBase) {\n-                                nonBisulfiteAlignedBases++;\n+                                hqNonBisulfiteAlignedBases++;\n                             }\n-\n-                            if (highQualityMapping) {\n-                                metrics.PF_HQ_ALIGNED_BASES++;\n-                                if (!bisulfiteBase) {\n-                                    hqNonBisulfiteAlignedBases++;\n-                                }\n-                                if (qualities[readBaseIndex] >= BASE_QUALITY_THRESHOLD) {\n-                                    metrics.PF_HQ_ALIGNED_Q20_BASES++;\n-                                }\n-                                if (mismatch) {\n-                                    hqMismatchCount++;\n-                                }\n+                            if (qualities[readBaseIndex] >= BASE_QUALITY_THRESHOLD) {\n+                                metrics.PF_HQ_ALIGNED_Q20_BASES++;\n                             }\n-\n-                            if (mismatch || SequenceUtil.isNoCall(readBases[readBaseIndex])) {\n-                                badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n+                            if (mismatch) {\n+                                hqMismatchCount++;\n                             }\n                         }\n+\n+                        if (mismatch || SequenceUtil.isNoCall(readBases[readBaseIndex])) {\n+                            badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n+                        }\n                     }\n+                }\n \n-                    mismatchHistogram.increment(mismatchCount);\n-                    hqMismatchHistogram.increment(hqMismatchCount);\n+                mismatchHistogram.increment(mismatchCount);\n+                hqMismatchHistogram.increment(hqMismatchCount);\n \n-                    // Add any insertions and/or deletions to the global count\n-                    for (final CigarElement elem : record.getCigar().getCigarElements()) {\n-                        final CigarOperator op = elem.getOperator();\n-                        if (op == CigarOperator.INSERTION || op == CigarOperator.DELETION) ++ this.indels;\n+                // Add any insertions and/or deletions to the global count\n+                for (final CigarElement elem : record.getCigar().getCigarElements()) {\n+                    final CigarOperator op = elem.getOperator();\n+                    if (op == CigarOperator.INSERTION || op == CigarOperator.DELETION) {\n+                        ++this.indels;\n                     }\n                 }\n             }\n-            \n-            private boolean isNoiseRead(final SAMRecord record) {\n-                final Object noiseAttribute = record.getAttribute(ReservedTagConstants.XN);\n-                return (noiseAttribute != null && noiseAttribute.equals(1));\n-            }\n+        }\n \n-            private boolean isHighQualityMapping(final SAMRecord record) {\n-                return !record.getReadFailsVendorQualityCheckFlag() &&\n-                        record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD;\n-            }\n+        private boolean isNoiseRead(final SAMRecord record) {\n+            final Object noiseAttribute = record.getAttribute(ReservedTagConstants.XN);\n+            return (noiseAttribute != null && noiseAttribute.equals(1));\n+        }\n \n-            public AlignmentSummaryMetrics getMetrics() {\n-                return this.metrics;\n-            }\n+        private boolean isHighQualityMapping(final SAMRecord record) {\n+            return !record.getReadFailsVendorQualityCheckFlag() &&\n+                    record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD;\n+        }\n+\n+        public AlignmentSummaryMetrics getMetrics() {\n+            return this.metrics;\n+        }\n+\n+        public Histogram<Integer> getReadHistogram() {\n+            return this.readLengthHistogram;\n+        }\n+\n+        public Histogram<Integer> getAlignedReadHistogram() {\n+            return this.alignedReadLengthHistogram;\n         }\n     }\n }\n+\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex 99379441b..95a8076fc 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n", "chunk": "@@ -394,15 +424,15 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n         }\n \n         public AlignmentSummaryMetrics getMetrics() {\n-            return this.metrics;\n+            return metrics;\n         }\n \n         public Histogram<Integer> getReadHistogram() {\n-            return this.readLengthHistogram;\n+            return readLengthHistogram;\n         }\n \n         public Histogram<Integer> getAlignedReadHistogram() {\n-            return this.alignedReadLengthHistogram;\n+            return alignedReadLengthHistogram;\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MTc5MQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464581791", "body": "can be `final`, I think", "bodyText": "can be final, I think", "bodyHTML": "<p dir=\"auto\">can be <code>final</code>, I think</p>", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:14:08Z", "path": "src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java", "diffHunk": "@@ -103,148 +104,206 @@ public GroupAlignmentSummaryMetricsPerUnitMetricCollector(final String sample, f\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;\n+        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n+        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n+\n+        private AlignmentSummaryMetrics metrics;", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex 89a9f8e63..f4a128ace 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n", "chunk": "@@ -104,206 +103,148 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n+            final SAMRecord rec         = args.getSamRecord();\n+            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (args.getSamRecord().getReadPairedFlag()) {\n-                if (args.getSamRecord().getFirstOfPairFlag()) {\n-                    firstOfPairCollector.acceptRecord(args);\n+            if (rec.getReadPairedFlag()) {\n+                if (rec.getFirstOfPairFlag()) {\n+                    firstOfPairCollector.addRecord(rec, ref);\n                 } else {\n-                    secondOfPairCollector.acceptRecord(args);\n+                    secondOfPairCollector.addRecord(rec, ref);\n                 }\n \n-                pairCollector.acceptRecord(args);\n+                pairCollector.addRecord(rec, ref);\n             } else {\n-                unpairedCollector.acceptRecord(args);\n+                unpairedCollector.addRecord(rec, ref);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.finish();\n-            firstOfPairCollector.finish();\n-            secondOfPairCollector.finish();\n-            pairCollector.finish();\n+            unpairedCollector.onComplete();\n+            firstOfPairCollector.onComplete();\n+            secondOfPairCollector.onComplete();\n+            pairCollector.onComplete();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                firstOfPairCollector.addMetricsToFile(file);\n-                secondOfPairCollector.addMetricsToFile(file);\n-                pairCollector.addMetricsToFile(file);\n+                file.addMetric(firstOfPairCollector.getMetrics());\n+                file.addMetric(secondOfPairCollector.getMetrics());\n+                file.addMetric(pairCollector.getMetrics());\n             }\n \n-            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                unpairedCollector.addMetricsToFile(file);\n+                file.addMetric(unpairedCollector.getMetrics());\n             }\n         }\n-    }\n-\n-    /**\n-     * Class that counts reads that match various conditions\n-     */\n-    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n-        private long numPositiveStrand = 0;\n-        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n-        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n-\n-        private AlignmentSummaryMetrics metrics;\n-        private long chimeras;\n-        private long chimerasDenominator;\n-        private long adapterReads;\n-        private long indels;\n-\n-        private long numSoftClipped;\n-        private long numHardClipped;\n-\n-        private long nonBisulfiteAlignedBases = 0;\n-        private long hqNonBisulfiteAlignedBases = 0;\n-        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                          final String sample,\n-                                                          final String library,\n-                                                          final String readGroup) {\n-            metrics = new AlignmentSummaryMetrics();\n-            metrics.CATEGORY = pairingCategory;\n-            metrics.SAMPLE = sample;\n-            metrics.LIBRARY = library;\n-            metrics.READ_GROUP = readGroup;\n-        }\n \n-        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n-            final SAMRecord record = samRecordAndReference.getSamRecord();\n-            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n-\n-            if (record.isSecondaryAlignment()) {\n-                // only want 1 count per read so skip non-primary alignments\n-                return;\n+        /**\n+         * Class that counts reads that match various conditions\n+         */\n+        private class IndividualAlignmentSummaryMetricsCollector {\n+            private long numPositiveStrand = 0;\n+            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n+            private AlignmentSummaryMetrics metrics;\n+            private long chimeras;\n+            private long chimerasDenominator;\n+            private long adapterReads;\n+            private long indels;\n+\n+            private long nonBisulfiteAlignedBases = 0;\n+            private long hqNonBisulfiteAlignedBases = 0;\n+            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                              final String sample,\n+                                                              final String library,\n+                                                              final String readGroup) {\n+                metrics = new AlignmentSummaryMetrics();\n+                metrics.CATEGORY = pairingCategory;\n+                metrics.SAMPLE = sample;\n+                metrics.LIBRARY = library;\n+                metrics.READ_GROUP = readGroup;\n             }\n \n-            collectReadData(record);\n-            collectQualityData(record, ref);\n-        }\n-\n-        @Override\n-        public void finish() {\n-            //summarize read data\n-            if (metrics.TOTAL_READS > 0) {\n-                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                //Calculate BAD_CYCLES\n-                metrics.BAD_CYCLES = 0;\n-                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                    if (badCyclePercentage >= 0.8) {\n-                        metrics.BAD_CYCLES++;\n-                    }\n+            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n+                if (record.getNotPrimaryAlignmentFlag()) {\n+                    // only want 1 count per read so skip non primary alignments\n+                    return;\n                 }\n \n-                if (doRefMetrics) {\n-                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                    metrics.PF_INDEL_RATE = MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                    metrics.PF_MISMATCH_RATE = MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                    metrics.PF_HQ_ERROR_RATE = MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                    metrics.PCT_HARDCLIP = this.numHardClipped / (double) metrics.PF_ALIGNED_BASES;\n-                    metrics.PCT_SOFTCLIP = this.numSoftClipped / (double) metrics.PF_ALIGNED_BASES;\n-\n-                    metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n-                }\n+                collectReadData(record);\n+                collectQualityData(record, ref);\n             }\n-        }\n-\n-        @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n-            file.addMetric(metrics);\n-        }\n \n-        /**\n-         * returns The number of read bases that are not clipped, from the cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @return Number of read bases that are not clipped\n-         */\n-        private int getUnclippedBaseCount(final Cigar cigar) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().consumesReadBases())\n-                    .filter(e -> !e.getOperator().isClipping())\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n-\n-        /**\n-         * returns The sum of lengths of a particular cigar operator in the provided cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @param op The operator that is being looked for\n-         * @return Sum of lengths of the Cigar elements in cigar that are of the operator op\n-         */\n-        private int getTotalCigarOperatorCount(final Cigar cigar, final CigarOperator op) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().equals(op))\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n+            public void onComplete() {\n+                //summarize read data\n+                if (metrics.TOTAL_READS > 0)\n+                {\n+                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                    //Calculate BAD_CYCLES\n+                    metrics.BAD_CYCLES = 0;\n+                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                        if (badCyclePercentage >= 0.8) {\n+                            metrics.BAD_CYCLES++;\n+                        }\n+                    }\n \n-        private void collectReadData(final SAMRecord record) {\n-            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n-            if (record.getSupplementaryAlignmentFlag()) {\n-                return;\n+                    if(doRefMetrics) {\n+                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n+                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n+                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n+                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n+\n+                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+                    }\n+                }\n             }\n \n-            metrics.TOTAL_READS++;\n-\n-            if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                metrics.PF_READS++;\n-                if (isNoiseRead(record)) {\n-                    metrics.PF_NOISE_READS++;\n-                }\n+            private void collectReadData(final SAMRecord record) {\n+                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+                if (record.getSupplementaryAlignmentFlag()) return;\n \n+                metrics.TOTAL_READS++;\n                 readLengthHistogram.increment(record.getReadBases().length);\n-                alignedReadLengthHistogram.increment(getUnclippedBaseCount(record.getCigar()));\n \n-                // See if the read is an adapter sequence\n-                if (adapterUtility.isAdapter(record)) {\n-                    this.adapterReads++;\n-                }\n-                // count clipped bases\n-                numHardClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.HARD_CLIP);\n+                if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                    metrics.PF_READS++;\n+                    if (isNoiseRead(record)) metrics.PF_NOISE_READS++;\n \n-                if (!record.getReadUnmappedFlag()) {\n-                    numSoftClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.SOFT_CLIP);\n-                    if (doRefMetrics) {\n+                    // See if the read is an adapter sequence\n+                    if (adapterUtility.isAdapter(record)) {\n+                        this.adapterReads++;\n+                    }\n \n+                    if (!record.getReadUnmappedFlag() && doRefMetrics) {\n                         metrics.PF_READS_ALIGNED++;\n-                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) {\n-                            metrics.PF_READS_IMPROPER_PAIRS++;\n-                        }\n-                        if (!record.getReadNegativeStrandFlag()) {\n-                            numPositiveStrand++;\n-                        }\n+                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) metrics.PF_READS_IMPROPER_PAIRS++;\n+                        if (!record.getReadNegativeStrandFlag()) numPositiveStrand++;\n                         if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n                             metrics.READS_ALIGNED_IN_PAIRS++;\n \n", "next_change": {"commit": "690fdc6532393877c3a6b04dffad0eee688223d6", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex f4a128ace..99379441b 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n", "chunk": "@@ -103,260 +104,306 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;\n+        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n+        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n+\n+        private AlignmentSummaryMetrics metrics;\n+        private long chimeras;\n+        private long chimerasDenominator;\n+        private long adapterReads;\n+        private long indels;\n+\n+        private long nonBisulfiteAlignedBases = 0;\n+        private long hqNonBisulfiteAlignedBases = 0;\n+        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                          final String sample,\n+                                                          final String library,\n+                                                          final String readGroup) {\n+            metrics = new AlignmentSummaryMetrics();\n+            metrics.CATEGORY = pairingCategory;\n+            metrics.SAMPLE = sample;\n+            metrics.LIBRARY = library;\n+            metrics.READ_GROUP = readGroup;\n+        }\n \n-            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n-                if (record.getNotPrimaryAlignmentFlag()) {\n-                    // only want 1 count per read so skip non primary alignments\n-                    return;\n-                }\n+        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n+            final SAMRecord record = samRecordAndReference.getSamRecord();\n+            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n \n-                collectReadData(record);\n-                collectQualityData(record, ref);\n+            if (record.isSecondaryAlignment()) {\n+                // only want 1 count per read so skip non-primary alignments\n+                return;\n             }\n \n-            public void onComplete() {\n-                //summarize read data\n-                if (metrics.TOTAL_READS > 0)\n-                {\n-                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                    //Calculate BAD_CYCLES\n-                    metrics.BAD_CYCLES = 0;\n-                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                        if (badCyclePercentage >= 0.8) {\n-                            metrics.BAD_CYCLES++;\n-                        }\n-                    }\n+            collectReadData(record);\n+            collectQualityData(record, ref);\n+        }\n \n-                    if(doRefMetrics) {\n-                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+        @Override\n+        public void finish() {\n+            //summarize read data\n+            if (metrics.TOTAL_READS > 0) {\n+                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                //Calculate BAD_CYCLES\n+                metrics.BAD_CYCLES = 0;\n+                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                    if (badCyclePercentage >= 0.8) {\n+                        metrics.BAD_CYCLES++;\n                     }\n                 }\n+\n+                if (doRefMetrics) {\n+                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n+                    metrics.PF_INDEL_RATE = MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n+                    metrics.PF_MISMATCH_RATE = MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n+                    metrics.PF_HQ_ERROR_RATE = MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n+\n+                    metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+                }\n             }\n+        }\n \n-            private void collectReadData(final SAMRecord record) {\n-                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n-                if (record.getSupplementaryAlignmentFlag()) return;\n+        @Override\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n+            file.addMetric(metrics);\n+        }\n+\n+        /**\n+         * returns The number of read bases that are not clipped, from the cigar\n+         *\n+         * @param cigar The input Cigar of the read\n+         * @return Number of read bases that are not clipped\n+         */\n+        private int getUnclippedBasCount(final Cigar cigar) {\n+            return cigar.getCigarElements().stream()\n+                    .filter(e -> e.getOperator().consumesReadBases())\n+                    .filter(e -> !e.getOperator().isClipping())\n+                    .mapToInt(CigarElement::getLength)\n+                    .reduce(Integer::sum).orElse(0);\n+        }\n+\n+        private void collectReadData(final SAMRecord record) {\n+            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+            if (record.getSupplementaryAlignmentFlag()) {\n+                return;\n+            }\n \n-                metrics.TOTAL_READS++;\n-                readLengthHistogram.increment(record.getReadBases().length);\n+            metrics.TOTAL_READS++;\n+            readLengthHistogram.increment(record.getReadBases().length);\n+            alignedReadLengthHistogram.increment(getUnclippedBasCount(record.getCigar()));\n \n-                if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                    metrics.PF_READS++;\n-                    if (isNoiseRead(record)) metrics.PF_NOISE_READS++;\n+            if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                metrics.PF_READS++;\n+                if (isNoiseRead(record)) {\n+                    metrics.PF_NOISE_READS++;\n+                }\n+\n+                // See if the read is an adapter sequence\n+                if (adapterUtility.isAdapter(record)) {\n+                    this.adapterReads++;\n+                }\n \n-                    // See if the read is an adapter sequence\n-                    if (adapterUtility.isAdapter(record)) {\n-                        this.adapterReads++;\n+                if (!record.getReadUnmappedFlag() && doRefMetrics) {\n+                    metrics.PF_READS_ALIGNED++;\n+                    if (record.getReadPairedFlag() && !record.getProperPairFlag()) {\n+                        metrics.PF_READS_IMPROPER_PAIRS++;\n+                    }\n+                    if (!record.getReadNegativeStrandFlag()) {\n+                        numPositiveStrand++;\n                     }\n+                    if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n+                        metrics.READS_ALIGNED_IN_PAIRS++;\n \n-                    if (!record.getReadUnmappedFlag() && doRefMetrics) {\n-                        metrics.PF_READS_ALIGNED++;\n-                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) metrics.PF_READS_IMPROPER_PAIRS++;\n-                        if (!record.getReadNegativeStrandFlag()) numPositiveStrand++;\n-                        if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n-                            metrics.READS_ALIGNED_IN_PAIRS++;\n-\n-                            // Check that both ends have mapq > minimum\n-                            final Integer mateMq = record.getIntegerAttribute(SAMTag.MQ.toString());\n-                            if (mateMq == null || mateMq >= MAPPING_QUALITY_THRESHOLD && record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n-                                ++this.chimerasDenominator;\n-\n-                                // With both reads mapped we can see if this pair is chimeric\n-                                if (ChimeraUtil.isChimeric(record, maxInsertSize, expectedOrientations)) {\n-                                    ++this.chimeras;\n-                                }\n+                        // Check that both ends have mapq > minimum\n+                        final Integer mateMq = record.getIntegerAttribute(SAMTag.MQ.toString());\n+                        if (mateMq == null || mateMq >= MAPPING_QUALITY_THRESHOLD && record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n+                            ++this.chimerasDenominator;\n+\n+                            // With both reads mapped we can see if this pair is chimeric\n+                            if (ChimeraUtil.isChimeric(record, maxInsertSize, expectedOrientations)) {\n+                                ++this.chimeras;\n                             }\n-                        } else { // fragment reads or read pairs with one end that maps\n-                            // Consider chimeras that occur *within* the read using the SA tag\n-                            if (record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n-                                ++this.chimerasDenominator;\n-                                if (record.getAttribute(SAMTag.SA.toString()) != null) ++this.chimeras;\n+                        }\n+                    } else { // fragment reads or read pairs with one end that maps\n+                        // Consider chimeras that occur *within* the read using the SA tag\n+                        if (record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n+                            ++this.chimerasDenominator;\n+                            if (record.getAttribute(SAMTag.SA.toString()) != null) {\n+                                ++this.chimeras;\n                             }\n                         }\n                     }\n                 }\n             }\n+        }\n \n-            private void collectQualityData(final SAMRecord record, final ReferenceSequence reference) {\n-                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+        private void collectQualityData(final SAMRecord record, final ReferenceSequence reference) {\n+            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n \n-                // If the read isn't an aligned PF read then look at the read for no-calls\n-                if (record.getReadUnmappedFlag() || record.getReadFailsVendorQualityCheckFlag() || !doRefMetrics) {\n-                    final byte[] readBases = record.getReadBases();\n-                    for (int i = 0; i < readBases.length; i++) {\n-                        if (SequenceUtil.isNoCall(readBases[i])) {\n-                            badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n-                        }\n+            // If the read isn't an aligned PF read then look at the read for no-calls\n+            if (record.getReadUnmappedFlag() || record.getReadFailsVendorQualityCheckFlag() || !doRefMetrics) {\n+                final byte[] readBases = record.getReadBases();\n+                for (int i = 0; i < readBases.length; i++) {\n+                    if (SequenceUtil.isNoCall(readBases[i])) {\n+                        badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n                     }\n-                } else if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                    final boolean highQualityMapping = isHighQualityMapping(record);\n-                    if (highQualityMapping && !record.getSupplementaryAlignmentFlag()) metrics.PF_HQ_ALIGNED_READS++;\n+                }\n+            } else if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                final boolean highQualityMapping = isHighQualityMapping(record);\n+                if (highQualityMapping && !record.getSupplementaryAlignmentFlag()) {\n+                    metrics.PF_HQ_ALIGNED_READS++;\n+                }\n \n-                    final byte[] readBases = record.getReadBases();\n-                    final byte[] refBases = reference == null ? null : reference.getBases();\n-                    final int refLength = reference == null ? Integer.MAX_VALUE : refBases.length;\n-                    final byte[] qualities = record.getBaseQualities();\n-                    long mismatchCount = 0;\n-                    long hqMismatchCount = 0;\n+                final byte[] readBases = record.getReadBases();\n+                final byte[] refBases = reference == null ? null : reference.getBases();\n+                final int refLength = reference == null ? Integer.MAX_VALUE : refBases.length;\n+                final byte[] qualities = record.getBaseQualities();\n+                long mismatchCount = 0;\n+                long hqMismatchCount = 0;\n \n-                    for (final AlignmentBlock alignmentBlock : record.getAlignmentBlocks()) {\n-                        final int readIndex = alignmentBlock.getReadStart() - 1;\n-                        final int refIndex = alignmentBlock.getReferenceStart() - 1;\n-                        final int length = alignmentBlock.getLength();\n+                for (final AlignmentBlock alignmentBlock : record.getAlignmentBlocks()) {\n+                    final int readIndex = alignmentBlock.getReadStart() - 1;\n+                    final int refIndex = alignmentBlock.getReferenceStart() - 1;\n+                    final int length = alignmentBlock.getLength();\n \n-                        for (int i = 0; i < length && refIndex + i < refLength; ++i) {\n-                            final int readBaseIndex = readIndex + i;\n-                            boolean mismatch = refBases != null && !SequenceUtil.basesEqual(readBases[readBaseIndex], refBases[refIndex + i]);\n+                    for (int i = 0; i < length && refIndex + i < refLength; ++i) {\n+                        final int readBaseIndex = readIndex + i;\n+                        boolean mismatch = refBases != null && !SequenceUtil.basesEqual(readBases[readBaseIndex], refBases[refIndex + i]);\n \n-                            final boolean bisulfiteMatch = refBases != null && isBisulfiteSequenced && SequenceUtil.bisulfiteBasesEqual(record.getReadNegativeStrandFlag(), readBases[readBaseIndex], refBases[readBaseIndex]);\n+                        final boolean bisulfiteMatch = refBases != null && isBisulfiteSequenced && SequenceUtil.bisulfiteBasesEqual(record.getReadNegativeStrandFlag(), readBases[readBaseIndex], refBases[readBaseIndex]);\n \n-                            final boolean bisulfiteBase = mismatch && bisulfiteMatch;\n-                            mismatch = mismatch && !bisulfiteMatch;\n+                        final boolean bisulfiteBase = mismatch && bisulfiteMatch;\n+                        mismatch = mismatch && !bisulfiteMatch;\n \n-                            if (mismatch) {\n-                                mismatchCount++;\n-                            }\n+                        if (mismatch) {\n+                            mismatchCount++;\n+                        }\n \n-                            metrics.PF_ALIGNED_BASES++;\n+                        metrics.PF_ALIGNED_BASES++;\n+                        if (!bisulfiteBase) {\n+                            nonBisulfiteAlignedBases++;\n+                        }\n+\n+                        if (highQualityMapping) {\n+                            metrics.PF_HQ_ALIGNED_BASES++;\n                             if (!bisulfiteBase) {\n-                                nonBisulfiteAlignedBases++;\n+                                hqNonBisulfiteAlignedBases++;\n                             }\n-\n-                            if (highQualityMapping) {\n-                                metrics.PF_HQ_ALIGNED_BASES++;\n-                                if (!bisulfiteBase) {\n-                                    hqNonBisulfiteAlignedBases++;\n-                                }\n-                                if (qualities[readBaseIndex] >= BASE_QUALITY_THRESHOLD) {\n-                                    metrics.PF_HQ_ALIGNED_Q20_BASES++;\n-                                }\n-                                if (mismatch) {\n-                                    hqMismatchCount++;\n-                                }\n+                            if (qualities[readBaseIndex] >= BASE_QUALITY_THRESHOLD) {\n+                                metrics.PF_HQ_ALIGNED_Q20_BASES++;\n                             }\n-\n-                            if (mismatch || SequenceUtil.isNoCall(readBases[readBaseIndex])) {\n-                                badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n+                            if (mismatch) {\n+                                hqMismatchCount++;\n                             }\n                         }\n+\n+                        if (mismatch || SequenceUtil.isNoCall(readBases[readBaseIndex])) {\n+                            badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n+                        }\n                     }\n+                }\n \n-                    mismatchHistogram.increment(mismatchCount);\n-                    hqMismatchHistogram.increment(hqMismatchCount);\n+                mismatchHistogram.increment(mismatchCount);\n+                hqMismatchHistogram.increment(hqMismatchCount);\n \n-                    // Add any insertions and/or deletions to the global count\n-                    for (final CigarElement elem : record.getCigar().getCigarElements()) {\n-                        final CigarOperator op = elem.getOperator();\n-                        if (op == CigarOperator.INSERTION || op == CigarOperator.DELETION) ++ this.indels;\n+                // Add any insertions and/or deletions to the global count\n+                for (final CigarElement elem : record.getCigar().getCigarElements()) {\n+                    final CigarOperator op = elem.getOperator();\n+                    if (op == CigarOperator.INSERTION || op == CigarOperator.DELETION) {\n+                        ++this.indels;\n                     }\n                 }\n             }\n-            \n-            private boolean isNoiseRead(final SAMRecord record) {\n-                final Object noiseAttribute = record.getAttribute(ReservedTagConstants.XN);\n-                return (noiseAttribute != null && noiseAttribute.equals(1));\n-            }\n+        }\n \n-            private boolean isHighQualityMapping(final SAMRecord record) {\n-                return !record.getReadFailsVendorQualityCheckFlag() &&\n-                        record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD;\n-            }\n+        private boolean isNoiseRead(final SAMRecord record) {\n+            final Object noiseAttribute = record.getAttribute(ReservedTagConstants.XN);\n+            return (noiseAttribute != null && noiseAttribute.equals(1));\n+        }\n \n-            public AlignmentSummaryMetrics getMetrics() {\n-                return this.metrics;\n-            }\n+        private boolean isHighQualityMapping(final SAMRecord record) {\n+            return !record.getReadFailsVendorQualityCheckFlag() &&\n+                    record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD;\n+        }\n+\n+        public AlignmentSummaryMetrics getMetrics() {\n+            return this.metrics;\n+        }\n+\n+        public Histogram<Integer> getReadHistogram() {\n+            return this.readLengthHistogram;\n+        }\n+\n+        public Histogram<Integer> getAlignedReadHistogram() {\n+            return this.alignedReadLengthHistogram;\n         }\n     }\n }\n+\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex 99379441b..95a8076fc 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n", "chunk": "@@ -394,15 +424,15 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n         }\n \n         public AlignmentSummaryMetrics getMetrics() {\n-            return this.metrics;\n+            return metrics;\n         }\n \n         public Histogram<Integer> getReadHistogram() {\n-            return this.readLengthHistogram;\n+            return readLengthHistogram;\n         }\n \n         public Histogram<Integer> getAlignedReadHistogram() {\n-            return this.alignedReadLengthHistogram;\n+            return alignedReadLengthHistogram;\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MzU5Mw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464583593", "body": "I wouldn't normally comment on `this.` but the code is inconsistent in its use. Why do these use `this.` but no other fields do? I think it would be better to omit them completely unless necessary for disambiguation purposes.", "bodyText": "I wouldn't normally comment on this. but the code is inconsistent in its use. Why do these use this. but no other fields do? I think it would be better to omit them completely unless necessary for disambiguation purposes.", "bodyHTML": "<p dir=\"auto\">I wouldn't normally comment on <code>this.</code> but the code is inconsistent in its use. Why do these use <code>this.</code> but no other fields do? I think it would be better to omit them completely unless necessary for disambiguation purposes.</p>", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:17:41Z", "path": "src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java", "diffHunk": "@@ -103,148 +104,206 @@ public GroupAlignmentSummaryMetricsPerUnitMetricCollector(final String sample, f\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;\n+        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n+        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n+\n+        private AlignmentSummaryMetrics metrics;\n+        private long chimeras;\n+        private long chimerasDenominator;\n+        private long adapterReads;\n+        private long indels;\n+\n+        private long numSoftClipped;\n+        private long numHardClipped;\n+\n+        private long nonBisulfiteAlignedBases = 0;\n+        private long hqNonBisulfiteAlignedBases = 0;\n+        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                          final String sample,\n+                                                          final String library,\n+                                                          final String readGroup) {\n+            metrics = new AlignmentSummaryMetrics();\n+            metrics.CATEGORY = pairingCategory;\n+            metrics.SAMPLE = sample;\n+            metrics.LIBRARY = library;\n+            metrics.READ_GROUP = readGroup;\n+        }\n \n-            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n-                if (record.getNotPrimaryAlignmentFlag()) {\n-                    // only want 1 count per read so skip non primary alignments\n-                    return;\n-                }\n+        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n+            final SAMRecord record = samRecordAndReference.getSamRecord();\n+            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n \n-                collectReadData(record);\n-                collectQualityData(record, ref);\n+            if (record.isSecondaryAlignment()) {\n+                // only want 1 count per read so skip non-primary alignments\n+                return;\n             }\n \n-            public void onComplete() {\n-                //summarize read data\n-                if (metrics.TOTAL_READS > 0)\n-                {\n-                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                    //Calculate BAD_CYCLES\n-                    metrics.BAD_CYCLES = 0;\n-                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                        if (badCyclePercentage >= 0.8) {\n-                            metrics.BAD_CYCLES++;\n-                        }\n-                    }\n+            collectReadData(record);\n+            collectQualityData(record, ref);\n+        }\n \n-                    if(doRefMetrics) {\n-                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+        @Override\n+        public void finish() {\n+            //summarize read data\n+            if (metrics.TOTAL_READS > 0) {\n+                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                //Calculate BAD_CYCLES\n+                metrics.BAD_CYCLES = 0;\n+                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                    if (badCyclePercentage >= 0.8) {\n+                        metrics.BAD_CYCLES++;\n                     }\n                 }\n+\n+                if (doRefMetrics) {\n+                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex 89a9f8e63..f4a128ace 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n", "chunk": "@@ -104,206 +103,148 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n+            final SAMRecord rec         = args.getSamRecord();\n+            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (args.getSamRecord().getReadPairedFlag()) {\n-                if (args.getSamRecord().getFirstOfPairFlag()) {\n-                    firstOfPairCollector.acceptRecord(args);\n+            if (rec.getReadPairedFlag()) {\n+                if (rec.getFirstOfPairFlag()) {\n+                    firstOfPairCollector.addRecord(rec, ref);\n                 } else {\n-                    secondOfPairCollector.acceptRecord(args);\n+                    secondOfPairCollector.addRecord(rec, ref);\n                 }\n \n-                pairCollector.acceptRecord(args);\n+                pairCollector.addRecord(rec, ref);\n             } else {\n-                unpairedCollector.acceptRecord(args);\n+                unpairedCollector.addRecord(rec, ref);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.finish();\n-            firstOfPairCollector.finish();\n-            secondOfPairCollector.finish();\n-            pairCollector.finish();\n+            unpairedCollector.onComplete();\n+            firstOfPairCollector.onComplete();\n+            secondOfPairCollector.onComplete();\n+            pairCollector.onComplete();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                firstOfPairCollector.addMetricsToFile(file);\n-                secondOfPairCollector.addMetricsToFile(file);\n-                pairCollector.addMetricsToFile(file);\n+                file.addMetric(firstOfPairCollector.getMetrics());\n+                file.addMetric(secondOfPairCollector.getMetrics());\n+                file.addMetric(pairCollector.getMetrics());\n             }\n \n-            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                unpairedCollector.addMetricsToFile(file);\n+                file.addMetric(unpairedCollector.getMetrics());\n             }\n         }\n-    }\n-\n-    /**\n-     * Class that counts reads that match various conditions\n-     */\n-    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n-        private long numPositiveStrand = 0;\n-        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n-        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n-\n-        private AlignmentSummaryMetrics metrics;\n-        private long chimeras;\n-        private long chimerasDenominator;\n-        private long adapterReads;\n-        private long indels;\n-\n-        private long numSoftClipped;\n-        private long numHardClipped;\n-\n-        private long nonBisulfiteAlignedBases = 0;\n-        private long hqNonBisulfiteAlignedBases = 0;\n-        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                          final String sample,\n-                                                          final String library,\n-                                                          final String readGroup) {\n-            metrics = new AlignmentSummaryMetrics();\n-            metrics.CATEGORY = pairingCategory;\n-            metrics.SAMPLE = sample;\n-            metrics.LIBRARY = library;\n-            metrics.READ_GROUP = readGroup;\n-        }\n \n-        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n-            final SAMRecord record = samRecordAndReference.getSamRecord();\n-            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n-\n-            if (record.isSecondaryAlignment()) {\n-                // only want 1 count per read so skip non-primary alignments\n-                return;\n+        /**\n+         * Class that counts reads that match various conditions\n+         */\n+        private class IndividualAlignmentSummaryMetricsCollector {\n+            private long numPositiveStrand = 0;\n+            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n+            private AlignmentSummaryMetrics metrics;\n+            private long chimeras;\n+            private long chimerasDenominator;\n+            private long adapterReads;\n+            private long indels;\n+\n+            private long nonBisulfiteAlignedBases = 0;\n+            private long hqNonBisulfiteAlignedBases = 0;\n+            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                              final String sample,\n+                                                              final String library,\n+                                                              final String readGroup) {\n+                metrics = new AlignmentSummaryMetrics();\n+                metrics.CATEGORY = pairingCategory;\n+                metrics.SAMPLE = sample;\n+                metrics.LIBRARY = library;\n+                metrics.READ_GROUP = readGroup;\n             }\n \n-            collectReadData(record);\n-            collectQualityData(record, ref);\n-        }\n-\n-        @Override\n-        public void finish() {\n-            //summarize read data\n-            if (metrics.TOTAL_READS > 0) {\n-                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                //Calculate BAD_CYCLES\n-                metrics.BAD_CYCLES = 0;\n-                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                    if (badCyclePercentage >= 0.8) {\n-                        metrics.BAD_CYCLES++;\n-                    }\n+            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n+                if (record.getNotPrimaryAlignmentFlag()) {\n+                    // only want 1 count per read so skip non primary alignments\n+                    return;\n                 }\n \n-                if (doRefMetrics) {\n-                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                    metrics.PF_INDEL_RATE = MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                    metrics.PF_MISMATCH_RATE = MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                    metrics.PF_HQ_ERROR_RATE = MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                    metrics.PCT_HARDCLIP = this.numHardClipped / (double) metrics.PF_ALIGNED_BASES;\n-                    metrics.PCT_SOFTCLIP = this.numSoftClipped / (double) metrics.PF_ALIGNED_BASES;\n-\n-                    metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n-                }\n+                collectReadData(record);\n+                collectQualityData(record, ref);\n             }\n-        }\n-\n-        @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n-            file.addMetric(metrics);\n-        }\n \n-        /**\n-         * returns The number of read bases that are not clipped, from the cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @return Number of read bases that are not clipped\n-         */\n-        private int getUnclippedBaseCount(final Cigar cigar) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().consumesReadBases())\n-                    .filter(e -> !e.getOperator().isClipping())\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n-\n-        /**\n-         * returns The sum of lengths of a particular cigar operator in the provided cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @param op The operator that is being looked for\n-         * @return Sum of lengths of the Cigar elements in cigar that are of the operator op\n-         */\n-        private int getTotalCigarOperatorCount(final Cigar cigar, final CigarOperator op) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().equals(op))\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n+            public void onComplete() {\n+                //summarize read data\n+                if (metrics.TOTAL_READS > 0)\n+                {\n+                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                    //Calculate BAD_CYCLES\n+                    metrics.BAD_CYCLES = 0;\n+                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                        if (badCyclePercentage >= 0.8) {\n+                            metrics.BAD_CYCLES++;\n+                        }\n+                    }\n \n-        private void collectReadData(final SAMRecord record) {\n-            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n-            if (record.getSupplementaryAlignmentFlag()) {\n-                return;\n+                    if(doRefMetrics) {\n+                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n+                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n+                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n+                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n+\n+                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+                    }\n+                }\n             }\n \n-            metrics.TOTAL_READS++;\n-\n-            if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                metrics.PF_READS++;\n-                if (isNoiseRead(record)) {\n-                    metrics.PF_NOISE_READS++;\n-                }\n+            private void collectReadData(final SAMRecord record) {\n+                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+                if (record.getSupplementaryAlignmentFlag()) return;\n \n+                metrics.TOTAL_READS++;\n                 readLengthHistogram.increment(record.getReadBases().length);\n-                alignedReadLengthHistogram.increment(getUnclippedBaseCount(record.getCigar()));\n \n-                // See if the read is an adapter sequence\n-                if (adapterUtility.isAdapter(record)) {\n-                    this.adapterReads++;\n-                }\n-                // count clipped bases\n-                numHardClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.HARD_CLIP);\n+                if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                    metrics.PF_READS++;\n+                    if (isNoiseRead(record)) metrics.PF_NOISE_READS++;\n \n-                if (!record.getReadUnmappedFlag()) {\n-                    numSoftClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.SOFT_CLIP);\n-                    if (doRefMetrics) {\n+                    // See if the read is an adapter sequence\n+                    if (adapterUtility.isAdapter(record)) {\n+                        this.adapterReads++;\n+                    }\n \n+                    if (!record.getReadUnmappedFlag() && doRefMetrics) {\n                         metrics.PF_READS_ALIGNED++;\n-                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) {\n-                            metrics.PF_READS_IMPROPER_PAIRS++;\n-                        }\n-                        if (!record.getReadNegativeStrandFlag()) {\n-                            numPositiveStrand++;\n-                        }\n+                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) metrics.PF_READS_IMPROPER_PAIRS++;\n+                        if (!record.getReadNegativeStrandFlag()) numPositiveStrand++;\n                         if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n                             metrics.READS_ALIGNED_IN_PAIRS++;\n \n", "next_change": {"commit": "690fdc6532393877c3a6b04dffad0eee688223d6", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex f4a128ace..99379441b 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n", "chunk": "@@ -103,260 +104,306 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;\n+        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n+        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n+\n+        private AlignmentSummaryMetrics metrics;\n+        private long chimeras;\n+        private long chimerasDenominator;\n+        private long adapterReads;\n+        private long indels;\n+\n+        private long nonBisulfiteAlignedBases = 0;\n+        private long hqNonBisulfiteAlignedBases = 0;\n+        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                          final String sample,\n+                                                          final String library,\n+                                                          final String readGroup) {\n+            metrics = new AlignmentSummaryMetrics();\n+            metrics.CATEGORY = pairingCategory;\n+            metrics.SAMPLE = sample;\n+            metrics.LIBRARY = library;\n+            metrics.READ_GROUP = readGroup;\n+        }\n \n-            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n-                if (record.getNotPrimaryAlignmentFlag()) {\n-                    // only want 1 count per read so skip non primary alignments\n-                    return;\n-                }\n+        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n+            final SAMRecord record = samRecordAndReference.getSamRecord();\n+            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n \n-                collectReadData(record);\n-                collectQualityData(record, ref);\n+            if (record.isSecondaryAlignment()) {\n+                // only want 1 count per read so skip non-primary alignments\n+                return;\n             }\n \n-            public void onComplete() {\n-                //summarize read data\n-                if (metrics.TOTAL_READS > 0)\n-                {\n-                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                    //Calculate BAD_CYCLES\n-                    metrics.BAD_CYCLES = 0;\n-                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                        if (badCyclePercentage >= 0.8) {\n-                            metrics.BAD_CYCLES++;\n-                        }\n-                    }\n+            collectReadData(record);\n+            collectQualityData(record, ref);\n+        }\n \n-                    if(doRefMetrics) {\n-                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+        @Override\n+        public void finish() {\n+            //summarize read data\n+            if (metrics.TOTAL_READS > 0) {\n+                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                //Calculate BAD_CYCLES\n+                metrics.BAD_CYCLES = 0;\n+                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                    if (badCyclePercentage >= 0.8) {\n+                        metrics.BAD_CYCLES++;\n                     }\n                 }\n+\n+                if (doRefMetrics) {\n+                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n+                    metrics.PF_INDEL_RATE = MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n+                    metrics.PF_MISMATCH_RATE = MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n+                    metrics.PF_HQ_ERROR_RATE = MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n+\n+                    metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+                }\n             }\n+        }\n \n-            private void collectReadData(final SAMRecord record) {\n-                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n-                if (record.getSupplementaryAlignmentFlag()) return;\n+        @Override\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n+            file.addMetric(metrics);\n+        }\n+\n+        /**\n+         * returns The number of read bases that are not clipped, from the cigar\n+         *\n+         * @param cigar The input Cigar of the read\n+         * @return Number of read bases that are not clipped\n+         */\n+        private int getUnclippedBasCount(final Cigar cigar) {\n+            return cigar.getCigarElements().stream()\n+                    .filter(e -> e.getOperator().consumesReadBases())\n+                    .filter(e -> !e.getOperator().isClipping())\n+                    .mapToInt(CigarElement::getLength)\n+                    .reduce(Integer::sum).orElse(0);\n+        }\n+\n+        private void collectReadData(final SAMRecord record) {\n+            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+            if (record.getSupplementaryAlignmentFlag()) {\n+                return;\n+            }\n \n-                metrics.TOTAL_READS++;\n-                readLengthHistogram.increment(record.getReadBases().length);\n+            metrics.TOTAL_READS++;\n+            readLengthHistogram.increment(record.getReadBases().length);\n+            alignedReadLengthHistogram.increment(getUnclippedBasCount(record.getCigar()));\n \n-                if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                    metrics.PF_READS++;\n-                    if (isNoiseRead(record)) metrics.PF_NOISE_READS++;\n+            if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                metrics.PF_READS++;\n+                if (isNoiseRead(record)) {\n+                    metrics.PF_NOISE_READS++;\n+                }\n+\n+                // See if the read is an adapter sequence\n+                if (adapterUtility.isAdapter(record)) {\n+                    this.adapterReads++;\n+                }\n \n-                    // See if the read is an adapter sequence\n-                    if (adapterUtility.isAdapter(record)) {\n-                        this.adapterReads++;\n+                if (!record.getReadUnmappedFlag() && doRefMetrics) {\n+                    metrics.PF_READS_ALIGNED++;\n+                    if (record.getReadPairedFlag() && !record.getProperPairFlag()) {\n+                        metrics.PF_READS_IMPROPER_PAIRS++;\n+                    }\n+                    if (!record.getReadNegativeStrandFlag()) {\n+                        numPositiveStrand++;\n                     }\n+                    if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n+                        metrics.READS_ALIGNED_IN_PAIRS++;\n \n-                    if (!record.getReadUnmappedFlag() && doRefMetrics) {\n-                        metrics.PF_READS_ALIGNED++;\n-                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) metrics.PF_READS_IMPROPER_PAIRS++;\n-                        if (!record.getReadNegativeStrandFlag()) numPositiveStrand++;\n-                        if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n-                            metrics.READS_ALIGNED_IN_PAIRS++;\n-\n-                            // Check that both ends have mapq > minimum\n-                            final Integer mateMq = record.getIntegerAttribute(SAMTag.MQ.toString());\n-                            if (mateMq == null || mateMq >= MAPPING_QUALITY_THRESHOLD && record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n-                                ++this.chimerasDenominator;\n-\n-                                // With both reads mapped we can see if this pair is chimeric\n-                                if (ChimeraUtil.isChimeric(record, maxInsertSize, expectedOrientations)) {\n-                                    ++this.chimeras;\n-                                }\n+                        // Check that both ends have mapq > minimum\n+                        final Integer mateMq = record.getIntegerAttribute(SAMTag.MQ.toString());\n+                        if (mateMq == null || mateMq >= MAPPING_QUALITY_THRESHOLD && record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n+                            ++this.chimerasDenominator;\n+\n+                            // With both reads mapped we can see if this pair is chimeric\n+                            if (ChimeraUtil.isChimeric(record, maxInsertSize, expectedOrientations)) {\n+                                ++this.chimeras;\n                             }\n-                        } else { // fragment reads or read pairs with one end that maps\n-                            // Consider chimeras that occur *within* the read using the SA tag\n-                            if (record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n-                                ++this.chimerasDenominator;\n-                                if (record.getAttribute(SAMTag.SA.toString()) != null) ++this.chimeras;\n+                        }\n+                    } else { // fragment reads or read pairs with one end that maps\n+                        // Consider chimeras that occur *within* the read using the SA tag\n+                        if (record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD) {\n+                            ++this.chimerasDenominator;\n+                            if (record.getAttribute(SAMTag.SA.toString()) != null) {\n+                                ++this.chimeras;\n                             }\n                         }\n                     }\n                 }\n             }\n+        }\n \n-            private void collectQualityData(final SAMRecord record, final ReferenceSequence reference) {\n-                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+        private void collectQualityData(final SAMRecord record, final ReferenceSequence reference) {\n+            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n \n-                // If the read isn't an aligned PF read then look at the read for no-calls\n-                if (record.getReadUnmappedFlag() || record.getReadFailsVendorQualityCheckFlag() || !doRefMetrics) {\n-                    final byte[] readBases = record.getReadBases();\n-                    for (int i = 0; i < readBases.length; i++) {\n-                        if (SequenceUtil.isNoCall(readBases[i])) {\n-                            badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n-                        }\n+            // If the read isn't an aligned PF read then look at the read for no-calls\n+            if (record.getReadUnmappedFlag() || record.getReadFailsVendorQualityCheckFlag() || !doRefMetrics) {\n+                final byte[] readBases = record.getReadBases();\n+                for (int i = 0; i < readBases.length; i++) {\n+                    if (SequenceUtil.isNoCall(readBases[i])) {\n+                        badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n                     }\n-                } else if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                    final boolean highQualityMapping = isHighQualityMapping(record);\n-                    if (highQualityMapping && !record.getSupplementaryAlignmentFlag()) metrics.PF_HQ_ALIGNED_READS++;\n+                }\n+            } else if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                final boolean highQualityMapping = isHighQualityMapping(record);\n+                if (highQualityMapping && !record.getSupplementaryAlignmentFlag()) {\n+                    metrics.PF_HQ_ALIGNED_READS++;\n+                }\n \n-                    final byte[] readBases = record.getReadBases();\n-                    final byte[] refBases = reference == null ? null : reference.getBases();\n-                    final int refLength = reference == null ? Integer.MAX_VALUE : refBases.length;\n-                    final byte[] qualities = record.getBaseQualities();\n-                    long mismatchCount = 0;\n-                    long hqMismatchCount = 0;\n+                final byte[] readBases = record.getReadBases();\n+                final byte[] refBases = reference == null ? null : reference.getBases();\n+                final int refLength = reference == null ? Integer.MAX_VALUE : refBases.length;\n+                final byte[] qualities = record.getBaseQualities();\n+                long mismatchCount = 0;\n+                long hqMismatchCount = 0;\n \n-                    for (final AlignmentBlock alignmentBlock : record.getAlignmentBlocks()) {\n-                        final int readIndex = alignmentBlock.getReadStart() - 1;\n-                        final int refIndex = alignmentBlock.getReferenceStart() - 1;\n-                        final int length = alignmentBlock.getLength();\n+                for (final AlignmentBlock alignmentBlock : record.getAlignmentBlocks()) {\n+                    final int readIndex = alignmentBlock.getReadStart() - 1;\n+                    final int refIndex = alignmentBlock.getReferenceStart() - 1;\n+                    final int length = alignmentBlock.getLength();\n \n-                        for (int i = 0; i < length && refIndex + i < refLength; ++i) {\n-                            final int readBaseIndex = readIndex + i;\n-                            boolean mismatch = refBases != null && !SequenceUtil.basesEqual(readBases[readBaseIndex], refBases[refIndex + i]);\n+                    for (int i = 0; i < length && refIndex + i < refLength; ++i) {\n+                        final int readBaseIndex = readIndex + i;\n+                        boolean mismatch = refBases != null && !SequenceUtil.basesEqual(readBases[readBaseIndex], refBases[refIndex + i]);\n \n-                            final boolean bisulfiteMatch = refBases != null && isBisulfiteSequenced && SequenceUtil.bisulfiteBasesEqual(record.getReadNegativeStrandFlag(), readBases[readBaseIndex], refBases[readBaseIndex]);\n+                        final boolean bisulfiteMatch = refBases != null && isBisulfiteSequenced && SequenceUtil.bisulfiteBasesEqual(record.getReadNegativeStrandFlag(), readBases[readBaseIndex], refBases[readBaseIndex]);\n \n-                            final boolean bisulfiteBase = mismatch && bisulfiteMatch;\n-                            mismatch = mismatch && !bisulfiteMatch;\n+                        final boolean bisulfiteBase = mismatch && bisulfiteMatch;\n+                        mismatch = mismatch && !bisulfiteMatch;\n \n-                            if (mismatch) {\n-                                mismatchCount++;\n-                            }\n+                        if (mismatch) {\n+                            mismatchCount++;\n+                        }\n \n-                            metrics.PF_ALIGNED_BASES++;\n+                        metrics.PF_ALIGNED_BASES++;\n+                        if (!bisulfiteBase) {\n+                            nonBisulfiteAlignedBases++;\n+                        }\n+\n+                        if (highQualityMapping) {\n+                            metrics.PF_HQ_ALIGNED_BASES++;\n                             if (!bisulfiteBase) {\n-                                nonBisulfiteAlignedBases++;\n+                                hqNonBisulfiteAlignedBases++;\n                             }\n-\n-                            if (highQualityMapping) {\n-                                metrics.PF_HQ_ALIGNED_BASES++;\n-                                if (!bisulfiteBase) {\n-                                    hqNonBisulfiteAlignedBases++;\n-                                }\n-                                if (qualities[readBaseIndex] >= BASE_QUALITY_THRESHOLD) {\n-                                    metrics.PF_HQ_ALIGNED_Q20_BASES++;\n-                                }\n-                                if (mismatch) {\n-                                    hqMismatchCount++;\n-                                }\n+                            if (qualities[readBaseIndex] >= BASE_QUALITY_THRESHOLD) {\n+                                metrics.PF_HQ_ALIGNED_Q20_BASES++;\n                             }\n-\n-                            if (mismatch || SequenceUtil.isNoCall(readBases[readBaseIndex])) {\n-                                badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n+                            if (mismatch) {\n+                                hqMismatchCount++;\n                             }\n                         }\n+\n+                        if (mismatch || SequenceUtil.isNoCall(readBases[readBaseIndex])) {\n+                            badCycleHistogram.increment(CoordMath.getCycle(record.getReadNegativeStrandFlag(), readBases.length, i));\n+                        }\n                     }\n+                }\n \n-                    mismatchHistogram.increment(mismatchCount);\n-                    hqMismatchHistogram.increment(hqMismatchCount);\n+                mismatchHistogram.increment(mismatchCount);\n+                hqMismatchHistogram.increment(hqMismatchCount);\n \n-                    // Add any insertions and/or deletions to the global count\n-                    for (final CigarElement elem : record.getCigar().getCigarElements()) {\n-                        final CigarOperator op = elem.getOperator();\n-                        if (op == CigarOperator.INSERTION || op == CigarOperator.DELETION) ++ this.indels;\n+                // Add any insertions and/or deletions to the global count\n+                for (final CigarElement elem : record.getCigar().getCigarElements()) {\n+                    final CigarOperator op = elem.getOperator();\n+                    if (op == CigarOperator.INSERTION || op == CigarOperator.DELETION) {\n+                        ++this.indels;\n                     }\n                 }\n             }\n-            \n-            private boolean isNoiseRead(final SAMRecord record) {\n-                final Object noiseAttribute = record.getAttribute(ReservedTagConstants.XN);\n-                return (noiseAttribute != null && noiseAttribute.equals(1));\n-            }\n+        }\n \n-            private boolean isHighQualityMapping(final SAMRecord record) {\n-                return !record.getReadFailsVendorQualityCheckFlag() &&\n-                        record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD;\n-            }\n+        private boolean isNoiseRead(final SAMRecord record) {\n+            final Object noiseAttribute = record.getAttribute(ReservedTagConstants.XN);\n+            return (noiseAttribute != null && noiseAttribute.equals(1));\n+        }\n \n-            public AlignmentSummaryMetrics getMetrics() {\n-                return this.metrics;\n-            }\n+        private boolean isHighQualityMapping(final SAMRecord record) {\n+            return !record.getReadFailsVendorQualityCheckFlag() &&\n+                    record.getMappingQuality() >= MAPPING_QUALITY_THRESHOLD;\n+        }\n+\n+        public AlignmentSummaryMetrics getMetrics() {\n+            return this.metrics;\n+        }\n+\n+        public Histogram<Integer> getReadHistogram() {\n+            return this.readLengthHistogram;\n+        }\n+\n+        public Histogram<Integer> getAlignedReadHistogram() {\n+            return this.alignedReadLengthHistogram;\n         }\n     }\n }\n+\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex 99379441b..95a8076fc 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n", "chunk": "@@ -394,15 +424,15 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n         }\n \n         public AlignmentSummaryMetrics getMetrics() {\n-            return this.metrics;\n+            return metrics;\n         }\n \n         public Histogram<Integer> getReadHistogram() {\n-            return this.readLengthHistogram;\n+            return readLengthHistogram;\n         }\n \n         public Histogram<Integer> getAlignedReadHistogram() {\n-            return this.alignedReadLengthHistogram;\n+            return alignedReadLengthHistogram;\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4NjY0NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464586644", "body": "unnecessary `;`\r\n```suggestion\r\n        }\r\n```", "bodyText": "unnecessary ;\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    };\n          \n          \n            \n                    }", "bodyHTML": "<p dir=\"auto\">unnecessary <code>;</code></p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"567\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }<span class=\"x x-first x-last\">;</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"567\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:23:52Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -432,17 +555,19 @@ public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final File refflat,\n                                                      final Set<String> ignoreSequence) {\n                 final CollectQualityYieldMetrics program = new CollectQualityYieldMetrics();\n-                program.output = new RequiredOutputArgumentCollection(new File(outbase + \".quality_yield_metrics\" + outext));\n+                program.output = new RequiredOutputArgumentCollection(new File(outbase + METRIC_EXTENSION + outext));\n                 // Generally programs should not be accessing these directly but it might make things smoother\n                 // to just set them anyway. These are set here to make sure that in case of a the derived class\n                 // overrides\n                 program.INPUT = input;\n \n                 return program;\n             }\n-        }\n+        };", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNjg2NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465306864", "bodyText": "", "author": "yfarjoun", "createdAt": "2020-08-04T20:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4NjY0NA=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f40b2fb23..f64645d3c 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -555,7 +432,7 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n                                                      final File refflat,\n                                                      final Set<String> ignoreSequence) {\n                 final CollectQualityYieldMetrics program = new CollectQualityYieldMetrics();\n-                program.output = new RequiredOutputArgumentCollection(new File(outbase + METRIC_EXTENSION + outext));\n+                program.output = new RequiredOutputArgumentCollection(new File(outbase + \".quality_yield_metrics\" + outext));\n                 // Generally programs should not be accessing these directly but it might make things smoother\n                 // to just set them anyway. These are set here to make sure that in case of a the derived class\n                 // overrides\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f64645d3c..cc0164b87 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -432,7 +555,7 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n                                                      final File refflat,\n                                                      final Set<String> ignoreSequence) {\n                 final CollectQualityYieldMetrics program = new CollectQualityYieldMetrics();\n-                program.output = new RequiredOutputArgumentCollection(new File(outbase + \".quality_yield_metrics\" + outext));\n+                program.output = new RequiredOutputArgumentCollection(new File(outbase + METRIC_EXTENSION + outext));\n                 // Generally programs should not be accessing these directly but it might make things smoother\n                 // to just set them anyway. These are set here to make sure that in case of a the derived class\n                 // overrides\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex cc0164b87..edff199ac 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -563,7 +566,17 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n \n                 return program;\n             }\n+\n         };\n+\n+        @Override\n+        public String getHelpDoc() {\n+            return getSummary() +\n+                    \"Creates output with \\\"\" + String.join(\", \",getExtensions()) + \"\\\" appended to OUTPUT.\";\n+        }\n+\n+        abstract String getSummary();\n+        abstract List<String> getExtensions();\n     }\n \n \n", "next_change": null}]}}, {"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f64645d3c..cc0164b87 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -440,9 +563,11 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n \n                 return program;\n             }\n-        }\n+        };\n     }\n \n+\n+\n     @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n             doc = \"Input SAM or BAM file.\")\n     public File INPUT;\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex cc0164b87..edff199ac 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -563,7 +566,17 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n \n                 return program;\n             }\n+\n         };\n+\n+        @Override\n+        public String getHelpDoc() {\n+            return getSummary() +\n+                    \"Creates output with \\\"\" + String.join(\", \",getExtensions()) + \"\\\" appended to OUTPUT.\";\n+        }\n+\n+        abstract String getSummary();\n+        abstract List<String> getExtensions();\n     }\n \n \n", "next_change": null}]}}]}}, {"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f40b2fb23..f64645d3c 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -563,11 +440,9 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n \n                 return program;\n             }\n-        };\n+        }\n     }\n \n-\n-\n     @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n             doc = \"Input SAM or BAM file.\")\n     public File INPUT;\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f64645d3c..cc0164b87 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -440,9 +563,11 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n \n                 return program;\n             }\n-        }\n+        };\n     }\n \n+\n+\n     @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n             doc = \"Input SAM or BAM file.\")\n     public File INPUT;\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex cc0164b87..edff199ac 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -563,7 +566,17 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n \n                 return program;\n             }\n+\n         };\n+\n+        @Override\n+        public String getHelpDoc() {\n+            return getSummary() +\n+                    \"Creates output with \\\"\" + String.join(\", \",getExtensions()) + \"\\\" appended to OUTPUT.\";\n+        }\n+\n+        abstract String getSummary();\n+        abstract List<String> getExtensions();\n     }\n \n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4OTI2OA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464589268", "body": "why `makeList` instead of `Arrays.asList`?\r\n```suggestion\r\n            final List<String> OUTPUT_EXTENSIONS = Arrays.asList(\r\n```", "bodyText": "why makeList instead of Arrays.asList?\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n          \n          \n            \n                        final List<String> OUTPUT_EXTENSIONS = Arrays.asList(", "bodyHTML": "<p dir=\"auto\">why <code>makeList</code> instead of <code>Arrays.asList</code>?</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">final</span> <span class=\"pl-k\">List&lt;<span class=\"pl-smi\">String</span>&gt;</span> <span class=\"pl-c1\">OUTPUT_EXTENSIONS</span> <span class=\"pl-k\">=</span> <span class=\"pl-smi x x-first\">CollectionUtil</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">makeList</span>(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-k\">final</span> <span class=\"pl-k\">List&lt;<span class=\"pl-smi\">String</span>&gt;</span> <span class=\"pl-c1\">OUTPUT_EXTENSIONS</span> <span class=\"pl-k\">=</span> <span class=\"pl-smi x x-first\">Arrays</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">asList</span>(</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:29:06Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -194,6 +209,19 @@ public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".insert_size_metrics\";\n+            final String PDF_EXTENSION = \".insert_size_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f40b2fb23..f64645d3c 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -209,19 +194,6 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n                 return true;\n             }\n \n-            final String METRICS_EXTENSION = \".insert_size_metrics\";\n-            final String PDF_EXTENSION = \".insert_size_histogram.pdf\";\n-\n-            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n-                    METRICS_EXTENSION,\n-                    PDF_EXTENSION);\n-\n-            @Override\n-            public String getHelpDoc() {\n-                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n-                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n-            }\n-\n             @Override\n             public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final String outext,\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f64645d3c..cc0164b87 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -194,6 +209,19 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".insert_size_metrics\";\n+            final String PDF_EXTENSION = \".insert_size_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n+                    METRICS_EXTENSION,\n+                    PDF_EXTENSION);\n+\n+            @Override\n+            public String getHelpDoc() {\n+                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n+                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n+            }\n+\n             @Override\n             public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final String outext,\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex cc0164b87..edff199ac 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -212,14 +213,14 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n             final String METRICS_EXTENSION = \".insert_size_metrics\";\n             final String PDF_EXTENSION = \".insert_size_histogram.pdf\";\n \n-            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n-                    METRICS_EXTENSION,\n-                    PDF_EXTENSION);\n+            @Override\n+            String getSummary() {\n+                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY;\n+            }\n \n             @Override\n-            public String getHelpDoc() {\n-                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n-                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n+            List<String> getExtensions() {\n+                return Arrays.asList(METRICS_EXTENSION, PDF_EXTENSION);\n             }\n \n             @Override\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MDg0Mg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464590842", "body": "It looks like this is the same for most (all?) subclasses. If you make `USAGE_SUMMARY` and `OUTPUT_EXTENSIONS` either constructor arguments or abstract methods then the duplicate code can be removed.", "bodyText": "It looks like this is the same for most (all?) subclasses. If you make USAGE_SUMMARY and OUTPUT_EXTENSIONS either constructor arguments or abstract methods then the duplicate code can be removed.", "bodyHTML": "<p dir=\"auto\">It looks like this is the same for most (all?) subclasses. If you make <code>USAGE_SUMMARY</code> and <code>OUTPUT_EXTENSIONS</code> either constructor arguments or abstract methods then the duplicate code can be removed.</p>", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:32:20Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -157,13 +156,28 @@ default boolean supportsMetricAccumulationLevel() {\n         }\n     }\n \n-    public enum Program implements ProgramInterface {\n+    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n+\n         CollectAlignmentSummaryMetrics {\n+\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n+            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n+                    METRICS_EXTENSION,\n+                    PDF_EXTENSION);\n+\n+            @Override\n+            public String getHelpDoc() {", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f40b2fb23..f64645d3c 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -156,28 +157,13 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n         }\n     }\n \n-    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n-\n+    public enum Program implements ProgramInterface {\n         CollectAlignmentSummaryMetrics {\n-\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n-            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n-            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n-\n-            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n-                    METRICS_EXTENSION,\n-                    PDF_EXTENSION);\n-\n-            @Override\n-            public String getHelpDoc() {\n-                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n-                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n-            }\n-\n             @Override\n             public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final String outext,\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f64645d3c..cc0164b87 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -157,13 +156,28 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n         }\n     }\n \n-    public enum Program implements ProgramInterface {\n+    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n+\n         CollectAlignmentSummaryMetrics {\n+\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n+            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n+                    METRICS_EXTENSION,\n+                    PDF_EXTENSION);\n+\n+            @Override\n+            public String getHelpDoc() {\n+                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n+                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n+            }\n+\n             @Override\n             public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final String outext,\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex cc0164b87..edff199ac 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -168,14 +169,14 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n             final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n             final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n \n-            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n-                    METRICS_EXTENSION,\n-                    PDF_EXTENSION);\n+            @Override\n+            String getSummary() {\n+                return picard.analysis.CollectAlignmentSummaryMetrics.USAGE_SUMMARY;\n+            }\n \n             @Override\n-            public String getHelpDoc() {\n-                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n-                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n+            List<String> getExtensions() {\n+                return Arrays.asList(METRICS_EXTENSION, PDF_EXTENSION);\n             }\n \n             @Override\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTAyNQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464591025", "body": "I think this should be `CollectAlignmentSummaryMetrics.USAGE_SUMMARY`", "bodyText": "I think this should be CollectAlignmentSummaryMetrics.USAGE_SUMMARY", "bodyHTML": "<p dir=\"auto\">I think this should be <code>CollectAlignmentSummaryMetrics.USAGE_SUMMARY</code></p>", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:32:47Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -157,13 +156,28 @@ default boolean supportsMetricAccumulationLevel() {\n         }\n     }\n \n-    public enum Program implements ProgramInterface {\n+    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n+\n         CollectAlignmentSummaryMetrics {\n+\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n+            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n+                    METRICS_EXTENSION,\n+                    PDF_EXTENSION);\n+\n+            @Override\n+            public String getHelpDoc() {\n+                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2NTg5NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465165894", "bodyText": "oops. good catch.", "author": "yfarjoun", "createdAt": "2020-08-04T16:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f40b2fb23..f64645d3c 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -156,28 +157,13 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n         }\n     }\n \n-    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n-\n+    public enum Program implements ProgramInterface {\n         CollectAlignmentSummaryMetrics {\n-\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n-            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n-            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n-\n-            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n-                    METRICS_EXTENSION,\n-                    PDF_EXTENSION);\n-\n-            @Override\n-            public String getHelpDoc() {\n-                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n-                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n-            }\n-\n             @Override\n             public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final String outext,\n", "next_change": {"commit": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f64645d3c..cc0164b87 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -157,13 +156,28 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n         }\n     }\n \n-    public enum Program implements ProgramInterface {\n+    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n+\n         CollectAlignmentSummaryMetrics {\n+\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n+            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n+                    METRICS_EXTENSION,\n+                    PDF_EXTENSION);\n+\n+            @Override\n+            public String getHelpDoc() {\n+                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n+                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n+            }\n+\n             @Override\n             public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final String outext,\n", "next_change": {"commit": "d3c121a38e71b082868514291b0baffd91544644", "changed_code": [{"header": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex cc0164b87..edff199ac 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n", "chunk": "@@ -168,14 +169,14 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n             final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n             final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n \n-            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n-                    METRICS_EXTENSION,\n-                    PDF_EXTENSION);\n+            @Override\n+            String getSummary() {\n+                return picard.analysis.CollectAlignmentSummaryMetrics.USAGE_SUMMARY;\n+            }\n \n             @Override\n-            public String getHelpDoc() {\n-                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n-                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n+            List<String> getExtensions() {\n+                return Arrays.asList(METRICS_EXTENSION, PDF_EXTENSION);\n             }\n \n             @Override\n", "next_change": null}]}}]}}]}}, {"oid": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "url": "https://github.com/broadinstitute/picard/commit/b92438175bcb131ae681e3e3f362714c0f9d0cd1", "message": "WIP", "committedDate": "2020-08-04T20:30:36Z", "type": "commit"}, {"oid": "690fdc6532393877c3a6b04dffad0eee688223d6", "url": "https://github.com/broadinstitute/picard/commit/690fdc6532393877c3a6b04dffad0eee688223d6", "message": "WIP", "committedDate": "2020-08-04T20:30:36Z", "type": "commit"}, {"oid": "6cc4f7e319f7b89abdfafe494e17930ceefcb659", "url": "https://github.com/broadinstitute/picard/commit/6cc4f7e319f7b89abdfafe494e17930ceefcb659", "message": "WIP", "committedDate": "2020-08-04T20:30:36Z", "type": "commit"}, {"oid": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "url": "https://github.com/broadinstitute/picard/commit/70768b2f7a2e6ac0d05bf84805ef1159ff428372", "message": "Several changes to metrics collections:\n\n- Added Clips (Soft and Hard) to AlignmentSummaryMetrics\n- Added read-length histogram and pdf output to AlignmentSummaryMetrics\n- Added Tests\n- Added a TEMP_OUTPUT_DIR to CommandLineProgramTest.java which is delete once the derived class is done testing\n- Modified Two test classes to use TEMP_OUTPUT_DIR\n- Modified enum in CollectMultipleMetrics so that it will display what the options are and what each program does in the help.", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "c515e9b634464d0ef8943e2f95bf8097b849c7db", "url": "https://github.com/broadinstitute/picard/commit/c515e9b634464d0ef8943e2f95bf8097b849c7db", "message": "- fixed failing tests (moved files)\n- fixed fialing test (protect against empty histogram)", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "215e12c2b44dc6741692d7f9b79c631b62bc3c80", "url": "https://github.com/broadinstitute/picard/commit/215e12c2b44dc6741692d7f9b79c631b62bc3c80", "message": "- testing failures (ggplot2?)\n- fixing other tests failures", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "64f74350f783534af23e030e0a0a4dfdb4edb7d0", "url": "https://github.com/broadinstitute/picard/commit/64f74350f783534af23e030e0a0a4dfdb4edb7d0", "message": "- test that one can load the reshape library in R in the test env", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "8891b58d1f994cd189997156ca43c82be0c0368b", "url": "https://github.com/broadinstitute/picard/commit/8891b58d1f994cd189997156ca43c82be0c0368b", "message": "- add test with library in R", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "05d03a38f6f8ff2280532846e2417c8fbdd744d7", "url": "https://github.com/broadinstitute/picard/commit/05d03a38f6f8ff2280532846e2417c8fbdd744d7", "message": "- now plotting like a champ...no ggplot, no reshape2....", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "d3c121a38e71b082868514291b0baffd91544644", "url": "https://github.com/broadinstitute/picard/commit/d3c121a38e71b082868514291b0baffd91544644", "message": "- responding to review comments", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "8e5b875089475c999ffec862886d9fb2868049bf", "url": "https://github.com/broadinstitute/picard/commit/8e5b875089475c999ffec862886d9fb2868049bf", "message": "remove r_packages test since we do not have these packages in the r distribution we use.", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "d1d17547088339055368553a9411cee98dd9fcae", "url": "https://github.com/broadinstitute/picard/commit/d1d17547088339055368553a9411cee98dd9fcae", "message": "- updated the javaDoc", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "d1d17547088339055368553a9411cee98dd9fcae", "url": "https://github.com/broadinstitute/picard/commit/d1d17547088339055368553a9411cee98dd9fcae", "message": "- updated the javaDoc", "committedDate": "2020-08-04T20:30:38Z", "type": "forcePushed"}]}