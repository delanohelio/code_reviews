{"pr_number": 1365, "pr_title": "Convert multi param lambdas and local method invocations to method references", "pr_author": "ferozco", "pr_createdAt": "2020-05-29T03:45:19Z", "pr_url": "https://github.com/palantir/gradle-baseline/pull/1365", "timeline": [{"oid": "3fa6f1b1239631f84a6b0a6177e5593ec45cb5aa", "url": "https://github.com/palantir/gradle-baseline/commit/3fa6f1b1239631f84a6b0a6177e5593ec45cb5aa", "message": "baby steps", "committedDate": "2020-05-29T02:41:41Z", "type": "commit"}, {"oid": "c7fa4b0fd1888c4fdacb533440c0edbf924d4b70", "url": "https://github.com/palantir/gradle-baseline/commit/c7fa4b0fd1888c4fdacb533440c0edbf924d4b70", "message": "convert local methods and multi param methods", "committedDate": "2020-05-29T03:41:53Z", "type": "commit"}, {"oid": "474512dbc8676a65536bd55662f7d1bc1c05dbe3", "url": "https://github.com/palantir/gradle-baseline/commit/474512dbc8676a65536bd55662f7d1bc1c05dbe3", "message": "Add generated changelog entries", "committedDate": "2020-05-29T03:41:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDQxNg==", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432244416", "body": "I think we should handle a receiver IdentifierTree with name \u201cthis\u201d as well. Worth a test case if we don\u2019t already have one (review on thumbs)", "bodyText": "I think we should handle a receiver IdentifierTree with name \u201cthis\u201d as well. Worth a test case if we don\u2019t already have one (review on thumbs)", "bodyHTML": "<p dir=\"auto\">I think we should handle a receiver IdentifierTree with name \u201cthis\u201d as well. Worth a test case if we don\u2019t already have one (review on thumbs)</p>", "author": "carterkozak", "createdAt": "2020-05-29T04:05:30Z", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        if (!root.getParameters().isEmpty()) {\n+            Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n+            Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n+            if (!paramSymbol.equals(receiverSymbol)) {\n+                return Description.NO_MATCH;\n+            }\n+        }\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = receiver == null;\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {\n             return Description.NO_MATCH;\n         }\n \n         return buildDescription(root)\n                 .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state))\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n                 .build();\n     }\n \n-    private static boolean shouldIgnore(\n-            Symbol.MethodSymbol methodSymbol, LambdaExpressionTree root, MethodInvocationTree methodInvocation) {\n-        if (!methodSymbol.isStatic()) {\n-            if (root.getParameters().size() == 1) {\n-                Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n-                Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n-                return !paramSymbol.equals(receiverSymbol);\n-            }\n-            return true;\n+    private Description convertMethodInvocations(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        List<Symbol> methodParams = getSymbols(methodInvocation.getArguments());\n+        List<Symbol> lambdaParam = getSymbols(root.getParameters());\n+\n+        // We are guaranteed that all of root params are symbols so equality should handle cases where methodInvocation\n+        // arguments are not symbols or are out of order\n+        if (!methodParams.equals(lambdaParam)) {\n+            return Description.NO_MATCH;\n         }\n-        return !root.getParameters().isEmpty();\n+\n+        boolean isLocal = ASTHelpers.getReceiver(methodInvocation) == null;", "originalCommit": "474512dbc8676a65536bd55662f7d1bc1c05dbe3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ac79db4930bc015819445a449f3579bf7a51dac", "changed_code": [{"header": "diff --git a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\nindex b84f06e1..ddbf8d38 100644\n--- a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n+++ b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n", "chunk": "@@ -145,10 +145,9 @@ public final class LambdaMethodReference extends BugChecker implements BugChecke\n             return Description.NO_MATCH;\n         }\n \n-        boolean isLocal = ASTHelpers.getReceiver(methodInvocation) == null;\n         return buildDescription(root)\n                 .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal(methodInvocation)))\n                 .build();\n     }\n \n", "next_change": {"commit": "7a43e41c8c66e33c3cc9451e3d6588ba408ac02b", "changed_code": [{"header": "diff --git a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\nindex ddbf8d38..56523c48 100644\n--- a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n+++ b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n", "chunk": "@@ -145,10 +165,10 @@ public final class LambdaMethodReference extends BugChecker implements BugChecke\n             return Description.NO_MATCH;\n         }\n \n-        return buildDescription(root)\n-                .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal(methodInvocation)))\n-                .build();\n+        return buildFix(methodSymbol, methodInvocation, root, state, isLocal(methodInvocation))\n+                .map(fix ->\n+                        buildDescription(root).setMessage(MESSAGE).addFix(fix).build())\n+                .orElse(Description.NO_MATCH);\n     }\n \n     private static List<Symbol> getSymbols(List<? extends Tree> params) {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NDcxNg==", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432244716", "body": "Not sure these negative tests are necessary when we have refactoring tests as well.", "bodyText": "Not sure these negative tests are necessary when we have refactoring tests as well.", "bodyHTML": "<p dir=\"auto\">Not sure these negative tests are necessary when we have refactoring tests as well.</p>", "author": "carterkozak", "createdAt": "2020-05-29T04:07:06Z", "path": "baseline-error-prone/src/test/java/com/palantir/baseline/errorprone/LambdaMethodReferenceTest.java", "diffHunk": "@@ -67,7 +68,83 @@ void testFunction() {\n     }\n \n     @Test\n-    public void testPositive_block() {\n+    void testLocalInstanceMethod() {\n+        compilationHelper\n+                .addSourceLines(\n+                        \"Test.java\",\n+                        \"import \" + Optional.class.getName() + ';',\n+                        \"class Test {\",\n+                        \"  public Optional<Integer> foo(Optional<String> optional) {\",\n+                        \"    // BUG: Diagnostic contains: Lambda should be a method reference\",\n+                        \"    return optional.map(v -> bar(v));\",\n+                        \"  }\",\n+                        \"  private Integer bar(String value) {\",\n+                        \"    return value.length();\",\n+                        \"  }\",\n+                        \"}\")\n+                .doTest();", "originalCommit": "474512dbc8676a65536bd55662f7d1bc1c05dbe3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "df14397f105db2b6ed623d6f228dc138f8343066", "changed_code": [{"header": "diff --git a/baseline-error-prone/src/test/java/com/palantir/baseline/errorprone/LambdaMethodReferenceTest.java b/baseline-error-prone/src/test/java/com/palantir/baseline/errorprone/LambdaMethodReferenceTest.java\nindex 10e89c91..b2bd0c43 100644\n--- a/baseline-error-prone/src/test/java/com/palantir/baseline/errorprone/LambdaMethodReferenceTest.java\n+++ b/baseline-error-prone/src/test/java/com/palantir/baseline/errorprone/LambdaMethodReferenceTest.java\n", "chunk": "@@ -87,7 +86,7 @@ public class LambdaMethodReferenceTest {\n \n     @Test\n     public void testLocalInstanceMethodSupplier() {\n-        compilationHelper\n+        compile()\n                 .addSourceLines(\n                         \"Test.java\",\n                         \"import \" + ImmutableList.class.getName() + ';',\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NTgwNA==", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432245804", "body": "Can we remove the supplier case here in favor of the zero-length method invocation code path?", "bodyText": "Can we remove the supplier case here in favor of the zero-length method invocation code path?", "bodyHTML": "<p dir=\"auto\">Can we remove the supplier case here in favor of the zero-length method invocation code path?</p>", "author": "carterkozak", "createdAt": "2020-05-29T04:12:17Z", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(", "originalCommit": "474512dbc8676a65536bd55662f7d1bc1c05dbe3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7f47bb7235f39a4b1a7ef60666c8d2e49049c766", "changed_code": [{"header": "diff --git a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\nindex b84f06e1..f7922eda 100644\n--- a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n+++ b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n", "chunk": "@@ -106,28 +111,20 @@ public final class LambdaMethodReference extends BugChecker implements BugChecke\n         return Description.NO_MATCH;\n     }\n \n-    private Description convertSuppliersAndVariableInstanceMethods(\n+    private Description convertVariableInstanceMethods(\n             Symbol.MethodSymbol methodSymbol,\n             MethodInvocationTree methodInvocation,\n             LambdaExpressionTree root,\n             VisitorState state) {\n-        if (!root.getParameters().isEmpty()) {\n-            Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n-            Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n-            if (!paramSymbol.equals(receiverSymbol)) {\n-                return Description.NO_MATCH;\n-            }\n-        }\n-\n-        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n-        boolean isLocal = receiver == null;\n-        if (!isLocal && !(receiver instanceof IdentifierTree)) {\n+        Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n+        Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n+        if (!paramSymbol.equals(receiverSymbol)) {\n             return Description.NO_MATCH;\n         }\n \n         return buildDescription(root)\n                 .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal(methodInvocation)))\n                 .build();\n     }\n \n", "next_change": {"commit": "df14397f105db2b6ed623d6f228dc138f8343066", "changed_code": [{"header": "diff --git a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\nindex f7922eda..2b6809a2 100644\n--- a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n+++ b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n", "chunk": "@@ -121,11 +148,10 @@ public final class LambdaMethodReference extends BugChecker implements BugChecke\n         if (!paramSymbol.equals(receiverSymbol)) {\n             return Description.NO_MATCH;\n         }\n-\n-        return buildDescription(root)\n-                .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal(methodInvocation)))\n-                .build();\n+        return buildFix(methodSymbol, methodInvocation, root, state, isLocal(methodInvocation))\n+                .map(fix ->\n+                        buildDescription(root).setMessage(MESSAGE).addFix(fix).build())\n+                .orElse(Description.NO_MATCH);\n     }\n \n     private Description convertMethodInvocations(\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0OTk4Mg==", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432249982", "body": "I think there might be some oddness if the method is. It provided by this, but an enclosing class, requiring prefix \u201cEnclosing.this.\u201c. Worth a test to verify, I\u2019d probably exclude that from the check rather than attempt to refactor since it\u2019s fairly uncommon.", "bodyText": "I think there might be some oddness if the method is. It provided by this, but an enclosing class, requiring prefix \u201cEnclosing.this.\u201c. Worth a test to verify, I\u2019d probably exclude that from the check rather than attempt to refactor since it\u2019s fairly uncommon.", "bodyHTML": "<p dir=\"auto\">I think there might be some oddness if the method is. It provided by this, but an enclosing class, requiring prefix \u201cEnclosing.this.\u201c. Worth a test to verify, I\u2019d probably exclude that from the check rather than attempt to refactor since it\u2019s fairly uncommon.</p>", "author": "carterkozak", "createdAt": "2020-05-29T04:31:21Z", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,97 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        if (methodInvocation.getArguments().isEmpty()\n+                && (root.getParameters().size() == 1 || root.getParameters().isEmpty())) {\n+            return convertSuppliersAndVariableInstanceMethods(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        if (methodInvocation.getArguments().size() == root.getParameters().size()) {\n+            return convertMethodInvocations(methodSymbol, methodInvocation, root, state);\n+        }\n+\n+        return Description.NO_MATCH;\n+    }\n+\n+    private Description convertSuppliersAndVariableInstanceMethods(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        if (!root.getParameters().isEmpty()) {\n+            Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n+            Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n+            if (!paramSymbol.equals(receiverSymbol)) {\n+                return Description.NO_MATCH;\n+            }\n+        }\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = receiver == null;\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {\n             return Description.NO_MATCH;\n         }\n \n         return buildDescription(root)\n                 .setMessage(MESSAGE)\n-                .addFix(buildFix(methodSymbol, methodInvocation, root, state))\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n                 .build();\n     }\n \n-    private static boolean shouldIgnore(\n-            Symbol.MethodSymbol methodSymbol, LambdaExpressionTree root, MethodInvocationTree methodInvocation) {\n-        if (!methodSymbol.isStatic()) {\n-            if (root.getParameters().size() == 1) {\n-                Symbol paramSymbol = ASTHelpers.getSymbol(Iterables.getOnlyElement(root.getParameters()));\n-                Symbol receiverSymbol = ASTHelpers.getSymbol(ASTHelpers.getReceiver(methodInvocation));\n-                return !paramSymbol.equals(receiverSymbol);\n-            }\n-            return true;\n+    private Description convertMethodInvocations(\n+            Symbol.MethodSymbol methodSymbol,\n+            MethodInvocationTree methodInvocation,\n+            LambdaExpressionTree root,\n+            VisitorState state) {\n+        List<Symbol> methodParams = getSymbols(methodInvocation.getArguments());\n+        List<Symbol> lambdaParam = getSymbols(root.getParameters());\n+\n+        // We are guaranteed that all of root params are symbols so equality should handle cases where methodInvocation\n+        // arguments are not symbols or are out of order\n+        if (!methodParams.equals(lambdaParam)) {\n+            return Description.NO_MATCH;\n         }\n-        return !root.getParameters().isEmpty();\n+\n+        boolean isLocal = ASTHelpers.getReceiver(methodInvocation) == null;\n+        return buildDescription(root)\n+                .setMessage(MESSAGE)\n+                .addFix(buildFix(methodSymbol, methodInvocation, root, state, isLocal))\n+                .build();\n+    }\n+\n+    private static List<Symbol> getSymbols(List<? extends Tree> params) {\n+        return params.stream()\n+                .map(ASTHelpers::getSymbol)\n+                .filter(Objects::nonNull)\n+                .collect(ImmutableList.toImmutableList());\n     }\n \n     private static Optional<SuggestedFix> buildFix(\n             Symbol.MethodSymbol symbol,\n             MethodInvocationTree invocation,\n             LambdaExpressionTree root,\n-            VisitorState state) {\n+            VisitorState state,\n+            boolean isLocal) {\n         SuggestedFix.Builder builder = SuggestedFix.builder();\n-        return toMethodReference(qualifyTarget(symbol, invocation, builder, state))\n+        return toMethodReference(qualifyTarget(symbol, invocation, builder, state, isLocal))\n                 .map(qualified -> builder.replace(root, qualified).build());\n     }\n \n     private static String qualifyTarget(\n             Symbol.MethodSymbol symbol,\n             MethodInvocationTree invocation,\n             SuggestedFix.Builder builder,\n-            VisitorState state) {\n+            VisitorState state,\n+            boolean isLocal) {\n+        if (!symbol.isStatic() && isLocal) {\n+            return \"this.\" + symbol.name.toString();", "originalCommit": "474512dbc8676a65536bd55662f7d1bc1c05dbe3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7a43e41c8c66e33c3cc9451e3d6588ba408ac02b", "changed_code": [{"header": "diff --git a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\nindex b84f06e1..56523c48 100644\n--- a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n+++ b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n", "chunk": "@@ -166,27 +185,42 @@ public final class LambdaMethodReference extends BugChecker implements BugChecke\n             VisitorState state,\n             boolean isLocal) {\n         SuggestedFix.Builder builder = SuggestedFix.builder();\n-        return toMethodReference(qualifyTarget(symbol, invocation, builder, state, isLocal))\n+        return qualifyTarget(symbol, invocation, root, builder, state, isLocal)\n+                .flatMap(LambdaMethodReference::toMethodReference)\n                 .map(qualified -> builder.replace(root, qualified).build());\n     }\n \n-    private static String qualifyTarget(\n+    private static Optional<String> qualifyTarget(\n             Symbol.MethodSymbol symbol,\n             MethodInvocationTree invocation,\n+            LambdaExpressionTree root,\n             SuggestedFix.Builder builder,\n             VisitorState state,\n             boolean isLocal) {\n         if (!symbol.isStatic() && isLocal) {\n-            return \"this.\" + symbol.name.toString();\n+            return Optional.of(\"this.\" + symbol.name.toString());\n         }\n \n+        ExpressionTree receiver = ASTHelpers.getReceiver(invocation);\n         Type receiverType = ASTHelpers.getReceiverType(invocation);\n         if (receiverType == null || receiverType.getLowerBound() != null || receiverType.getUpperBound() != null) {\n-            return SuggestedFixes.qualifyType(state, builder, symbol);\n+            return Optional.of(SuggestedFixes.qualifyType(state, builder, symbol));\n         }\n-        return SuggestedFixes.qualifyType(state, builder, state.getTypes().erasure(receiverType))\n-                + '.'\n-                + symbol.name.toString();\n+        Symbol receiverSymbol = ASTHelpers.getSymbol(receiver);\n+        if (!symbol.isStatic()\n+                && receiver instanceof IdentifierTree\n+                && !Objects.equals(ImmutableList.of(receiverSymbol), getSymbols(root.getParameters()))) {\n+            if (!isFinal(receiverSymbol)) {\n+                // Not safe to replace lambdas which lazily reference values with an eager capture.\n+                return Optional.empty();\n+            }\n+            return Optional.of(state.getSourceForNode(receiver) + '.' + symbol.name.toString());\n+        }\n+\n+        return Optional.of(\n+                SuggestedFixes.qualifyType(state, builder, state.getTypes().erasure(receiverType))\n+                        + '.'\n+                        + symbol.name.toString());\n     }\n \n     private static Optional<String> toMethodReference(String qualifiedMethodName) {\n", "next_change": null}]}}, {"oid": "9ac79db4930bc015819445a449f3579bf7a51dac", "url": "https://github.com/palantir/gradle-baseline/commit/9ac79db4930bc015819445a449f3579bf7a51dac", "message": "handle explicit this", "committedDate": "2020-05-29T12:53:20Z", "type": "commit"}, {"oid": "7f47bb7235f39a4b1a7ef60666c8d2e49049c766", "url": "https://github.com/palantir/gradle-baseline/commit/7f47bb7235f39a4b1a7ef60666c8d2e49049c766", "message": "simplify", "committedDate": "2020-05-29T13:00:20Z", "type": "commit"}, {"oid": "0ecf78c33382ef0749b53388ba321269eeff645d", "url": "https://github.com/palantir/gradle-baseline/commit/0ecf78c33382ef0749b53388ba321269eeff645d", "message": "Merge branch 'fo/lambda-methods' of github.com:palantir/gradle-baseline into fo/lambda-methods", "committedDate": "2020-05-29T15:46:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU4MzgxMw==", "url": "https://github.com/palantir/gradle-baseline/pull/1365#discussion_r432583813", "body": "Does this prevent us from fixing static method calls? I don't think static methods have receivers (but I may be incorrect)\r\n\r\n```diff\r\n- value -> Preconditions.checkNotNull(value)\r\n+ Preconditions::checkNotNull\r\n```", "bodyText": "Does this prevent us from fixing static method calls? I don't think static methods have receivers (but I may be incorrect)\n- value -> Preconditions.checkNotNull(value)\n+ Preconditions::checkNotNull", "bodyHTML": "<p dir=\"auto\">Does this prevent us from fixing static method calls? I don't think static methods have receivers (but I may be incorrect)</p>\n<div class=\"highlight highlight-source-diff position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"- value -&gt; Preconditions.checkNotNull(value)\n+ Preconditions::checkNotNull\"><pre><span class=\"pl-md\"><span class=\"pl-md\">-</span> value -&gt; Preconditions.checkNotNull(value)</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span> Preconditions::checkNotNull</span></pre></div>", "author": "carterkozak", "createdAt": "2020-05-29T16:00:43Z", "path": "baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java", "diffHunk": "@@ -91,49 +89,93 @@ public Description matchLambdaExpression(LambdaExpressionTree tree, VisitorState\n \n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n-        if (!methodInvocation.getArguments().isEmpty()\n-                || !methodInvocation.getTypeArguments().isEmpty()) {\n+        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n+        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n             return Description.NO_MATCH;\n         }\n-        Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || shouldIgnore(methodSymbol, root, methodInvocation)) {\n+\n+        ExpressionTree receiver = ASTHelpers.getReceiver(methodInvocation);\n+        boolean isLocal = isLocal(methodInvocation);\n+        if (!isLocal && !(receiver instanceof IdentifierTree)) {", "originalCommit": "0ecf78c33382ef0749b53388ba321269eeff645d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7a43e41c8c66e33c3cc9451e3d6588ba408ac02b", "changed_code": [{"header": "diff --git a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\nindex f7922eda..56523c48 100644\n--- a/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n+++ b/baseline-error-prone/src/main/java/com/palantir/baseline/errorprone/LambdaMethodReference.java\n", "chunk": "@@ -90,7 +94,9 @@ public final class LambdaMethodReference extends BugChecker implements BugChecke\n     private Description checkMethodInvocation(\n             MethodInvocationTree methodInvocation, LambdaExpressionTree root, VisitorState state) {\n         Symbol.MethodSymbol methodSymbol = ASTHelpers.getSymbol(methodInvocation);\n-        if (methodSymbol == null || !methodInvocation.getTypeArguments().isEmpty()) {\n+        if (methodSymbol == null\n+                || !methodInvocation.getTypeArguments().isEmpty()\n+                || hasExplicitParameterTypes(root, state)) {\n             return Description.NO_MATCH;\n         }\n \n", "next_change": null}]}}, {"oid": "63697913887e4a07b6ef1f3c48333894d50148cc", "url": "https://github.com/palantir/gradle-baseline/commit/63697913887e4a07b6ef1f3c48333894d50148cc", "message": "demonstrate static method with param", "committedDate": "2020-05-29T19:32:45Z", "type": "commit"}, {"oid": "7a43e41c8c66e33c3cc9451e3d6588ba408ac02b", "url": "https://github.com/palantir/gradle-baseline/commit/7a43e41c8c66e33c3cc9451e3d6588ba408ac02b", "message": "Ckozak/fo/lambda methods/fix (#1369)\n\n* Fix lambdas\n\n* dont change reference capture time\n\n* avoid refactoring lambdas with param types\n\n* cyclo", "committedDate": "2020-05-29T20:16:17Z", "type": "commit"}, {"oid": "df14397f105db2b6ed623d6f228dc138f8343066", "url": "https://github.com/palantir/gradle-baseline/commit/df14397f105db2b6ed623d6f228dc138f8343066", "message": "validate against ambiguous references (#1372)\n\n<!-- User-facing outcomes this PR delivers -->", "committedDate": "2020-06-01T20:48:10Z", "type": "commit"}]}