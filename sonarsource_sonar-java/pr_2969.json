{"pr_number": 2969, "pr_title": "Adding new Regex Parser (SONARJAVA-3425)", "pr_author": "m-g-sonar", "pr_createdAt": "2020-05-28T08:08:20Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/2969", "timeline": [{"oid": "a8dd3cba914b1efb471e2417a8a1ae2819d31270", "url": "https://github.com/SonarSource/sonar-java/commit/a8dd3cba914b1efb471e2417a8a1ae2819d31270", "message": "Create AST for Regex parser", "committedDate": "2020-05-26T19:03:53Z", "type": "commit"}, {"oid": "39383d8572955dbc55fe30ac272478367cf4c557", "url": "https://github.com/SonarSource/sonar-java/commit/39383d8572955dbc55fe30ac272478367cf4c557", "message": "Implement getting locations from RegexSource\n\nAlso implement getting the full string from a RegexSource and simplify\nthe code to get substrings.", "committedDate": "2020-05-27T11:17:28Z", "type": "commit"}, {"oid": "909eb41c3ee6c30860a0b5ca0e3a432c64145a76", "url": "https://github.com/SonarSource/sonar-java/commit/909eb41c3ee6c30860a0b5ca0e3a432c64145a76", "message": "Add missing license headers", "committedDate": "2020-05-27T13:57:40Z", "type": "commit"}, {"oid": "adbc5a39173132e86cbba0b22a94eac38dea3cb2", "url": "https://github.com/SonarSource/sonar-java/commit/adbc5a39173132e86cbba0b22a94eac38dea3cb2", "message": "Implement parsing for basic regex syntax", "committedDate": "2020-05-27T17:27:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4NTI4MA==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431785280", "body": "I wonder about this `List`. since we are passing the reference, it might be possible to modify it after. We probably better provide a `Collections.unmodifiableList(...)`.", "bodyText": "I wonder about this List. since we are passing the reference, it might be possible to modify it after. We probably better provide a Collections.unmodifiableList(...).", "bodyHTML": "<p dir=\"auto\">I wonder about this <code>List</code>. since we are passing the reference, it might be possible to modify it after. We probably better provide a <code>Collections.unmodifiableList(...)</code>.</p>", "author": "m-g-sonar", "createdAt": "2020-05-28T12:06:28Z", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;", "originalCommit": "adbc5a39173132e86cbba0b22a94eac38dea3cb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyMjg3MA==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431822870", "bodyText": "@m-g-sonar Are you worried that RegexSource might modify the list? Or that someone else (with access to the original list) might modify the list after the RegexSource is created? Because unmodifiableList won't prevent the latter - we'd need to make an actual copy to protect against that. And as for the former, I don't think it's necessary to use unmodifiableList to prevent modifications from within the same class.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-05-28T13:11:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4NTI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyNjY1OQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431826659", "bodyText": "Actually you're right, we should be making it unmodifiable because the literals are accessible through a public getter. I forgot about that. Thanks.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-05-28T13:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4NTI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyNzMxMQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431827311", "bodyText": "Though on third thought, it might make more sense to just remove the getter because I don't think we actually need it.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-05-28T13:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4NTI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4ODIxMw==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431788213", "body": "instead of throwing an exception here, I believe we could simply check at the very beginning of constructing the `RegexSource` if all the literals are `STRING_LITERAL`s, and throw if it's not the case.", "bodyText": "instead of throwing an exception here, I believe we could simply check at the very beginning of constructing the RegexSource if all the literals are STRING_LITERALs, and throw if it's not the case.", "bodyHTML": "<p dir=\"auto\">instead of throwing an exception here, I believe we could simply check at the very beginning of constructing the <code>RegexSource</code> if all the literals are <code>STRING_LITERAL</code>s, and throw if it's not the case.</p>", "author": "m-g-sonar", "createdAt": "2020-05-28T12:12:10Z", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());\n+  }\n+\n+  private static String getString(LiteralTree literal) {\n+    Optional<String> string = literal.asConstant(String.class);\n+    if (string.isPresent()) {\n+      return string.get();\n+    } else {\n+      throw new IllegalArgumentException(\"Only string literals allowed\");", "originalCommit": "adbc5a39173132e86cbba0b22a94eac38dea3cb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzMDUyMA==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431830520", "bodyText": "We are doing this at the beginning of the constructor (that's when getString is called).", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-05-28T13:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4ODIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc4OTE4NA==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431789184", "body": "can be written directly:\r\n```\r\nreturn literal.asConstant(String.class)\r\n  .orElseThrow(() -> new IllegalArgumentException(\"Only string literals allowed\"));\r\n```", "bodyText": "can be written directly:\nreturn literal.asConstant(String.class)\n  .orElseThrow(() -> new IllegalArgumentException(\"Only string literals allowed\"));", "bodyHTML": "<p dir=\"auto\">can be written directly:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"return literal.asConstant(String.class)\n  .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Only string literals allowed&quot;));\"><pre><code>return literal.asConstant(String.class)\n  .orElseThrow(() -&gt; new IllegalArgumentException(\"Only string literals allowed\"));\n</code></pre></div>", "author": "m-g-sonar", "createdAt": "2020-05-28T12:13:58Z", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());\n+  }\n+\n+  private static String getString(LiteralTree literal) {\n+    Optional<String> string = literal.asConstant(String.class);", "originalCommit": "adbc5a39173132e86cbba0b22a94eac38dea3cb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc5MDc3MA==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431790770", "body": "even if used only for temporary objects when computing locations, these 2 fields can be `final`", "bodyText": "even if used only for temporary objects when computing locations, these 2 fields can be final", "bodyHTML": "<p dir=\"auto\">even if used only for temporary objects when computing locations, these 2 fields can be <code>final</code></p>", "author": "m-g-sonar", "createdAt": "2020-05-28T12:16:51Z", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());\n+  }\n+\n+  private static String getString(LiteralTree literal) {\n+    Optional<String> string = literal.asConstant(String.class);\n+    if (string.isPresent()) {\n+      return string.get();\n+    } else {\n+      throw new IllegalArgumentException(\"Only string literals allowed\");\n+    }\n+  }\n+\n+  private static class Position {\n+    int indexOfLiteral;", "originalCommit": "adbc5a39173132e86cbba0b22a94eac38dea3cb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc5MzQ1NQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431793455", "body": "What about a `Position` constructor which exactly this instead of a dedicated method? Of course then the class can not be `static` anymore, but I think it makes sense.\r\n\r\n```\r\nPosition startPosition = new Position(beginningOffset);\r\nPosition endPosition = new Position(endingOffset);\r\n```\r\n...\r\n```\r\nprivate class Position {\r\n  Position(int sourceIndex) {\r\n    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\r\n    this.indexOfLiteral = entry.getKey();\r\n    this.indexInsideLiteral = entry.getValue();\r\n  }\r\n\r\n...\r\n```", "bodyText": "What about a Position constructor which exactly this instead of a dedicated method? Of course then the class can not be static anymore, but I think it makes sense.\nPosition startPosition = new Position(beginningOffset);\nPosition endPosition = new Position(endingOffset);\n\n...\nprivate class Position {\n  Position(int sourceIndex) {\n    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n    this.indexOfLiteral = entry.getKey();\n    this.indexInsideLiteral = entry.getValue();\n  }\n\n...", "bodyHTML": "<p dir=\"auto\">What about a <code>Position</code> constructor which exactly this instead of a dedicated method? Of course then the class can not be <code>static</code> anymore, but I think it makes sense.</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Position startPosition = new Position(beginningOffset);\nPosition endPosition = new Position(endingOffset);\"><pre><code>Position startPosition = new Position(beginningOffset);\nPosition endPosition = new Position(endingOffset);\n</code></pre></div>\n<p dir=\"auto\">...</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"private class Position {\n  Position(int sourceIndex) {\n    Map.Entry&lt;Integer, Integer&gt; entry = indices.floorEntry(sourceIndex);\n    this.indexOfLiteral = entry.getKey();\n    this.indexInsideLiteral = entry.getValue();\n  }\n\n...\"><pre><code>private class Position {\n  Position(int sourceIndex) {\n    Map.Entry&lt;Integer, Integer&gt; entry = indices.floorEntry(sourceIndex);\n    this.indexOfLiteral = entry.getKey();\n    this.indexInsideLiteral = entry.getValue();\n  }\n\n...\n</code></pre></div>", "author": "m-g-sonar", "createdAt": "2020-05-28T12:21:52Z", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/RegexSource.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+\n+/**\n+ * The source code of a regular expression, made up out of 1 or more string literals\n+ */\n+public class RegexSource {\n+\n+  private final List<LiteralTree> stringLiterals;\n+  private final String sourceText;\n+  private final TreeMap<Integer, Integer> indices;\n+\n+  public RegexSource(List<LiteralTree> stringLiterals) {\n+    this.stringLiterals = stringLiterals;\n+    sourceText = stringLiterals.stream().map(RegexSource::getString).collect(Collectors.joining());\n+    indices = new TreeMap<>();\n+    int currentSourceIndex = 0;\n+    int currentLiteralIndex = 0;\n+    for (LiteralTree string : stringLiterals) {\n+      indices.put(currentSourceIndex, currentLiteralIndex);\n+      currentSourceIndex += string.value().length() - 2;\n+      currentLiteralIndex++;\n+    }\n+  }\n+\n+  public Iterable<LiteralTree> getStringLiterals() {\n+    return stringLiterals;\n+  }\n+\n+  public String substringAt(IndexRange range) {\n+    return sourceText.substring(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public String getSourceText() {\n+    return sourceText;\n+  }\n+\n+  public List<Location> locationsFor(IndexRange range) {\n+    return locationsFor(range.getBeginningOffset(), range.getEndingOffset());\n+  }\n+\n+  public List<Location> locationsFor(int beginningOffset, int endingOffset) {\n+    List<Location> result = new ArrayList<>();\n+    Position startPosition = findPosition(beginningOffset);\n+    Position endPosition = findPosition(endingOffset);\n+    for (int i = startPosition.indexOfLiteral; i <= endPosition.indexOfLiteral; i++) {\n+      LiteralTree literal = stringLiterals.get(i);\n+      int length = literal.value().length() - 2;\n+      int startIndex = startPosition.indexOfLiteral == i ? startPosition.indexInsideLiteral : 0;\n+      int endIndex = endPosition.indexOfLiteral == i ? endPosition.indexInsideLiteral : length;\n+      result.add(new Location(literal, startIndex, endIndex));\n+    }\n+    return result;\n+  }\n+\n+  private Position findPosition(int sourceIndex) {\n+    Map.Entry<Integer, Integer> entry = indices.floorEntry(sourceIndex);\n+    return new Position(entry.getKey(), entry.getValue());", "originalCommit": "adbc5a39173132e86cbba0b22a94eac38dea3cb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyMzk3MA==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431823970", "bodyText": "That makes sense, I'll do that. Thank you.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-05-28T13:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTc5MzQ1NQ=="}], "type": "inlineReview"}, {"oid": "4beb022b72ab3d0276bcb4b088a9ae5dc8cd0609", "url": "https://github.com/SonarSource/sonar-java/commit/4beb022b72ab3d0276bcb4b088a9ae5dc8cd0609", "message": "Fixes from code review", "committedDate": "2020-05-28T14:01:34Z", "type": "commit"}, {"oid": "ef46538260bb2d5250c20d08981c9bd331bc8e8b", "url": "https://github.com/SonarSource/sonar-java/commit/ef46538260bb2d5250c20d08981c9bd331bc8e8b", "message": "Fix errors in the parser discovered while testing\n\nMost notably this fixes the precedence of sequences vs. the repetition\noperator (meaning PlainTextTree is now PlainCharacterTree because it\ncan't contain more than one character); inverts the result of\n`isPlainTextCharacter` to actually be correct; amends the list of\nnon-plain-text-characters and properly handles the index going out of\nbounds.", "committedDate": "2020-05-28T14:05:55Z", "type": "commit"}, {"oid": "88bbcca56739540e73b5e2772a6711a032f20a58", "url": "https://github.com/SonarSource/sonar-java/commit/88bbcca56739540e73b5e2772a6711a032f20a58", "message": "Fix error in index-range-to-location translation", "committedDate": "2020-05-28T15:16:01Z", "type": "commit"}, {"oid": "b35a2678e04b6223daf6d8296109b4b8429a95f6", "url": "https://github.com/SonarSource/sonar-java/commit/b35a2678e04b6223daf6d8296109b4b8429a95f6", "message": "Implement equality for index ranges for easier testing", "committedDate": "2020-05-28T15:16:39Z", "type": "commit"}, {"oid": "a7fe0dbfb0462445713bcae6aa37515a19a7bbdc", "url": "https://github.com/SonarSource/sonar-java/commit/a7fe0dbfb0462445713bcae6aa37515a19a7bbdc", "message": "Add parser tests", "committedDate": "2020-05-28T15:19:24Z", "type": "commit"}, {"oid": "a7fe0dbfb0462445713bcae6aa37515a19a7bbdc", "url": "https://github.com/SonarSource/sonar-java/commit/a7fe0dbfb0462445713bcae6aa37515a19a7bbdc", "message": "Add parser tests", "committedDate": "2020-05-28T15:19:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1MDM4NA==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431950384", "body": "This merging can only work if the IndexRange given as argument is AFTER this IndexRange. Could it be done the other way or by construction we will always call it correctly?", "bodyText": "This merging can only work if the IndexRange given as argument is AFTER this IndexRange. Could it be done the other way or by construction we will always call it correctly?", "bodyHTML": "<p dir=\"auto\">This merging can only work if the IndexRange given as argument is AFTER this IndexRange. Could it be done the other way or by construction we will always call it correctly?</p>", "author": "m-g-sonar", "createdAt": "2020-05-28T16:02:30Z", "path": "java-frontend/src/main/java/org/sonar/java/regex/ast/IndexRange.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.regex.ast;\n+\n+import java.util.Objects;\n+\n+public class IndexRange {\n+\n+  private final int beginningOffset;\n+  private final int endingOffset;\n+\n+  public IndexRange(int beginningOffset, int endingOffset) {\n+    this.beginningOffset = beginningOffset;\n+    this.endingOffset = endingOffset;\n+  }\n+\n+  public int getBeginningOffset() {\n+    return beginningOffset;\n+  }\n+\n+  public int getEndingOffset() {\n+    return endingOffset;\n+  }\n+\n+  public IndexRange merge(IndexRange other) {\n+    return new IndexRange(beginningOffset, other.endingOffset);", "originalCommit": "a7fe0dbfb0462445713bcae6aa37515a19a7bbdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1NTM0Ng==", "url": "https://github.com/SonarSource/sonar-java/pull/2969#discussion_r431955346", "bodyText": "Barring bugs in the parser, it should only ever be called with the earlier index range first. It might be a good idea to verify this and throw an InvalidArgumentException otherwise though.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-05-28T16:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk1MDM4NA=="}], "type": "inlineReview"}, {"oid": "787fb066596e1038b2866ba58203ebb5ea8467c1", "url": "https://github.com/SonarSource/sonar-java/commit/787fb066596e1038b2866ba58203ebb5ea8467c1", "message": "Separate regex parser tests into multiple classes", "committedDate": "2020-05-29T11:55:23Z", "type": "commit"}, {"oid": "9f07df79d0c18acbec7f236198efca2fa8c6f5a2", "url": "https://github.com/SonarSource/sonar-java/commit/9f07df79d0c18acbec7f236198efca2fa8c6f5a2", "message": "Make SyntaxErrors contain a RegexToken object\n\nOtherwise we'd have nothing to pass to `reportIssue`.", "committedDate": "2020-05-29T12:40:02Z", "type": "commit"}, {"oid": "e2ba1af9fb4bdd4cae73be66c1ab0a2e08a420d3", "url": "https://github.com/SonarSource/sonar-java/commit/e2ba1af9fb4bdd4cae73be66c1ab0a2e08a420d3", "message": "Add more tests for syntax errors and improve error messages\n\nAlso fix possible exception when trying to report an error at the end\nof the regular expression", "committedDate": "2020-05-29T13:09:38Z", "type": "commit"}]}