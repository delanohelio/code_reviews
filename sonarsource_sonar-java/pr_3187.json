{"pr_number": 3187, "pr_title": "Fix FP for Serializable with initializer", "pr_author": "margarita-nedzelska-sonarsource", "pr_createdAt": "2020-09-16T15:59:02Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3187", "timeline": [{"oid": "e7c59e3b28a9e7fdca76f6d440865475cd95598a", "url": "https://github.com/SonarSource/sonar-java/commit/e7c59e3b28a9e7fdca76f6d440865475cd95598a", "message": "Refactoring", "committedDate": "2020-09-17T15:16:06Z", "type": "forcePushed"}, {"oid": "0110047e75ceb77e4275d0dfa68c460e69eec0eb", "url": "https://github.com/SonarSource/sonar-java/commit/0110047e75ceb77e4275d0dfa68c460e69eec0eb", "message": "SONARJAVA-3504 FP on S1948 for fields having non-serializable interface as type but serializable type as initializer", "committedDate": "2020-09-17T15:23:47Z", "type": "forcePushed"}, {"oid": "5761ef075de64681ebbf56e4da0a64f240828b20", "url": "https://github.com/SonarSource/sonar-java/commit/5761ef075de64681ebbf56e4da0a64f240828b20", "message": "SONARJAVA-3504 FP on S1948 for fields having non-serializable interface as type but serializable type as initializer", "committedDate": "2020-09-17T15:56:36Z", "type": "forcePushed"}, {"oid": "7e7ff23d933c77ca1e406695988b6e3c8c96b65d", "url": "https://github.com/SonarSource/sonar-java/commit/7e7ff23d933c77ca1e406695988b6e3c8c96b65d", "message": "SONARJAVA-3504 FP on S1948 for fields having non-serializable interface as type but serializable type as initializer", "committedDate": "2020-09-17T16:05:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczMDI3Ng==", "url": "https://github.com/SonarSource/sonar-java/pull/3187#discussion_r490730276", "body": "To answer your question, I believe we should not report Issues for lines with `@EJB` or `@Inject` if bytecode is incomplete.\r\n\r\nThere is however an easy way to cover this, we simply have to check if there is any unknown annotation. To do so, I would simply modify method `isTransientSerializableOrInjected` as follow:\r\n\r\n```java\r\nprivate static boolean isTransientSerializableOrInjected(VariableTree member) {\r\n    if (ModifiersUtils.hasModifier(member.modifiers(), Modifier.TRANSIENT) || (isSerializable(member.type()) && !isSubtypeOfCollectionApi(member.type().symbolType()))) {\r\n      return true;\r\n    }\r\n    SymbolMetadata metadata = member.symbol().metadata();\r\n    return metadata.isAnnotatedWith(\"javax.inject.Inject\")\r\n      || metadata.isAnnotatedWith(\"javax.ejb.EJB\")\r\n      // we can not guarantee anything due to the presence of an unknown annotation\r\n      || metadata.annotations().stream().anyMatch(annotationInstance -> annotationInstance.symbol().isUnknown());\r\n  }\r\n```", "bodyText": "To answer your question, I believe we should not report Issues for lines with @EJB or @Inject if bytecode is incomplete.\nThere is however an easy way to cover this, we simply have to check if there is any unknown annotation. To do so, I would simply modify method isTransientSerializableOrInjected as follow:\nprivate static boolean isTransientSerializableOrInjected(VariableTree member) {\n    if (ModifiersUtils.hasModifier(member.modifiers(), Modifier.TRANSIENT) || (isSerializable(member.type()) && !isSubtypeOfCollectionApi(member.type().symbolType()))) {\n      return true;\n    }\n    SymbolMetadata metadata = member.symbol().metadata();\n    return metadata.isAnnotatedWith(\"javax.inject.Inject\")\n      || metadata.isAnnotatedWith(\"javax.ejb.EJB\")\n      // we can not guarantee anything due to the presence of an unknown annotation\n      || metadata.annotations().stream().anyMatch(annotationInstance -> annotationInstance.symbol().isUnknown());\n  }", "bodyHTML": "<p dir=\"auto\">To answer your question, I believe we should not report Issues for lines with <code>@EJB</code> or <code>@Inject</code> if bytecode is incomplete.</p>\n<p dir=\"auto\">There is however an easy way to cover this, we simply have to check if there is any unknown annotation. To do so, I would simply modify method <code>isTransientSerializableOrInjected</code> as follow:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"private static boolean isTransientSerializableOrInjected(VariableTree member) {\n    if (ModifiersUtils.hasModifier(member.modifiers(), Modifier.TRANSIENT) || (isSerializable(member.type()) &amp;&amp; !isSubtypeOfCollectionApi(member.type().symbolType()))) {\n      return true;\n    }\n    SymbolMetadata metadata = member.symbol().metadata();\n    return metadata.isAnnotatedWith(&quot;javax.inject.Inject&quot;)\n      || metadata.isAnnotatedWith(&quot;javax.ejb.EJB&quot;)\n      // we can not guarantee anything due to the presence of an unknown annotation\n      || metadata.annotations().stream().anyMatch(annotationInstance -&gt; annotationInstance.symbol().isUnknown());\n  }\"><pre><span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">boolean</span> isTransientSerializableOrInjected(<span class=\"pl-smi\">VariableTree</span> member) {\n    <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">ModifiersUtils</span><span class=\"pl-k\">.</span>hasModifier(member<span class=\"pl-k\">.</span>modifiers(), <span class=\"pl-smi\">Modifier</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>TRANSIENT</span>) <span class=\"pl-k\">||</span> (isSerializable(member<span class=\"pl-k\">.</span>type()) <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span>isSubtypeOfCollectionApi(member<span class=\"pl-k\">.</span>type()<span class=\"pl-k\">.</span>symbolType()))) {\n      <span class=\"pl-k\">return</span> <span class=\"pl-c1\">true</span>;\n    }\n    <span class=\"pl-smi\">SymbolMetadata</span> metadata <span class=\"pl-k\">=</span> member<span class=\"pl-k\">.</span>symbol()<span class=\"pl-k\">.</span>metadata();\n    <span class=\"pl-k\">return</span> metadata<span class=\"pl-k\">.</span>isAnnotatedWith(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>javax.inject.Inject<span class=\"pl-pds\">\"</span></span>)\n      <span class=\"pl-k\">||</span> metadata<span class=\"pl-k\">.</span>isAnnotatedWith(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>javax.ejb.EJB<span class=\"pl-pds\">\"</span></span>)\n      <span class=\"pl-c\"><span class=\"pl-c\">//</span> we can not guarantee anything due to the presence of an unknown annotation</span>\n      <span class=\"pl-k\">||</span> metadata<span class=\"pl-k\">.</span>annotations()<span class=\"pl-k\">.</span>stream()<span class=\"pl-k\">.</span>anyMatch(annotationInstance <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> annotationInstance<span class=\"pl-k\">.</span>symbol()<span class=\"pl-k\">.</span>isUnknown());\n  }</pre></div>", "author": "m-g-sonar", "createdAt": "2020-09-18T06:31:29Z", "path": "java-checks/src/test/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheckTest.java", "diffHunk": "@@ -39,4 +39,13 @@ void test() {\n       .verifyIssues();\n   }\n \n+  @Test\n+  void testWithoutSemantic() {\n+    JavaCheckVerifier.newVerifier()\n+      .onFile(nonCompilingTestSourcesPath(\"checks/serialization/SerializableFieldInSerializableClassCheck.java\"))", "originalCommit": "7e7ff23d933c77ca1e406695988b6e3c8c96b65d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczNzIyNA==", "url": "https://github.com/SonarSource/sonar-java/pull/3187#discussion_r490737224", "bodyText": "Thanks. That helped me a lot :)", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-09-18T06:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczMDI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczMTk3NA==", "url": "https://github.com/SonarSource/sonar-java/pull/3187#discussion_r490731974", "body": "This is not a required change. Is it IntelliJ who suggests you to do it?\r\n\r\nOn this, We (as SonarSource) are not aligned with their definition of nullness. `Tree.Parent()` is annotated with `@Nullable`, which is a *weak* nullness annotation, contrarily to `@CheckForNull`. Here, it's the responsibility of the developer calling the method to know when it will be null or not, and it usually depends on very precise conditions, and it can not happen here. Our NPE detection rule is not raising any issue, and I believe we are right.\r\n\r\nCould you revert the change?", "bodyText": "This is not a required change. Is it IntelliJ who suggests you to do it?\nOn this, We (as SonarSource) are not aligned with their definition of nullness. Tree.Parent() is annotated with @Nullable, which is a weak nullness annotation, contrarily to @CheckForNull. Here, it's the responsibility of the developer calling the method to know when it will be null or not, and it usually depends on very precise conditions, and it can not happen here. Our NPE detection rule is not raising any issue, and I believe we are right.\nCould you revert the change?", "bodyHTML": "<p dir=\"auto\">This is not a required change. Is it IntelliJ who suggests you to do it?</p>\n<p dir=\"auto\">On this, We (as SonarSource) are not aligned with their definition of nullness. <code>Tree.Parent()</code> is annotated with <code>@Nullable</code>, which is a <em>weak</em> nullness annotation, contrarily to <code>@CheckForNull</code>. Here, it's the responsibility of the developer calling the method to know when it will be null or not, and it usually depends on very precise conditions, and it can not happen here. Our NPE detection rule is not raising any issue, and I believe we are right.</p>\n<p dir=\"auto\">Could you revert the change?</p>", "author": "m-g-sonar", "createdAt": "2020-09-18T06:36:08Z", "path": "java-checks/src/main/java/org/sonar/java/checks/serialization/SerializableFieldInSerializableClassCheck.java", "diffHunk": "@@ -94,7 +95,7 @@ private static boolean isUnserializableCollection(Type type) {\n   private void checkCollectionAssignments(List<IdentifierTree> usages) {\n     for (IdentifierTree usage : usages) {\n       Tree parentTree = usage.parent();\n-      if (parentTree.is(Tree.Kind.ASSIGNMENT)) {\n+      if (Objects.requireNonNull(parentTree).is(Tree.Kind.ASSIGNMENT)) {", "originalCommit": "7e7ff23d933c77ca1e406695988b6e3c8c96b65d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cd05b4de88ee866bdb0b2655031de216c84851f0", "url": "https://github.com/SonarSource/sonar-java/commit/cd05b4de88ee866bdb0b2655031de216c84851f0", "message": "SONARJAVA-3504 FP on S1948 for fields having non-serializable interface as type but serializable type as initializer", "committedDate": "2020-09-18T06:54:51Z", "type": "forcePushed"}, {"oid": "3e21d4b18b7e26b7b01c73616a567474fc825936", "url": "https://github.com/SonarSource/sonar-java/commit/3e21d4b18b7e26b7b01c73616a567474fc825936", "message": "SONARJAVA-3504 FP on S1948 for fields having non-serializable interface as type but serializable type as initializer", "committedDate": "2020-09-18T07:18:15Z", "type": "commit"}, {"oid": "3e21d4b18b7e26b7b01c73616a567474fc825936", "url": "https://github.com/SonarSource/sonar-java/commit/3e21d4b18b7e26b7b01c73616a567474fc825936", "message": "SONARJAVA-3504 FP on S1948 for fields having non-serializable interface as type but serializable type as initializer", "committedDate": "2020-09-18T07:18:15Z", "type": "forcePushed"}]}