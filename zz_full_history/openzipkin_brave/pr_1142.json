{"pr_number": 1142, "pr_title": "Prepares for dynamic baggage and fixes broken OSGi config", "pr_author": "codefromthecrypt", "pr_createdAt": "2020-04-05T13:15:56Z", "pr_url": "https://github.com/openzipkin/brave/pull/1142", "timeline": [{"oid": "cc91a08a49a25d5e34192b00f7826bc990054afe", "url": "https://github.com/openzipkin/brave/commit/cc91a08a49a25d5e34192b00f7826bc990054afe", "message": "Prepares for dynamic baggage\n\nThis refactors internal code around baggage so that it can handle\ndynamic baggage in a single propagated field. This also removes unused\ntag parsing logic in gRPC as we no longer mutate tags.\n\n`BaggageState` is the entry in `TraceContext.extra()` that holds all\nbaggage, whether they are fixed or not. `BaggageStateHandler` is given\none slot and currently uses one slot per `BaggageField`. However,\n`DynamicBaggageStateHandler` shows we can do multiple fields in one\nslot, just we aren't doing that yet as we need to define an encoding.", "committedDate": "2020-04-05T13:12:00Z", "type": "commit"}, {"oid": "1a5eacafe835565ca2b6884f75387ac8675a40b5", "url": "https://github.com/openzipkin/brave/commit/1a5eacafe835565ca2b6884f75387ac8675a40b5", "message": "Update instrumentation/grpc/src/main/java/brave/grpc/GrpcPropagation.java", "committedDate": "2020-04-05T13:19:44Z", "type": "commit"}, {"oid": "3ba960fc3885aa9543b39d804438e02ad514f7bb", "url": "https://github.com/openzipkin/brave/commit/3ba960fc3885aa9543b39d804438e02ad514f7bb", "message": "Update instrumentation/grpc/src/main/java/brave/grpc/HexBinaryMarshaller.java", "committedDate": "2020-04-05T13:22:27Z", "type": "commit"}, {"oid": "aa23f3e7864a8172fadbc69571ef27724dc4dbab", "url": "https://github.com/openzipkin/brave/commit/aa23f3e7864a8172fadbc69571ef27724dc4dbab", "message": "dramatically simplify grpc tags forwarding", "committedDate": "2020-04-06T00:31:59Z", "type": "commit"}, {"oid": "9ff95acd313ae3166e63c89a248df360470fd13c", "url": "https://github.com/openzipkin/brave/commit/9ff95acd313ae3166e63c89a248df360470fd13c", "message": "rename", "committedDate": "2020-04-06T00:32:41Z", "type": "commit"}, {"oid": "08f8e63b017be9e45b30f0cb979061f0b9a723db", "url": "https://github.com/openzipkin/brave/commit/08f8e63b017be9e45b30f0cb979061f0b9a723db", "message": "reflection drift", "committedDate": "2020-04-06T01:05:54Z", "type": "commit"}, {"oid": "6960dd36e4c2bafda42b0be407e478f8022a353f", "url": "https://github.com/openzipkin/brave/commit/6960dd36e4c2bafda42b0be407e478f8022a353f", "message": "cleans up naming and fixes OSGi glitch", "committedDate": "2020-04-06T01:19:09Z", "type": "commit"}, {"oid": "5b9649799ead8e456836b27a3289b4812403b220", "url": "https://github.com/openzipkin/brave/commit/5b9649799ead8e456836b27a3289b4812403b220", "message": "polish", "committedDate": "2020-04-06T01:23:03Z", "type": "commit"}, {"oid": "21ec2224cdd94a5faf267eba693ffd0115f85911", "url": "https://github.com/openzipkin/brave/commit/21ec2224cdd94a5faf267eba693ffd0115f85911", "message": "restores getAllFields performance for base case", "committedDate": "2020-04-06T02:04:33Z", "type": "commit"}, {"oid": "d2de9c37599cb86f077ef3a13072a30d6d603f6a", "url": "https://github.com/openzipkin/brave/commit/d2de9c37599cb86f077ef3a13072a30d6d603f6a", "message": "Improves example", "committedDate": "2020-04-06T02:14:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc5ODY1NQ==", "url": "https://github.com/openzipkin/brave/pull/1142#discussion_r403798655", "body": "`Collections.emptyMap`? Otherwise the interface needs to be updated to have a `@Nullable` return with what it means, but empty map seems simpler without any overhead.", "bodyText": "Collections.emptyMap? Otherwise the interface needs to be updated to have a @Nullable return with what it means, but empty map seems simpler without any overhead.", "bodyHTML": "<p dir=\"auto\"><code>Collections.emptyMap</code>? Otherwise the interface needs to be updated to have a <code>@Nullable</code> return with what it means, but empty map seems simpler without any overhead.</p>", "author": "anuraaga", "createdAt": "2020-04-06T02:22:09Z", "path": "brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.baggage;\n+\n+import brave.baggage.BaggageField;\n+import brave.internal.Nullable;\n+import brave.internal.baggage.BaggageHandler;\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import org.apache.logging.log4j.core.util.StringBuilderWriter;\n+\n+import static com.google.common.base.Objects.equal;\n+\n+/** This accepts any keys, but only writes to one propagation field. */\n+final class DynamicBaggageHandler implements BaggageHandler<Map<BaggageField, String>> {\n+  @Override public boolean isDynamic() {\n+    return true;\n+  }\n+\n+  @Override public List<BaggageField> currentFields(@Nullable Map<BaggageField, String> state) {\n+    if (state == null) return Collections.emptyList();\n+    return new ArrayList<>(state.keySet());\n+  }\n+\n+  @Override public boolean handlesField(BaggageField field) {\n+    return true; // grow indefinitely\n+  }\n+\n+  @Override public String getValue(BaggageField field, Map<BaggageField, String> state) {\n+    return state.get(field);\n+  }\n+\n+  @Override public Map<BaggageField, String> newState(BaggageField field, String value) {\n+    LinkedHashMap<BaggageField, String> newState = new LinkedHashMap<>();\n+    newState.put(field, value);\n+    return newState;\n+  }\n+\n+  @Override\n+  public Map<BaggageField, String> mergeState(Map<BaggageField, String> state, BaggageField field,\n+    String value) {\n+    if (equal(value, state.get(field))) return state;\n+    if (value == null) {\n+      if (!state.containsKey(field)) return state;\n+      if (state.size() == 1) return null;", "originalCommit": "21ec2224cdd94a5faf267eba693ffd0115f85911", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2Mjg4Ng==", "url": "https://github.com/openzipkin/brave/pull/1142#discussion_r407162886", "bodyText": "punted to #1153.. agree empty map doesn't have more overhead as the copy/constructor of LHM is cheap.  However, it does complicate the state model. let me know what you think..", "author": "codefromthecrypt", "createdAt": "2020-04-12T08:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc5ODY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "1f8da1ee15ef3227370c4377e05042b5b8e64bb3", "changed_code": [{"header": "diff --git a/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java b/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\nindex 0d25b759c..abd413081 100644\n--- a/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\n+++ b/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\n", "chunk": "@@ -62,13 +69,10 @@ final class DynamicBaggageHandler implements BaggageHandler<Map<BaggageField, St\n       if (state.size() == 1) return null;\n     }\n \n-    // Now we are updating. Either replace the entry or delete it\n+    // We replace an existing value with null instead of deleting it. This way we know there was\n+    // a field value at some point (ex for reverting state).\n     LinkedHashMap<BaggageField, String> mergedState = new LinkedHashMap<>(state);\n-    if (value != null) {\n-      mergedState.put(field, value);\n-    } else {\n-      mergedState.remove(field);\n-    }\n+    mergedState.put(field, value);\n     return mergedState;\n   }\n \n", "next_change": {"commit": "8c76d1cc5505ec0219d853a3bd39fd6c1a3004c4", "changed_code": [{"header": "diff --git a/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java b/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\nindex abd413081..e6c41520b 100644\n--- a/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\n+++ b/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\n", "chunk": "@@ -77,7 +77,7 @@ final class DynamicBaggageHandler implements BaggageHandler<Map<BaggageField, St\n   }\n \n   @Override\n-  public Map<BaggageField, String> fromRemoteValue(String encoded) {\n+  public Map<BaggageField, String> fromRequestValue(Object request, String encoded) {\n     Properties decoded = new Properties();\n     try {\n       decoded.load(new StringReader(encoded));\n", "next_change": {"commit": "4b7418de4fcbcde1c9e87220199c74c122f91e59", "changed_code": [{"header": "diff --git a/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java b/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\nindex e6c41520b..5cbc9a59a 100644\n--- a/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\n+++ b/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\n", "chunk": "@@ -77,7 +88,7 @@ final class DynamicBaggageHandler implements BaggageHandler<Map<BaggageField, St\n   }\n \n   @Override\n-  public Map<BaggageField, String> fromRequestValue(Object request, String encoded) {\n+  public Map<BaggageField, String> fromRemoteValue(Object request, String encoded) {\n     Properties decoded = new Properties();\n     try {\n       decoded.load(new StringReader(encoded));\n", "next_change": {"commit": "d7ee9db01909945c735e33f671ef3fa802a5442a", "changed_code": [{"header": "diff --git a/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java b/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\nindex 5cbc9a59a..26feef61f 100644\n--- a/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\n+++ b/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\n", "chunk": "@@ -87,30 +77,23 @@ final class DynamicBaggageHandler implements RemoteBaggageHandler<Map<BaggageFie\n     return mergedState;\n   }\n \n-  @Override\n-  public Map<BaggageField, String> fromRemoteValue(Object request, String encoded) {\n-    Properties decoded = new Properties();\n-    try {\n-      decoded.load(new StringReader(encoded));\n-    } catch (IOException e) {\n-      throw new AssertionError(e);\n-    }\n-\n+  @Override public <R> Map<BaggageField, String> decode(R request, String value) {\n     Map<BaggageField, String> result = new LinkedHashMap<>();\n-    for (Map.Entry<Object, Object> entry : decoded.entrySet()) {\n-      result.put(BaggageField.create(entry.getKey().toString()), entry.getValue().toString());\n+    for (String entry : value.split(\",\")) {\n+      String[] keyValue = entry.split(\"=\", 2);\n+      result.put(BaggageField.create(keyValue[0]), keyValue[1]);\n     }\n     return result;\n   }\n \n-  @Override public String toRemoteValue(Map<BaggageField, String> state) {\n-    Properties encoded = new Properties();\n-    state.forEach((f, v) -> encoded.put(f.name(), v));\n+  @Override\n+  public <R> String encode(Map<BaggageField, String> state, TraceContext context, R request) {\n     StringBuilder result = new StringBuilder();\n-    try {\n-      encoded.store(new StringBuilderWriter(result), \"\");\n-    } catch (IOException e) {\n-      throw new AssertionError(e);\n+    Iterator<Entry<BaggageField, String>> iterator = state.entrySet().iterator();\n+    while (iterator.hasNext()) {\n+      Entry<BaggageField, String> entry = iterator.next();\n+      result.append(entry.getKey().name()).append('=').append(entry.getValue());\n+      if (iterator.hasNext()) result.append(',');\n     }\n     return result.toString();\n   }\n", "next_change": {"commit": "9080e888fbd9d5b597156849d37f673b7630558e", "changed_code": [{"header": "diff --git a/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java b/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\ndeleted file mode 100644\nindex 26feef61f..000000000\n--- a/brave/src/test/java/brave/features/baggage/DynamicBaggageHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,100 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.features.baggage;\n-\n-import brave.baggage.BaggageField;\n-import brave.internal.Nullable;\n-import brave.internal.baggage.BaggageHandler;\n-import brave.internal.baggage.BaggageHandler.StateDecoder;\n-import brave.internal.baggage.BaggageHandler.StateEncoder;\n-import brave.propagation.TraceContext;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Objects;\n-\n-/**\n- * This accepts any fields, but only uses one remote value. This is an example, but not of good\n- * performance.\n- */\n-final class DynamicBaggageHandler implements BaggageHandler<Map<BaggageField, String>>,\n-    StateDecoder<Map<BaggageField, String>>, StateEncoder<Map<BaggageField, String>> {\n-  static final DynamicBaggageHandler INSTANCE = new DynamicBaggageHandler();\n-\n-  static DynamicBaggageHandler get() {\n-    return INSTANCE;\n-  }\n-\n-  DynamicBaggageHandler() {\n-  }\n-\n-  @Override public boolean isDynamic() {\n-    return true;\n-  }\n-\n-  @Override public List<BaggageField> currentFields(@Nullable Map<BaggageField, String> state) {\n-    if (state == null) return Collections.emptyList();\n-    return new ArrayList<>(state.keySet());\n-  }\n-\n-  @Override public boolean handlesField(BaggageField field) {\n-    return true; // grow indefinitely\n-  }\n-\n-  @Override public String getValue(BaggageField field, Map<BaggageField, String> state) {\n-    return state.get(field);\n-  }\n-\n-  @Override\n-  public Map<BaggageField, String> updateState(@Nullable Map<BaggageField, String> state,\n-      BaggageField field, @Nullable String value) {\n-    if (state == null) state = Collections.emptyMap();\n-    if (Objects.equals(value, state.get(field))) return state;\n-    if (value == null) {\n-      if (!state.containsKey(field)) return state;\n-      if (state.size() == 1) return Collections.emptyMap();\n-    }\n-\n-    // We replace an existing value with null instead of deleting it. This way we know there was\n-    // a field value at some point (ex for reverting state).\n-    LinkedHashMap<BaggageField, String> mergedState = new LinkedHashMap<>(state);\n-    mergedState.put(field, value);\n-    return mergedState;\n-  }\n-\n-  @Override public <R> Map<BaggageField, String> decode(R request, String value) {\n-    Map<BaggageField, String> result = new LinkedHashMap<>();\n-    for (String entry : value.split(\",\")) {\n-      String[] keyValue = entry.split(\"=\", 2);\n-      result.put(BaggageField.create(keyValue[0]), keyValue[1]);\n-    }\n-    return result;\n-  }\n-\n-  @Override\n-  public <R> String encode(Map<BaggageField, String> state, TraceContext context, R request) {\n-    StringBuilder result = new StringBuilder();\n-    Iterator<Entry<BaggageField, String>> iterator = state.entrySet().iterator();\n-    while (iterator.hasNext()) {\n-      Entry<BaggageField, String> entry = iterator.next();\n-      result.append(entry.getKey().name()).append('=').append(entry.getValue());\n-      if (iterator.hasNext()) result.append(',');\n-    }\n-    return result.toString();\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc5ODc4Mw==", "url": "https://github.com/openzipkin/brave/pull/1142#discussion_r403798783", "body": "Any reason not to use `updateState` like `updateValue`?", "bodyText": "Any reason not to use updateState like updateValue?", "bodyHTML": "<p dir=\"auto\">Any reason not to use <code>updateState</code> like <code>updateValue</code>?</p>", "author": "anuraaga", "createdAt": "2020-04-06T02:22:52Z", "path": "brave/src/main/java/brave/internal/baggage/BaggageHandler.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.baggage.BaggageField;\n+import brave.internal.Nullable;\n+import brave.propagation.Propagation;\n+import brave.propagation.TraceContext;\n+import brave.propagation.TraceContextOrSamplingFlags;\n+import java.util.List;\n+\n+/**\n+ * Handles context storage of one or more baggage fields using one {@link ExtraBaggageFields}\n+ * state.\n+ *\n+ * @param <S> the state that represents one or more baggage fields\n+ */\n+public interface BaggageHandler<S> {\n+  /**\n+   * When true, calls to {@link #currentFields(Object)} and {@link #handlesField(BaggageField)}\n+   * cannot be cached.\n+   */\n+  boolean isDynamic();\n+\n+  /** Don't cache if {@link #isDynamic()}. If not dynamic, the state parameter can be ignored. */\n+  List<BaggageField> currentFields(@Nullable S state);\n+\n+  /** Don't cache if {@link #isDynamic()}. */\n+  boolean handlesField(BaggageField field);\n+\n+  /**\n+   * Gets the value of this field in the given state.\n+   *\n+   * @see BaggageField#getValue(TraceContext)\n+   * @see BaggageField#getValue(TraceContextOrSamplingFlags)\n+   */\n+  @Nullable String getValue(BaggageField field, S state);\n+\n+  /**\n+   * Creates a state object to support the first field value.\n+   *\n+   * @see BaggageField#updateValue(TraceContext, String)\n+   * @see BaggageField#updateValue(TraceContextOrSamplingFlags, String)\n+   */\n+  S newState(BaggageField field, String value);\n+\n+  /**\n+   * Updates a state object to handle a field value change.\n+   *\n+   * @see BaggageField#updateValue(TraceContext, String)\n+   * @see BaggageField#updateValue(TraceContextOrSamplingFlags, String)\n+   */\n+  S mergeState(S state, BaggageField field, @Nullable String value);", "originalCommit": "d2de9c37599cb86f077ef3a13072a30d6d603f6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2MjkwNw==", "url": "https://github.com/openzipkin/brave/pull/1142#discussion_r407162907", "bodyText": "good!", "author": "codefromthecrypt", "createdAt": "2020-04-12T08:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc5ODc4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2f88ab096cb7459a1c6f0d119adab7f0a1a08b07", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/internal/baggage/BaggageHandler.java b/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\nindex 0089bf3e7..fd5002ab9 100644\n--- a/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\n+++ b/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\n", "chunk": "@@ -56,12 +56,18 @@ public interface BaggageHandler<S> {\n   S newState(BaggageField field, String value);\n \n   /**\n-   * Updates a state object to handle a field value change.\n+   * Updates a state object to include a value change.\n+   *\n+   * <p>When the value is {@code null} and the input only includes the given field, either {@code\n+   * null} or an appropriate empty sentinel value should be returned.\n+   *\n+   * <p>When {@code null} is returned, the next non-null update results in a call to {@link\n+   * #newState}. Otherwise, the empty state object will become the next input parameter here.\n    *\n    * @see BaggageField#updateValue(TraceContext, String)\n    * @see BaggageField#updateValue(TraceContextOrSamplingFlags, String)\n    */\n-  S mergeState(S state, BaggageField field, @Nullable String value);\n+  @Nullable S updateState(S state, BaggageField field, @Nullable String value);\n \n   /**\n    * Extracts any state from a remote value received by {@link Propagation.Getter#get(Object,\n", "next_change": {"commit": "8c76d1cc5505ec0219d853a3bd39fd6c1a3004c4", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/internal/baggage/BaggageHandler.java b/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\nindex fd5002ab9..f481b1ab6 100644\n--- a/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\n+++ b/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\n", "chunk": "@@ -70,22 +70,22 @@ public interface BaggageHandler<S> {\n   @Nullable S updateState(S state, BaggageField field, @Nullable String value);\n \n   /**\n-   * Extracts any state from a remote value received by {@link Propagation.Getter#get(Object,\n+   * Extracts any state from a request value received by {@link Propagation.Getter#get(Object,\n    * Object)}.\n    *\n-   * <p>Ex. When the state is a simple string, this will just use the remote value directly.\n+   * <p>Ex. When the state is a simple string, this will just use the request value directly.\n    * {@linkplain #isDynamic() Dynamic values} will need to perform some decoding, such as splitting\n    * on comma and equals.\n    */\n-  @Nullable S fromRemoteValue(String remoteValue);\n+  @Nullable S fromRequestValue(Object request, String value);\n \n   /**\n-   * Converts any state to a remote value used by {@link Propagation.Setter#put(Object, Object,\n+   * Converts any state to a request value used by {@link Propagation.Setter#put(Object, Object,\n    * String)}.\n    *\n    * <p>Ex. When the state is a simple string, this will just be returned with no change.\n    * {@linkplain #isDynamic() Dynamic values} will need to perform some encoding, such as joining on\n    * equals and comma.\n    */\n-  String toRemoteValue(S state);\n+  String toRequestValue(S state);\n }\n", "next_change": {"commit": "4b7418de4fcbcde1c9e87220199c74c122f91e59", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/internal/baggage/BaggageHandler.java b/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\nindex f481b1ab6..566ad681d 100644\n--- a/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\n+++ b/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\n", "chunk": "@@ -68,24 +67,4 @@ public interface BaggageHandler<S> {\n    * @see BaggageField#updateValue(TraceContextOrSamplingFlags, String)\n    */\n   @Nullable S updateState(S state, BaggageField field, @Nullable String value);\n-\n-  /**\n-   * Extracts any state from a request value received by {@link Propagation.Getter#get(Object,\n-   * Object)}.\n-   *\n-   * <p>Ex. When the state is a simple string, this will just use the request value directly.\n-   * {@linkplain #isDynamic() Dynamic values} will need to perform some decoding, such as splitting\n-   * on comma and equals.\n-   */\n-  @Nullable S fromRequestValue(Object request, String value);\n-\n-  /**\n-   * Converts any state to a request value used by {@link Propagation.Setter#put(Object, Object,\n-   * String)}.\n-   *\n-   * <p>Ex. When the state is a simple string, this will just be returned with no change.\n-   * {@linkplain #isDynamic() Dynamic values} will need to perform some encoding, such as joining on\n-   * equals and comma.\n-   */\n-  String toRequestValue(S state);\n }\n", "next_change": {"commit": "d7ee9db01909945c735e33f671ef3fa802a5442a", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/internal/baggage/BaggageHandler.java b/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\nindex 566ad681d..71a098cc6 100644\n--- a/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\n+++ b/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\n", "chunk": "@@ -41,30 +99,26 @@ public interface BaggageHandler<S> {\n   /**\n    * Gets the value of this field in the given state.\n    *\n+   * @see ExtraBaggageFields#getState(BaggageHandler)\n    * @see BaggageField#getValue(TraceContext)\n    * @see BaggageField#getValue(TraceContextOrSamplingFlags)\n    */\n   @Nullable String getValue(BaggageField field, S state);\n \n-  /**\n-   * Creates a state object to support the first field value.\n-   *\n-   * @see BaggageField#updateValue(TraceContext, String)\n-   * @see BaggageField#updateValue(TraceContextOrSamplingFlags, String)\n-   */\n-  S newState(BaggageField field, String value);\n-\n   /**\n    * Updates a state object to include a value change.\n    *\n    * <p>When the value is {@code null} and the input only includes the given field, either {@code\n    * null} or an appropriate empty sentinel value should be returned.\n    *\n-   * <p>When {@code null} is returned, the next non-null update results in a call to {@link\n-   * #newState}. Otherwise, the empty state object will become the next input parameter here.\n-   *\n+   * @param state {@code null} when there was formerly no state assigned to this handler\n+   * @param field the field that was updated\n+   * @param value {@code null} means remove the mapping to this field.\n+   * @return the possibly {@code null} value used as the {@code previous} parameter in the next call\n+   * to this method.\n+   * @see ExtraBaggageFields#putState(BaggageHandler, Object)\n    * @see BaggageField#updateValue(TraceContext, String)\n    * @see BaggageField#updateValue(TraceContextOrSamplingFlags, String)\n    */\n-  @Nullable S updateState(S state, BaggageField field, @Nullable String value);\n+  @Nullable S updateState(@Nullable S state, BaggageField field, @Nullable String value);\n }\n", "next_change": {"commit": "9080e888fbd9d5b597156849d37f673b7630558e", "changed_code": [{"header": "diff --git a/brave/src/main/java/brave/internal/baggage/BaggageHandler.java b/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\ndeleted file mode 100644\nindex 71a098cc6..000000000\n--- a/brave/src/main/java/brave/internal/baggage/BaggageHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,124 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.internal.baggage;\n-\n-import brave.baggage.BaggageField;\n-import brave.baggage.BaggagePropagationConfig;\n-import brave.internal.Nullable;\n-import brave.propagation.Propagation.Getter;\n-import brave.propagation.Propagation.Setter;\n-import brave.propagation.TraceContext;\n-import brave.propagation.TraceContext.Extractor;\n-import brave.propagation.TraceContext.Injector;\n-import brave.propagation.TraceContextOrSamplingFlags;\n-import java.util.List;\n-\n-/**\n- * Handles context storage of one or more baggage values using a single {@linkplain #<S> state\n- * value}. This is configured with {@link ExtraBaggageFields#newFactory(List)}.\n- *\n- * @param <S> the state that represents one or more baggage fields. <em>Note</em>: when {@link\n- * String} on a single field handler, {@code null} should reflect empty state, as empty string (\"\")\n- * is a valid baggage field value.\n- */\n-public interface BaggageHandler<S> {\n-  StateDecoder<String> STRING_DECODER = new StateDecoder<String>() {\n-    @Override public <R> String decode(R request, String encoded) {\n-      return encoded;\n-    }\n-  };\n-  StateEncoder<String> STRING_ENCODER = new StateEncoder<String>() {\n-    @Override public <R> String encode(String state, TraceContext context, R request) {\n-      return state;\n-    }\n-  };\n-\n-  /** @param <S> Same as {@link BaggageHandler#<S>} */\n-  interface StateDecoder<S> {\n-    /**\n-     * Called on the first non-{@code null} value from an {@link BaggagePropagationConfig#extractKeyNames()\n-     * extract key}. Decodes any field state from an extracted value or returns {@code null} if\n-     * there were none.\n-     *\n-     * <p>Ex. When the state is a simple string, this will just use the request value directly.\n-     * {@linkplain BaggageHandler#isDynamic() Dynamic values} will need to perform some decoding,\n-     * such as splitting on comma and equals.\n-     *\n-     * @param <R> the parameter from {@link Extractor#<R>}\n-     * @param request the parameter from {@link Extractor#extract(Object)}\n-     * @param encoded a non-{@code null} result of {@link Getter#get(Object, Object)}\n-     * @return the possibly {@code null} state to that will be assigned via {@link\n-     * ExtraBaggageFields#putState(BaggageHandler, Object)}\n-     * @see BaggagePropagationConfig#extractKeyNames()\n-     */\n-    @Nullable <R> S decode(R request, String encoded);\n-  }\n-\n-  /** @param <S> Same as {@link BaggageHandler#<S>} */\n-  interface StateEncoder<S> {\n-    /**\n-     * Encodes any state to a request value used by {@link Setter#put(Object, Object, String)}. When\n-     * not {@code null}, the value will be used for all {@link BaggagePropagationConfig#injectKeyNames()}.\n-     *\n-     * <p>Ex. When the {@code state} is a simple string, this will just be returned with no change.\n-     * {@linkplain BaggageHandler#isDynamic() Dynamic values} will need to perform some encoding,\n-     * such as joining on equals and comma.\n-     *\n-     * @param <R> the parameter from {@link Injector#<R>}\n-     * @param state state returned by {@link ExtraBaggageFields#getState(BaggageHandler)}\n-     * @param request the parameter from {@link Injector#inject(TraceContext, Object)}\n-     * @return an input to {@link Setter#put(Object, Object, String)}\n-     * @see BaggagePropagationConfig#injectKeyNames()\n-     */\n-    @Nullable <R> String encode(S state, TraceContext context, R request);\n-  }\n-\n-  /**\n-   * When true, calls to {@link #currentFields(Object)} and {@link #handlesField(BaggageField)}\n-   * cannot be cached.\n-   */\n-  boolean isDynamic();\n-\n-  /** Don't cache if {@link #isDynamic()}. If not dynamic, the state parameter can be ignored. */\n-  List<BaggageField> currentFields(@Nullable S state);\n-\n-  /** Don't cache if {@link #isDynamic()}. */\n-  boolean handlesField(BaggageField field);\n-\n-  /**\n-   * Gets the value of this field in the given state.\n-   *\n-   * @see ExtraBaggageFields#getState(BaggageHandler)\n-   * @see BaggageField#getValue(TraceContext)\n-   * @see BaggageField#getValue(TraceContextOrSamplingFlags)\n-   */\n-  @Nullable String getValue(BaggageField field, S state);\n-\n-  /**\n-   * Updates a state object to include a value change.\n-   *\n-   * <p>When the value is {@code null} and the input only includes the given field, either {@code\n-   * null} or an appropriate empty sentinel value should be returned.\n-   *\n-   * @param state {@code null} when there was formerly no state assigned to this handler\n-   * @param field the field that was updated\n-   * @param value {@code null} means remove the mapping to this field.\n-   * @return the possibly {@code null} value used as the {@code previous} parameter in the next call\n-   * to this method.\n-   * @see ExtraBaggageFields#putState(BaggageHandler, Object)\n-   * @see BaggageField#updateValue(TraceContext, String)\n-   * @see BaggageField#updateValue(TraceContextOrSamplingFlags, String)\n-   */\n-  @Nullable S updateState(@Nullable S state, BaggageField field, @Nullable String value);\n-}\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc5OTQ3OQ==", "url": "https://github.com/openzipkin/brave/pull/1142#discussion_r403799479", "body": "Guessing you'll replace the properties load with this later but maybe add a TODO", "bodyText": "Guessing you'll replace the properties load with this later but maybe add a TODO", "bodyHTML": "<p dir=\"auto\">Guessing you'll replace the properties load with this later but maybe add a TODO</p>", "author": "anuraaga", "createdAt": "2020-04-06T02:26:20Z", "path": "brave/src/test/java/brave/internal/baggage/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string trimming optional whitespace (OWS)\n+ * before or after delimiters.\n+ */\n+public final class EntrySplitter {", "originalCommit": "d2de9c37599cb86f077ef3a13072a30d6d603f6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2MDU0NQ==", "url": "https://github.com/openzipkin/brave/pull/1142#discussion_r407160545", "bodyText": "4680f9f", "author": "codefromthecrypt", "createdAt": "2020-04-12T07:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc5OTQ3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "4680f9f273a0ff70b3eae31340abc115bf04fb8f", "changed_code": [{"header": "diff --git a/brave/src/test/java/brave/internal/baggage/EntrySplitter.java b/brave/src/test/java/brave/internal/baggage/EntrySplitter.java\ndeleted file mode 100644\nindex e339ac51d..000000000\n--- a/brave/src/test/java/brave/internal/baggage/EntrySplitter.java\n+++ /dev/null\n", "chunk": "@@ -1,92 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.internal.baggage;\n-\n-import brave.internal.Platform;\n-\n-/**\n- * Splits a character sequence that's in a delimited string trimming optional whitespace (OWS)\n- * before or after delimiters.\n- */\n-public final class EntrySplitter {\n-  static final EntrySplitter INSTANCE = new EntrySplitter('=', ',');\n-\n-  public static EntrySplitter get() {\n-    return INSTANCE;\n-  }\n-\n-  public static EntrySplitter create(char keyValueSeparator, char entrySeparator) {\n-    return new EntrySplitter(keyValueSeparator, entrySeparator);\n-  }\n-\n-  interface Handler {\n-    boolean onEntry(CharSequence buffer, int beginName, int endName, int beginValue, int endValue);\n-  }\n-\n-  final int keyValueSeparator, entrySeparator;\n-  final String missingKeyValueSeparator;\n-\n-  EntrySplitter(int keyValueSeparator, int entrySeparator) {\n-    this.keyValueSeparator = keyValueSeparator;\n-    this.entrySeparator = entrySeparator;\n-    this.missingKeyValueSeparator =\n-      \"Invalid input: missing '\" + keyValueSeparator + \"' between key and value\";\n-  }\n-\n-  public boolean parse(String buffer, Handler handler, boolean shouldThrow) {\n-    int i = 0, length = buffer.length();\n-    while (i < length) {\n-      if (isOWS(buffer.charAt(i++))) break; // skip whitespace\n-    }\n-\n-    if (i == length) return logOrThrow(\"Invalid input: only whitespace\", shouldThrow);\n-    if (buffer.charAt(i) == keyValueSeparator) {\n-      return logOrThrow(\"Invalid input: missing key\", shouldThrow);\n-    }\n-\n-    int beginName = i, endName = -1, beginValue = -1;\n-    while (i < length) {\n-      char c = buffer.charAt(i++);\n-      // OWS is zero or more spaces or tabs https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\n-      if (isOWS(c)) continue; // trim whitespace\n-\n-      if (c == keyValueSeparator) { // we reached a field name\n-        endName = i;\n-        if (++i == length) break; // skip '=' character\n-        beginValue = i;\n-      } else if (i == length || c == entrySeparator) { // we finished an entry\n-        if (beginValue == -1) return logOrThrow(missingKeyValueSeparator, shouldThrow);\n-\n-        int endValue = i == length ? i : i - 1;\n-        if (!handler.onEntry(buffer, beginName, endName, beginValue, endValue)) {\n-          return false; // assume handler logs\n-        }\n-        beginName = -1;\n-        endName = -1;\n-        beginValue = -1;\n-      }\n-    }\n-    return true;\n-  }\n-\n-  static boolean isOWS(char c) {\n-    return c == ' ' || c == '\\t';\n-  }\n-\n-  static boolean logOrThrow(String msg, boolean shouldThrow) {\n-    if (shouldThrow) throw new IllegalArgumentException(msg);\n-    Platform.get().log(msg, null);\n-    return false;\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc5OTkzOQ==", "url": "https://github.com/openzipkin/brave/pull/1142#discussion_r403799939", "body": "Think you may have intended to have the below comment here too, or only here since it's the first occurrence", "bodyText": "Think you may have intended to have the below comment here too, or only here since it's the first occurrence", "bodyHTML": "<p dir=\"auto\">Think you may have intended to have the below comment here too, or only here since it's the first occurrence</p>", "author": "anuraaga", "createdAt": "2020-04-06T02:28:40Z", "path": "brave/src/test/java/brave/internal/baggage/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string trimming optional whitespace (OWS)\n+ * before or after delimiters.\n+ */\n+public final class EntrySplitter {\n+  static final EntrySplitter INSTANCE = new EntrySplitter('=', ',');\n+\n+  public static EntrySplitter get() {\n+    return INSTANCE;\n+  }\n+\n+  public static EntrySplitter create(char keyValueSeparator, char entrySeparator) {\n+    return new EntrySplitter(keyValueSeparator, entrySeparator);\n+  }\n+\n+  interface Handler {\n+    boolean onEntry(CharSequence buffer, int beginName, int endName, int beginValue, int endValue);\n+  }\n+\n+  final int keyValueSeparator, entrySeparator;\n+  final String missingKeyValueSeparator;\n+\n+  EntrySplitter(int keyValueSeparator, int entrySeparator) {\n+    this.keyValueSeparator = keyValueSeparator;\n+    this.entrySeparator = entrySeparator;\n+    this.missingKeyValueSeparator =\n+      \"Invalid input: missing '\" + keyValueSeparator + \"' between key and value\";\n+  }\n+\n+  public boolean parse(String buffer, Handler handler, boolean shouldThrow) {\n+    int i = 0, length = buffer.length();\n+    while (i < length) {\n+      if (isOWS(buffer.charAt(i++))) break; // skip whitespace", "originalCommit": "d2de9c37599cb86f077ef3a13072a30d6d603f6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2MDQzNg==", "url": "https://github.com/openzipkin/brave/pull/1142#discussion_r407160436", "bodyText": "accident.. let's review properly when actually used", "author": "codefromthecrypt", "createdAt": "2020-04-12T07:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc5OTkzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "4680f9f273a0ff70b3eae31340abc115bf04fb8f", "changed_code": [{"header": "diff --git a/brave/src/test/java/brave/internal/baggage/EntrySplitter.java b/brave/src/test/java/brave/internal/baggage/EntrySplitter.java\ndeleted file mode 100644\nindex e339ac51d..000000000\n--- a/brave/src/test/java/brave/internal/baggage/EntrySplitter.java\n+++ /dev/null\n", "chunk": "@@ -1,92 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.internal.baggage;\n-\n-import brave.internal.Platform;\n-\n-/**\n- * Splits a character sequence that's in a delimited string trimming optional whitespace (OWS)\n- * before or after delimiters.\n- */\n-public final class EntrySplitter {\n-  static final EntrySplitter INSTANCE = new EntrySplitter('=', ',');\n-\n-  public static EntrySplitter get() {\n-    return INSTANCE;\n-  }\n-\n-  public static EntrySplitter create(char keyValueSeparator, char entrySeparator) {\n-    return new EntrySplitter(keyValueSeparator, entrySeparator);\n-  }\n-\n-  interface Handler {\n-    boolean onEntry(CharSequence buffer, int beginName, int endName, int beginValue, int endValue);\n-  }\n-\n-  final int keyValueSeparator, entrySeparator;\n-  final String missingKeyValueSeparator;\n-\n-  EntrySplitter(int keyValueSeparator, int entrySeparator) {\n-    this.keyValueSeparator = keyValueSeparator;\n-    this.entrySeparator = entrySeparator;\n-    this.missingKeyValueSeparator =\n-      \"Invalid input: missing '\" + keyValueSeparator + \"' between key and value\";\n-  }\n-\n-  public boolean parse(String buffer, Handler handler, boolean shouldThrow) {\n-    int i = 0, length = buffer.length();\n-    while (i < length) {\n-      if (isOWS(buffer.charAt(i++))) break; // skip whitespace\n-    }\n-\n-    if (i == length) return logOrThrow(\"Invalid input: only whitespace\", shouldThrow);\n-    if (buffer.charAt(i) == keyValueSeparator) {\n-      return logOrThrow(\"Invalid input: missing key\", shouldThrow);\n-    }\n-\n-    int beginName = i, endName = -1, beginValue = -1;\n-    while (i < length) {\n-      char c = buffer.charAt(i++);\n-      // OWS is zero or more spaces or tabs https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\n-      if (isOWS(c)) continue; // trim whitespace\n-\n-      if (c == keyValueSeparator) { // we reached a field name\n-        endName = i;\n-        if (++i == length) break; // skip '=' character\n-        beginValue = i;\n-      } else if (i == length || c == entrySeparator) { // we finished an entry\n-        if (beginValue == -1) return logOrThrow(missingKeyValueSeparator, shouldThrow);\n-\n-        int endValue = i == length ? i : i - 1;\n-        if (!handler.onEntry(buffer, beginName, endName, beginValue, endValue)) {\n-          return false; // assume handler logs\n-        }\n-        beginName = -1;\n-        endName = -1;\n-        beginValue = -1;\n-      }\n-    }\n-    return true;\n-  }\n-\n-  static boolean isOWS(char c) {\n-    return c == ' ' || c == '\\t';\n-  }\n-\n-  static boolean logOrThrow(String msg, boolean shouldThrow) {\n-    if (shouldThrow) throw new IllegalArgumentException(msg);\n-    Platform.get().log(msg, null);\n-    return false;\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzgwMDYyNw==", "url": "https://github.com/openzipkin/brave/pull/1142#discussion_r403800627", "body": "I think we need to only do this check when not inside a field or value, maybe not fields but presumably value should allow spaces.", "bodyText": "I think we need to only do this check when not inside a field or value, maybe not fields but presumably value should allow spaces.", "bodyHTML": "<p dir=\"auto\">I think we need to only do this check when not inside a field or value, maybe not fields but presumably value should allow spaces.</p>", "author": "anuraaga", "createdAt": "2020-04-06T02:31:59Z", "path": "brave/src/test/java/brave/internal/baggage/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string trimming optional whitespace (OWS)\n+ * before or after delimiters.\n+ */\n+public final class EntrySplitter {\n+  static final EntrySplitter INSTANCE = new EntrySplitter('=', ',');\n+\n+  public static EntrySplitter get() {\n+    return INSTANCE;\n+  }\n+\n+  public static EntrySplitter create(char keyValueSeparator, char entrySeparator) {\n+    return new EntrySplitter(keyValueSeparator, entrySeparator);\n+  }\n+\n+  interface Handler {\n+    boolean onEntry(CharSequence buffer, int beginName, int endName, int beginValue, int endValue);\n+  }\n+\n+  final int keyValueSeparator, entrySeparator;\n+  final String missingKeyValueSeparator;\n+\n+  EntrySplitter(int keyValueSeparator, int entrySeparator) {\n+    this.keyValueSeparator = keyValueSeparator;\n+    this.entrySeparator = entrySeparator;\n+    this.missingKeyValueSeparator =\n+      \"Invalid input: missing '\" + keyValueSeparator + \"' between key and value\";\n+  }\n+\n+  public boolean parse(String buffer, Handler handler, boolean shouldThrow) {\n+    int i = 0, length = buffer.length();\n+    while (i < length) {\n+      if (isOWS(buffer.charAt(i++))) break; // skip whitespace\n+    }\n+\n+    if (i == length) return logOrThrow(\"Invalid input: only whitespace\", shouldThrow);\n+    if (buffer.charAt(i) == keyValueSeparator) {\n+      return logOrThrow(\"Invalid input: missing key\", shouldThrow);\n+    }\n+\n+    int beginName = i, endName = -1, beginValue = -1;\n+    while (i < length) {\n+      char c = buffer.charAt(i++);\n+      // OWS is zero or more spaces or tabs https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\n+      if (isOWS(c)) continue; // trim whitespace", "originalCommit": "d2de9c37599cb86f077ef3a13072a30d6d603f6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE2MDM3Mw==", "url": "https://github.com/openzipkin/brave/pull/1142#discussion_r407160373", "bodyText": "sorry this type was not intended yet.. it isn't used.. let me delete and we can do a proper review later?", "author": "codefromthecrypt", "createdAt": "2020-04-12T07:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzgwMDYyNw=="}], "type": "inlineReview", "revised_code": {"commit": "4680f9f273a0ff70b3eae31340abc115bf04fb8f", "changed_code": [{"header": "diff --git a/brave/src/test/java/brave/internal/baggage/EntrySplitter.java b/brave/src/test/java/brave/internal/baggage/EntrySplitter.java\ndeleted file mode 100644\nindex e339ac51d..000000000\n--- a/brave/src/test/java/brave/internal/baggage/EntrySplitter.java\n+++ /dev/null\n", "chunk": "@@ -1,92 +0,0 @@\n-/*\n- * Copyright 2013-2020 The OpenZipkin Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n- * in compliance with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License\n- * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n- * or implied. See the License for the specific language governing permissions and limitations under\n- * the License.\n- */\n-package brave.internal.baggage;\n-\n-import brave.internal.Platform;\n-\n-/**\n- * Splits a character sequence that's in a delimited string trimming optional whitespace (OWS)\n- * before or after delimiters.\n- */\n-public final class EntrySplitter {\n-  static final EntrySplitter INSTANCE = new EntrySplitter('=', ',');\n-\n-  public static EntrySplitter get() {\n-    return INSTANCE;\n-  }\n-\n-  public static EntrySplitter create(char keyValueSeparator, char entrySeparator) {\n-    return new EntrySplitter(keyValueSeparator, entrySeparator);\n-  }\n-\n-  interface Handler {\n-    boolean onEntry(CharSequence buffer, int beginName, int endName, int beginValue, int endValue);\n-  }\n-\n-  final int keyValueSeparator, entrySeparator;\n-  final String missingKeyValueSeparator;\n-\n-  EntrySplitter(int keyValueSeparator, int entrySeparator) {\n-    this.keyValueSeparator = keyValueSeparator;\n-    this.entrySeparator = entrySeparator;\n-    this.missingKeyValueSeparator =\n-      \"Invalid input: missing '\" + keyValueSeparator + \"' between key and value\";\n-  }\n-\n-  public boolean parse(String buffer, Handler handler, boolean shouldThrow) {\n-    int i = 0, length = buffer.length();\n-    while (i < length) {\n-      if (isOWS(buffer.charAt(i++))) break; // skip whitespace\n-    }\n-\n-    if (i == length) return logOrThrow(\"Invalid input: only whitespace\", shouldThrow);\n-    if (buffer.charAt(i) == keyValueSeparator) {\n-      return logOrThrow(\"Invalid input: missing key\", shouldThrow);\n-    }\n-\n-    int beginName = i, endName = -1, beginValue = -1;\n-    while (i < length) {\n-      char c = buffer.charAt(i++);\n-      // OWS is zero or more spaces or tabs https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\n-      if (isOWS(c)) continue; // trim whitespace\n-\n-      if (c == keyValueSeparator) { // we reached a field name\n-        endName = i;\n-        if (++i == length) break; // skip '=' character\n-        beginValue = i;\n-      } else if (i == length || c == entrySeparator) { // we finished an entry\n-        if (beginValue == -1) return logOrThrow(missingKeyValueSeparator, shouldThrow);\n-\n-        int endValue = i == length ? i : i - 1;\n-        if (!handler.onEntry(buffer, beginName, endName, beginValue, endValue)) {\n-          return false; // assume handler logs\n-        }\n-        beginName = -1;\n-        endName = -1;\n-        beginValue = -1;\n-      }\n-    }\n-    return true;\n-  }\n-\n-  static boolean isOWS(char c) {\n-    return c == ' ' || c == '\\t';\n-  }\n-\n-  static boolean logOrThrow(String msg, boolean shouldThrow) {\n-    if (shouldThrow) throw new IllegalArgumentException(msg);\n-    Platform.get().log(msg, null);\n-    return false;\n-  }\n-}\n", "next_change": null}]}}]}