{"pr_number": 1818, "pr_title": "Fixes #1808 - Stop server side VM on Error in Thread", "pr_author": "dlmarion", "pr_createdAt": "2020-11-30T20:06:00Z", "pr_url": "https://github.com/apache/accumulo/pull/1818", "merge_commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "timeline": [{"oid": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "url": "https://github.com/apache/accumulo/commit/d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "message": "Fixes #1808 - Stop server side VM on Error in Thread\n\nModified the AccumuloUncaughtExceptionHandler to log Exception and\nError and Halt the VM if the system property HaltVMOnThreadError\nis set to true. Modified all Executors to use the NamingThreadFactory\nwhich uses AccumuloUncaughtExceptionHandler. When modifying\nSimpleTimer I found that some critical tasks could fail and only\nbe logged. Created SimpleCriticalTimer for the critical tasks.", "committedDate": "2020-11-30T20:00:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4MjI3NA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532882274", "body": "We don't need String.format here. The slf4j logger supports substitution with `{}`\r\n\r\n```suggestion\r\n        log.error(\"Caught an exception in {}.\", t, e);\r\n```", "bodyText": "We don't need String.format here. The slf4j logger supports substitution with {}\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    log.error(String.format(\"Caught an exception in %s.\", t), e);\n          \n          \n            \n                    log.error(\"Caught an exception in {}.\", t, e);", "bodyHTML": "<p dir=\"auto\">We don't need String.format here. The slf4j logger supports substitution with <code>{}</code></p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        log<span class=\"pl-k\">.</span>error(<span class=\"pl-smi x x-first\">String</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">format(</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Caught an exception in <span class=\"x x-first x-last\">%s</span>.<span class=\"pl-pds\">\"</span></span>, t<span class=\"x x-first x-last\">)</span>, e);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        log<span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Caught an exception in <span class=\"x x-first x-last\">{}</span>.<span class=\"pl-pds\">\"</span></span>, t, e);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ctubbsii", "createdAt": "2020-11-30T20:26:34Z", "path": "core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -26,10 +26,20 @@\n public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n   private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+    } else {\n+      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n+        log.error(String.format(\"Caught an exception in %s.\", t), e);", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0efa5901a38d42a1628fcbe8bd7cba46c9a0f8d0", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java b/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\nindex 428c2b1126..b1a9782095 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n", "chunk": "@@ -31,13 +31,13 @@ public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandle\n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n     if (e instanceof Exception) {\n-      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+      log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n     } else {\n       if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n-        log.error(String.format(\"Caught an exception in %s.\", t), e);\n+        log.error(\"Caught an exception in {}.\", t, e);\n         Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n       } else {\n-        log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+        log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n       }\n     }\n   }\n", "next_change": {"commit": "de1846bcd05b9d967b760146580fa8eadc4545e8", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java b/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\ndeleted file mode 100644\nindex b1a9782095..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,45 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.util;\n-\n-import java.lang.Thread.UncaughtExceptionHandler;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n-\n-  private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n-  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n-\n-  @Override\n-  public void uncaughtException(Thread t, Throwable e) {\n-    if (e instanceof Exception) {\n-      log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n-    } else {\n-      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n-        log.error(\"Caught an exception in {}.\", t, e);\n-        Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n-      } else {\n-        log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n-      }\n-    }\n-  }\n-\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java b/core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\nsimilarity index 58%\nrename from core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\nrename to core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\nindex 428c2b1126..a9c40040d2 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\n", "chunk": "@@ -16,30 +16,36 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.accumulo.core.util;\n+package org.apache.accumulo.core.util.threads;\n \n import java.lang.Thread.UncaughtExceptionHandler;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n+/**\n+ * UncaughtExceptionHandler that logs all Exceptions and Errors thrown from a Thread. If an Error is\n+ * thrown, halt the JVM.\n+ *\n+ */\n+class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n-  private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n-  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n+  private static final Logger LOG = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n     if (e instanceof Exception) {\n-      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n-    } else {\n-      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n-        log.error(String.format(\"Caught an exception in %s.\", t), e);\n-        Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n-      } else {\n-        log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+      LOG.error(\"Caught an Exception in {}. Thread is dead.\", t, e);\n+    } else if (e instanceof Error) {\n+      try {\n+        e.printStackTrace();\n+        System.err.println(\"Error thrown in thread: \" + t + \", halting VM.\");\n+      } catch (Throwable e1) {\n+        // If e == OutOfMemoryError, then it's probably that another Error might be\n+        // thrown when trying to print to System.err.\n+      } finally {\n+        Runtime.getRuntime().halt(-1);\n       }\n     }\n   }\n-\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4MzIyOQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532883229", "body": "```suggestion\r\n      log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n          \n          \n            \n                  log.error(\"Caught an exception in {}. Thread is dead.\", t, e);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      log<span class=\"pl-k\">.</span>error(<span class=\"pl-smi x x-first\">String</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">format(</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Caught an exception in <span class=\"x x-first x-last\">%s</span>. Thread is dead.<span class=\"pl-pds\">\"</span></span>, t<span class=\"x x-first x-last\">)</span>, e);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      log<span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Caught an exception in <span class=\"x x-first x-last\">{}</span>. Thread is dead.<span class=\"pl-pds\">\"</span></span>, t, e);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ctubbsii", "createdAt": "2020-11-30T20:28:27Z", "path": "core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -26,10 +26,20 @@\n public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n   private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0efa5901a38d42a1628fcbe8bd7cba46c9a0f8d0", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java b/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\nindex 428c2b1126..b1a9782095 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n", "chunk": "@@ -31,13 +31,13 @@ public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandle\n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n     if (e instanceof Exception) {\n-      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+      log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n     } else {\n       if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n-        log.error(String.format(\"Caught an exception in %s.\", t), e);\n+        log.error(\"Caught an exception in {}.\", t, e);\n         Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n       } else {\n-        log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+        log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n       }\n     }\n   }\n", "next_change": {"commit": "de1846bcd05b9d967b760146580fa8eadc4545e8", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java b/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\ndeleted file mode 100644\nindex b1a9782095..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,45 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.util;\n-\n-import java.lang.Thread.UncaughtExceptionHandler;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n-\n-  private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n-  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n-\n-  @Override\n-  public void uncaughtException(Thread t, Throwable e) {\n-    if (e instanceof Exception) {\n-      log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n-    } else {\n-      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n-        log.error(\"Caught an exception in {}.\", t, e);\n-        Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n-      } else {\n-        log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n-      }\n-    }\n-  }\n-\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java b/core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\nsimilarity index 58%\nrename from core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\nrename to core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\nindex 428c2b1126..a9c40040d2 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\n", "chunk": "@@ -16,30 +16,36 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.accumulo.core.util;\n+package org.apache.accumulo.core.util.threads;\n \n import java.lang.Thread.UncaughtExceptionHandler;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n+/**\n+ * UncaughtExceptionHandler that logs all Exceptions and Errors thrown from a Thread. If an Error is\n+ * thrown, halt the JVM.\n+ *\n+ */\n+class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n-  private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n-  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n+  private static final Logger LOG = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n     if (e instanceof Exception) {\n-      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n-    } else {\n-      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n-        log.error(String.format(\"Caught an exception in %s.\", t), e);\n-        Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n-      } else {\n-        log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+      LOG.error(\"Caught an Exception in {}. Thread is dead.\", t, e);\n+    } else if (e instanceof Error) {\n+      try {\n+        e.printStackTrace();\n+        System.err.println(\"Error thrown in thread: \" + t + \", halting VM.\");\n+      } catch (Throwable e1) {\n+        // If e == OutOfMemoryError, then it's probably that another Error might be\n+        // thrown when trying to print to System.err.\n+      } finally {\n+        Runtime.getRuntime().halt(-1);\n       }\n     }\n   }\n-\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4MzU3OQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532883579", "body": "```suggestion\r\n        log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n          \n          \n            \n                    log.error(\"Caught an exception in {}. Thread is dead.\", t, e);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        log<span class=\"pl-k\">.</span>error(<span class=\"pl-smi x x-first\">String</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">format(</span><span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Caught an exception in <span class=\"x x-first x-last\">%s</span>. Thread is dead.<span class=\"pl-pds\">\"</span></span>, t<span class=\"x x-first x-last\">)</span>, e);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        log<span class=\"pl-k\">.</span>error(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Caught an exception in <span class=\"x x-first x-last\">{}</span>. Thread is dead.<span class=\"pl-pds\">\"</span></span>, t, e);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ctubbsii", "createdAt": "2020-11-30T20:29:05Z", "path": "core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -26,10 +26,20 @@\n public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n   private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+    } else {\n+      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n+        log.error(String.format(\"Caught an exception in %s.\", t), e);\n+        Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n+      } else {\n+        log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0efa5901a38d42a1628fcbe8bd7cba46c9a0f8d0", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java b/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\nindex 428c2b1126..b1a9782095 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n", "chunk": "@@ -31,13 +31,13 @@ public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandle\n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n     if (e instanceof Exception) {\n-      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+      log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n     } else {\n       if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n-        log.error(String.format(\"Caught an exception in %s.\", t), e);\n+        log.error(\"Caught an exception in {}.\", t, e);\n         Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n       } else {\n-        log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+        log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n       }\n     }\n   }\n", "next_change": {"commit": "de1846bcd05b9d967b760146580fa8eadc4545e8", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java b/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\ndeleted file mode 100644\nindex b1a9782095..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n+++ /dev/null\n", "chunk": "@@ -1,45 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.util;\n-\n-import java.lang.Thread.UncaughtExceptionHandler;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n-\n-  private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n-  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n-\n-  @Override\n-  public void uncaughtException(Thread t, Throwable e) {\n-    if (e instanceof Exception) {\n-      log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n-    } else {\n-      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n-        log.error(\"Caught an exception in {}.\", t, e);\n-        Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n-      } else {\n-        log.error(\"Caught an exception in {}. Thread is dead.\", t, e);\n-      }\n-    }\n-  }\n-\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java b/core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\nsimilarity index 58%\nrename from core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\nrename to core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\nindex 428c2b1126..a9c40040d2 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\n", "chunk": "@@ -16,30 +16,36 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.accumulo.core.util;\n+package org.apache.accumulo.core.util.threads;\n \n import java.lang.Thread.UncaughtExceptionHandler;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n+/**\n+ * UncaughtExceptionHandler that logs all Exceptions and Errors thrown from a Thread. If an Error is\n+ * thrown, halt the JVM.\n+ *\n+ */\n+class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n-  private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n-  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n+  private static final Logger LOG = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n     if (e instanceof Exception) {\n-      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n-    } else {\n-      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n-        log.error(String.format(\"Caught an exception in %s.\", t), e);\n-        Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n-      } else {\n-        log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+      LOG.error(\"Caught an Exception in {}. Thread is dead.\", t, e);\n+    } else if (e instanceof Error) {\n+      try {\n+        e.printStackTrace();\n+        System.err.println(\"Error thrown in thread: \" + t + \", halting VM.\");\n+      } catch (Throwable e1) {\n+        // If e == OutOfMemoryError, then it's probably that another Error might be\n+        // thrown when trying to print to System.err.\n+      } finally {\n+        Runtime.getRuntime().halt(-1);\n       }\n     }\n   }\n-\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4NDk0Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532884946", "body": "What differentiates this from `SimpleTimer`? Could improve the javadoc here with a high-level explanation.", "bodyText": "What differentiates this from SimpleTimer? Could improve the javadoc here with a high-level explanation.", "bodyHTML": "<p dir=\"auto\">What differentiates this from <code>SimpleTimer</code>? Could improve the javadoc here with a high-level explanation.</p>", "author": "ctubbsii", "createdAt": "2020-11-30T20:31:37Z", "path": "server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.server.util.time;\n+\n+import java.lang.Thread.UncaughtExceptionHandler;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.AccumuloUncaughtExceptionHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic singleton timer for critical tasks.\n+ */\n+public class SimpleCriticalTimer extends SimpleTimer {", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0efa5901a38d42a1628fcbe8bd7cba46c9a0f8d0", "changed_code": [{"header": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java b/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java\nindex 1b77b34553..8c9aad5fb8 100644\n--- a/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java\n+++ b/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java\n", "chunk": "@@ -27,7 +27,8 @@ import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n- * Generic singleton timer for critical tasks.\n+ * Generic singleton timer for critical tasks. Overrides {@link #getUncaughtExceptionHandler()} to\n+ * use {@link AccumuloUncaughtExceptionHandler}\n  */\n public class SimpleCriticalTimer extends SimpleTimer {\n \n", "next_change": {"commit": "de1846bcd05b9d967b760146580fa8eadc4545e8", "changed_code": [{"header": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java b/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java\ndeleted file mode 100644\nindex 8c9aad5fb8..0000000000\n--- a/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java\n+++ /dev/null\n", "chunk": "@@ -1,88 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.server.util.time;\n-\n-import java.lang.Thread.UncaughtExceptionHandler;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.AccumuloUncaughtExceptionHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Generic singleton timer for critical tasks. Overrides {@link #getUncaughtExceptionHandler()} to\n- * use {@link AccumuloUncaughtExceptionHandler}\n- */\n-public class SimpleCriticalTimer extends SimpleTimer {\n-\n-  private static final Logger log = LoggerFactory.getLogger(SimpleCriticalTimer.class);\n-\n-  private static int instanceThreadPoolSize = -1;\n-  private static SimpleCriticalTimer instance;\n-\n-  /**\n-   * Gets the timer instance. If an instance has already been created, it will have the number of\n-   * threads supplied when it was constructed, and the size provided here is ignored.\n-   *\n-   * @param threadPoolSize\n-   *          number of threads\n-   */\n-  public static synchronized SimpleTimer getInstance(int threadPoolSize) {\n-    if (instance == null) {\n-      instance = new SimpleCriticalTimer(threadPoolSize);\n-      SimpleCriticalTimer.instanceThreadPoolSize = threadPoolSize;\n-    } else {\n-      if (SimpleCriticalTimer.instanceThreadPoolSize != threadPoolSize) {\n-        log.warn(\"Asked to create SimpleTimer with thread pool size {}, existing instance has {}\",\n-            threadPoolSize, instanceThreadPoolSize);\n-      }\n-    }\n-    return instance;\n-  }\n-\n-  /**\n-   * Gets the timer instance. If an instance has already been created, it will have the number of\n-   * threads supplied when it was constructed, and the size provided by the configuration here is\n-   * ignored. If a null configuration is supplied, the number of threads defaults to 1.\n-   *\n-   * @param conf\n-   *          configuration from which to get the number of threads\n-   * @see Property#GENERAL_SIMPLETIMER_THREADPOOL_SIZE\n-   */\n-  public static synchronized SimpleTimer getInstance(AccumuloConfiguration conf) {\n-    int threadPoolSize;\n-    if (conf != null) {\n-      threadPoolSize = conf.getCount(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    } else {\n-      threadPoolSize = DEFAULT_THREAD_POOL_SIZE;\n-    }\n-    return getInstance(threadPoolSize);\n-  }\n-\n-  protected SimpleCriticalTimer(int threadPoolSize) {\n-    super(threadPoolSize);\n-  }\n-\n-  @Override\n-  protected UncaughtExceptionHandler getUncaughtExceptionHandler() {\n-    return new AccumuloUncaughtExceptionHandler();\n-  }\n-\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java b/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java\ndeleted file mode 100644\nindex 1b77b34553..0000000000\n--- a/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java\n+++ /dev/null\n", "chunk": "@@ -1,87 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.server.util.time;\n-\n-import java.lang.Thread.UncaughtExceptionHandler;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.AccumuloUncaughtExceptionHandler;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Generic singleton timer for critical tasks.\n- */\n-public class SimpleCriticalTimer extends SimpleTimer {\n-\n-  private static final Logger log = LoggerFactory.getLogger(SimpleCriticalTimer.class);\n-\n-  private static int instanceThreadPoolSize = -1;\n-  private static SimpleCriticalTimer instance;\n-\n-  /**\n-   * Gets the timer instance. If an instance has already been created, it will have the number of\n-   * threads supplied when it was constructed, and the size provided here is ignored.\n-   *\n-   * @param threadPoolSize\n-   *          number of threads\n-   */\n-  public static synchronized SimpleTimer getInstance(int threadPoolSize) {\n-    if (instance == null) {\n-      instance = new SimpleCriticalTimer(threadPoolSize);\n-      SimpleCriticalTimer.instanceThreadPoolSize = threadPoolSize;\n-    } else {\n-      if (SimpleCriticalTimer.instanceThreadPoolSize != threadPoolSize) {\n-        log.warn(\"Asked to create SimpleTimer with thread pool size {}, existing instance has {}\",\n-            threadPoolSize, instanceThreadPoolSize);\n-      }\n-    }\n-    return instance;\n-  }\n-\n-  /**\n-   * Gets the timer instance. If an instance has already been created, it will have the number of\n-   * threads supplied when it was constructed, and the size provided by the configuration here is\n-   * ignored. If a null configuration is supplied, the number of threads defaults to 1.\n-   *\n-   * @param conf\n-   *          configuration from which to get the number of threads\n-   * @see Property#GENERAL_SIMPLETIMER_THREADPOOL_SIZE\n-   */\n-  public static synchronized SimpleTimer getInstance(AccumuloConfiguration conf) {\n-    int threadPoolSize;\n-    if (conf != null) {\n-      threadPoolSize = conf.getCount(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    } else {\n-      threadPoolSize = DEFAULT_THREAD_POOL_SIZE;\n-    }\n-    return getInstance(threadPoolSize);\n-  }\n-\n-  protected SimpleCriticalTimer(int threadPoolSize) {\n-    super(threadPoolSize);\n-  }\n-\n-  @Override\n-  protected UncaughtExceptionHandler getUncaughtExceptionHandler() {\n-    return new AccumuloUncaughtExceptionHandler();\n-  }\n-\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4NjkzNA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532886934", "body": "This is probably a little easier to read if you assign the ThreadFactory to a variable first, like the following (formatting probably isn't right):\r\n\r\n```suggestion\r\n    var threadFactory = new NamingThreadFactory(\"GatherTableInformation\");\r\n    ExecutorService tp = threads == 0\r\n        ? Executors.newCachedThreadPool(threadFactory)\r\n        : Executors.newFixedThreadPool(threads, threadFactory);\r\n```", "bodyText": "This is probably a little easier to read if you assign the ThreadFactory to a variable first, like the following (formatting probably isn't right):\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ExecutorService tp = threads == 0\n          \n          \n            \n                    ? Executors.newCachedThreadPool(new NamingThreadFactory(\"GatherTableInformation\"))\n          \n          \n            \n                    : Executors.newFixedThreadPool(threads, new NamingThreadFactory(\"GatherTableInformation\"));\n          \n          \n            \n                var threadFactory = new NamingThreadFactory(\"GatherTableInformation\");\n          \n          \n            \n                ExecutorService tp = threads == 0\n          \n          \n            \n                    ? Executors.newCachedThreadPool(threadFactory)\n          \n          \n            \n                    : Executors.newFixedThreadPool(threads, threadFactory);", "bodyHTML": "<p dir=\"auto\">This is probably a little easier to read if you assign the ThreadFactory to a variable first, like the following (formatting probably isn't right):</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-smi\">ExecutorService</span> tp <span class=\"pl-k\">=</span> threads <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">?</span> <span class=\"pl-smi\">Executors</span><span class=\"pl-k\">.</span>newCachedThreadPool(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">NamingThreadFactory</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>GatherTableInformation<span class=\"pl-pds\">\"</span></span>))</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">:</span> <span class=\"pl-smi\">Executors</span><span class=\"pl-k\">.</span>newFixedThreadPool(threads, <span class=\"pl-k\">new</span> <span class=\"pl-smi\">NamingThreadFactory</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>GatherTableInformation<span class=\"pl-pds\">\"</span></span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">var</span> threadFactory <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">NamingThreadFactory</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>GatherTableInformation<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-smi\">ExecutorService</span> tp <span class=\"pl-k\">=</span> threads <span class=\"pl-k\">==</span> <span class=\"pl-c1\">0</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">?</span> <span class=\"pl-smi\">Executors</span><span class=\"pl-k\">.</span>newCachedThreadPool(threadFactory)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">:</span> <span class=\"pl-smi\">Executors</span><span class=\"pl-k\">.</span>newFixedThreadPool(threads, threadFactory);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ctubbsii", "createdAt": "2020-11-30T20:35:32Z", "path": "server/manager/src/main/java/org/apache/accumulo/master/Master.java", "diffHunk": "@@ -884,8 +886,9 @@ private long balanceTablets() {\n       gatherTableInformation(Set<TServerInstance> currentServers) {\n     final long rpcTimeout = getConfiguration().getTimeInMillis(Property.GENERAL_RPC_TIMEOUT);\n     int threads = getConfiguration().getCount(Property.MASTER_STATUS_THREAD_POOL_SIZE);\n-    ExecutorService tp =\n-        threads == 0 ? Executors.newCachedThreadPool() : Executors.newFixedThreadPool(threads);\n+    ExecutorService tp = threads == 0\n+        ? Executors.newCachedThreadPool(new NamingThreadFactory(\"GatherTableInformation\"))\n+        : Executors.newFixedThreadPool(threads, new NamingThreadFactory(\"GatherTableInformation\"));", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0efa5901a38d42a1628fcbe8bd7cba46c9a0f8d0", "changed_code": [{"header": "diff --git a/server/manager/src/main/java/org/apache/accumulo/master/Master.java b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\nindex 858cb31f02..b0267392a1 100644\n--- a/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n+++ b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n", "chunk": "@@ -886,9 +886,9 @@ public class Master extends AbstractServer\n       gatherTableInformation(Set<TServerInstance> currentServers) {\n     final long rpcTimeout = getConfiguration().getTimeInMillis(Property.GENERAL_RPC_TIMEOUT);\n     int threads = getConfiguration().getCount(Property.MASTER_STATUS_THREAD_POOL_SIZE);\n-    ExecutorService tp = threads == 0\n-        ? Executors.newCachedThreadPool(new NamingThreadFactory(\"GatherTableInformation\"))\n-        : Executors.newFixedThreadPool(threads, new NamingThreadFactory(\"GatherTableInformation\"));\n+    var threadFactory = new NamingThreadFactory(\"GatherTableInformation\");\n+    ExecutorService tp = threads == 0 ? Executors.newCachedThreadPool(threadFactory)\n+        : Executors.newFixedThreadPool(threads, threadFactory);\n     long start = System.currentTimeMillis();\n     final SortedMap<TServerInstance,TabletServerStatus> result = new ConcurrentSkipListMap<>();\n     final RateLimiter shutdownServerRateLimiter = RateLimiter.create(MAX_SHUTDOWNS_PER_SEC);\n", "next_change": {"commit": "de1846bcd05b9d967b760146580fa8eadc4545e8", "changed_code": [{"header": "diff --git a/server/manager/src/main/java/org/apache/accumulo/master/Master.java b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\nindex b0267392a1..c5d582ca5c 100644\n--- a/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n+++ b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n", "chunk": "@@ -886,9 +884,8 @@ public class Master extends AbstractServer\n       gatherTableInformation(Set<TServerInstance> currentServers) {\n     final long rpcTimeout = getConfiguration().getTimeInMillis(Property.GENERAL_RPC_TIMEOUT);\n     int threads = getConfiguration().getCount(Property.MASTER_STATUS_THREAD_POOL_SIZE);\n-    var threadFactory = new NamingThreadFactory(\"GatherTableInformation\");\n-    ExecutorService tp = threads == 0 ? Executors.newCachedThreadPool(threadFactory)\n-        : Executors.newFixedThreadPool(threads, threadFactory);\n+    ExecutorService tp =\n+        ThreadPools.getExecutorService(getConfiguration(), Property.MASTER_STATUS_THREAD_POOL_SIZE);\n     long start = System.currentTimeMillis();\n     final SortedMap<TServerInstance,TabletServerStatus> result = new ConcurrentSkipListMap<>();\n     final RateLimiter shutdownServerRateLimiter = RateLimiter.create(MAX_SHUTDOWNS_PER_SEC);\n", "next_change": {"commit": "7957d8240581ce74a942c4858cf452bbb2067b90", "changed_code": [{"header": "diff --git a/server/manager/src/main/java/org/apache/accumulo/master/Master.java b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\nindex c5d582ca5c..f04fbcfe13 100644\n--- a/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n+++ b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n", "chunk": "@@ -884,8 +882,8 @@ public class Master extends AbstractServer\n       gatherTableInformation(Set<TServerInstance> currentServers) {\n     final long rpcTimeout = getConfiguration().getTimeInMillis(Property.GENERAL_RPC_TIMEOUT);\n     int threads = getConfiguration().getCount(Property.MASTER_STATUS_THREAD_POOL_SIZE);\n-    ExecutorService tp =\n-        ThreadPools.getExecutorService(getConfiguration(), Property.MASTER_STATUS_THREAD_POOL_SIZE);\n+    ExecutorService tp = ThreadPools.createExecutorService(getConfiguration(),\n+        Property.MASTER_STATUS_THREAD_POOL_SIZE);\n     long start = System.currentTimeMillis();\n     final SortedMap<TServerInstance,TabletServerStatus> result = new ConcurrentSkipListMap<>();\n     final RateLimiter shutdownServerRateLimiter = RateLimiter.create(MAX_SHUTDOWNS_PER_SEC);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/server/manager/src/main/java/org/apache/accumulo/master/Master.java b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\nindex 858cb31f02..f04fbcfe13 100644\n--- a/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n+++ b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n", "chunk": "@@ -886,9 +882,8 @@ public class Master extends AbstractServer\n       gatherTableInformation(Set<TServerInstance> currentServers) {\n     final long rpcTimeout = getConfiguration().getTimeInMillis(Property.GENERAL_RPC_TIMEOUT);\n     int threads = getConfiguration().getCount(Property.MASTER_STATUS_THREAD_POOL_SIZE);\n-    ExecutorService tp = threads == 0\n-        ? Executors.newCachedThreadPool(new NamingThreadFactory(\"GatherTableInformation\"))\n-        : Executors.newFixedThreadPool(threads, new NamingThreadFactory(\"GatherTableInformation\"));\n+    ExecutorService tp = ThreadPools.createExecutorService(getConfiguration(),\n+        Property.MASTER_STATUS_THREAD_POOL_SIZE);\n     long start = System.currentTimeMillis();\n     final SortedMap<TServerInstance,TabletServerStatus> result = new ConcurrentSkipListMap<>();\n     final RateLimiter shutdownServerRateLimiter = RateLimiter.create(MAX_SHUTDOWNS_PER_SEC);\n", "next_change": {"commit": "300c933baa5800fd3bdcee2793dd416aeb26a9e6", "changed_code": [{"header": "diff --git a/server/manager/src/main/java/org/apache/accumulo/master/Master.java b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\nindex f04fbcfe13..cf2ec31d48 100644\n--- a/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n+++ b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n", "chunk": "@@ -881,9 +881,9 @@ public class Master extends AbstractServer\n   private SortedMap<TServerInstance,TabletServerStatus>\n       gatherTableInformation(Set<TServerInstance> currentServers) {\n     final long rpcTimeout = getConfiguration().getTimeInMillis(Property.GENERAL_RPC_TIMEOUT);\n-    int threads = getConfiguration().getCount(Property.MASTER_STATUS_THREAD_POOL_SIZE);\n+    int threads = getConfiguration().getCount(Property.MANAGER_STATUS_THREAD_POOL_SIZE);\n     ExecutorService tp = ThreadPools.createExecutorService(getConfiguration(),\n-        Property.MASTER_STATUS_THREAD_POOL_SIZE);\n+        Property.MANAGER_STATUS_THREAD_POOL_SIZE);\n     long start = System.currentTimeMillis();\n     final SortedMap<TServerInstance,TabletServerStatus> result = new ConcurrentSkipListMap<>();\n     final RateLimiter shutdownServerRateLimiter = RateLimiter.create(MAX_SHUTDOWNS_PER_SEC);\n", "next_change": {"commit": "95a8df18049118fcf3b5564e325a08af47e0a964", "changed_code": [{"header": "diff --git a/server/manager/src/main/java/org/apache/accumulo/master/Master.java b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\nindex cf2ec31d48..4d9d256cf1 100644\n--- a/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n+++ b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n", "chunk": "@@ -852,34 +866,57 @@ public class Master extends AbstractServer\n     }\n \n     private long balanceTablets() {\n-      List<TabletMigration> migrationsOut = new ArrayList<>();\n-      long wait = tabletBalancer.balance(Collections.unmodifiableSortedMap(tserverStatus),\n-          migrationsSnapshot(), migrationsOut);\n-\n-      for (TabletMigration m : TabletBalancer.checkMigrationSanity(tserverStatus.keySet(),\n-          migrationsOut)) {\n-        if (migrations.containsKey(m.tablet)) {\n+      BalanceParamsImpl params = BalanceParamsImpl.fromThrift(tserverStatusForBalancer,\n+          tserverStatus, migrationsSnapshot());\n+      long wait = tabletBalancer.balance(params);\n+\n+      for (TabletMigration m : checkMigrationSanity(tserverStatusForBalancer.keySet(),\n+          params.migrationsOut())) {\n+        KeyExtent ke = KeyExtent.fromTabletId(m.getTablet());\n+        if (migrations.containsKey(ke)) {\n           log.warn(\"balancer requested migration more than once, skipping {}\", m);\n           continue;\n         }\n-        migrations.put(m.tablet, m.newServer);\n+        TServerInstance tserverInstance = TabletServerIdImpl.toThrift(m.getNewTabletServer());\n+        migrations.put(ke, tserverInstance);\n         log.debug(\"migration {}\", m);\n       }\n-      if (migrationsOut.isEmpty()) {\n+      if (params.migrationsOut().isEmpty()) {\n         synchronized (balancedNotifier) {\n           balancedNotifier.notifyAll();\n         }\n       } else {\n-        nextEvent.event(\"Migrating %d more tablets, %d total\", migrationsOut.size(),\n+        nextEvent.event(\"Migrating %d more tablets, %d total\", params.migrationsOut().size(),\n             migrations.size());\n       }\n       return wait;\n     }\n \n+    private List<TabletMigration> checkMigrationSanity(Set<TabletServerId> current,\n+        List<TabletMigration> migrations) {\n+      return migrations.stream().filter(m -> {\n+        boolean includeMigration = false;\n+        if (m.getTablet() == null) {\n+          log.error(\"Balancer gave back a null tablet {}\", m);\n+        } else if (m.getNewTabletServer() == null) {\n+          log.error(\"Balancer did not set the destination {}\", m);\n+        } else if (m.getOldTabletServer() == null) {\n+          log.error(\"Balancer did not set the source {}\", m);\n+        } else if (!current.contains(m.getOldTabletServer())) {\n+          log.warn(\"Balancer wants to move a tablet from a server that is not current: {}\", m);\n+        } else if (!current.contains(m.getNewTabletServer())) {\n+          log.warn(\"Balancer wants to move a tablet to a server that is not current: {}\", m);\n+        } else {\n+          includeMigration = true;\n+        }\n+        return includeMigration;\n+      }).collect(Collectors.toList());\n+    }\n+\n   }\n \n-  private SortedMap<TServerInstance,TabletServerStatus>\n-      gatherTableInformation(Set<TServerInstance> currentServers) {\n+  private SortedMap<TServerInstance,TabletServerStatus> gatherTableInformation(\n+      Set<TServerInstance> currentServers, SortedMap<TabletServerId,TServerStatus> balancerMap) {\n     final long rpcTimeout = getConfiguration().getTimeInMillis(Property.GENERAL_RPC_TIMEOUT);\n     int threads = getConfiguration().getCount(Property.MANAGER_STATUS_THREAD_POOL_SIZE);\n     ExecutorService tp = ThreadPools.createExecutorService(getConfiguration(),\n", "next_change": {"commit": "e6164901a3acdd464a7a9beff0126097b53fc06f", "changed_code": [{"header": "diff --git a/server/manager/src/main/java/org/apache/accumulo/master/Master.java b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\nindex 4d9d256cf1..b78ed733a5 100644\n--- a/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n+++ b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n", "chunk": "@@ -18,1729 +18,21 @@\n  */\n package org.apache.accumulo.master;\n \n-import static java.nio.charset.StandardCharsets.UTF_8;\n-import static org.apache.accumulo.fate.util.UtilWaitThread.sleepUninterruptibly;\n-\n-import java.io.IOException;\n-import java.net.UnknownHostException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Set;\n-import java.util.SortedMap;\n-import java.util.TreeMap;\n-import java.util.UUID;\n-import java.util.concurrent.ConcurrentSkipListMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.stream.Collectors;\n-\n-import org.apache.accumulo.core.Constants;\n-import org.apache.accumulo.core.client.AccumuloClient;\n-import org.apache.accumulo.core.client.Scanner;\n-import org.apache.accumulo.core.client.TableNotFoundException;\n-import org.apache.accumulo.core.clientImpl.Tables;\n-import org.apache.accumulo.core.clientImpl.ThriftTransportPool;\n-import org.apache.accumulo.core.clientImpl.thrift.TableOperation;\n-import org.apache.accumulo.core.clientImpl.thrift.TableOperationExceptionType;\n-import org.apache.accumulo.core.clientImpl.thrift.ThriftTableOperationException;\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.data.Key;\n-import org.apache.accumulo.core.data.TableId;\n-import org.apache.accumulo.core.data.Value;\n-import org.apache.accumulo.core.dataImpl.KeyExtent;\n-import org.apache.accumulo.core.manager.balancer.AssignmentParamsImpl;\n-import org.apache.accumulo.core.manager.balancer.BalanceParamsImpl;\n-import org.apache.accumulo.core.manager.balancer.TServerStatusImpl;\n-import org.apache.accumulo.core.manager.balancer.TabletServerIdImpl;\n-import org.apache.accumulo.core.master.state.tables.TableState;\n-import org.apache.accumulo.core.master.thrift.BulkImportState;\n-import org.apache.accumulo.core.master.thrift.MasterClientService.Iface;\n-import org.apache.accumulo.core.master.thrift.MasterClientService.Processor;\n-import org.apache.accumulo.core.master.thrift.MasterGoalState;\n-import org.apache.accumulo.core.master.thrift.MasterMonitorInfo;\n-import org.apache.accumulo.core.master.thrift.MasterState;\n-import org.apache.accumulo.core.master.thrift.TableInfo;\n-import org.apache.accumulo.core.master.thrift.TabletServerStatus;\n-import org.apache.accumulo.core.metadata.MetadataTable;\n-import org.apache.accumulo.core.metadata.RootTable;\n-import org.apache.accumulo.core.metadata.TServerInstance;\n-import org.apache.accumulo.core.metadata.TabletLocationState;\n-import org.apache.accumulo.core.metadata.TabletState;\n-import org.apache.accumulo.core.metadata.schema.Ample.DataLevel;\n-import org.apache.accumulo.core.metadata.schema.MetadataSchema.TabletsSection.TabletColumnFamily;\n-import org.apache.accumulo.core.replication.thrift.ReplicationCoordinator;\n-import org.apache.accumulo.core.security.Authorizations;\n-import org.apache.accumulo.core.spi.balancer.BalancerEnvironment;\n-import org.apache.accumulo.core.spi.balancer.SimpleLoadBalancer;\n-import org.apache.accumulo.core.spi.balancer.TabletBalancer;\n-import org.apache.accumulo.core.spi.balancer.data.TServerStatus;\n-import org.apache.accumulo.core.spi.balancer.data.TabletMigration;\n-import org.apache.accumulo.core.spi.balancer.data.TabletServerId;\n-import org.apache.accumulo.core.tabletserver.thrift.TUnloadTabletGoal;\n-import org.apache.accumulo.core.trace.TraceUtil;\n-import org.apache.accumulo.core.util.Halt;\n-import org.apache.accumulo.core.util.threads.ThreadPools;\n-import org.apache.accumulo.core.util.threads.Threads;\n-import org.apache.accumulo.fate.AgeOffStore;\n-import org.apache.accumulo.fate.Fate;\n-import org.apache.accumulo.fate.util.Retry;\n-import org.apache.accumulo.fate.zookeeper.ZooLock;\n-import org.apache.accumulo.fate.zookeeper.ZooLock.LockLossReason;\n-import org.apache.accumulo.fate.zookeeper.ZooReaderWriter;\n-import org.apache.accumulo.fate.zookeeper.ZooUtil;\n-import org.apache.accumulo.fate.zookeeper.ZooUtil.NodeExistsPolicy;\n-import org.apache.accumulo.fate.zookeeper.ZooUtil.NodeMissingPolicy;\n-import org.apache.accumulo.master.metrics.MasterMetricsFactory;\n-import org.apache.accumulo.master.recovery.RecoveryManager;\n-import org.apache.accumulo.master.replication.MasterReplicationCoordinator;\n-import org.apache.accumulo.master.replication.ReplicationDriver;\n-import org.apache.accumulo.master.replication.WorkDriver;\n-import org.apache.accumulo.master.state.TableCounts;\n-import org.apache.accumulo.master.tableOps.TraceRepo;\n-import org.apache.accumulo.master.upgrade.UpgradeCoordinator;\n-import org.apache.accumulo.server.AbstractServer;\n-import org.apache.accumulo.server.HighlyAvailableService;\n-import org.apache.accumulo.server.ServerContext;\n-import org.apache.accumulo.server.ServerOpts;\n-import org.apache.accumulo.server.fs.VolumeManager;\n-import org.apache.accumulo.server.manager.balancer.BalancerEnvironmentImpl;\n-import org.apache.accumulo.server.master.LiveTServerSet;\n-import org.apache.accumulo.server.master.LiveTServerSet.TServerConnection;\n-import org.apache.accumulo.server.master.state.CurrentState;\n-import org.apache.accumulo.server.master.state.DeadServerList;\n-import org.apache.accumulo.server.master.state.MergeInfo;\n-import org.apache.accumulo.server.master.state.MergeState;\n-import org.apache.accumulo.server.master.state.TabletServerState;\n-import org.apache.accumulo.server.master.state.TabletStateStore;\n-import org.apache.accumulo.server.replication.ZooKeeperInitialization;\n-import org.apache.accumulo.server.rpc.HighlyAvailableServiceWrapper;\n-import org.apache.accumulo.server.rpc.ServerAddress;\n-import org.apache.accumulo.server.rpc.TCredentialsUpdatingWrapper;\n-import org.apache.accumulo.server.rpc.TServerUtils;\n-import org.apache.accumulo.server.rpc.ThriftServerType;\n-import org.apache.accumulo.server.security.AuditedSecurityOperation;\n-import org.apache.accumulo.server.security.SecurityOperation;\n-import org.apache.accumulo.server.security.delegation.AuthenticationTokenKeyManager;\n-import org.apache.accumulo.server.security.delegation.AuthenticationTokenSecretManager;\n-import org.apache.accumulo.server.security.delegation.ZooAuthenticationKeyDistributor;\n-import org.apache.accumulo.server.tables.TableManager;\n-import org.apache.accumulo.server.tables.TableObserver;\n-import org.apache.accumulo.server.util.ServerBulkImportStatus;\n-import org.apache.accumulo.server.util.TableInfoUtil;\n-import org.apache.hadoop.io.DataInputBuffer;\n-import org.apache.hadoop.io.DataOutputBuffer;\n-import org.apache.thrift.TException;\n-import org.apache.thrift.server.TServer;\n-import org.apache.thrift.transport.TTransportException;\n-import org.apache.zookeeper.KeeperException;\n-import org.apache.zookeeper.KeeperException.NoAuthException;\n-import org.apache.zookeeper.WatchedEvent;\n-import org.apache.zookeeper.Watcher;\n+import org.apache.accumulo.manager.MasterExecutable;\n+import org.apache.accumulo.start.Main;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import com.google.common.collect.ImmutableSortedMap;\n-import com.google.common.util.concurrent.RateLimiter;\n-\n-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n-\n /**\n- * The Master is responsible for assigning and balancing tablets to tablet servers.\n- * <p>\n- * The master will also coordinate log recoveries and reports general status.\n+ * @deprecated since 2.1.0. Use {@link Main} with keyword \"manager\" instead.\n  */\n-public class Master extends AbstractServer\n-    implements LiveTServerSet.Listener, TableObserver, CurrentState, HighlyAvailableService {\n-\n-  static final Logger log = LoggerFactory.getLogger(Master.class);\n-\n-  static final int ONE_SECOND = 1000;\n-  static final long TIME_TO_WAIT_BETWEEN_SCANS = 60 * ONE_SECOND;\n-  // made this less than TIME_TO_WAIT_BETWEEN_SCANS, so that the cache is cleared between cycles\n-  static final long TIME_TO_CACHE_RECOVERY_WAL_EXISTENCE = TIME_TO_WAIT_BETWEEN_SCANS / 4;\n-  private static final long TIME_BETWEEN_MIGRATION_CLEANUPS = 5 * 60 * ONE_SECOND;\n-  static final long WAIT_BETWEEN_ERRORS = ONE_SECOND;\n-  private static final long DEFAULT_WAIT_FOR_WATCHER = 10 * ONE_SECOND;\n-  private static final int MAX_CLEANUP_WAIT_TIME = ONE_SECOND;\n-  private static final int TIME_TO_WAIT_BETWEEN_LOCK_CHECKS = ONE_SECOND;\n-  static final int MAX_TSERVER_WORK_CHUNK = 5000;\n-  private static final int MAX_BAD_STATUS_COUNT = 3;\n-  private static final double MAX_SHUTDOWNS_PER_SEC = 10D / 60D;\n-\n-  private final Object balancedNotifier = new Object();\n-  final LiveTServerSet tserverSet;\n-  private final List<TabletGroupWatcher> watchers = new ArrayList<>();\n-  final SecurityOperation security;\n-  final Map<TServerInstance,AtomicInteger> badServers =\n-      Collections.synchronizedMap(new HashMap<>());\n-  final Set<TServerInstance> serversToShutdown = Collections.synchronizedSet(new HashSet<>());\n-  final SortedMap<KeyExtent,TServerInstance> migrations =\n-      Collections.synchronizedSortedMap(new TreeMap<>());\n-  final EventCoordinator nextEvent = new EventCoordinator();\n-  private final Object mergeLock = new Object();\n-  private Thread replicationWorkThread;\n-  private Thread replicationAssignerThread;\n-  RecoveryManager recoveryManager = null;\n-  private final MasterTime timeKeeper;\n-\n-  // Delegation Token classes\n-  private final boolean delegationTokensAvailable;\n-  private ZooAuthenticationKeyDistributor keyDistributor;\n-  private AuthenticationTokenKeyManager authenticationTokenKeyManager;\n-\n-  ZooLock masterLock = null;\n-  private TServer clientService = null;\n-  private volatile TabletBalancer tabletBalancer;\n-  private final BalancerEnvironment balancerEnvironment;\n-\n-  private MasterState state = MasterState.INITIAL;\n-\n-  Fate<Master> fate;\n-\n-  volatile SortedMap<TServerInstance,TabletServerStatus> tserverStatus =\n-      Collections.unmodifiableSortedMap(new TreeMap<>());\n-  volatile SortedMap<TabletServerId,TServerStatus> tserverStatusForBalancer =\n-      Collections.unmodifiableSortedMap(new TreeMap<>());\n-  final ServerBulkImportStatus bulkImportStatus = new ServerBulkImportStatus();\n-\n-  private final AtomicBoolean masterInitialized = new AtomicBoolean(false);\n-\n-  @Override\n-  public synchronized MasterState getMasterState() {\n-    return state;\n-  }\n-\n-  public boolean stillMaster() {\n-    return getMasterState() != MasterState.STOP;\n-  }\n-\n-  static final boolean X = true;\n-  static final boolean O = false;\n-  // @formatter:off\n-  static final boolean[][] transitionOK = {\n-      //                            INITIAL HAVE_LOCK SAFE_MODE NORMAL UNLOAD_META UNLOAD_ROOT STOP\n-      /* INITIAL */                 {X, X, O, O, O, O, X},\n-      /* HAVE_LOCK */               {O, X, X, X, O, O, X},\n-      /* SAFE_MODE */               {O, O, X, X, X, O, X},\n-      /* NORMAL */                  {O, O, X, X, X, O, X},\n-      /* UNLOAD_METADATA_TABLETS */ {O, O, X, X, X, X, X},\n-      /* UNLOAD_ROOT_TABLET */      {O, O, O, X, X, X, X},\n-      /* STOP */                    {O, O, O, O, O, X, X}};\n-  //@formatter:on\n-  synchronized void setMasterState(MasterState newState) {\n-    if (state.equals(newState)) {\n-      return;\n-    }\n-    if (!transitionOK[state.ordinal()][newState.ordinal()]) {\n-      log.error(\"Programmer error: master should not transition from {} to {}\", state, newState);\n-    }\n-    MasterState oldState = state;\n-    state = newState;\n-    nextEvent.event(\"State changed from %s to %s\", oldState, newState);\n-    if (newState == MasterState.STOP) {\n-      // Give the server a little time before shutdown so the client\n-      // thread requesting the stop can return\n-      ThreadPools.createGeneralScheduledExecutorService(getConfiguration())\n-          .scheduleWithFixedDelay(() -> {\n-            // This frees the main thread and will cause the master to exit\n-            clientService.stop();\n-            Master.this.nextEvent.event(\"stopped event loop\");\n-          }, 100L, 1000L, TimeUnit.MILLISECONDS);\n-    }\n-\n-    if (oldState != newState && (newState == MasterState.HAVE_LOCK)) {\n-      upgradeCoordinator.upgradeZookeeper(getContext(), nextEvent);\n-    }\n-\n-    if (oldState != newState && (newState == MasterState.NORMAL)) {\n-      if (fate != null) {\n-        throw new IllegalStateException(\"Access to Fate should not have been\"\n-            + \" initialized prior to the Master finishing upgrades. Please save\"\n-            + \" all logs and file a bug.\");\n-      }\n-      upgradeMetadataFuture = upgradeCoordinator.upgradeMetadata(getContext(), nextEvent);\n-    }\n-  }\n-\n-  private final UpgradeCoordinator upgradeCoordinator = new UpgradeCoordinator();\n-\n-  private Future<Void> upgradeMetadataFuture;\n-\n-  private MasterClientServiceHandler clientHandler;\n-\n-  private int assignedOrHosted(TableId tableId) {\n-    int result = 0;\n-    for (TabletGroupWatcher watcher : watchers) {\n-      TableCounts count = watcher.getStats(tableId);\n-      result += count.hosted() + count.assigned();\n-    }\n-    return result;\n-  }\n-\n-  private int totalAssignedOrHosted() {\n-    int result = 0;\n-    for (TabletGroupWatcher watcher : watchers) {\n-      for (TableCounts counts : watcher.getStats().values()) {\n-        result += counts.assigned() + counts.hosted();\n-      }\n-    }\n-    return result;\n-  }\n-\n-  private int nonMetaDataTabletsAssignedOrHosted() {\n-    return totalAssignedOrHosted() - assignedOrHosted(MetadataTable.ID)\n-        - assignedOrHosted(RootTable.ID);\n-  }\n-\n-  private int notHosted() {\n-    int result = 0;\n-    for (TabletGroupWatcher watcher : watchers) {\n-      for (TableCounts counts : watcher.getStats().values()) {\n-        result += counts.assigned() + counts.assignedToDeadServers() + counts.suspended();\n-      }\n-    }\n-    return result;\n-  }\n-\n-  // The number of unassigned tablets that should be assigned: displayed on the monitor page\n-  int displayUnassigned() {\n-    int result = 0;\n-    switch (getMasterState()) {\n-      case NORMAL:\n-        // Count offline tablets for online tables\n-        for (TabletGroupWatcher watcher : watchers) {\n-          TableManager manager = getContext().getTableManager();\n-          for (Entry<TableId,TableCounts> entry : watcher.getStats().entrySet()) {\n-            TableId tableId = entry.getKey();\n-            TableCounts counts = entry.getValue();\n-            TableState tableState = manager.getTableState(tableId);\n-            if (tableState != null && tableState.equals(TableState.ONLINE)) {\n-              result += counts.unassigned() + counts.assignedToDeadServers() + counts.assigned()\n-                  + counts.suspended();\n-            }\n-          }\n-        }\n-        break;\n-      case SAFE_MODE:\n-        // Count offline tablets for the metadata table\n-        for (TabletGroupWatcher watcher : watchers) {\n-          TableCounts counts = watcher.getStats(MetadataTable.ID);\n-          result += counts.unassigned() + counts.suspended();\n-        }\n-        break;\n-      case UNLOAD_METADATA_TABLETS:\n-      case UNLOAD_ROOT_TABLET:\n-        for (TabletGroupWatcher watcher : watchers) {\n-          TableCounts counts = watcher.getStats(MetadataTable.ID);\n-          result += counts.unassigned() + counts.suspended();\n-        }\n-        break;\n-      default:\n-        break;\n-    }\n-    return result;\n-  }\n-\n-  public void mustBeOnline(final TableId tableId) throws ThriftTableOperationException {\n-    ServerContext context = getContext();\n-    Tables.clearCache(context);\n-    if (!Tables.getTableState(context, tableId).equals(TableState.ONLINE)) {\n-      throw new ThriftTableOperationException(tableId.canonical(), null, TableOperation.MERGE,\n-          TableOperationExceptionType.OFFLINE, \"table is not online\");\n-    }\n-  }\n-\n-  public TableManager getTableManager() {\n-    return getContext().getTableManager();\n-  }\n+@Deprecated(since = \"2.1.0\")\n+public class Master {\n+  private static final Logger LOG = LoggerFactory.getLogger(Master.class);\n \n   public static void main(String[] args) throws Exception {\n-    try (Master master = new Master(new ServerOpts(), args)) {\n-      master.runServer();\n-    }\n-  }\n-\n-  Master(ServerOpts opts, String[] args) throws IOException {\n-    super(\"master\", opts, args);\n-    ServerContext context = super.getContext();\n-    balancerEnvironment = new BalancerEnvironmentImpl(context);\n-\n-    AccumuloConfiguration aconf = context.getConfiguration();\n-\n-    log.info(\"Version {}\", Constants.VERSION);\n-    log.info(\"Instance {}\", getInstanceID());\n-    timeKeeper = new MasterTime(this, aconf);\n-    ThriftTransportPool.getInstance()\n-        .setIdleTime(aconf.getTimeInMillis(Property.GENERAL_RPC_TIMEOUT));\n-    tserverSet = new LiveTServerSet(context, this);\n-    initializeBalancer();\n-\n-    this.security = AuditedSecurityOperation.getInstance(context);\n-\n-    // Create the secret manager (can generate and verify delegation tokens)\n-    final long tokenLifetime = aconf.getTimeInMillis(Property.GENERAL_DELEGATION_TOKEN_LIFETIME);\n-    context.setSecretManager(new AuthenticationTokenSecretManager(getInstanceID(), tokenLifetime));\n-\n-    authenticationTokenKeyManager = null;\n-    keyDistributor = null;\n-    if (getConfiguration().getBoolean(Property.INSTANCE_RPC_SASL_ENABLED)) {\n-      // SASL is enabled, create the key distributor (ZooKeeper) and manager (generates/rolls secret\n-      // keys)\n-      log.info(\"SASL is enabled, creating delegation token key manager and distributor\");\n-      final long tokenUpdateInterval =\n-          aconf.getTimeInMillis(Property.GENERAL_DELEGATION_TOKEN_UPDATE_INTERVAL);\n-      keyDistributor = new ZooAuthenticationKeyDistributor(context.getZooReaderWriter(),\n-          getZooKeeperRoot() + Constants.ZDELEGATION_TOKEN_KEYS);\n-      authenticationTokenKeyManager = new AuthenticationTokenKeyManager(context.getSecretManager(),\n-          keyDistributor, tokenUpdateInterval, tokenLifetime);\n-      delegationTokensAvailable = true;\n-    } else {\n-      log.info(\"SASL is not enabled, delegation tokens will not be available\");\n-      delegationTokensAvailable = false;\n-    }\n-  }\n-\n-  public String getInstanceID() {\n-    return getContext().getInstanceID();\n-  }\n-\n-  public String getZooKeeperRoot() {\n-    return getContext().getZooKeeperRoot();\n-  }\n-\n-  public TServerConnection getConnection(TServerInstance server) {\n-    return tserverSet.getConnection(server);\n-  }\n-\n-  public MergeInfo getMergeInfo(TableId tableId) {\n-    ServerContext context = getContext();\n-    synchronized (mergeLock) {\n-      try {\n-        String path = getZooKeeperRoot() + Constants.ZTABLES + \"/\" + tableId + \"/merge\";\n-        if (!context.getZooReaderWriter().exists(path)) {\n-          return new MergeInfo();\n-        }\n-        byte[] data = context.getZooReaderWriter().getData(path);\n-        DataInputBuffer in = new DataInputBuffer();\n-        in.reset(data, data.length);\n-        MergeInfo info = new MergeInfo();\n-        info.readFields(in);\n-        return info;\n-      } catch (KeeperException.NoNodeException ex) {\n-        log.info(\"Error reading merge state, it probably just finished\");\n-        return new MergeInfo();\n-      } catch (Exception ex) {\n-        log.warn(\"Unexpected error reading merge state\", ex);\n-        return new MergeInfo();\n-      }\n-    }\n-  }\n-\n-  public void setMergeState(MergeInfo info, MergeState state)\n-      throws KeeperException, InterruptedException {\n-    ServerContext context = getContext();\n-    synchronized (mergeLock) {\n-      String path =\n-          getZooKeeperRoot() + Constants.ZTABLES + \"/\" + info.getExtent().tableId() + \"/merge\";\n-      info.setState(state);\n-      if (state.equals(MergeState.NONE)) {\n-        context.getZooReaderWriter().recursiveDelete(path, NodeMissingPolicy.SKIP);\n-      } else {\n-        DataOutputBuffer out = new DataOutputBuffer();\n-        try {\n-          info.write(out);\n-        } catch (IOException ex) {\n-          throw new AssertionError(\"Unlikely\", ex);\n-        }\n-        context.getZooReaderWriter().putPersistentData(path, out.getData(),\n-            state.equals(MergeState.STARTED) ? ZooUtil.NodeExistsPolicy.FAIL\n-                : ZooUtil.NodeExistsPolicy.OVERWRITE);\n-      }\n-      mergeLock.notifyAll();\n-    }\n-    nextEvent.event(\"Merge state of %s set to %s\", info.getExtent(), state);\n-  }\n-\n-  public void clearMergeState(TableId tableId) throws KeeperException, InterruptedException {\n-    synchronized (mergeLock) {\n-      String path = getZooKeeperRoot() + Constants.ZTABLES + \"/\" + tableId + \"/merge\";\n-      getContext().getZooReaderWriter().recursiveDelete(path, NodeMissingPolicy.SKIP);\n-      mergeLock.notifyAll();\n-    }\n-    nextEvent.event(\"Merge state of %s cleared\", tableId);\n-  }\n-\n-  void setMasterGoalState(MasterGoalState state) {\n-    try {\n-      getContext().getZooReaderWriter().putPersistentData(\n-          getZooKeeperRoot() + Constants.ZMASTER_GOAL_STATE, state.name().getBytes(),\n-          NodeExistsPolicy.OVERWRITE);\n-    } catch (Exception ex) {\n-      log.error(\"Unable to set master goal state in zookeeper\");\n-    }\n-  }\n-\n-  MasterGoalState getMasterGoalState() {\n-    while (true) {\n-      try {\n-        byte[] data = getContext().getZooReaderWriter()\n-            .getData(getZooKeeperRoot() + Constants.ZMASTER_GOAL_STATE);\n-        return MasterGoalState.valueOf(new String(data));\n-      } catch (Exception e) {\n-        log.error(\"Problem getting real goal state from zookeeper: \", e);\n-        sleepUninterruptibly(1, TimeUnit.SECONDS);\n-      }\n-    }\n-  }\n-\n-  public boolean hasCycled(long time) {\n-    for (TabletGroupWatcher watcher : watchers) {\n-      if (watcher.stats.lastScanFinished() < time) {\n-        return false;\n-      }\n-    }\n-\n-    return true;\n-  }\n-\n-  public void clearMigrations(TableId tableId) {\n-    synchronized (migrations) {\n-      migrations.keySet().removeIf(extent -> extent.tableId().equals(tableId));\n-    }\n-  }\n-\n-  enum TabletGoalState {\n-    HOSTED(TUnloadTabletGoal.UNKNOWN),\n-    UNASSIGNED(TUnloadTabletGoal.UNASSIGNED),\n-    DELETED(TUnloadTabletGoal.DELETED),\n-    SUSPENDED(TUnloadTabletGoal.SUSPENDED);\n-\n-    private final TUnloadTabletGoal unloadGoal;\n-\n-    TabletGoalState(TUnloadTabletGoal unloadGoal) {\n-      this.unloadGoal = unloadGoal;\n-    }\n-\n-    /** The purpose of unloading this tablet. */\n-    public TUnloadTabletGoal howUnload() {\n-      return unloadGoal;\n-    }\n-  }\n-\n-  TabletGoalState getSystemGoalState(TabletLocationState tls) {\n-    switch (getMasterState()) {\n-      case NORMAL:\n-        return TabletGoalState.HOSTED;\n-      case HAVE_LOCK: // fall-through intended\n-      case INITIAL: // fall-through intended\n-      case SAFE_MODE:\n-        if (tls.extent.isMeta()) {\n-          return TabletGoalState.HOSTED;\n-        }\n-        return TabletGoalState.UNASSIGNED;\n-      case UNLOAD_METADATA_TABLETS:\n-        if (tls.extent.isRootTablet()) {\n-          return TabletGoalState.HOSTED;\n-        }\n-        return TabletGoalState.UNASSIGNED;\n-      case UNLOAD_ROOT_TABLET:\n-        return TabletGoalState.UNASSIGNED;\n-      case STOP:\n-        return TabletGoalState.UNASSIGNED;\n-      default:\n-        throw new IllegalStateException(\"Unknown Master State\");\n-    }\n-  }\n-\n-  TabletGoalState getTableGoalState(KeyExtent extent) {\n-    TableState tableState = getContext().getTableManager().getTableState(extent.tableId());\n-    if (tableState == null) {\n-      return TabletGoalState.DELETED;\n-    }\n-    switch (tableState) {\n-      case DELETING:\n-        return TabletGoalState.DELETED;\n-      case OFFLINE:\n-      case NEW:\n-        return TabletGoalState.UNASSIGNED;\n-      default:\n-        return TabletGoalState.HOSTED;\n-    }\n-  }\n-\n-  TabletGoalState getGoalState(TabletLocationState tls, MergeInfo mergeInfo) {\n-    KeyExtent extent = tls.extent;\n-    // Shutting down?\n-    TabletGoalState state = getSystemGoalState(tls);\n-    if (state == TabletGoalState.HOSTED) {\n-      if (!upgradeCoordinator.getStatus().isParentLevelUpgraded(extent)) {\n-        // The place where this tablet stores its metadata was not upgraded, so do not assign this\n-        // tablet yet.\n-        return TabletGoalState.UNASSIGNED;\n-      }\n-\n-      if (tls.current != null && serversToShutdown.contains(tls.current)) {\n-        return TabletGoalState.SUSPENDED;\n-      }\n-      // Handle merge transitions\n-      if (mergeInfo.getExtent() != null) {\n-\n-        final boolean overlaps = mergeInfo.overlaps(extent);\n-\n-        if (overlaps) {\n-          log.debug(\"mergeInfo overlaps: {} true\", extent);\n-          switch (mergeInfo.getState()) {\n-            case NONE:\n-            case COMPLETE:\n-              break;\n-            case STARTED:\n-            case SPLITTING:\n-              return TabletGoalState.HOSTED;\n-            case WAITING_FOR_CHOPPED:\n-              if (tls.getState(tserverSet.getCurrentServers()).equals(TabletState.HOSTED)) {\n-                if (tls.chopped) {\n-                  return TabletGoalState.UNASSIGNED;\n-                }\n-              } else {\n-                if (tls.chopped && tls.walogs.isEmpty()) {\n-                  return TabletGoalState.UNASSIGNED;\n-                }\n-              }\n-\n-              return TabletGoalState.HOSTED;\n-            case WAITING_FOR_OFFLINE:\n-            case MERGING:\n-              return TabletGoalState.UNASSIGNED;\n-          }\n-        } else {\n-          log.trace(\"mergeInfo overlaps: {} false\", extent);\n-        }\n-      }\n-\n-      // taking table offline?\n-      state = getTableGoalState(extent);\n-      if (state == TabletGoalState.HOSTED) {\n-        // Maybe this tablet needs to be migrated\n-        TServerInstance dest = migrations.get(extent);\n-        if (dest != null && tls.current != null && !dest.equals(tls.current)) {\n-          return TabletGoalState.UNASSIGNED;\n-        }\n-      }\n-    }\n-    return state;\n-  }\n-\n-  private class MigrationCleanupThread implements Runnable {\n-\n-    @Override\n-    public void run() {\n-      while (stillMaster()) {\n-        if (!migrations.isEmpty()) {\n-          try {\n-            cleanupOfflineMigrations();\n-            cleanupNonexistentMigrations(getContext());\n-          } catch (Exception ex) {\n-            log.error(\"Error cleaning up migrations\", ex);\n-          }\n-        }\n-        sleepUninterruptibly(TIME_BETWEEN_MIGRATION_CLEANUPS, TimeUnit.MILLISECONDS);\n-      }\n-    }\n-\n-    /**\n-     * If a migrating tablet splits, and the tablet dies before sending the master a message, the\n-     * migration will refer to a non-existing tablet, so it can never complete. Periodically scan\n-     * the metadata table and remove any migrating tablets that no longer exist.\n-     */\n-    private void cleanupNonexistentMigrations(final AccumuloClient accumuloClient)\n-        throws TableNotFoundException {\n-      Scanner scanner = accumuloClient.createScanner(MetadataTable.NAME, Authorizations.EMPTY);\n-      TabletColumnFamily.PREV_ROW_COLUMN.fetch(scanner);\n-      Set<KeyExtent> found = new HashSet<>();\n-      for (Entry<Key,Value> entry : scanner) {\n-        KeyExtent extent = KeyExtent.fromMetaPrevRow(entry);\n-        if (migrations.containsKey(extent)) {\n-          found.add(extent);\n-        }\n-      }\n-      migrations.keySet().retainAll(found);\n-    }\n-\n-    /**\n-     * If migrating a tablet for a table that is offline, the migration can never succeed because no\n-     * tablet server will load the tablet. check for offline tables and remove their migrations.\n-     */\n-    private void cleanupOfflineMigrations() {\n-      ServerContext context = getContext();\n-      TableManager manager = context.getTableManager();\n-      for (TableId tableId : Tables.getIdToNameMap(context).keySet()) {\n-        TableState state = manager.getTableState(tableId);\n-        if (state == TableState.OFFLINE) {\n-          clearMigrations(tableId);\n-        }\n-      }\n-    }\n-  }\n-\n-  private class StatusThread implements Runnable {\n-\n-    private boolean goodStats() {\n-      int start;\n-      switch (getMasterState()) {\n-        case UNLOAD_METADATA_TABLETS:\n-          start = 1;\n-          break;\n-        case UNLOAD_ROOT_TABLET:\n-          start = 2;\n-          break;\n-        default:\n-          start = 0;\n-      }\n-      for (int i = start; i < watchers.size(); i++) {\n-        TabletGroupWatcher watcher = watchers.get(i);\n-        if (watcher.stats.getLastMasterState() != getMasterState()) {\n-          log.debug(\"{}: {} != {}\", watcher.getName(), watcher.stats.getLastMasterState(),\n-              getMasterState());\n-          return false;\n-        }\n-      }\n-      return true;\n-    }\n-\n-    @Override\n-    public void run() {\n-      EventCoordinator.Listener eventListener = nextEvent.getListener();\n-      while (stillMaster()) {\n-        long wait = DEFAULT_WAIT_FOR_WATCHER;\n-        try {\n-          switch (getMasterGoalState()) {\n-            case NORMAL:\n-              setMasterState(MasterState.NORMAL);\n-              break;\n-            case SAFE_MODE:\n-              if (getMasterState() == MasterState.NORMAL) {\n-                setMasterState(MasterState.SAFE_MODE);\n-              }\n-              if (getMasterState() == MasterState.HAVE_LOCK) {\n-                setMasterState(MasterState.SAFE_MODE);\n-              }\n-              break;\n-            case CLEAN_STOP:\n-              switch (getMasterState()) {\n-                case NORMAL:\n-                  setMasterState(MasterState.SAFE_MODE);\n-                  break;\n-                case SAFE_MODE: {\n-                  int count = nonMetaDataTabletsAssignedOrHosted();\n-                  log.debug(\n-                      String.format(\"There are %d non-metadata tablets assigned or hosted\", count));\n-                  if (count == 0 && goodStats()) {\n-                    setMasterState(MasterState.UNLOAD_METADATA_TABLETS);\n-                  }\n-                }\n-                  break;\n-                case UNLOAD_METADATA_TABLETS: {\n-                  int count = assignedOrHosted(MetadataTable.ID);\n-                  log.debug(\n-                      String.format(\"There are %d metadata tablets assigned or hosted\", count));\n-                  if (count == 0 && goodStats()) {\n-                    setMasterState(MasterState.UNLOAD_ROOT_TABLET);\n-                  }\n-                }\n-                  break;\n-                case UNLOAD_ROOT_TABLET:\n-                  int count = assignedOrHosted(MetadataTable.ID);\n-                  if (count > 0 && goodStats()) {\n-                    log.debug(String.format(\"%d metadata tablets online\", count));\n-                    setMasterState(MasterState.UNLOAD_ROOT_TABLET);\n-                  }\n-                  int root_count = assignedOrHosted(RootTable.ID);\n-                  if (root_count > 0 && goodStats()) {\n-                    log.debug(\"The root tablet is still assigned or hosted\");\n-                  }\n-                  if (count + root_count == 0 && goodStats()) {\n-                    Set<TServerInstance> currentServers = tserverSet.getCurrentServers();\n-                    log.debug(\"stopping {} tablet servers\", currentServers.size());\n-                    for (TServerInstance server : currentServers) {\n-                      try {\n-                        serversToShutdown.add(server);\n-                        tserverSet.getConnection(server).fastHalt(masterLock);\n-                      } catch (TException e) {\n-                        // its probably down, and we don't care\n-                      } finally {\n-                        tserverSet.remove(server);\n-                      }\n-                    }\n-                    if (currentServers.isEmpty()) {\n-                      setMasterState(MasterState.STOP);\n-                    }\n-                  }\n-                  break;\n-                default:\n-                  break;\n-              }\n-          }\n-        } catch (Exception t) {\n-          log.error(\"Error occurred reading / switching master goal state. Will\"\n-              + \" continue with attempt to update status\", t);\n-        }\n-\n-        try {\n-          wait = updateStatus();\n-          eventListener.waitForEvents(wait);\n-        } catch (Exception t) {\n-          log.error(\"Error balancing tablets, will wait for {} (seconds) and then retry \",\n-              WAIT_BETWEEN_ERRORS / ONE_SECOND, t);\n-          sleepUninterruptibly(WAIT_BETWEEN_ERRORS, TimeUnit.MILLISECONDS);\n-        }\n-      }\n-    }\n-\n-    private long updateStatus() {\n-      Set<TServerInstance> currentServers = tserverSet.getCurrentServers();\n-      TreeMap<TabletServerId,TServerStatus> temp = new TreeMap<>();\n-      tserverStatus = gatherTableInformation(currentServers, temp);\n-      tserverStatusForBalancer = Collections.unmodifiableSortedMap(temp);\n-      checkForHeldServer(tserverStatus);\n-\n-      if (!badServers.isEmpty()) {\n-        log.debug(\"not balancing because the balance information is out-of-date {}\",\n-            badServers.keySet());\n-      } else if (notHosted() > 0) {\n-        log.debug(\"not balancing because there are unhosted tablets: {}\", notHosted());\n-      } else if (getMasterGoalState() == MasterGoalState.CLEAN_STOP) {\n-        log.debug(\"not balancing because the master is attempting to stop cleanly\");\n-      } else if (!serversToShutdown.isEmpty()) {\n-        log.debug(\"not balancing while shutting down servers {}\", serversToShutdown);\n-      } else {\n-        for (TabletGroupWatcher tgw : watchers) {\n-          if (!tgw.isSameTserversAsLastScan(currentServers)) {\n-            log.debug(\"not balancing just yet, as collection of live tservers is in flux\");\n-            return DEFAULT_WAIT_FOR_WATCHER;\n-          }\n-        }\n-        return balanceTablets();\n-      }\n-      return DEFAULT_WAIT_FOR_WATCHER;\n-    }\n-\n-    private void checkForHeldServer(SortedMap<TServerInstance,TabletServerStatus> tserverStatus) {\n-      TServerInstance instance = null;\n-      int crazyHoldTime = 0;\n-      int someHoldTime = 0;\n-      final long maxWait = getConfiguration().getTimeInMillis(Property.TSERV_HOLD_TIME_SUICIDE);\n-      for (Entry<TServerInstance,TabletServerStatus> entry : tserverStatus.entrySet()) {\n-        if (entry.getValue().getHoldTime() > 0) {\n-          someHoldTime++;\n-          if (entry.getValue().getHoldTime() > maxWait) {\n-            instance = entry.getKey();\n-            crazyHoldTime++;\n-          }\n-        }\n-      }\n-      if (crazyHoldTime == 1 && someHoldTime == 1 && tserverStatus.size() > 1) {\n-        log.warn(\"Tablet server {} exceeded maximum hold time: attempting to kill it\", instance);\n-        try {\n-          TServerConnection connection = tserverSet.getConnection(instance);\n-          if (connection != null) {\n-            connection.fastHalt(masterLock);\n-          }\n-        } catch (TException e) {\n-          log.error(\"{}\", e.getMessage(), e);\n-        }\n-        badServers.putIfAbsent(instance, new AtomicInteger(1));\n-      }\n-    }\n-\n-    private long balanceTablets() {\n-      BalanceParamsImpl params = BalanceParamsImpl.fromThrift(tserverStatusForBalancer,\n-          tserverStatus, migrationsSnapshot());\n-      long wait = tabletBalancer.balance(params);\n-\n-      for (TabletMigration m : checkMigrationSanity(tserverStatusForBalancer.keySet(),\n-          params.migrationsOut())) {\n-        KeyExtent ke = KeyExtent.fromTabletId(m.getTablet());\n-        if (migrations.containsKey(ke)) {\n-          log.warn(\"balancer requested migration more than once, skipping {}\", m);\n-          continue;\n-        }\n-        TServerInstance tserverInstance = TabletServerIdImpl.toThrift(m.getNewTabletServer());\n-        migrations.put(ke, tserverInstance);\n-        log.debug(\"migration {}\", m);\n-      }\n-      if (params.migrationsOut().isEmpty()) {\n-        synchronized (balancedNotifier) {\n-          balancedNotifier.notifyAll();\n-        }\n-      } else {\n-        nextEvent.event(\"Migrating %d more tablets, %d total\", params.migrationsOut().size(),\n-            migrations.size());\n-      }\n-      return wait;\n-    }\n-\n-    private List<TabletMigration> checkMigrationSanity(Set<TabletServerId> current,\n-        List<TabletMigration> migrations) {\n-      return migrations.stream().filter(m -> {\n-        boolean includeMigration = false;\n-        if (m.getTablet() == null) {\n-          log.error(\"Balancer gave back a null tablet {}\", m);\n-        } else if (m.getNewTabletServer() == null) {\n-          log.error(\"Balancer did not set the destination {}\", m);\n-        } else if (m.getOldTabletServer() == null) {\n-          log.error(\"Balancer did not set the source {}\", m);\n-        } else if (!current.contains(m.getOldTabletServer())) {\n-          log.warn(\"Balancer wants to move a tablet from a server that is not current: {}\", m);\n-        } else if (!current.contains(m.getNewTabletServer())) {\n-          log.warn(\"Balancer wants to move a tablet to a server that is not current: {}\", m);\n-        } else {\n-          includeMigration = true;\n-        }\n-        return includeMigration;\n-      }).collect(Collectors.toList());\n-    }\n-\n-  }\n-\n-  private SortedMap<TServerInstance,TabletServerStatus> gatherTableInformation(\n-      Set<TServerInstance> currentServers, SortedMap<TabletServerId,TServerStatus> balancerMap) {\n-    final long rpcTimeout = getConfiguration().getTimeInMillis(Property.GENERAL_RPC_TIMEOUT);\n-    int threads = getConfiguration().getCount(Property.MANAGER_STATUS_THREAD_POOL_SIZE);\n-    ExecutorService tp = ThreadPools.createExecutorService(getConfiguration(),\n-        Property.MANAGER_STATUS_THREAD_POOL_SIZE);\n-    long start = System.currentTimeMillis();\n-    final SortedMap<TServerInstance,TabletServerStatus> result = new ConcurrentSkipListMap<>();\n-    final RateLimiter shutdownServerRateLimiter = RateLimiter.create(MAX_SHUTDOWNS_PER_SEC);\n-    for (TServerInstance serverInstance : currentServers) {\n-      final TServerInstance server = serverInstance;\n-      if (threads == 0) {\n-        // Since an unbounded thread pool is being used, rate limit how fast task are added to the\n-        // executor. This prevents the threads from growing large unless there are lots of\n-        // unresponsive tservers.\n-        sleepUninterruptibly(Math.max(1, rpcTimeout / 120_000), TimeUnit.MILLISECONDS);\n-      }\n-      tp.submit(() -> {\n-        try {\n-          Thread t = Thread.currentThread();\n-          String oldName = t.getName();\n-          try {\n-            String message = \"Getting status from \" + server;\n-            t.setName(message);\n-            long startForServer = System.currentTimeMillis();\n-            log.trace(message);\n-            TServerConnection connection1 = tserverSet.getConnection(server);\n-            if (connection1 == null) {\n-              throw new IOException(\"No connection to \" + server);\n-            }\n-            TabletServerStatus status = connection1.getTableMap(false);\n-            result.put(server, status);\n-\n-            long duration = System.currentTimeMillis() - startForServer;\n-            log.trace(\"Got status from {} in {} ms\", server, duration);\n-\n-          } finally {\n-            t.setName(oldName);\n-          }\n-        } catch (Exception ex) {\n-          log.error(\"unable to get tablet server status {} {}\", server, ex.toString());\n-          log.debug(\"unable to get tablet server status {}\", server, ex);\n-          // Attempt to shutdown server only if able to acquire. If unable, this tablet server\n-          // will be removed from the badServers set below and status will be reattempted again\n-          // MAX_BAD_STATUS_COUNT times\n-          if (badServers.computeIfAbsent(server, k -> new AtomicInteger(0)).incrementAndGet()\n-              > MAX_BAD_STATUS_COUNT) {\n-            if (shutdownServerRateLimiter.tryAcquire()) {\n-              log.warn(\"attempting to stop {}\", server);\n-              try {\n-                TServerConnection connection2 = tserverSet.getConnection(server);\n-                if (connection2 != null) {\n-                  connection2.halt(masterLock);\n-                }\n-              } catch (TTransportException e1) {\n-                // ignore: it's probably down\n-              } catch (Exception e2) {\n-                log.info(\"error talking to troublesome tablet server\", e2);\n-              }\n-            } else {\n-              log.warn(\"Unable to shutdown {} as over the shutdown limit of {} per minute\", server,\n-                  MAX_SHUTDOWNS_PER_SEC * 60);\n-            }\n-            badServers.remove(server);\n-          }\n-        }\n-      });\n-    }\n-    tp.shutdown();\n-    try {\n-      tp.awaitTermination(Math.max(10000, rpcTimeout / 3), TimeUnit.MILLISECONDS);\n-    } catch (InterruptedException e) {\n-      log.debug(\"Interrupted while fetching status\");\n-    }\n-\n-    tp.shutdownNow();\n-\n-    // Threads may still modify map after shutdownNow is called, so create an immutable snapshot.\n-    SortedMap<TServerInstance,TabletServerStatus> info = ImmutableSortedMap.copyOf(result);\n-    tserverStatus.forEach((tsi, status) -> balancerMap.put(new TabletServerIdImpl(tsi),\n-        TServerStatusImpl.fromThrift(status)));\n-\n-    synchronized (badServers) {\n-      badServers.keySet().retainAll(currentServers);\n-      badServers.keySet().removeAll(info.keySet());\n-    }\n-    log.debug(String.format(\"Finished gathering information from %d of %d servers in %.2f seconds\",\n-        info.size(), currentServers.size(), (System.currentTimeMillis() - start) / 1000.));\n-\n-    return info;\n-  }\n-\n-  @Override\n-  public void run() {\n-    final ServerContext context = getContext();\n-    final String zroot = getZooKeeperRoot();\n-\n-    // ACCUMULO-4424 Put up the Thrift servers before getting the lock as a sign of process health\n-    // when a hot-standby\n-    //\n-    // Start the Master's Client service\n-    clientHandler = new MasterClientServiceHandler(this);\n-    // Ensure that calls before the master gets the lock fail\n-    Iface haProxy = HighlyAvailableServiceWrapper.service(clientHandler, this);\n-    Iface rpcProxy = TraceUtil.wrapService(haProxy);\n-    final Processor<Iface> processor;\n-    if (context.getThriftServerType() == ThriftServerType.SASL) {\n-      Iface tcredsProxy = TCredentialsUpdatingWrapper.service(rpcProxy, clientHandler.getClass(),\n-          getConfiguration());\n-      processor = new Processor<>(tcredsProxy);\n-    } else {\n-      processor = new Processor<>(rpcProxy);\n-    }\n-    ServerAddress sa;\n-    try {\n-      sa = TServerUtils.startServer(getMetricsSystem(), context, getHostname(),\n-          Property.MANAGER_CLIENTPORT, processor, \"Master\", \"Master Client Service Handler\", null,\n-          Property.MANAGER_MINTHREADS, Property.MANAGER_MINTHREADS_TIMEOUT,\n-          Property.MANAGER_THREADCHECK, Property.GENERAL_MAX_MESSAGE_SIZE);\n-    } catch (UnknownHostException e) {\n-      throw new IllegalStateException(\"Unable to start server on host \" + getHostname(), e);\n-    }\n-    clientService = sa.server;\n-    log.info(\"Started Master client service at {}\", sa.address);\n-\n-    // block until we can obtain the ZK lock for the master\n-    try {\n-      getMasterLock(zroot + Constants.ZMASTER_LOCK);\n-    } catch (KeeperException | InterruptedException e) {\n-      throw new IllegalStateException(\"Exception getting master lock\", e);\n-    }\n-\n-    recoveryManager = new RecoveryManager(this, TIME_TO_CACHE_RECOVERY_WAL_EXISTENCE);\n-\n-    context.getTableManager().addObserver(this);\n-\n-    Thread statusThread = Threads.createThread(\"Status Thread\", new StatusThread());\n-    statusThread.start();\n-\n-    Threads.createThread(\"Migration Cleanup Thread\", new MigrationCleanupThread()).start();\n-\n-    tserverSet.startListeningForTabletServerChanges();\n-\n-    try {\n-      blockForTservers();\n-    } catch (InterruptedException ex) {\n-      Thread.currentThread().interrupt();\n-    }\n-\n-    ZooReaderWriter zReaderWriter = context.getZooReaderWriter();\n-\n-    try {\n-      zReaderWriter.getChildren(zroot + Constants.ZRECOVERY, new Watcher() {\n-        @Override\n-        public void process(WatchedEvent event) {\n-          nextEvent.event(\"Noticed recovery changes %s\", event.getType());\n-          try {\n-            // watcher only fires once, add it back\n-            zReaderWriter.getChildren(zroot + Constants.ZRECOVERY, this);\n-          } catch (Exception e) {\n-            log.error(\"Failed to add log recovery watcher back\", e);\n-          }\n-        }\n-      });\n-    } catch (KeeperException | InterruptedException e) {\n-      throw new IllegalStateException(\"Unable to read \" + zroot + Constants.ZRECOVERY, e);\n-    }\n-\n-    watchers.add(new TabletGroupWatcher(this,\n-        TabletStateStore.getStoreForLevel(DataLevel.USER, context, this), null) {\n-      @Override\n-      boolean canSuspendTablets() {\n-        // Always allow user data tablets to enter suspended state.\n-        return true;\n-      }\n-    });\n-\n-    watchers.add(new TabletGroupWatcher(this,\n-        TabletStateStore.getStoreForLevel(DataLevel.METADATA, context, this), watchers.get(0)) {\n-      @Override\n-      boolean canSuspendTablets() {\n-        // Allow metadata tablets to enter suspended state only if so configured. Generally\n-        // we'll want metadata tablets to\n-        // be immediately reassigned, even if there's a global table.suspension.duration\n-        // setting.\n-        return getConfiguration().getBoolean(Property.MANAGER_METADATA_SUSPENDABLE);\n-      }\n-    });\n-\n-    watchers.add(new TabletGroupWatcher(this,\n-        TabletStateStore.getStoreForLevel(DataLevel.ROOT, context), watchers.get(1)) {\n-      @Override\n-      boolean canSuspendTablets() {\n-        // Never allow root tablet to enter suspended state.\n-        return false;\n-      }\n-    });\n-    for (TabletGroupWatcher watcher : watchers) {\n-      watcher.start();\n-    }\n-\n-    // Once we are sure the upgrade is complete, we can safely allow fate use.\n-    try {\n-      // wait for metadata upgrade running in background to complete\n-      if (null != upgradeMetadataFuture) {\n-        upgradeMetadataFuture.get();\n-      }\n-    } catch (ExecutionException | InterruptedException e) {\n-      throw new IllegalStateException(\"Metadata upgrade failed\", e);\n-    }\n-\n-    try {\n-      final AgeOffStore<Master> store = new AgeOffStore<>(new org.apache.accumulo.fate.ZooStore<>(\n-          getZooKeeperRoot() + Constants.ZFATE, context.getZooReaderWriter()), 1000 * 60 * 60 * 8);\n-\n-      fate = new Fate<>(this, store, TraceRepo::toLogString);\n-      fate.startTransactionRunners(getConfiguration());\n-\n-      ThreadPools.createGeneralScheduledExecutorService(getConfiguration())\n-          .scheduleWithFixedDelay(store::ageOff, 63000, 63000, TimeUnit.MILLISECONDS);\n-    } catch (KeeperException | InterruptedException e) {\n-      throw new IllegalStateException(\"Exception setting up FaTE cleanup thread\", e);\n-    }\n-\n-    try {\n-      ZooKeeperInitialization.ensureZooKeeperInitialized(zReaderWriter, zroot);\n-    } catch (KeeperException | InterruptedException e) {\n-      throw new IllegalStateException(\"Exception while ensuring ZooKeeper is initialized\", e);\n-    }\n-\n-    // Make sure that we have a secret key (either a new one or an old one from ZK) before we start\n-    // the master client service.\n-    Thread authenticationTokenKeyManagerThread = null;\n-    if (authenticationTokenKeyManager != null && keyDistributor != null) {\n-      log.info(\"Starting delegation-token key manager\");\n-      try {\n-        keyDistributor.initialize();\n-      } catch (KeeperException | InterruptedException e) {\n-        throw new IllegalStateException(\"Exception setting up delegation-token key manager\", e);\n-      }\n-      authenticationTokenKeyManagerThread =\n-          Threads.createThread(\"Delegation Token Key Manager\", authenticationTokenKeyManager);\n-      authenticationTokenKeyManagerThread.start();\n-      boolean logged = false;\n-      while (!authenticationTokenKeyManager.isInitialized()) {\n-        // Print out a status message when we start waiting for the key manager to get initialized\n-        if (!logged) {\n-          log.info(\"Waiting for AuthenticationTokenKeyManager to be initialized\");\n-          logged = true;\n-        }\n-        sleepUninterruptibly(200, TimeUnit.MILLISECONDS);\n-      }\n-      // And log when we are initialized\n-      log.info(\"AuthenticationTokenSecretManager is initialized\");\n-    }\n-\n-    String address = sa.address.toString();\n-    log.info(\"Setting master lock data to {}\", address);\n-    try {\n-      masterLock.replaceLockData(address.getBytes());\n-    } catch (KeeperException | InterruptedException e) {\n-      throw new IllegalStateException(\"Exception updating master lock\", e);\n-    }\n-\n-    while (!clientService.isServing()) {\n-      sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-    }\n-\n-    // if the replication name is ever set, then start replication services\n-    final AtomicReference<TServer> replServer = new AtomicReference<>();\n-    ThreadPools.createGeneralScheduledExecutorService(getConfiguration())\n-        .scheduleWithFixedDelay(() -> {\n-          try {\n-            if (replServer.get() == null) {\n-              if (!getConfiguration().get(Property.REPLICATION_NAME).isEmpty()) {\n-                log.info(Property.REPLICATION_NAME.getKey() + \" was set, starting repl services.\");\n-                replServer.set(setupReplication());\n-              }\n-            }\n-          } catch (UnknownHostException | KeeperException | InterruptedException e) {\n-            log.error(\"Error occurred starting replication services. \", e);\n-          }\n-        }, 0, 5000, TimeUnit.MILLISECONDS);\n-\n-    // Register metrics modules\n-    int failureCount = new MasterMetricsFactory(getConfiguration()).register(this);\n-\n-    if (failureCount > 0) {\n-      log.info(\"Failed to register {} metrics modules\", failureCount);\n-    } else {\n-      log.info(\"All metrics modules registered\");\n-    }\n-\n-    // checking stored user hashes if any of them uses an outdated algorithm\n-    security.validateStoredUserCreditentials();\n-\n-    // The master is fully initialized. Clients are allowed to connect now.\n-    masterInitialized.set(true);\n-\n-    while (clientService.isServing()) {\n-      sleepUninterruptibly(500, TimeUnit.MILLISECONDS);\n-    }\n-    log.info(\"Shutting down fate.\");\n-    fate.shutdown();\n-\n-    final long deadline = System.currentTimeMillis() + MAX_CLEANUP_WAIT_TIME;\n-    try {\n-      statusThread.join(remaining(deadline));\n-      if (null != replicationAssignerThread) {\n-        replicationAssignerThread.join(remaining(deadline));\n-      }\n-      if (null != replicationWorkThread) {\n-        replicationWorkThread.join(remaining(deadline));\n-      }\n-    } catch (InterruptedException e) {\n-      throw new IllegalStateException(\"Exception stopping replication workers\", e);\n-    }\n-    TServerUtils.stopTServer(replServer.get());\n-\n-    // Signal that we want it to stop, and wait for it to do so.\n-    if (authenticationTokenKeyManager != null) {\n-      authenticationTokenKeyManager.gracefulStop();\n-      try {\n-        if (null != authenticationTokenKeyManagerThread) {\n-          authenticationTokenKeyManagerThread.join(remaining(deadline));\n-        }\n-      } catch (InterruptedException e) {\n-        throw new IllegalStateException(\"Exception waiting on delegation-token key manager\", e);\n-      }\n-    }\n-\n-    // quit, even if the tablet servers somehow jam up and the watchers\n-    // don't stop\n-    for (TabletGroupWatcher watcher : watchers) {\n-      try {\n-        watcher.join(remaining(deadline));\n-      } catch (InterruptedException e) {\n-        throw new IllegalStateException(\"Exception waiting on watcher\", e);\n-      }\n-    }\n-    log.info(\"exiting\");\n-  }\n-\n-  /**\n-   * Allows property configuration to block master start-up waiting for a minimum number of tservers\n-   * to register in zookeeper. It also accepts a maximum time to wait - if the time expires, the\n-   * start-up will continue with any tservers available. This check is only performed at master\n-   * initialization, when the master acquires the lock. The following properties are used to control\n-   * the behaviour:\n-   * <ul>\n-   * <li>MASTER_STARTUP_TSERVER_AVAIL_MIN_COUNT - when set to 0 or less, no blocking occurs (default\n-   * behaviour) otherwise will block until the number of tservers are available.</li>\n-   * <li>MASTER_STARTUP_TSERVER_AVAIL_MAX_WAIT - time to wait in milliseconds. When set to 0 or\n-   * less, will block indefinitely.</li>\n-   * </ul>\n-   *\n-   * @throws InterruptedException\n-   *           if interrupted while blocking, propagated for caller to handle.\n-   */\n-  private void blockForTservers() throws InterruptedException {\n-\n-    long waitStart = System.currentTimeMillis();\n-\n-    long minTserverCount =\n-        getConfiguration().getCount(Property.MANAGER_STARTUP_TSERVER_AVAIL_MIN_COUNT);\n-\n-    if (minTserverCount <= 0) {\n-      log.info(\"tserver availability check disabled, continuing with-{} servers. To enable, set {}\",\n-          tserverSet.size(), Property.MANAGER_STARTUP_TSERVER_AVAIL_MIN_COUNT.getKey());\n-      return;\n-    }\n-\n-    long maxWait =\n-        getConfiguration().getTimeInMillis(Property.MANAGER_STARTUP_TSERVER_AVAIL_MAX_WAIT);\n-\n-    if (maxWait <= 0) {\n-      log.info(\"tserver availability check set to block indefinitely, To change, set {} > 0.\",\n-          Property.MANAGER_STARTUP_TSERVER_AVAIL_MAX_WAIT.getKey());\n-      maxWait = Long.MAX_VALUE;\n-    }\n-\n-    // honor Retry condition that initial wait < max wait, otherwise use small value to allow thread\n-    // yield to happen\n-    long initialWait = Math.min(50, maxWait / 2);\n-\n-    Retry tserverRetry =\n-        Retry.builder().infiniteRetries().retryAfter(initialWait, TimeUnit.MILLISECONDS)\n-            .incrementBy(15_000, TimeUnit.MILLISECONDS).maxWait(maxWait, TimeUnit.MILLISECONDS)\n-            .backOffFactor(1).logInterval(30_000, TimeUnit.MILLISECONDS).createRetry();\n-\n-    log.info(\"Checking for tserver availability - need to reach {} servers. Have {}\",\n-        minTserverCount, tserverSet.size());\n-\n-    boolean needTservers = tserverSet.size() < minTserverCount;\n-\n-    while (needTservers && tserverRetry.canRetry()) {\n-\n-      tserverRetry.waitForNextAttempt();\n-\n-      needTservers = tserverSet.size() < minTserverCount;\n-\n-      // suppress last message once threshold reached.\n-      if (needTservers) {\n-        log.info(\n-            \"Blocking for tserver availability - need to reach {} servers. Have {}\"\n-                + \" Time spent blocking {} sec.\",\n-            minTserverCount, tserverSet.size(),\n-            TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - waitStart));\n-      }\n-    }\n-\n-    if (tserverSet.size() < minTserverCount) {\n-      log.warn(\n-          \"tserver availability check time expired - continuing. Requested {}, have {} tservers on line. \"\n-              + \" Time waiting {} ms\",\n-          tserverSet.size(), minTserverCount,\n-          TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - waitStart));\n-\n-    } else {\n-      log.info(\n-          \"tserver availability check completed. Requested {}, have {} tservers on line. \"\n-              + \" Time waiting {} ms\",\n-          tserverSet.size(), minTserverCount,\n-          TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - waitStart));\n-    }\n-  }\n-\n-  private TServer setupReplication()\n-      throws UnknownHostException, KeeperException, InterruptedException {\n-    ServerContext context = getContext();\n-    // Start the replication coordinator which assigns tservers to service replication requests\n-    MasterReplicationCoordinator impl = new MasterReplicationCoordinator(this);\n-    ReplicationCoordinator.Iface haReplicationProxy =\n-        HighlyAvailableServiceWrapper.service(impl, this);\n-    ReplicationCoordinator.Processor<ReplicationCoordinator.Iface> replicationCoordinatorProcessor =\n-        new ReplicationCoordinator.Processor<>(TraceUtil.wrapService(haReplicationProxy));\n-    ServerAddress replAddress = TServerUtils.startServer(getMetricsSystem(), context, getHostname(),\n-        Property.MANAGER_REPLICATION_COORDINATOR_PORT, replicationCoordinatorProcessor,\n-        \"Master Replication Coordinator\", \"Replication Coordinator\", null,\n-        Property.MANAGER_REPLICATION_COORDINATOR_MINTHREADS, null,\n-        Property.MANAGER_REPLICATION_COORDINATOR_THREADCHECK, Property.GENERAL_MAX_MESSAGE_SIZE);\n-\n-    log.info(\"Started replication coordinator service at \" + replAddress.address);\n-    // Start the daemon to scan the replication table and make units of work\n-    replicationWorkThread = Threads.createThread(\"Replication Driver\", new ReplicationDriver(this));\n-    replicationWorkThread.start();\n-\n-    // Start the daemon to assign work to tservers to replicate to our peers\n-    WorkDriver wd = new WorkDriver(this);\n-    replicationAssignerThread = Threads.createThread(wd.getName(), wd);\n-    replicationAssignerThread.start();\n-\n-    // Advertise that port we used so peers don't have to be told what it is\n-    context.getZooReaderWriter().putPersistentData(\n-        getZooKeeperRoot() + Constants.ZMASTER_REPLICATION_COORDINATOR_ADDR,\n-        replAddress.address.toString().getBytes(UTF_8), NodeExistsPolicy.OVERWRITE);\n-    return replAddress.server;\n-  }\n-\n-  private long remaining(long deadline) {\n-    return Math.max(1, deadline - System.currentTimeMillis());\n-  }\n-\n-  public ZooLock getMasterLock() {\n-    return masterLock;\n-  }\n-\n-  private static class MasterLockWatcher implements ZooLock.AccumuloLockWatcher {\n-\n-    boolean acquiredLock = false;\n-    boolean failedToAcquireLock = false;\n-\n-    @Override\n-    public void lostLock(LockLossReason reason) {\n-      Halt.halt(\"Master lock in zookeeper lost (reason = \" + reason + \"), exiting!\", -1);\n-    }\n-\n-    @Override\n-    public void unableToMonitorLockNode(final Exception e) {\n-      // ACCUMULO-3651 Changed level to error and added FATAL to message for slf4j compatibility\n-      Halt.halt(-1, () -> log.error(\"FATAL: No longer able to monitor master lock node\", e));\n-\n-    }\n-\n-    @Override\n-    public synchronized void acquiredLock() {\n-      log.debug(\"Acquired master lock\");\n-\n-      if (acquiredLock || failedToAcquireLock) {\n-        Halt.halt(\"Zoolock in unexpected state AL \" + acquiredLock + \" \" + failedToAcquireLock, -1);\n-      }\n-\n-      acquiredLock = true;\n-      notifyAll();\n-    }\n-\n-    @Override\n-    public synchronized void failedToAcquireLock(Exception e) {\n-      log.warn(\"Failed to get master lock\", e);\n-\n-      if (e instanceof NoAuthException) {\n-        String msg = \"Failed to acquire master lock due to incorrect ZooKeeper authentication.\";\n-        log.error(\"{} Ensure instance.secret is consistent across Accumulo configuration\", msg, e);\n-        Halt.halt(msg, -1);\n-      }\n-\n-      if (acquiredLock) {\n-        Halt.halt(\"Zoolock in unexpected state FAL \" + acquiredLock + \" \" + failedToAcquireLock,\n-            -1);\n-      }\n-\n-      failedToAcquireLock = true;\n-      notifyAll();\n-    }\n-\n-    public synchronized void waitForChange() {\n-      while (!acquiredLock && !failedToAcquireLock) {\n-        try {\n-          wait();\n-        } catch (InterruptedException e) {}\n-      }\n-    }\n-  }\n-\n-  private void getMasterLock(final String zMasterLoc) throws KeeperException, InterruptedException {\n-    ServerContext context = getContext();\n-    log.info(\"trying to get master lock\");\n-\n-    final String masterClientAddress =\n-        getHostname() + \":\" + getConfiguration().getPort(Property.MANAGER_CLIENTPORT)[0];\n-\n-    UUID zooLockUUID = UUID.randomUUID();\n-    while (true) {\n-\n-      MasterLockWatcher masterLockWatcher = new MasterLockWatcher();\n-      masterLock = new ZooLock(context.getSiteConfiguration(), zMasterLoc, zooLockUUID);\n-      masterLock.lock(masterLockWatcher, masterClientAddress.getBytes());\n-\n-      masterLockWatcher.waitForChange();\n-\n-      if (masterLockWatcher.acquiredLock) {\n-        break;\n-      }\n-\n-      if (!masterLockWatcher.failedToAcquireLock) {\n-        throw new IllegalStateException(\"master lock in unknown state\");\n-      }\n-\n-      masterLock.tryToCancelAsyncLockOrUnlock();\n-\n-      sleepUninterruptibly(TIME_TO_WAIT_BETWEEN_LOCK_CHECKS, TimeUnit.MILLISECONDS);\n-    }\n-\n-    setMasterState(MasterState.HAVE_LOCK);\n-  }\n-\n-  @Override\n-  public void update(LiveTServerSet current, Set<TServerInstance> deleted,\n-      Set<TServerInstance> added) {\n-    // if we have deleted or added tservers, then adjust our dead server list\n-    if (!deleted.isEmpty() || !added.isEmpty()) {\n-      DeadServerList obit = new DeadServerList(getContext());\n-      if (!added.isEmpty()) {\n-        log.info(\"New servers: {}\", added);\n-        for (TServerInstance up : added) {\n-          obit.delete(up.getHostPort());\n-        }\n-      }\n-      for (TServerInstance dead : deleted) {\n-        String cause = \"unexpected failure\";\n-        if (serversToShutdown.contains(dead)) {\n-          cause = \"clean shutdown\"; // maybe an incorrect assumption\n-        }\n-        if (!getMasterGoalState().equals(MasterGoalState.CLEAN_STOP)) {\n-          obit.post(dead.getHostPort(), cause);\n-        }\n-      }\n-\n-      Set<TServerInstance> unexpected = new HashSet<>(deleted);\n-      unexpected.removeAll(this.serversToShutdown);\n-      if (!unexpected.isEmpty()) {\n-        if (stillMaster() && !getMasterGoalState().equals(MasterGoalState.CLEAN_STOP)) {\n-          log.warn(\"Lost servers {}\", unexpected);\n-        }\n-      }\n-      serversToShutdown.removeAll(deleted);\n-      badServers.keySet().removeAll(deleted);\n-      // clear out any bad server with the same host/port as a new server\n-      synchronized (badServers) {\n-        cleanListByHostAndPort(badServers.keySet(), deleted, added);\n-      }\n-      synchronized (serversToShutdown) {\n-        cleanListByHostAndPort(serversToShutdown, deleted, added);\n-      }\n-\n-      synchronized (migrations) {\n-        Iterator<Entry<KeyExtent,TServerInstance>> iter = migrations.entrySet().iterator();\n-        while (iter.hasNext()) {\n-          Entry<KeyExtent,TServerInstance> entry = iter.next();\n-          if (deleted.contains(entry.getValue())) {\n-            log.info(\"Canceling migration of {} to {}\", entry.getKey(), entry.getValue());\n-            iter.remove();\n-          }\n-        }\n-      }\n-      nextEvent.event(\"There are now %d tablet servers\", current.size());\n-    }\n-\n-    // clear out any servers that are no longer current\n-    // this is needed when we are using a fate operation to shutdown a tserver as it\n-    // will continue to add the server to the serversToShutdown (ACCUMULO-4410)\n-    serversToShutdown.retainAll(current.getCurrentServers());\n-  }\n-\n-  private static void cleanListByHostAndPort(Collection<TServerInstance> badServers,\n-      Set<TServerInstance> deleted, Set<TServerInstance> added) {\n-    Iterator<TServerInstance> badIter = badServers.iterator();\n-    while (badIter.hasNext()) {\n-      TServerInstance bad = badIter.next();\n-      for (TServerInstance add : added) {\n-        if (bad.getHostPort().equals(add.getHostPort())) {\n-          badIter.remove();\n-          break;\n-        }\n-      }\n-      for (TServerInstance del : deleted) {\n-        if (bad.getHostPort().equals(del.getHostPort())) {\n-          badIter.remove();\n-          break;\n-        }\n-      }\n-    }\n-  }\n-\n-  @Override\n-  public void stateChanged(TableId tableId, TableState state) {\n-    nextEvent.event(\"Table state in zookeeper changed for %s to %s\", tableId, state);\n-    if (state == TableState.OFFLINE) {\n-      clearMigrations(tableId);\n-    }\n-  }\n-\n-  @Override\n-  public void initialize() {}\n-\n-  @Override\n-  public void sessionExpired() {}\n-\n-  @Override\n-  public Set<TableId> onlineTables() {\n-    Set<TableId> result = new HashSet<>();\n-    if (getMasterState() != MasterState.NORMAL) {\n-      if (getMasterState() != MasterState.UNLOAD_METADATA_TABLETS) {\n-        result.add(MetadataTable.ID);\n-      }\n-      if (getMasterState() != MasterState.UNLOAD_ROOT_TABLET) {\n-        result.add(RootTable.ID);\n-      }\n-      return result;\n-    }\n-    ServerContext context = getContext();\n-    TableManager manager = context.getTableManager();\n-\n-    for (TableId tableId : Tables.getIdToNameMap(context).keySet()) {\n-      TableState state = manager.getTableState(tableId);\n-      if (state != null) {\n-        if (state == TableState.ONLINE) {\n-          result.add(tableId);\n-        }\n-      }\n-    }\n-    return result;\n-  }\n-\n-  @Override\n-  public Set<TServerInstance> onlineTabletServers() {\n-    return tserverSet.getCurrentServers();\n-  }\n-\n-  @Override\n-  public Collection<MergeInfo> merges() {\n-    List<MergeInfo> result = new ArrayList<>();\n-    for (TableId tableId : Tables.getIdToNameMap(getContext()).keySet()) {\n-      result.add(getMergeInfo(tableId));\n-    }\n-    return result;\n-  }\n-\n-  // recovers state from the persistent transaction to shutdown a server\n-  public void shutdownTServer(TServerInstance server) {\n-    nextEvent.event(\"Tablet Server shutdown requested for %s\", server);\n-    serversToShutdown.add(server);\n-  }\n-\n-  public EventCoordinator getEventCoordinator() {\n-    return nextEvent;\n-  }\n-\n-  public VolumeManager getVolumeManager() {\n-    return getContext().getVolumeManager();\n-  }\n-\n-  public void assignedTablet(KeyExtent extent) {\n-    if (extent.isMeta()) {\n-      if (getMasterState().equals(MasterState.UNLOAD_ROOT_TABLET)) {\n-        setMasterState(MasterState.UNLOAD_METADATA_TABLETS);\n-      }\n-    }\n-    if (extent.isRootTablet()) {\n-      // probably too late, but try anyhow\n-      if (getMasterState().equals(MasterState.STOP)) {\n-        setMasterState(MasterState.UNLOAD_ROOT_TABLET);\n-      }\n-    }\n-  }\n-\n-  @SuppressFBWarnings(value = \"UW_UNCOND_WAIT\", justification = \"TODO needs triage\")\n-  public void waitForBalance() {\n-    synchronized (balancedNotifier) {\n-      long eventCounter;\n-      do {\n-        eventCounter = nextEvent.waitForEvents(0, 0);\n-        try {\n-          balancedNotifier.wait();\n-        } catch (InterruptedException e) {\n-          log.debug(e.toString(), e);\n-        }\n-      } while (displayUnassigned() > 0 || !migrations.isEmpty()\n-          || eventCounter != nextEvent.waitForEvents(0, 0));\n-    }\n-  }\n-\n-  public MasterMonitorInfo getMasterMonitorInfo() {\n-    final MasterMonitorInfo result = new MasterMonitorInfo();\n-\n-    result.tServerInfo = new ArrayList<>();\n-    result.tableMap = new HashMap<>();\n-    for (Entry<TServerInstance,TabletServerStatus> serverEntry : tserverStatus.entrySet()) {\n-      final TabletServerStatus status = serverEntry.getValue();\n-      result.tServerInfo.add(status);\n-      for (Entry<String,TableInfo> entry : status.tableMap.entrySet()) {\n-        TableInfoUtil.add(result.tableMap.computeIfAbsent(entry.getKey(), k -> new TableInfo()),\n-            entry.getValue());\n-      }\n-    }\n-    result.badTServers = new HashMap<>();\n-    synchronized (badServers) {\n-      for (TServerInstance bad : badServers.keySet()) {\n-        result.badTServers.put(bad.getHostPort(), TabletServerState.UNRESPONSIVE.getId());\n-      }\n-    }\n-    result.state = getMasterState();\n-    result.goalState = getMasterGoalState();\n-    result.unassignedTablets = displayUnassigned();\n-    result.serversShuttingDown = new HashSet<>();\n-    synchronized (serversToShutdown) {\n-      for (TServerInstance server : serversToShutdown) {\n-        result.serversShuttingDown.add(server.getHostPort());\n-      }\n-    }\n-    DeadServerList obit = new DeadServerList(getContext());\n-    result.deadTabletServers = obit.getList();\n-    result.bulkImports = bulkImportStatus.getBulkLoadStatus();\n-    return result;\n-  }\n-\n-  /**\n-   * Can delegation tokens be generated for users\n-   */\n-  public boolean delegationTokensAvailable() {\n-    return delegationTokensAvailable;\n-  }\n-\n-  @Override\n-  public Set<KeyExtent> migrationsSnapshot() {\n-    Set<KeyExtent> migrationKeys;\n-    synchronized (migrations) {\n-      migrationKeys = new HashSet<>(migrations.keySet());\n-    }\n-    return Collections.unmodifiableSet(migrationKeys);\n-  }\n-\n-  @Override\n-  public Set<TServerInstance> shutdownServers() {\n-    synchronized (serversToShutdown) {\n-      return new HashSet<>(serversToShutdown);\n-    }\n-  }\n-\n-  public void updateBulkImportStatus(String directory, BulkImportState state) {\n-    bulkImportStatus.updateBulkImportStatus(Collections.singletonList(directory), state);\n-  }\n-\n-  public void removeBulkImportStatus(String directory) {\n-    bulkImportStatus.removeBulkImportStatus(Collections.singletonList(directory));\n-  }\n-\n-  /**\n-   * Return how long (in milliseconds) there has been a master overseeing this cluster. This is an\n-   * approximately monotonic clock, which will be approximately consistent between different masters\n-   * or different runs of the same master.\n-   */\n-  public Long getSteadyTime() {\n-    return timeKeeper.getTime();\n-  }\n-\n-  @Override\n-  public boolean isActiveService() {\n-    return masterInitialized.get();\n-  }\n-\n-  void initializeBalancer() {\n-    var localTabletBalancer = Property.createInstanceFromPropertyName(getConfiguration(),\n-        Property.MANAGER_TABLET_BALANCER, TabletBalancer.class, new SimpleLoadBalancer());\n-    localTabletBalancer.init(balancerEnvironment);\n-    tabletBalancer = localTabletBalancer;\n-  }\n-\n-  Class<?> getBalancerClass() {\n-    return tabletBalancer.getClass();\n-  }\n-\n-  void getAssignments(SortedMap<TServerInstance,TabletServerStatus> currentStatus,\n-      Map<KeyExtent,TServerInstance> unassigned, Map<KeyExtent,TServerInstance> assignedOut) {\n-    AssignmentParamsImpl params =\n-        AssignmentParamsImpl.fromThrift(currentStatus, unassigned, assignedOut);\n-    tabletBalancer.getAssignments(params);\n+    LOG.warn(\"Usage of {} directly has been deprecated. Use {} with keyword manager instead.\",\n+        Master.class.getName(), Main.class.getName());\n+    new MasterExecutable().execute(args);\n   }\n }\n", "next_change": {"commit": "3d7d2a5809ee1a33b5d8fa097a2345f51b5924da", "changed_code": [{"header": "diff --git a/server/manager/src/main/java/org/apache/accumulo/master/Master.java b/server/manager/src/main/java/org/apache/accumulo/master/Master.java\ndeleted file mode 100644\nindex b78ed733a5..0000000000\n--- a/server/manager/src/main/java/org/apache/accumulo/master/Master.java\n+++ /dev/null\n", "chunk": "@@ -1,38 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.master;\n-\n-import org.apache.accumulo.manager.MasterExecutable;\n-import org.apache.accumulo.start.Main;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * @deprecated since 2.1.0. Use {@link Main} with keyword \"manager\" instead.\n- */\n-@Deprecated(since = \"2.1.0\")\n-public class Master {\n-  private static final Logger LOG = LoggerFactory.getLogger(Master.class);\n-\n-  public static void main(String[] args) throws Exception {\n-    LOG.warn(\"Usage of {} directly has been deprecated. Use {} with keyword manager instead.\",\n-        Master.class.getName(), Main.class.getName());\n-    new MasterExecutable().execute(args);\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "bbd87a6693fc5cdbbe947b0821a4f05a18cf905b", "committedDate": "2021-01-19 08:07:07 -0500", "message": "Closes #1689: Don't catch Throwable (unless it's rethrown) (#1840)"}, {"oid": "9fdfaff15bfb1a1ec91512c3e9d08b5bdb45efb1", "committedDate": "2021-01-26 08:31:01 -0500", "message": "Add tserver to badservers instead of dropping. Fixes #1775 (#1878)"}, {"oid": "300c933baa5800fd3bdcee2793dd416aeb26a9e6", "committedDate": "2021-01-26 08:40:13 -0500", "message": "Deprecate/replace 'master.*' properties with 'manager.*'. (fixes #1640) (#1873)"}, {"oid": "fd70e086bf4d9add11d7bc1cef1d2b30954e9efa", "committedDate": "2021-02-01 13:32:49 -0500", "message": "Closes #637: Add a UUID to the server's ZooLock (#1866)"}, {"oid": "dd0dfd89c84e92659c971705777bbf902d32e82a", "committedDate": "2021-02-03 16:02:43 -0500", "message": "re #1086: modify ZooLock to use the native zookeeper client (#1896)"}, {"oid": "95a8df18049118fcf3b5564e325a08af47e0a964", "committedDate": "2021-02-04 07:29:52 -0500", "message": "Add TabletBalancer to SPI package (#1891)"}, {"oid": "675e41aaed0f8ae250d97a10dad35a8aef4c3e82", "committedDate": "2021-02-04 07:55:40 -0500", "message": "Rename master packages to manager. (#1904)"}, {"oid": "e6164901a3acdd464a7a9beff0126097b53fc06f", "committedDate": "2021-02-05 09:31:25 -0500", "message": "Rename Master to Manager in class names. (#1907)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "3d7d2a5809ee1a33b5d8fa097a2345f51b5924da", "committedDate": "2023-03-09 09:22:05 -0500", "message": "Remove some deprecated items (#3229)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4OTIwOA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532889208", "body": "I'm curious what non-critical use cases we still have for this, that would warrant continuing to swallow OOM errors and such.", "bodyText": "I'm curious what non-critical use cases we still have for this, that would warrant continuing to swallow OOM errors and such.", "bodyHTML": "<p dir=\"auto\">I'm curious what non-critical use cases we still have for this, that would warrant continuing to swallow OOM errors and such.</p>", "author": "ctubbsii", "createdAt": "2020-11-30T20:39:40Z", "path": "server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleTimer.java", "diffHunk": "@@ -100,10 +93,19 @@ static int getInstanceThreadPoolSize() {\n     return instanceThreadPoolSize;\n   }\n \n-  private SimpleTimer(int threadPoolSize) {\n+  protected SimpleTimer(int threadPoolSize) {\n     executor = Executors.newScheduledThreadPool(threadPoolSize,\n         new ThreadFactoryBuilder().setNameFormat(\"SimpleTimer-%d\").setDaemon(true)\n-            .setUncaughtExceptionHandler(new ExceptionHandler()).build());\n+            .setUncaughtExceptionHandler(getUncaughtExceptionHandler()).build());\n+  }\n+\n+  protected Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() {\n+    return new Thread.UncaughtExceptionHandler() {\n+      @Override\n+      public void uncaughtException(Thread t, Throwable e) {\n+        log.warn(\"SimpleTimer task failed\", e);\n+      }\n+    };", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMDQ1Mw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532900453", "bodyText": "I agree, I'm not sure I have the ability to decide what is critical vs what is not. I came across a reference to new JVM parameters that may take OOME handling out of our hands: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8152669", "author": "dlmarion", "createdAt": "2020-11-30T21:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4OTIwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxMDM4Nw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532910387", "bodyText": "It looks like this new parameter does not work in all cases. https://bugs.openjdk.java.net/browse/JDK-8155004.", "author": "dlmarion", "createdAt": "2020-11-30T21:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4OTIwOA=="}], "type": "inlineReview", "revised_code": {"commit": "de1846bcd05b9d967b760146580fa8eadc4545e8", "changed_code": [{"header": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleTimer.java b/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleTimer.java\ndeleted file mode 100644\nindex 70bec393e1..0000000000\n--- a/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleTimer.java\n+++ /dev/null\n", "chunk": "@@ -1,138 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.server.util.time;\n-\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n-\n-/**\n- * Generic singleton timer. Don't use this if you are going to do anything that will take very long.\n- * Please use it to reduce the number of threads dedicated to simple events.\n- */\n-public class SimpleTimer {\n-  private static final Logger log = LoggerFactory.getLogger(SimpleTimer.class);\n-\n-  private static int instanceThreadPoolSize = -1;\n-  private static SimpleTimer instance;\n-  private ScheduledExecutorService executor;\n-\n-  protected static final int DEFAULT_THREAD_POOL_SIZE = 1;\n-\n-  /**\n-   * Gets the timer instance. If an instance has already been created, it will have the number of\n-   * threads supplied when it was constructed, and the size provided here is ignored.\n-   *\n-   * @param threadPoolSize\n-   *          number of threads\n-   */\n-  public static synchronized SimpleTimer getInstance(int threadPoolSize) {\n-    if (instance == null) {\n-      instance = new SimpleTimer(threadPoolSize);\n-      SimpleTimer.instanceThreadPoolSize = threadPoolSize;\n-    } else {\n-      if (SimpleTimer.instanceThreadPoolSize != threadPoolSize) {\n-        log.warn(\"Asked to create SimpleTimer with thread pool size {}, existing instance has {}\",\n-            threadPoolSize, instanceThreadPoolSize);\n-      }\n-    }\n-    return instance;\n-  }\n-\n-  /**\n-   * Gets the timer instance. If an instance has already been created, it will have the number of\n-   * threads supplied when it was constructed, and the size provided by the configuration here is\n-   * ignored. If a null configuration is supplied, the number of threads defaults to 1.\n-   *\n-   * @param conf\n-   *          configuration from which to get the number of threads\n-   * @see Property#GENERAL_SIMPLETIMER_THREADPOOL_SIZE\n-   */\n-  public static synchronized SimpleTimer getInstance(AccumuloConfiguration conf) {\n-    int threadPoolSize;\n-    if (conf != null) {\n-      threadPoolSize = conf.getCount(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    } else {\n-      threadPoolSize = DEFAULT_THREAD_POOL_SIZE;\n-    }\n-    return getInstance(threadPoolSize);\n-  }\n-\n-  /**\n-   * Gets the thread pool size for the timer instance. Use for testing only.\n-   *\n-   * @return thread pool size for timer instance, or -1 if not yet constructed\n-   */\n-  @VisibleForTesting\n-  static int getInstanceThreadPoolSize() {\n-    return instanceThreadPoolSize;\n-  }\n-\n-  protected SimpleTimer(int threadPoolSize) {\n-    executor = Executors.newScheduledThreadPool(threadPoolSize,\n-        new ThreadFactoryBuilder().setNameFormat(\"SimpleTimer-%d\").setDaemon(true)\n-            .setUncaughtExceptionHandler(getUncaughtExceptionHandler()).build());\n-  }\n-\n-  protected Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() {\n-    return new Thread.UncaughtExceptionHandler() {\n-      @Override\n-      public void uncaughtException(Thread t, Throwable e) {\n-        log.warn(\"SimpleTimer task failed\", e);\n-      }\n-    };\n-  }\n-\n-  /**\n-   * Schedules a task to run in the future.\n-   *\n-   * @param task\n-   *          task to run\n-   * @param delay\n-   *          number of milliseconds to wait before execution\n-   * @return future for scheduled task\n-   */\n-  public ScheduledFuture<?> schedule(Runnable task, long delay) {\n-    return executor.schedule(task, delay, TimeUnit.MILLISECONDS);\n-  }\n-\n-  /**\n-   * Schedules a task to run in the future with a fixed delay between repeated executions.\n-   *\n-   * @param task\n-   *          task to run\n-   * @param delay\n-   *          number of milliseconds to wait before first execution\n-   * @param period\n-   *          number of milliseconds to wait between executions\n-   * @return future for scheduled task\n-   */\n-  public ScheduledFuture<?> schedule(Runnable task, long delay, long period) {\n-    return executor.scheduleWithFixedDelay(task, delay, period, TimeUnit.MILLISECONDS);\n-  }\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleTimer.java b/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleTimer.java\ndeleted file mode 100644\nindex 70bec393e1..0000000000\n--- a/server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleTimer.java\n+++ /dev/null\n", "chunk": "@@ -1,138 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.server.util.time;\n-\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n-\n-/**\n- * Generic singleton timer. Don't use this if you are going to do anything that will take very long.\n- * Please use it to reduce the number of threads dedicated to simple events.\n- */\n-public class SimpleTimer {\n-  private static final Logger log = LoggerFactory.getLogger(SimpleTimer.class);\n-\n-  private static int instanceThreadPoolSize = -1;\n-  private static SimpleTimer instance;\n-  private ScheduledExecutorService executor;\n-\n-  protected static final int DEFAULT_THREAD_POOL_SIZE = 1;\n-\n-  /**\n-   * Gets the timer instance. If an instance has already been created, it will have the number of\n-   * threads supplied when it was constructed, and the size provided here is ignored.\n-   *\n-   * @param threadPoolSize\n-   *          number of threads\n-   */\n-  public static synchronized SimpleTimer getInstance(int threadPoolSize) {\n-    if (instance == null) {\n-      instance = new SimpleTimer(threadPoolSize);\n-      SimpleTimer.instanceThreadPoolSize = threadPoolSize;\n-    } else {\n-      if (SimpleTimer.instanceThreadPoolSize != threadPoolSize) {\n-        log.warn(\"Asked to create SimpleTimer with thread pool size {}, existing instance has {}\",\n-            threadPoolSize, instanceThreadPoolSize);\n-      }\n-    }\n-    return instance;\n-  }\n-\n-  /**\n-   * Gets the timer instance. If an instance has already been created, it will have the number of\n-   * threads supplied when it was constructed, and the size provided by the configuration here is\n-   * ignored. If a null configuration is supplied, the number of threads defaults to 1.\n-   *\n-   * @param conf\n-   *          configuration from which to get the number of threads\n-   * @see Property#GENERAL_SIMPLETIMER_THREADPOOL_SIZE\n-   */\n-  public static synchronized SimpleTimer getInstance(AccumuloConfiguration conf) {\n-    int threadPoolSize;\n-    if (conf != null) {\n-      threadPoolSize = conf.getCount(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    } else {\n-      threadPoolSize = DEFAULT_THREAD_POOL_SIZE;\n-    }\n-    return getInstance(threadPoolSize);\n-  }\n-\n-  /**\n-   * Gets the thread pool size for the timer instance. Use for testing only.\n-   *\n-   * @return thread pool size for timer instance, or -1 if not yet constructed\n-   */\n-  @VisibleForTesting\n-  static int getInstanceThreadPoolSize() {\n-    return instanceThreadPoolSize;\n-  }\n-\n-  protected SimpleTimer(int threadPoolSize) {\n-    executor = Executors.newScheduledThreadPool(threadPoolSize,\n-        new ThreadFactoryBuilder().setNameFormat(\"SimpleTimer-%d\").setDaemon(true)\n-            .setUncaughtExceptionHandler(getUncaughtExceptionHandler()).build());\n-  }\n-\n-  protected Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() {\n-    return new Thread.UncaughtExceptionHandler() {\n-      @Override\n-      public void uncaughtException(Thread t, Throwable e) {\n-        log.warn(\"SimpleTimer task failed\", e);\n-      }\n-    };\n-  }\n-\n-  /**\n-   * Schedules a task to run in the future.\n-   *\n-   * @param task\n-   *          task to run\n-   * @param delay\n-   *          number of milliseconds to wait before execution\n-   * @return future for scheduled task\n-   */\n-  public ScheduledFuture<?> schedule(Runnable task, long delay) {\n-    return executor.schedule(task, delay, TimeUnit.MILLISECONDS);\n-  }\n-\n-  /**\n-   * Schedules a task to run in the future with a fixed delay between repeated executions.\n-   *\n-   * @param task\n-   *          task to run\n-   * @param delay\n-   *          number of milliseconds to wait before first execution\n-   * @param period\n-   *          number of milliseconds to wait between executions\n-   * @return future for scheduled task\n-   */\n-  public ScheduledFuture<?> schedule(Runnable task, long delay, long period) {\n-    return executor.scheduleWithFixedDelay(task, delay, period, TimeUnit.MILLISECONDS);\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}]}, {"oid": "0efa5901a38d42a1628fcbe8bd7cba46c9a0f8d0", "url": "https://github.com/apache/accumulo/commit/0efa5901a38d42a1628fcbe8bd7cba46c9a0f8d0", "message": "re #1808 addressed some PR comments, added uncaught exception handler to Daemon", "committedDate": "2020-11-30T21:11:33Z", "type": "commit"}, {"oid": "de1846bcd05b9d967b760146580fa8eadc4545e8", "url": "https://github.com/apache/accumulo/commit/de1846bcd05b9d967b760146580fa8eadc4545e8", "message": "re *1808: wip, does not compile, working on consolidating all thread pool creation", "committedDate": "2020-12-01T22:26:55Z", "type": "commit"}, {"oid": "b2f62e73b96f0605a16099ec047b5ff41bdab380", "url": "https://github.com/apache/accumulo/commit/b2f62e73b96f0605a16099ec047b5ff41bdab380", "message": "re #1808 - consolidate Thread and ThreadPool creation down to one consistent code path", "committedDate": "2020-12-03T19:46:31Z", "type": "commit"}, {"oid": "5649ff9a81cc825cf46e32078a20e960d7b5e766", "url": "https://github.com/apache/accumulo/commit/5649ff9a81cc825cf46e32078a20e960d7b5e766", "message": "Merge branch 'main' into 1808-thread-errors\n\nConflicts:\n\tserver/base/src/test/java/org/apache/accumulo/server/util/time/SimpleTimerTest.java", "committedDate": "2020-12-03T19:48:08Z", "type": "commit"}, {"oid": "3dad05e0f314a73e792da919661f1308645c7806", "url": "https://github.com/apache/accumulo/commit/3dad05e0f314a73e792da919661f1308645c7806", "message": "re #1808 - fixing build issues", "committedDate": "2020-12-03T21:01:58Z", "type": "commit"}, {"oid": "80faa9eb2b7840b77ba9adb0922c8b12d0111ed8", "url": "https://github.com/apache/accumulo/commit/80faa9eb2b7840b77ba9adb0922c8b12d0111ed8", "message": "re #1808 - javadoc fixes", "committedDate": "2020-12-03T21:39:33Z", "type": "commit"}, {"oid": "6af4545fad5c9d45632bce5ce29cb310fa4f60ca", "url": "https://github.com/apache/accumulo/commit/6af4545fad5c9d45632bce5ce29cb310fa4f60ca", "message": "Merge branch 'main' into 1808-thread-errors\n\nConflicts:\n\tserver/tracer/src/main/java/org/apache/accumulo/tracer/ZooTraceClient.java", "committedDate": "2020-12-04T16:23:13Z", "type": "commit"}, {"oid": "79dfb9e5ab0a61a398fe167e73976d70709be698", "url": "https://github.com/apache/accumulo/commit/79dfb9e5ab0a61a398fe167e73976d70709be698", "message": "re #1808 - Remove almost all of the uses of Timer", "committedDate": "2020-12-04T18:55:03Z", "type": "commit"}, {"oid": "4a8cd565976e1ebb9917a3adefc8d71c617498c8", "url": "https://github.com/apache/accumulo/commit/4a8cd565976e1ebb9917a3adefc8d71c617498c8", "message": "re #1808 - removed property, always halt VM on Error in Thread.", "committedDate": "2020-12-04T19:34:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNTI4Mg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536525282", "body": "Rather than create this new type, you can just have a different cleanup method in CleanerUtil that calls shutdownNow instead of close on the argument. It should be a much smaller change... and fewer types is good. I can help with this part, if you're not sure what I mean.", "bodyText": "Rather than create this new type, you can just have a different cleanup method in CleanerUtil that calls shutdownNow instead of close on the argument. It should be a much smaller change... and fewer types is good. I can help with this part, if you're not sure what I mean.", "bodyHTML": "<p dir=\"auto\">Rather than create this new type, you can just have a different cleanup method in CleanerUtil that calls shutdownNow instead of close on the argument. It should be a much smaller change... and fewer types is good. I can help with this part, if you're not sure what I mean.</p>", "author": "ctubbsii", "createdAt": "2020-12-05T06:16:40Z", "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.Threads.NamedRunnable;\n+import org.apache.htrace.wrappers.TraceCallable;\n+import org.apache.htrace.wrappers.TraceRunnable;\n+\n+public class ThreadPools {\n+\n+  /**\n+   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n+   */\n+  private static class NamedThreadFactory implements ThreadFactory {\n+\n+    private static final String FORMAT = \"%s-%s-%d\";\n+\n+    private AtomicInteger threadNum = new AtomicInteger(1);\n+    private String name;\n+    private OptionalInt priority;\n+\n+    private NamedThreadFactory(String name) {\n+      this(name, OptionalInt.empty());\n+    }\n+\n+    private NamedThreadFactory(String name, OptionalInt priority) {\n+      this.name = name;\n+      this.priority = priority;\n+    }\n+\n+    @Override\n+    public Thread newThread(Runnable r) {\n+      String threadName = null;\n+      if (r instanceof NamedRunnable) {\n+        NamedRunnable nr = (NamedRunnable) r;\n+        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n+      } else {\n+        threadName =\n+            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n+      }\n+      return Threads.createThread(threadName, priority, r);\n+    }\n+  }\n+\n+  /**\n+   * ScheduledThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n+\n+    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n+      super(corePoolSize, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  /**\n+   * ThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n+\n+    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n+        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n+      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n+\n+    private final ThreadPoolExecutor tpe;\n+\n+    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n+      this.tpe = tpe;\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+      this.tpe.shutdownNow();\n+    }\n+\n+  }", "originalCommit": "4a8cd565976e1ebb9917a3adefc8d71c617498c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe29c4cfd724ae81cad630471775ceb335aeed6d", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nsimilarity index 52%\nrename from core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\nrename to core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nindex 7c97207f13..68f2a280dc 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n", "chunk": "@@ -16,228 +16,22 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.accumulo.core.util;\n+package org.apache.accumulo.core.util.threads;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n import java.util.OptionalInt;\n import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.SynchronousQueue;\n-import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.Threads.NamedRunnable;\n-import org.apache.htrace.wrappers.TraceCallable;\n-import org.apache.htrace.wrappers.TraceRunnable;\n \n public class ThreadPools {\n \n-  /**\n-   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n-   */\n-  private static class NamedThreadFactory implements ThreadFactory {\n-\n-    private static final String FORMAT = \"%s-%s-%d\";\n-\n-    private AtomicInteger threadNum = new AtomicInteger(1);\n-    private String name;\n-    private OptionalInt priority;\n-\n-    private NamedThreadFactory(String name) {\n-      this(name, OptionalInt.empty());\n-    }\n-\n-    private NamedThreadFactory(String name, OptionalInt priority) {\n-      this.name = name;\n-      this.priority = priority;\n-    }\n-\n-    @Override\n-    public Thread newThread(Runnable r) {\n-      String threadName = null;\n-      if (r instanceof NamedRunnable) {\n-        NamedRunnable nr = (NamedRunnable) r;\n-        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n-      } else {\n-        threadName =\n-            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n-      }\n-      return Threads.createThread(threadName, priority, r);\n-    }\n-  }\n-\n-  /**\n-   * ScheduledThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n-\n-    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n-      super(corePoolSize, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  /**\n-   * ThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n-\n-    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n-        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n-      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n-\n-    private final ThreadPoolExecutor tpe;\n-\n-    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n-      this.tpe = tpe;\n-    }\n-\n-    @Override\n-    public void close() throws Exception {\n-      this.tpe.shutdownNow();\n-    }\n-\n-  }\n-\n   // the number of seconds before we allow a thread to terminate with non-use.\n   public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\ndeleted file mode 100644\nindex 7c97207f13..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\n+++ /dev/null\n", "chunk": "@@ -1,368 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.util;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.OptionalInt;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.ScheduledThreadPoolExecutor;\n-import java.util.concurrent.SynchronousQueue;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.Threads.NamedRunnable;\n-import org.apache.htrace.wrappers.TraceCallable;\n-import org.apache.htrace.wrappers.TraceRunnable;\n-\n-public class ThreadPools {\n-\n-  /**\n-   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n-   */\n-  private static class NamedThreadFactory implements ThreadFactory {\n-\n-    private static final String FORMAT = \"%s-%s-%d\";\n-\n-    private AtomicInteger threadNum = new AtomicInteger(1);\n-    private String name;\n-    private OptionalInt priority;\n-\n-    private NamedThreadFactory(String name) {\n-      this(name, OptionalInt.empty());\n-    }\n-\n-    private NamedThreadFactory(String name, OptionalInt priority) {\n-      this.name = name;\n-      this.priority = priority;\n-    }\n-\n-    @Override\n-    public Thread newThread(Runnable r) {\n-      String threadName = null;\n-      if (r instanceof NamedRunnable) {\n-        NamedRunnable nr = (NamedRunnable) r;\n-        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n-      } else {\n-        threadName =\n-            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n-      }\n-      return Threads.createThread(threadName, priority, r);\n-    }\n-  }\n-\n-  /**\n-   * ScheduledThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n-\n-    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n-      super(corePoolSize, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  /**\n-   * ThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n-\n-    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n-        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n-      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n-\n-    private final ThreadPoolExecutor tpe;\n-\n-    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n-      this.tpe = tpe;\n-    }\n-\n-    @Override\n-    public void close() throws Exception {\n-      this.tpe.shutdownNow();\n-    }\n-\n-  }\n-\n-  // the number of seconds before we allow a thread to terminate with non-use.\n-  public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n-\n-  /**\n-   * Get a thread pool based on a thread pool related property\n-   *\n-   * @param conf\n-   *          accumulo configuration\n-   * @param p\n-   *          thread pool related property\n-   * @return ExecutorService impl\n-   * @throws RuntimeException\n-   *           if property is not handled\n-   */\n-  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {\n-\n-    switch (p) {\n-      case GENERAL_SIMPLETIMER_THREADPOOL_SIZE:\n-        return getScheduledExecutorService(conf.getCount(p), \"SimpleTimer\", false);\n-      case MASTER_BULK_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p),\n-            conf.getTimeInMillis(Property.MASTER_BULK_THREADPOOL_TIMEOUT), TimeUnit.MILLISECONDS,\n-            \"bulk import\", true);\n-      case MASTER_RENAME_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"bulk move\", false);\n-      case MASTER_FATE_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p), \"Repo Runner\", false);\n-      case MASTER_STATUS_THREAD_POOL_SIZE:\n-        int threads = conf.getCount(p);\n-        if (threads == 0) {\n-          return getThreadPool(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n-              \"GatherTableInformation\", new SynchronousQueue<Runnable>(), OptionalInt.empty(),\n-              false);\n-        } else {\n-          return getFixedThreadPool(threads, \"GatherTableInformation\", false);\n-        }\n-      case TSERV_WORKQ_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"distributed work queue\", false);\n-      case TSERV_MINC_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"minor compactor\",\n-            true);\n-      case TSERV_MIGRATE_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet migration\",\n-            true);\n-      case TSERV_ASSIGNMENT_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet assignment\",\n-            true);\n-      case TSERV_SUMMARY_RETRIEVAL_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary file retriever\", true);\n-      case TSERV_SUMMARY_REMOTE_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary remote\", true);\n-      case TSERV_SUMMARY_PARTITION_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary partition\", true);\n-      case GC_DELETE_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"deleting\", false);\n-      case REPLICATION_WORKER_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"replication task\", false);\n-      default:\n-        throw new RuntimeException(\"Unhandled thread pool property: \" + p);\n-    }\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n-      boolean enableTracing) {\n-    return getFixedThreadPool(numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS, name,\n-        enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n-      BlockingQueue<Runnable> queue, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS,\n-        name, queue, OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, long timeOut, TimeUnit units,\n-      final String name, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, boolean enableTracing) {\n-    return getThreadPool(coreThreads, maxThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, BlockingQueue<Runnable> queue, OptionalInt priority,\n-      boolean enableTracing) {\n-    ThreadPoolExecutor result = null;\n-    if (enableTracing) {\n-      result = new TracingThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    } else {\n-      result = new ThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    }\n-    if (timeOut > 0) {\n-      result.allowCoreThreadTimeOut(true);\n-    }\n-    return result;\n-  }\n-\n-  public static ScheduledThreadPoolExecutor\n-      getGeneralScheduledExecutorService(AccumuloConfiguration conf) {\n-    return (ScheduledThreadPoolExecutor) getExecutorService(conf,\n-        Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-  }\n-\n-  public static ScheduledThreadPoolExecutor getScheduledExecutorService(int numThreads,\n-      final String name, boolean enableTracing) {\n-    return getScheduledExecutorService(numThreads, name, OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ScheduledThreadPoolExecutor getScheduledExecutorService(int numThreads,\n-      final String name, OptionalInt priority, boolean enableTracing) {\n-    if (enableTracing) {\n-      return new TracingScheduledThreadPoolExecutor(numThreads,\n-          new NamedThreadFactory(name, priority));\n-    } else {\n-      return new ScheduledThreadPoolExecutor(numThreads, new NamedThreadFactory(name, priority));\n-    }\n-  }\n-\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNTU0MQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536525541", "body": "There's a few of these methods that don't do anything other than call the superclass implementation. These overriding methods can be removed, so the caller of these methods can call the superclass' implementation directly.", "bodyText": "There's a few of these methods that don't do anything other than call the superclass implementation. These overriding methods can be removed, so the caller of these methods can call the superclass' implementation directly.", "bodyHTML": "<p dir=\"auto\">There's a few of these methods that don't do anything other than call the superclass implementation. These overriding methods can be removed, so the caller of these methods can call the superclass' implementation directly.</p>", "author": "ctubbsii", "createdAt": "2020-12-05T06:18:14Z", "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.Threads.NamedRunnable;\n+import org.apache.htrace.wrappers.TraceCallable;\n+import org.apache.htrace.wrappers.TraceRunnable;\n+\n+public class ThreadPools {\n+\n+  /**\n+   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n+   */\n+  private static class NamedThreadFactory implements ThreadFactory {\n+\n+    private static final String FORMAT = \"%s-%s-%d\";\n+\n+    private AtomicInteger threadNum = new AtomicInteger(1);\n+    private String name;\n+    private OptionalInt priority;\n+\n+    private NamedThreadFactory(String name) {\n+      this(name, OptionalInt.empty());\n+    }\n+\n+    private NamedThreadFactory(String name, OptionalInt priority) {\n+      this.name = name;\n+      this.priority = priority;\n+    }\n+\n+    @Override\n+    public Thread newThread(Runnable r) {\n+      String threadName = null;\n+      if (r instanceof NamedRunnable) {\n+        NamedRunnable nr = (NamedRunnable) r;\n+        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n+      } else {\n+        threadName =\n+            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n+      }\n+      return Threads.createThread(threadName, priority, r);\n+    }\n+  }\n+\n+  /**\n+   * ScheduledThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n+\n+    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n+      super(corePoolSize, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  /**\n+   * ThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n+\n+    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n+        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n+      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }", "originalCommit": "4a8cd565976e1ebb9917a3adefc8d71c617498c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5NzM3MQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536897371", "bodyText": "Yeah, these were leftovers from an earlier implementation idea.", "author": "dlmarion", "createdAt": "2020-12-05T21:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNTU0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "fe29c4cfd724ae81cad630471775ceb335aeed6d", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nsimilarity index 52%\nrename from core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\nrename to core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nindex 7c97207f13..68f2a280dc 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n", "chunk": "@@ -16,228 +16,22 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.accumulo.core.util;\n+package org.apache.accumulo.core.util.threads;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n import java.util.OptionalInt;\n import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.SynchronousQueue;\n-import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.Threads.NamedRunnable;\n-import org.apache.htrace.wrappers.TraceCallable;\n-import org.apache.htrace.wrappers.TraceRunnable;\n \n public class ThreadPools {\n \n-  /**\n-   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n-   */\n-  private static class NamedThreadFactory implements ThreadFactory {\n-\n-    private static final String FORMAT = \"%s-%s-%d\";\n-\n-    private AtomicInteger threadNum = new AtomicInteger(1);\n-    private String name;\n-    private OptionalInt priority;\n-\n-    private NamedThreadFactory(String name) {\n-      this(name, OptionalInt.empty());\n-    }\n-\n-    private NamedThreadFactory(String name, OptionalInt priority) {\n-      this.name = name;\n-      this.priority = priority;\n-    }\n-\n-    @Override\n-    public Thread newThread(Runnable r) {\n-      String threadName = null;\n-      if (r instanceof NamedRunnable) {\n-        NamedRunnable nr = (NamedRunnable) r;\n-        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n-      } else {\n-        threadName =\n-            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n-      }\n-      return Threads.createThread(threadName, priority, r);\n-    }\n-  }\n-\n-  /**\n-   * ScheduledThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n-\n-    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n-      super(corePoolSize, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  /**\n-   * ThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n-\n-    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n-        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n-      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n-\n-    private final ThreadPoolExecutor tpe;\n-\n-    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n-      this.tpe = tpe;\n-    }\n-\n-    @Override\n-    public void close() throws Exception {\n-      this.tpe.shutdownNow();\n-    }\n-\n-  }\n-\n   // the number of seconds before we allow a thread to terminate with non-use.\n   public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\ndeleted file mode 100644\nindex 7c97207f13..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\n+++ /dev/null\n", "chunk": "@@ -1,368 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.util;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.OptionalInt;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.ScheduledThreadPoolExecutor;\n-import java.util.concurrent.SynchronousQueue;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.Threads.NamedRunnable;\n-import org.apache.htrace.wrappers.TraceCallable;\n-import org.apache.htrace.wrappers.TraceRunnable;\n-\n-public class ThreadPools {\n-\n-  /**\n-   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n-   */\n-  private static class NamedThreadFactory implements ThreadFactory {\n-\n-    private static final String FORMAT = \"%s-%s-%d\";\n-\n-    private AtomicInteger threadNum = new AtomicInteger(1);\n-    private String name;\n-    private OptionalInt priority;\n-\n-    private NamedThreadFactory(String name) {\n-      this(name, OptionalInt.empty());\n-    }\n-\n-    private NamedThreadFactory(String name, OptionalInt priority) {\n-      this.name = name;\n-      this.priority = priority;\n-    }\n-\n-    @Override\n-    public Thread newThread(Runnable r) {\n-      String threadName = null;\n-      if (r instanceof NamedRunnable) {\n-        NamedRunnable nr = (NamedRunnable) r;\n-        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n-      } else {\n-        threadName =\n-            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n-      }\n-      return Threads.createThread(threadName, priority, r);\n-    }\n-  }\n-\n-  /**\n-   * ScheduledThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n-\n-    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n-      super(corePoolSize, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  /**\n-   * ThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n-\n-    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n-        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n-      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n-\n-    private final ThreadPoolExecutor tpe;\n-\n-    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n-      this.tpe = tpe;\n-    }\n-\n-    @Override\n-    public void close() throws Exception {\n-      this.tpe.shutdownNow();\n-    }\n-\n-  }\n-\n-  // the number of seconds before we allow a thread to terminate with non-use.\n-  public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n-\n-  /**\n-   * Get a thread pool based on a thread pool related property\n-   *\n-   * @param conf\n-   *          accumulo configuration\n-   * @param p\n-   *          thread pool related property\n-   * @return ExecutorService impl\n-   * @throws RuntimeException\n-   *           if property is not handled\n-   */\n-  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {\n-\n-    switch (p) {\n-      case GENERAL_SIMPLETIMER_THREADPOOL_SIZE:\n-        return getScheduledExecutorService(conf.getCount(p), \"SimpleTimer\", false);\n-      case MASTER_BULK_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p),\n-            conf.getTimeInMillis(Property.MASTER_BULK_THREADPOOL_TIMEOUT), TimeUnit.MILLISECONDS,\n-            \"bulk import\", true);\n-      case MASTER_RENAME_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"bulk move\", false);\n-      case MASTER_FATE_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p), \"Repo Runner\", false);\n-      case MASTER_STATUS_THREAD_POOL_SIZE:\n-        int threads = conf.getCount(p);\n-        if (threads == 0) {\n-          return getThreadPool(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n-              \"GatherTableInformation\", new SynchronousQueue<Runnable>(), OptionalInt.empty(),\n-              false);\n-        } else {\n-          return getFixedThreadPool(threads, \"GatherTableInformation\", false);\n-        }\n-      case TSERV_WORKQ_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"distributed work queue\", false);\n-      case TSERV_MINC_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"minor compactor\",\n-            true);\n-      case TSERV_MIGRATE_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet migration\",\n-            true);\n-      case TSERV_ASSIGNMENT_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet assignment\",\n-            true);\n-      case TSERV_SUMMARY_RETRIEVAL_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary file retriever\", true);\n-      case TSERV_SUMMARY_REMOTE_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary remote\", true);\n-      case TSERV_SUMMARY_PARTITION_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary partition\", true);\n-      case GC_DELETE_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"deleting\", false);\n-      case REPLICATION_WORKER_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"replication task\", false);\n-      default:\n-        throw new RuntimeException(\"Unhandled thread pool property: \" + p);\n-    }\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n-      boolean enableTracing) {\n-    return getFixedThreadPool(numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS, name,\n-        enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n-      BlockingQueue<Runnable> queue, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS,\n-        name, queue, OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, long timeOut, TimeUnit units,\n-      final String name, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, boolean enableTracing) {\n-    return getThreadPool(coreThreads, maxThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, BlockingQueue<Runnable> queue, OptionalInt priority,\n-      boolean enableTracing) {\n-    ThreadPoolExecutor result = null;\n-    if (enableTracing) {\n-      result = new TracingThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    } else {\n-      result = new ThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    }\n-    if (timeOut > 0) {\n-      result.allowCoreThreadTimeOut(true);\n-    }\n-    return result;\n-  }\n-\n-  public static ScheduledThreadPoolExecutor\n-      getGeneralScheduledExecutorService(AccumuloConfiguration conf) {\n-    return (ScheduledThreadPoolExecutor) getExecutorService(conf,\n-        Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-  }\n-\n-  public static ScheduledThreadPoolExecutor getScheduledExecutorService(int numThreads,\n-      final String name, boolean enableTracing) {\n-    return getScheduledExecutorService(numThreads, name, OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ScheduledThreadPoolExecutor getScheduledExecutorService(int numThreads,\n-      final String name, OptionalInt priority, boolean enableTracing) {\n-    if (enableTracing) {\n-      return new TracingScheduledThreadPoolExecutor(numThreads,\n-          new NamedThreadFactory(name, priority));\n-    } else {\n-      return new ScheduledThreadPoolExecutor(numThreads, new NamedThreadFactory(name, priority));\n-    }\n-  }\n-\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNTg5NA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536525894", "body": "This method, and how you based it on the property might be my favorite piece of code this year. :smiley_cat:  This was a great way to bring all the various implementations into one centralized place.", "bodyText": "This method, and how you based it on the property might be my favorite piece of code this year. \ud83d\ude3a  This was a great way to bring all the various implementations into one centralized place.", "bodyHTML": "<p dir=\"auto\">This method, and how you based it on the property might be my favorite piece of code this year. <g-emoji class=\"g-emoji\" alias=\"smiley_cat\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f63a.png\">\ud83d\ude3a</g-emoji>  This was a great way to bring all the various implementations into one centralized place.</p>", "author": "ctubbsii", "createdAt": "2020-12-05T06:20:49Z", "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.Threads.NamedRunnable;\n+import org.apache.htrace.wrappers.TraceCallable;\n+import org.apache.htrace.wrappers.TraceRunnable;\n+\n+public class ThreadPools {\n+\n+  /**\n+   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n+   */\n+  private static class NamedThreadFactory implements ThreadFactory {\n+\n+    private static final String FORMAT = \"%s-%s-%d\";\n+\n+    private AtomicInteger threadNum = new AtomicInteger(1);\n+    private String name;\n+    private OptionalInt priority;\n+\n+    private NamedThreadFactory(String name) {\n+      this(name, OptionalInt.empty());\n+    }\n+\n+    private NamedThreadFactory(String name, OptionalInt priority) {\n+      this.name = name;\n+      this.priority = priority;\n+    }\n+\n+    @Override\n+    public Thread newThread(Runnable r) {\n+      String threadName = null;\n+      if (r instanceof NamedRunnable) {\n+        NamedRunnable nr = (NamedRunnable) r;\n+        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n+      } else {\n+        threadName =\n+            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n+      }\n+      return Threads.createThread(threadName, priority, r);\n+    }\n+  }\n+\n+  /**\n+   * ScheduledThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n+\n+    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n+      super(corePoolSize, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  /**\n+   * ThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n+\n+    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n+        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n+      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n+\n+    private final ThreadPoolExecutor tpe;\n+\n+    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n+      this.tpe = tpe;\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+      this.tpe.shutdownNow();\n+    }\n+\n+  }\n+\n+  // the number of seconds before we allow a thread to terminate with non-use.\n+  public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n+\n+  /**\n+   * Get a thread pool based on a thread pool related property\n+   *\n+   * @param conf\n+   *          accumulo configuration\n+   * @param p\n+   *          thread pool related property\n+   * @return ExecutorService impl\n+   * @throws RuntimeException\n+   *           if property is not handled\n+   */\n+  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {", "originalCommit": "4a8cd565976e1ebb9917a3adefc8d71c617498c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7957d8240581ce74a942c4858cf452bbb2067b90", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\ndeleted file mode 100644\nindex 7c97207f13..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\n+++ /dev/null\n", "chunk": "@@ -1,368 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.util;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.OptionalInt;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.ScheduledThreadPoolExecutor;\n-import java.util.concurrent.SynchronousQueue;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.Threads.NamedRunnable;\n-import org.apache.htrace.wrappers.TraceCallable;\n-import org.apache.htrace.wrappers.TraceRunnable;\n-\n-public class ThreadPools {\n-\n-  /**\n-   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n-   */\n-  private static class NamedThreadFactory implements ThreadFactory {\n-\n-    private static final String FORMAT = \"%s-%s-%d\";\n-\n-    private AtomicInteger threadNum = new AtomicInteger(1);\n-    private String name;\n-    private OptionalInt priority;\n-\n-    private NamedThreadFactory(String name) {\n-      this(name, OptionalInt.empty());\n-    }\n-\n-    private NamedThreadFactory(String name, OptionalInt priority) {\n-      this.name = name;\n-      this.priority = priority;\n-    }\n-\n-    @Override\n-    public Thread newThread(Runnable r) {\n-      String threadName = null;\n-      if (r instanceof NamedRunnable) {\n-        NamedRunnable nr = (NamedRunnable) r;\n-        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n-      } else {\n-        threadName =\n-            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n-      }\n-      return Threads.createThread(threadName, priority, r);\n-    }\n-  }\n-\n-  /**\n-   * ScheduledThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n-\n-    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n-      super(corePoolSize, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  /**\n-   * ThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n-\n-    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n-        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n-      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n-\n-    private final ThreadPoolExecutor tpe;\n-\n-    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n-      this.tpe = tpe;\n-    }\n-\n-    @Override\n-    public void close() throws Exception {\n-      this.tpe.shutdownNow();\n-    }\n-\n-  }\n-\n-  // the number of seconds before we allow a thread to terminate with non-use.\n-  public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n-\n-  /**\n-   * Get a thread pool based on a thread pool related property\n-   *\n-   * @param conf\n-   *          accumulo configuration\n-   * @param p\n-   *          thread pool related property\n-   * @return ExecutorService impl\n-   * @throws RuntimeException\n-   *           if property is not handled\n-   */\n-  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {\n-\n-    switch (p) {\n-      case GENERAL_SIMPLETIMER_THREADPOOL_SIZE:\n-        return getScheduledExecutorService(conf.getCount(p), \"SimpleTimer\", false);\n-      case MASTER_BULK_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p),\n-            conf.getTimeInMillis(Property.MASTER_BULK_THREADPOOL_TIMEOUT), TimeUnit.MILLISECONDS,\n-            \"bulk import\", true);\n-      case MASTER_RENAME_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"bulk move\", false);\n-      case MASTER_FATE_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p), \"Repo Runner\", false);\n-      case MASTER_STATUS_THREAD_POOL_SIZE:\n-        int threads = conf.getCount(p);\n-        if (threads == 0) {\n-          return getThreadPool(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n-              \"GatherTableInformation\", new SynchronousQueue<Runnable>(), OptionalInt.empty(),\n-              false);\n-        } else {\n-          return getFixedThreadPool(threads, \"GatherTableInformation\", false);\n-        }\n-      case TSERV_WORKQ_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"distributed work queue\", false);\n-      case TSERV_MINC_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"minor compactor\",\n-            true);\n-      case TSERV_MIGRATE_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet migration\",\n-            true);\n-      case TSERV_ASSIGNMENT_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet assignment\",\n-            true);\n-      case TSERV_SUMMARY_RETRIEVAL_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary file retriever\", true);\n-      case TSERV_SUMMARY_REMOTE_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary remote\", true);\n-      case TSERV_SUMMARY_PARTITION_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary partition\", true);\n-      case GC_DELETE_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"deleting\", false);\n-      case REPLICATION_WORKER_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"replication task\", false);\n-      default:\n-        throw new RuntimeException(\"Unhandled thread pool property: \" + p);\n-    }\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n-      boolean enableTracing) {\n-    return getFixedThreadPool(numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS, name,\n-        enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n-      BlockingQueue<Runnable> queue, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS,\n-        name, queue, OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, long timeOut, TimeUnit units,\n-      final String name, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, boolean enableTracing) {\n-    return getThreadPool(coreThreads, maxThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, BlockingQueue<Runnable> queue, OptionalInt priority,\n-      boolean enableTracing) {\n-    ThreadPoolExecutor result = null;\n-    if (enableTracing) {\n-      result = new TracingThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    } else {\n-      result = new ThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    }\n-    if (timeOut > 0) {\n-      result.allowCoreThreadTimeOut(true);\n-    }\n-    return result;\n-  }\n-\n-  public static ScheduledThreadPoolExecutor\n-      getGeneralScheduledExecutorService(AccumuloConfiguration conf) {\n-    return (ScheduledThreadPoolExecutor) getExecutorService(conf,\n-        Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-  }\n-\n-  public static ScheduledThreadPoolExecutor getScheduledExecutorService(int numThreads,\n-      final String name, boolean enableTracing) {\n-    return getScheduledExecutorService(numThreads, name, OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ScheduledThreadPoolExecutor getScheduledExecutorService(int numThreads,\n-      final String name, OptionalInt priority, boolean enableTracing) {\n-    if (enableTracing) {\n-      return new TracingScheduledThreadPoolExecutor(numThreads,\n-          new NamedThreadFactory(name, priority));\n-    } else {\n-      return new ScheduledThreadPoolExecutor(numThreads, new NamedThreadFactory(name, priority));\n-    }\n-  }\n-\n-}\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\ndeleted file mode 100644\nindex 7c97207f13..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\n+++ /dev/null\n", "chunk": "@@ -1,368 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.util;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.OptionalInt;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.ScheduledThreadPoolExecutor;\n-import java.util.concurrent.SynchronousQueue;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.Threads.NamedRunnable;\n-import org.apache.htrace.wrappers.TraceCallable;\n-import org.apache.htrace.wrappers.TraceRunnable;\n-\n-public class ThreadPools {\n-\n-  /**\n-   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n-   */\n-  private static class NamedThreadFactory implements ThreadFactory {\n-\n-    private static final String FORMAT = \"%s-%s-%d\";\n-\n-    private AtomicInteger threadNum = new AtomicInteger(1);\n-    private String name;\n-    private OptionalInt priority;\n-\n-    private NamedThreadFactory(String name) {\n-      this(name, OptionalInt.empty());\n-    }\n-\n-    private NamedThreadFactory(String name, OptionalInt priority) {\n-      this.name = name;\n-      this.priority = priority;\n-    }\n-\n-    @Override\n-    public Thread newThread(Runnable r) {\n-      String threadName = null;\n-      if (r instanceof NamedRunnable) {\n-        NamedRunnable nr = (NamedRunnable) r;\n-        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n-      } else {\n-        threadName =\n-            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n-      }\n-      return Threads.createThread(threadName, priority, r);\n-    }\n-  }\n-\n-  /**\n-   * ScheduledThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n-\n-    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n-      super(corePoolSize, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  /**\n-   * ThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n-\n-    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n-        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n-      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n-\n-    private final ThreadPoolExecutor tpe;\n-\n-    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n-      this.tpe = tpe;\n-    }\n-\n-    @Override\n-    public void close() throws Exception {\n-      this.tpe.shutdownNow();\n-    }\n-\n-  }\n-\n-  // the number of seconds before we allow a thread to terminate with non-use.\n-  public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n-\n-  /**\n-   * Get a thread pool based on a thread pool related property\n-   *\n-   * @param conf\n-   *          accumulo configuration\n-   * @param p\n-   *          thread pool related property\n-   * @return ExecutorService impl\n-   * @throws RuntimeException\n-   *           if property is not handled\n-   */\n-  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {\n-\n-    switch (p) {\n-      case GENERAL_SIMPLETIMER_THREADPOOL_SIZE:\n-        return getScheduledExecutorService(conf.getCount(p), \"SimpleTimer\", false);\n-      case MASTER_BULK_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p),\n-            conf.getTimeInMillis(Property.MASTER_BULK_THREADPOOL_TIMEOUT), TimeUnit.MILLISECONDS,\n-            \"bulk import\", true);\n-      case MASTER_RENAME_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"bulk move\", false);\n-      case MASTER_FATE_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p), \"Repo Runner\", false);\n-      case MASTER_STATUS_THREAD_POOL_SIZE:\n-        int threads = conf.getCount(p);\n-        if (threads == 0) {\n-          return getThreadPool(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n-              \"GatherTableInformation\", new SynchronousQueue<Runnable>(), OptionalInt.empty(),\n-              false);\n-        } else {\n-          return getFixedThreadPool(threads, \"GatherTableInformation\", false);\n-        }\n-      case TSERV_WORKQ_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"distributed work queue\", false);\n-      case TSERV_MINC_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"minor compactor\",\n-            true);\n-      case TSERV_MIGRATE_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet migration\",\n-            true);\n-      case TSERV_ASSIGNMENT_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet assignment\",\n-            true);\n-      case TSERV_SUMMARY_RETRIEVAL_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary file retriever\", true);\n-      case TSERV_SUMMARY_REMOTE_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary remote\", true);\n-      case TSERV_SUMMARY_PARTITION_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary partition\", true);\n-      case GC_DELETE_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"deleting\", false);\n-      case REPLICATION_WORKER_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"replication task\", false);\n-      default:\n-        throw new RuntimeException(\"Unhandled thread pool property: \" + p);\n-    }\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n-      boolean enableTracing) {\n-    return getFixedThreadPool(numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS, name,\n-        enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n-      BlockingQueue<Runnable> queue, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS,\n-        name, queue, OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, long timeOut, TimeUnit units,\n-      final String name, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, boolean enableTracing) {\n-    return getThreadPool(coreThreads, maxThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, BlockingQueue<Runnable> queue, OptionalInt priority,\n-      boolean enableTracing) {\n-    ThreadPoolExecutor result = null;\n-    if (enableTracing) {\n-      result = new TracingThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    } else {\n-      result = new ThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    }\n-    if (timeOut > 0) {\n-      result.allowCoreThreadTimeOut(true);\n-    }\n-    return result;\n-  }\n-\n-  public static ScheduledThreadPoolExecutor\n-      getGeneralScheduledExecutorService(AccumuloConfiguration conf) {\n-    return (ScheduledThreadPoolExecutor) getExecutorService(conf,\n-        Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-  }\n-\n-  public static ScheduledThreadPoolExecutor getScheduledExecutorService(int numThreads,\n-      final String name, boolean enableTracing) {\n-    return getScheduledExecutorService(numThreads, name, OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ScheduledThreadPoolExecutor getScheduledExecutorService(int numThreads,\n-      final String name, OptionalInt priority, boolean enableTracing) {\n-    if (enableTracing) {\n-      return new TracingScheduledThreadPoolExecutor(numThreads,\n-          new NamedThreadFactory(name, priority));\n-    } else {\n-      return new ScheduledThreadPoolExecutor(numThreads, new NamedThreadFactory(name, priority));\n-    }\n-  }\n-\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNjA5Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536526096", "body": "Let's move this to a subpackage of util. Util is pretty bloated, and in a subpackage, we can break out all the inner classes. Inner classes make it hard to follow the code. package-private classes would be better than private inner classes.", "bodyText": "Let's move this to a subpackage of util. Util is pretty bloated, and in a subpackage, we can break out all the inner classes. Inner classes make it hard to follow the code. package-private classes would be better than private inner classes.", "bodyHTML": "<p dir=\"auto\">Let's move this to a subpackage of util. Util is pretty bloated, and in a subpackage, we can break out all the inner classes. Inner classes make it hard to follow the code. package-private classes would be better than private inner classes.</p>", "author": "ctubbsii", "createdAt": "2020-12-05T06:22:06Z", "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;", "originalCommit": "4a8cd565976e1ebb9917a3adefc8d71c617498c8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fe29c4cfd724ae81cad630471775ceb335aeed6d", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nsimilarity index 52%\nrename from core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\nrename to core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nindex 7c97207f13..68f2a280dc 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n", "chunk": "@@ -16,228 +16,22 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.accumulo.core.util;\n+package org.apache.accumulo.core.util.threads;\n \n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n import java.util.OptionalInt;\n import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.SynchronousQueue;\n-import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n \n import org.apache.accumulo.core.conf.AccumuloConfiguration;\n import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.Threads.NamedRunnable;\n-import org.apache.htrace.wrappers.TraceCallable;\n-import org.apache.htrace.wrappers.TraceRunnable;\n \n public class ThreadPools {\n \n-  /**\n-   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n-   */\n-  private static class NamedThreadFactory implements ThreadFactory {\n-\n-    private static final String FORMAT = \"%s-%s-%d\";\n-\n-    private AtomicInteger threadNum = new AtomicInteger(1);\n-    private String name;\n-    private OptionalInt priority;\n-\n-    private NamedThreadFactory(String name) {\n-      this(name, OptionalInt.empty());\n-    }\n-\n-    private NamedThreadFactory(String name, OptionalInt priority) {\n-      this.name = name;\n-      this.priority = priority;\n-    }\n-\n-    @Override\n-    public Thread newThread(Runnable r) {\n-      String threadName = null;\n-      if (r instanceof NamedRunnable) {\n-        NamedRunnable nr = (NamedRunnable) r;\n-        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n-      } else {\n-        threadName =\n-            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n-      }\n-      return Threads.createThread(threadName, priority, r);\n-    }\n-  }\n-\n-  /**\n-   * ScheduledThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n-\n-    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n-      super(corePoolSize, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  /**\n-   * ThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n-\n-    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n-        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n-      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n-\n-    private final ThreadPoolExecutor tpe;\n-\n-    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n-      this.tpe = tpe;\n-    }\n-\n-    @Override\n-    public void close() throws Exception {\n-      this.tpe.shutdownNow();\n-    }\n-\n-  }\n-\n   // the number of seconds before we allow a thread to terminate with non-use.\n   public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\ndeleted file mode 100644\nindex 7c97207f13..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java\n+++ /dev/null\n", "chunk": "@@ -1,368 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.util;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.OptionalInt;\n-import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.ScheduledThreadPoolExecutor;\n-import java.util.concurrent.SynchronousQueue;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.ThreadPoolExecutor;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.Threads.NamedRunnable;\n-import org.apache.htrace.wrappers.TraceCallable;\n-import org.apache.htrace.wrappers.TraceRunnable;\n-\n-public class ThreadPools {\n-\n-  /**\n-   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n-   */\n-  private static class NamedThreadFactory implements ThreadFactory {\n-\n-    private static final String FORMAT = \"%s-%s-%d\";\n-\n-    private AtomicInteger threadNum = new AtomicInteger(1);\n-    private String name;\n-    private OptionalInt priority;\n-\n-    private NamedThreadFactory(String name) {\n-      this(name, OptionalInt.empty());\n-    }\n-\n-    private NamedThreadFactory(String name, OptionalInt priority) {\n-      this.name = name;\n-      this.priority = priority;\n-    }\n-\n-    @Override\n-    public Thread newThread(Runnable r) {\n-      String threadName = null;\n-      if (r instanceof NamedRunnable) {\n-        NamedRunnable nr = (NamedRunnable) r;\n-        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n-      } else {\n-        threadName =\n-            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n-      }\n-      return Threads.createThread(threadName, priority, r);\n-    }\n-  }\n-\n-  /**\n-   * ScheduledThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n-\n-    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n-      super(corePoolSize, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  /**\n-   * ThreadPoolExecutor that traces executed tasks.\n-   */\n-  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n-\n-    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n-        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n-      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-      super.execute(new TraceRunnable(command));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-      return super.submit(new TraceCallable<T>(task));\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-      return super.submit(new TraceRunnable(task), result);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-      return super.submit(new TraceRunnable(task));\n-    }\n-\n-    private <T> Collection<? extends Callable<T>>\n-        wrapCollection(Collection<? extends Callable<T>> tasks) {\n-      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n-      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n-      return result;\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n-        TimeUnit unit) throws InterruptedException {\n-      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-        throws InterruptedException, ExecutionException {\n-      return super.invokeAny(wrapCollection(tasks));\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-      super.shutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-      return super.shutdownNow();\n-    }\n-\n-  }\n-\n-  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n-\n-    private final ThreadPoolExecutor tpe;\n-\n-    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n-      this.tpe = tpe;\n-    }\n-\n-    @Override\n-    public void close() throws Exception {\n-      this.tpe.shutdownNow();\n-    }\n-\n-  }\n-\n-  // the number of seconds before we allow a thread to terminate with non-use.\n-  public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n-\n-  /**\n-   * Get a thread pool based on a thread pool related property\n-   *\n-   * @param conf\n-   *          accumulo configuration\n-   * @param p\n-   *          thread pool related property\n-   * @return ExecutorService impl\n-   * @throws RuntimeException\n-   *           if property is not handled\n-   */\n-  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {\n-\n-    switch (p) {\n-      case GENERAL_SIMPLETIMER_THREADPOOL_SIZE:\n-        return getScheduledExecutorService(conf.getCount(p), \"SimpleTimer\", false);\n-      case MASTER_BULK_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p),\n-            conf.getTimeInMillis(Property.MASTER_BULK_THREADPOOL_TIMEOUT), TimeUnit.MILLISECONDS,\n-            \"bulk import\", true);\n-      case MASTER_RENAME_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"bulk move\", false);\n-      case MASTER_FATE_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p), \"Repo Runner\", false);\n-      case MASTER_STATUS_THREAD_POOL_SIZE:\n-        int threads = conf.getCount(p);\n-        if (threads == 0) {\n-          return getThreadPool(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n-              \"GatherTableInformation\", new SynchronousQueue<Runnable>(), OptionalInt.empty(),\n-              false);\n-        } else {\n-          return getFixedThreadPool(threads, \"GatherTableInformation\", false);\n-        }\n-      case TSERV_WORKQ_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"distributed work queue\", false);\n-      case TSERV_MINC_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"minor compactor\",\n-            true);\n-      case TSERV_MIGRATE_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet migration\",\n-            true);\n-      case TSERV_ASSIGNMENT_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet assignment\",\n-            true);\n-      case TSERV_SUMMARY_RETRIEVAL_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary file retriever\", true);\n-      case TSERV_SUMMARY_REMOTE_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary remote\", true);\n-      case TSERV_SUMMARY_PARTITION_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary partition\", true);\n-      case GC_DELETE_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"deleting\", false);\n-      case REPLICATION_WORKER_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"replication task\", false);\n-      default:\n-        throw new RuntimeException(\"Unhandled thread pool property: \" + p);\n-    }\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n-      boolean enableTracing) {\n-    return getFixedThreadPool(numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS, name,\n-        enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n-      BlockingQueue<Runnable> queue, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS,\n-        name, queue, OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, long timeOut, TimeUnit units,\n-      final String name, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, boolean enableTracing) {\n-    return getThreadPool(coreThreads, maxThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, BlockingQueue<Runnable> queue, OptionalInt priority,\n-      boolean enableTracing) {\n-    ThreadPoolExecutor result = null;\n-    if (enableTracing) {\n-      result = new TracingThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    } else {\n-      result = new ThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    }\n-    if (timeOut > 0) {\n-      result.allowCoreThreadTimeOut(true);\n-    }\n-    return result;\n-  }\n-\n-  public static ScheduledThreadPoolExecutor\n-      getGeneralScheduledExecutorService(AccumuloConfiguration conf) {\n-    return (ScheduledThreadPoolExecutor) getExecutorService(conf,\n-        Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-  }\n-\n-  public static ScheduledThreadPoolExecutor getScheduledExecutorService(int numThreads,\n-      final String name, boolean enableTracing) {\n-    return getScheduledExecutorService(numThreads, name, OptionalInt.empty(), enableTracing);\n-  }\n-\n-  public static ScheduledThreadPoolExecutor getScheduledExecutorService(int numThreads,\n-      final String name, OptionalInt priority, boolean enableTracing) {\n-    if (enableTracing) {\n-      return new TracingScheduledThreadPoolExecutor(numThreads,\n-          new NamedThreadFactory(name, priority));\n-    } else {\n-      return new ScheduledThreadPoolExecutor(numThreads, new NamedThreadFactory(name, priority));\n-    }\n-  }\n-\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}]}, {"oid": "fe29c4cfd724ae81cad630471775ceb335aeed6d", "url": "https://github.com/apache/accumulo/commit/fe29c4cfd724ae81cad630471775ceb335aeed6d", "message": "re #1808 - addressing comments from PR", "committedDate": "2020-12-05T22:10:31Z", "type": "commit"}, {"oid": "06209ca242705ff42c5f2b925e5bef8d2b5b7952", "url": "https://github.com/apache/accumulo/commit/06209ca242705ff42c5f2b925e5bef8d2b5b7952", "message": "Merge branch 'main' into 1808-thread-errors\n\nConflicts:\n\tserver/tserver/src/main/java/org/apache/accumulo/tserver/TabletServerResourceManager.java\n\tshell/src/main/java/org/apache/accumulo/shell/commands/ActiveCompactionHelper.java", "committedDate": "2020-12-14T15:48:15Z", "type": "commit"}, {"oid": "6a15ae5c2bd1b82ab2980a34ec655648edad1862", "url": "https://github.com/apache/accumulo/commit/6a15ae5c2bd1b82ab2980a34ec655648edad1862", "message": "Merge branch '1808-thread-errors' of github.com:dlmarion/accumulo into 1808-thread-errors\n\nConflicts:\n\tshell/src/main/java/org/apache/accumulo/shell/commands/ActiveCompactionHelper.java", "committedDate": "2020-12-14T16:01:49Z", "type": "commit"}, {"oid": "d7c1aeba61833a89e02c738a5841866810b04de4", "url": "https://github.com/apache/accumulo/commit/d7c1aeba61833a89e02c738a5841866810b04de4", "message": "re #1808 - don't log message in CleanerUtil if thread pool is already shut down", "committedDate": "2020-12-15T16:14:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5ODEyMw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543498123", "body": "Why cast here? Why not just make the type more restrictive in the method signature 4 lines above?", "bodyText": "Why cast here? Why not just make the type more restrictive in the method signature 4 lines above?", "bodyHTML": "<p dir=\"auto\">Why cast here? Why not just make the type more restrictive in the method signature 4 lines above?</p>", "author": "ctubbsii", "createdAt": "2020-12-15T16:33:18Z", "path": "core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java", "diffHunk": "@@ -107,10 +107,14 @@ public static Cleanable shutdownThreadPoolExecutor(Object tpe, Logger log) {\n     requireNonNull(tpe);\n     requireNonNull(log);\n     return CLEANER.register(tpe, () -> {\n+      ThreadPoolExecutor pool = (ThreadPoolExecutor) tpe;", "originalCommit": "d7c1aeba61833a89e02c738a5841866810b04de4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java b/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\nindex 2fb4312cbf..7276f7b06a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\n", "chunk": "@@ -103,12 +103,12 @@ public class CleanerUtil {\n     });\n   }\n \n-  public static Cleanable shutdownThreadPoolExecutor(Object tpe, Logger log) {\n-    requireNonNull(tpe);\n+  public static Cleanable shutdownThreadPoolExecutor(ThreadPoolExecutor pool, AtomicBoolean closed,\n+      Logger log) {\n+    requireNonNull(pool);\n     requireNonNull(log);\n-    return CLEANER.register(tpe, () -> {\n-      ThreadPoolExecutor pool = (ThreadPoolExecutor) tpe;\n-      if (pool.isShutdown()) {\n+    return CLEANER.register(pool, () -> {\n+      if (closed.get()) {\n         return;\n       }\n       log.warn(\"{} found unreferenced without calling shutdown() or shutdownNow()\",\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java b/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\nindex 2fb4312cbf..7276f7b06a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\n", "chunk": "@@ -103,12 +103,12 @@ public class CleanerUtil {\n     });\n   }\n \n-  public static Cleanable shutdownThreadPoolExecutor(Object tpe, Logger log) {\n-    requireNonNull(tpe);\n+  public static Cleanable shutdownThreadPoolExecutor(ThreadPoolExecutor pool, AtomicBoolean closed,\n+      Logger log) {\n+    requireNonNull(pool);\n     requireNonNull(log);\n-    return CLEANER.register(tpe, () -> {\n-      ThreadPoolExecutor pool = (ThreadPoolExecutor) tpe;\n-      if (pool.isShutdown()) {\n+    return CLEANER.register(pool, () -> {\n+      if (closed.get()) {\n         return;\n       }\n       log.warn(\"{} found unreferenced without calling shutdown() or shutdownNow()\",\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "b6a466348807fe0d23203f3776cbc3119d5a037d", "committedDate": "2021-11-09 15:25:15 -0500", "message": "Instrument code using OpenTelemetry (#2259)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "2dbdc085390794e7925740a81439c66dc3dfbb7c", "committedDate": "2022-10-20 00:16:54 -0400", "message": "Move o.a.a.fate to o.a.a.core.fate (#3035)"}, {"oid": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "committedDate": "2022-11-30 02:21:37 -0500", "message": "Update javadoc tag style to match google style guide (#3064)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMDIyOA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543500228", "body": "We really should deregister the cleanable first, so we don't get duplicate exceptions from that if there's a problem calling the shutdown.", "bodyText": "We really should deregister the cleanable first, so we don't get duplicate exceptions from that if there's a problem calling the shutdown.", "bodyHTML": "<p dir=\"auto\">We really should deregister the cleanable first, so we don't get duplicate exceptions from that if there's a problem calling the shutdown.</p>", "author": "ctubbsii", "createdAt": "2020-12-15T16:36:01Z", "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchReader.java", "diffHunk": "@@ -72,16 +72,15 @@ protected TabletServerBatchReader(ClientContext context, Class<?> scopeClass, Ta\n \n     queryThreadPool = ThreadPools.getFixedThreadPool(numQueryThreads,\n         \"batch scanner \" + batchReaderInstance + \"-\", false);\n+    // Call shutdown on this thread pool in case the caller does not call close().\n     cleanable = CleanerUtil.shutdownThreadPoolExecutor(queryThreadPool, log);\n   }\n \n   @Override\n   public void close() {\n     if (closed.compareAndSet(false, true)) {\n-      // deregister cleanable, but it won't run because it checks\n-      // the value of closed first, which is now true\n-      cleanable.clean();\n       queryThreadPool.shutdownNow();\n+      cleanable.clean();", "originalCommit": "d7c1aeba61833a89e02c738a5841866810b04de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUxNDkzNA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543514934", "bodyText": "So we really only need cleanable.clean() here as it deregisters and invokes the cleaning action.", "author": "dlmarion", "createdAt": "2020-12-15T16:53:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUzMTg0Mg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543531842", "bodyText": "In the next commit I left the order of calls the same. If we only use cleanable.clean() or put cleanable.clean() first, then we will always get the WARN log message: ThreadPoolExecutor found unreferenced without calling shutdown() or shutdownNow().", "author": "dlmarion", "createdAt": "2020-12-15T17:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1ODU2OQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543558569", "bodyText": "In the next commit I left the order of calls the same. If we only use cleanable.clean() or put cleanable.clean() first, then we will always get the WARN log message: ThreadPoolExecutor found unreferenced without calling shutdown() or shutdownNow().\n\nIf shutdown is only called in the close method, then it can be guarded with the closed variable that you are now passing to the cleaner. I guess what I don't know is if we ever want to call shutdown while leaving the containing object unclosed.", "author": "ctubbsii", "createdAt": "2020-12-15T17:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5ODg0OQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556298849", "bodyText": "The reason to ensure the cleanable is deregistered first, is because the shutdownNow() could throw an exception, causing the cleanable to stick around until the object is garbage collected. In general, we don't want cleanables to stick around if they are going to be NOOPs later (the AtomicBoolean \"closed\" variable will ensure it's a NOOP, so we don't try to close it both inside the cleanable and outside).", "author": "ctubbsii", "createdAt": "2021-01-13T06:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMDIyOA=="}], "type": "inlineReview", "revised_code": {"commit": "e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchReader.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchReader.java\nindex 009d750273..46c1b58be2 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchReader.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchReader.java\n", "chunk": "@@ -73,13 +73,15 @@ public class TabletServerBatchReader extends ScannerOptions implements BatchScan\n     queryThreadPool = ThreadPools.getFixedThreadPool(numQueryThreads,\n         \"batch scanner \" + batchReaderInstance + \"-\", false);\n     // Call shutdown on this thread pool in case the caller does not call close().\n-    cleanable = CleanerUtil.shutdownThreadPoolExecutor(queryThreadPool, log);\n+    cleanable = CleanerUtil.shutdownThreadPoolExecutor(queryThreadPool, closed, log);\n   }\n \n   @Override\n   public void close() {\n     if (closed.compareAndSet(false, true)) {\n+      // Shutdown the pool\n       queryThreadPool.shutdownNow();\n+      // deregister the cleaner, will not call shutdownNow() because closed is now true\n       cleanable.clean();\n     }\n   }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchReader.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchReader.java\nindex 009d750273..a3b7816b5b 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchReader.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchReader.java\n", "chunk": "@@ -70,16 +70,18 @@ public class TabletServerBatchReader extends ScannerOptions implements BatchScan\n     this.tableId = tableId;\n     this.numThreads = numQueryThreads;\n \n-    queryThreadPool = ThreadPools.getFixedThreadPool(numQueryThreads,\n+    queryThreadPool = ThreadPools.createFixedThreadPool(numQueryThreads,\n         \"batch scanner \" + batchReaderInstance + \"-\", false);\n     // Call shutdown on this thread pool in case the caller does not call close().\n-    cleanable = CleanerUtil.shutdownThreadPoolExecutor(queryThreadPool, log);\n+    cleanable = CleanerUtil.shutdownThreadPoolExecutor(queryThreadPool, closed, log);\n   }\n \n   @Override\n   public void close() {\n     if (closed.compareAndSet(false, true)) {\n+      // Shutdown the pool\n       queryThreadPool.shutdownNow();\n+      // deregister the cleaner, will not call shutdownNow() because closed is now true\n       cleanable.clean();\n     }\n   }\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "f2b0936029fcaadb925bd9c229403c82f0283211", "committedDate": "2021-07-09 12:22:20 -0400", "message": "Improve client table exceptions (#2195)"}, {"oid": "b6a466348807fe0d23203f3776cbc3119d5a037d", "committedDate": "2021-11-09 15:25:15 -0500", "message": "Instrument code using OpenTelemetry (#2259)"}, {"oid": "36fca0f3c8f7481e2ec400a486e6955026ba7af4", "committedDate": "2022-01-28 10:33:48 -0500", "message": "Modified ThreadPools to conditionally register metrics (#2432)"}, {"oid": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "committedDate": "2022-03-15 07:29:39 -0400", "message": "Set default UncaughtExceptionHandler in client, enable override (#2554)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "557125539cf35362c69002ad72b00af5dd69e672", "committedDate": "2022-11-17 11:50:22 -0500", "message": "Allow ScanServers to scan offline tables (#3082)"}, {"oid": "0928f740f9ddf9aeb104d8357f219457e67de925", "committedDate": "2022-12-01 13:12:54 -0500", "message": "Revert \"Allow ScanServers to scan offline tables (#3082)\" (#3101)"}, {"oid": "895479eb08074b70df9ec71046ba6a75c099d360", "committedDate": "2023-02-08 12:45:19 -0500", "message": "Merge branch '1.10' into 2.1"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMTc1OA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543501758", "body": "The other cleanables pass in the closed atomic boolean, so they can detect whether the resource has already been closed, and the cleanable action isn't needed. I suggest following the same pattern, just for convenience, rather than follow a custom pattern here.", "bodyText": "The other cleanables pass in the closed atomic boolean, so they can detect whether the resource has already been closed, and the cleanable action isn't needed. I suggest following the same pattern, just for convenience, rather than follow a custom pattern here.", "bodyHTML": "<p dir=\"auto\">The other cleanables pass in the closed atomic boolean, so they can detect whether the resource has already been closed, and the cleanable action isn't needed. I suggest following the same pattern, just for convenience, rather than follow a custom pattern here.</p>", "author": "ctubbsii", "createdAt": "2020-12-15T16:37:47Z", "path": "core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java", "diffHunk": "@@ -107,10 +107,14 @@ public static Cleanable shutdownThreadPoolExecutor(Object tpe, Logger log) {\n     requireNonNull(tpe);\n     requireNonNull(log);\n     return CLEANER.register(tpe, () -> {\n+      ThreadPoolExecutor pool = (ThreadPoolExecutor) tpe;\n+      if (pool.isShutdown()) {\n+        return;\n+      }", "originalCommit": "d7c1aeba61833a89e02c738a5841866810b04de4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java b/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\nindex 2fb4312cbf..7276f7b06a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\n", "chunk": "@@ -103,12 +103,12 @@ public class CleanerUtil {\n     });\n   }\n \n-  public static Cleanable shutdownThreadPoolExecutor(Object tpe, Logger log) {\n-    requireNonNull(tpe);\n+  public static Cleanable shutdownThreadPoolExecutor(ThreadPoolExecutor pool, AtomicBoolean closed,\n+      Logger log) {\n+    requireNonNull(pool);\n     requireNonNull(log);\n-    return CLEANER.register(tpe, () -> {\n-      ThreadPoolExecutor pool = (ThreadPoolExecutor) tpe;\n-      if (pool.isShutdown()) {\n+    return CLEANER.register(pool, () -> {\n+      if (closed.get()) {\n         return;\n       }\n       log.warn(\"{} found unreferenced without calling shutdown() or shutdownNow()\",\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java b/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\nindex 2fb4312cbf..7276f7b06a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java\n", "chunk": "@@ -103,12 +103,12 @@ public class CleanerUtil {\n     });\n   }\n \n-  public static Cleanable shutdownThreadPoolExecutor(Object tpe, Logger log) {\n-    requireNonNull(tpe);\n+  public static Cleanable shutdownThreadPoolExecutor(ThreadPoolExecutor pool, AtomicBoolean closed,\n+      Logger log) {\n+    requireNonNull(pool);\n     requireNonNull(log);\n-    return CLEANER.register(tpe, () -> {\n-      ThreadPoolExecutor pool = (ThreadPoolExecutor) tpe;\n-      if (pool.isShutdown()) {\n+    return CLEANER.register(pool, () -> {\n+      if (closed.get()) {\n         return;\n       }\n       log.warn(\"{} found unreferenced without calling shutdown() or shutdownNow()\",\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "b6a466348807fe0d23203f3776cbc3119d5a037d", "committedDate": "2021-11-09 15:25:15 -0500", "message": "Instrument code using OpenTelemetry (#2259)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "2dbdc085390794e7925740a81439c66dc3dfbb7c", "committedDate": "2022-10-20 00:16:54 -0400", "message": "Move o.a.a.fate to o.a.a.core.fate (#3035)"}, {"oid": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "committedDate": "2022-11-30 02:21:37 -0500", "message": "Update javadoc tag style to match google style guide (#3064)"}]}, {"oid": "e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b", "url": "https://github.com/apache/accumulo/commit/e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b", "message": "re #1808: addressing PR comments", "committedDate": "2020-12-15T17:21:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543599320", "body": "In talking with @ivakegg and @drewfarris, this may be too severe as it does not run any shutdown hooks and does not perform a graceful shutdown of the application. For example, in [TabletServer](https://github.com/apache/accumulo/blob/main/server/tserver/src/main/java/org/apache/accumulo/tserver/TabletServer.java#L865) a normal shutdown will close the FileSystem and return leases on the files in HDFS. Or, maybe this remains the default action and we need to better handle the errors in the threads.\r\n\r\nThere is also the case where we may want to still catch Throwable in non-critical threads (e.g. QueryTask) so that a StackOverflowError does not shutdown the TabletServer, for example.", "bodyText": "In talking with @ivakegg and @drewfarris, this may be too severe as it does not run any shutdown hooks and does not perform a graceful shutdown of the application. For example, in TabletServer a normal shutdown will close the FileSystem and return leases on the files in HDFS. Or, maybe this remains the default action and we need to better handle the errors in the threads.\nThere is also the case where we may want to still catch Throwable in non-critical threads (e.g. QueryTask) so that a StackOverflowError does not shutdown the TabletServer, for example.", "bodyHTML": "<p dir=\"auto\">In talking with <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/ivakegg/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/ivakegg\">@ivakegg</a> and <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/drewfarris/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/drewfarris\">@drewfarris</a>, this may be too severe as it does not run any shutdown hooks and does not perform a graceful shutdown of the application. For example, in <a href=\"https://github.com/apache/accumulo/blob/main/server/tserver/src/main/java/org/apache/accumulo/tserver/TabletServer.java#L865\">TabletServer</a> a normal shutdown will close the FileSystem and return leases on the files in HDFS. Or, maybe this remains the default action and we need to better handle the errors in the threads.</p>\n<p dir=\"auto\">There is also the case where we may want to still catch Throwable in non-critical threads (e.g. QueryTask) so that a StackOverflowError does not shutdown the TabletServer, for example.</p>", "author": "dlmarion", "createdAt": "2020-12-15T18:50:20Z", "path": "core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -16,20 +16,36 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.accumulo.core.util;\n+package org.apache.accumulo.core.util.threads;\n \n import java.lang.Thread.UncaughtExceptionHandler;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n+/**\n+ * UncaughtExceptionHandler that logs all Exceptions and Errors thrown from a Thread. If an Error is\n+ * thrown, halt the JVM.\n+ *\n+ */\n+class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n-  private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final Logger LOG = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      LOG.error(\"Caught an Exception in {}. Thread is dead.\", t, e);\n+    } else if (e instanceof Error) {\n+      try {\n+        e.printStackTrace();\n+        System.err.println(\"Error thrown in thread: \" + t + \", halting VM.\");\n+      } catch (Throwable e1) {\n+        // If e == OutOfMemoryError, then it's probably that another Error might be\n+        // thrown when trying to print to System.err.\n+      } finally {\n+        Runtime.getRuntime().halt(-1);", "originalCommit": "e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYyODcwOQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543628709", "bodyText": "I think we can't trust the TServer to shut down gracefully if we get to this state, and adding code to categorize and handle different threads each individually, would add too much (unmaintainable) complexity that would be prone to accruing technical debt and drifting from the original intent over time. I think it's simpler and safer to just stop everything in the TServer. Yes, it prevents some graceful shutdown steps from occurring... but it also prevents it from causing harm that is somewhat unpredictable. Rather than try to write protective shutdown code in uncertain emergency circumstances, our code complexity and development effort would be better spent on ensuring robust recovery, in my opinion.", "author": "ctubbsii", "createdAt": "2020-12-15T19:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYyOTU2Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543629566", "bodyText": "That said, I'm not sure if this particular method of killing the tserver in the face of errors is best or not.", "author": "ctubbsii", "createdAt": "2020-12-15T19:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzNjgxNQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543636815", "bodyText": "That just means that we need to make sure that we are catching Exceptions appropriately in the non-critical threads so that it doesn't take down the server.", "author": "dlmarion", "createdAt": "2020-12-15T19:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3ODM1Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543678356", "bodyText": "That just means that we need to make sure that we are catching Exceptions appropriately in the non-critical threads so that it doesn't take down the server.\n\nRight, but I would say all threads, regardless of critical or non-critical. The more we handle regular exceptions robustly, and recover robustly on restart, the less it matters that we didn't do a graceful shutdown under emergency (Error) conditions, because 1) it won't happen very often, and 2) we'll handle recovery well when we restart (or re-assign).", "author": "ctubbsii", "createdAt": "2020-12-15T20:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE0ODU5NA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555148594", "bodyText": "From reading the discussion here, it sounds like there's some uncertainty of what action to take if we get here. Did Ivan or Drew ever weigh in again? I think Christopher's arguments make sense, but am just wondering if it's worth adding configuration to skip halting the tserver? The main reason I suggest that is if there's some unanticipated case where this is hit and it has a big impact on production systems. At least in such a case it could be disabled with a configuration change vs a re-release and deployment of Accumulo. I only suggest that given the uncertainty of whether or not this is too severe of a response to uncaught errors.", "author": "brianloss", "createdAt": "2021-01-11T15:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE5MDgxOA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555190818", "bodyText": "In the first commit for this PR I had put in some logic to only halt the server it a property was set, and then I set that property in the JVM arguments for the server processes. I can easily resurrect that code, but to your point, I think there are still differing opinions.", "author": "dlmarion", "createdAt": "2021-01-11T16:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjYzMjczNw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556632737", "bodyText": "I would argue that there are potential subclasses of Error, that when appearing in a Scan thread should simply log and fail the scan, not halt the entire tserver. It's easy to agree that an OutOfMemoryError warrants halting, but what about a miss-configured context that leads to a UnsupportedClassVersionError or an IOError on a particular file? Particularly the scan threads need to have more flexibility since they are not necessarily running core code. One bad iterator/edge case should not be able to take a cluster down. If this is asking too much than having a configurable list of classes/subclasses that result in a halt would feel more comfortable.", "author": "FineAndDandy", "createdAt": "2021-01-13T15:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY0NTIzNQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556645235", "bodyText": "I would rather resurrect the system property from the first commit and make it enabled by default instead of making a configurable list of Error's that you want to ignore. If you don't want that functionality, then you don't set that property in your accumulo-env.sh file.", "author": "dlmarion", "createdAt": "2021-01-13T16:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAxNDIxOQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r557014219", "bodyText": "a miss-configured context that leads to a UnsupportedClassVersionError or an IOError on a particular file\n\nI would argue that misconfigured class paths are much more serious of an issue than would be implied by trying to proceed in spite of errors caused by them. We should not be trying to proceed when an error occurs as the result of a misconfigured class path. If you can't trust the class path, you can't trust anything, and it is not safe to proceed.\nAs for IOError, see Mark Reinhold's explanation for that ; he specifically explains that it was added to be used in situations where an unrecoverable error (his words) occurs. Suggesting that we should try to recover from situations that are definition-ally unrecoverable seems a bit unreasonable to me.\n\nOne bad iterator/edge case should not be able to take a cluster down.\n\nI understand the motivation for pursuing this. However, thinking about worst case scenarios, I can imagine far worse things than being temporarily offline (data corruption, hijacking by malware, etc.) due to administrator error deploying a bad iterator.\nI think that baking in special handling for these (what should be exceedingly rare) edge cases would be a mistake for a number of reasons. However, persuasive arguments in favor of, or against, such a thing can be made in a subsequent effort, if there is a critical demand for such a thing. There's no need to block this PR on that. It would actually be much simpler to discuss that sort of thing on its own, rather than bundled with the other changes in this PR.", "author": "ctubbsii", "createdAt": "2021-01-14T03:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "3546261f007a8780b0f478ab870a4f1a1d6cb3fc", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java b/core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\nindex a9c40040d2..babfea6cc0 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java\n", "chunk": "@@ -32,11 +32,40 @@ class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n   private static final Logger LOG = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n \n+  private static boolean isError(Throwable t, int depth) {\n+\n+    if (depth > 32) {\n+      // This is a peculiar exception. No error has been found, but recursing too deep may cause a\n+      // stack overflow so going to stop.\n+      return false;\n+    }\n+\n+    while (t != null) {\n+      if (t instanceof Error) {\n+        return true;\n+      }\n+\n+      for (Throwable suppressed : t.getSuppressed()) {\n+        if (isError(suppressed, depth + 1)) {\n+          return true;\n+        }\n+      }\n+\n+      t = t.getCause();\n+    }\n+\n+    return false;\n+  }\n+\n+  static boolean isError(Throwable t) {\n+    return isError(t, 0);\n+  }\n+\n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n     if (e instanceof Exception) {\n       LOG.error(\"Caught an Exception in {}. Thread is dead.\", t, e);\n-    } else if (e instanceof Error) {\n+    } else if (isError(e)) {\n       try {\n         e.printStackTrace();\n         System.err.println(\"Error thrown in thread: \" + t + \", halting VM.\");\n", "next_change": null}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "3546261f007a8780b0f478ab870a4f1a1d6cb3fc", "committedDate": "2022-02-28 12:22:12 -0500", "message": "checks for nested error in AccumuloUncaughtExceptionHandler (#2530)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}]}, {"oid": "4b818173015c5e9c42246b11836060d86a34d5c1", "url": "https://github.com/apache/accumulo/commit/4b818173015c5e9c42246b11836060d86a34d5c1", "message": "Merge branch 'main' into 1808-thread-errors", "committedDate": "2021-01-11T13:38:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMDM5NQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555100395", "body": "Just curious why the initialization for `failedMutations` was moved into the constructor but the other nearby inline final initializations (`violations`, `authorizationFailures`, `serverSideErrors`) weren't?", "bodyText": "Just curious why the initialization for failedMutations was moved into the constructor but the other nearby inline final initializations (violations, authorizationFailures, serverSideErrors) weren't?", "bodyHTML": "<p dir=\"auto\">Just curious why the initialization for <code>failedMutations</code> was moved into the constructor but the other nearby inline final initializations (<code>violations</code>, <code>authorizationFailures</code>, <code>serverSideErrors</code>) weren't?</p>", "author": "brianloss", "createdAt": "2021-01-11T14:51:33Z", "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java", "diffHunk": "@@ -198,6 +197,8 @@ public long getTimeOut() {\n \n   public TabletServerBatchWriter(ClientContext context, BatchWriterConfig config) {\n     this.context = context;\n+    this.executor = ThreadPools.getGeneralScheduledExecutorService(this.context.getConfiguration());\n+    this.failedMutations = new FailedMutations();", "originalCommit": "4b818173015c5e9c42246b11836060d86a34d5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE2OTg0OQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555169849", "bodyText": "It's been almost a month since I looked at this. I don't remember the reason why I moved it and it should work if this line was reverted. I'm not sure if there is reason to do it one vs the other. I can easily change it back if necessary.", "author": "dlmarion", "createdAt": "2021-01-11T16:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMDM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE3MTI2OA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555171268", "bodyText": "No worries--I wasn't suggesting a change, but rather just trying to figure out if I missed something special about that one variable.", "author": "brianloss", "createdAt": "2021-01-11T16:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMDM5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7957d8240581ce74a942c4858cf452bbb2067b90", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex 1a13f0a6e8..e4feb99d02 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -197,7 +197,8 @@ public class TabletServerBatchWriter implements AutoCloseable {\n \n   public TabletServerBatchWriter(ClientContext context, BatchWriterConfig config) {\n     this.context = context;\n-    this.executor = ThreadPools.getGeneralScheduledExecutorService(this.context.getConfiguration());\n+    this.executor =\n+        ThreadPools.createGeneralScheduledExecutorService(this.context.getConfiguration());\n     this.failedMutations = new FailedMutations();\n     this.maxMem = config.getMaxMemory();\n     this.maxLatency = config.getMaxLatency(TimeUnit.MILLISECONDS) <= 0 ? Long.MAX_VALUE\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex 1a13f0a6e8..83f5d98891 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -197,7 +197,8 @@ public class TabletServerBatchWriter implements AutoCloseable {\n \n   public TabletServerBatchWriter(ClientContext context, BatchWriterConfig config) {\n     this.context = context;\n-    this.executor = ThreadPools.getGeneralScheduledExecutorService(this.context.getConfiguration());\n+    this.executor =\n+        ThreadPools.createGeneralScheduledExecutorService(this.context.getConfiguration());\n     this.failedMutations = new FailedMutations();\n     this.maxMem = config.getMaxMemory();\n     this.maxLatency = config.getMaxLatency(TimeUnit.MILLISECONDS) <= 0 ? Long.MAX_VALUE\n", "next_change": {"commit": "0a64b442a92f728858066c2bc12312f96d41d22e", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex 83f5d98891..9047622e6a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -201,9 +204,9 @@ public class TabletServerBatchWriter implements AutoCloseable {\n         ThreadPools.createGeneralScheduledExecutorService(this.context.getConfiguration());\n     this.failedMutations = new FailedMutations();\n     this.maxMem = config.getMaxMemory();\n-    this.maxLatency = config.getMaxLatency(TimeUnit.MILLISECONDS) <= 0 ? Long.MAX_VALUE\n-        : config.getMaxLatency(TimeUnit.MILLISECONDS);\n-    this.timeout = config.getTimeout(TimeUnit.MILLISECONDS);\n+    this.maxLatency = config.getMaxLatency(MILLISECONDS) <= 0 ? Long.MAX_VALUE\n+        : config.getMaxLatency(MILLISECONDS);\n+    this.timeout = config.getTimeout(MILLISECONDS);\n     this.mutations = new MutationSet();\n     this.lastProcessingStartTime = System.currentTimeMillis();\n     this.durability = config.getDurability();\n", "next_change": {"commit": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex 9047622e6a..b2374bcf0a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -214,17 +216,18 @@ public class TabletServerBatchWriter implements AutoCloseable {\n     this.writer = new MutationWriter(config.getMaxWriteThreads());\n \n     if (this.maxLatency != Long.MAX_VALUE) {\n-      executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"BatchWriterLatencyTimer\", () -> {\n-        try {\n-          synchronized (TabletServerBatchWriter.this) {\n-            if ((System.currentTimeMillis() - lastProcessingStartTime)\n-                > TabletServerBatchWriter.this.maxLatency)\n-              startProcessing();\n-          }\n-        } catch (Exception e) {\n-          updateUnknownErrors(\"Max latency task failed \" + e.getMessage(), e);\n-        }\n-      }), 0, this.maxLatency / 4, MILLISECONDS);\n+      latencyTimerFuture = executor\n+          .scheduleWithFixedDelay(Threads.createNamedRunnable(\"BatchWriterLatencyTimer\", () -> {\n+            try {\n+              synchronized (TabletServerBatchWriter.this) {\n+                if ((System.currentTimeMillis() - lastProcessingStartTime)\n+                    > TabletServerBatchWriter.this.maxLatency)\n+                  startProcessing();\n+              }\n+            } catch (Exception e) {\n+              updateUnknownErrors(\"Max latency task failed \" + e.getMessage(), e);\n+            }\n+          }), 0, this.maxLatency / 4, MILLISECONDS);\n     }\n   }\n \n", "next_change": {"commit": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex b2374bcf0a..c5740c02f8 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -232,8 +234,9 @@ public class TabletServerBatchWriter implements AutoCloseable {\n   }\n \n   private synchronized void startProcessing() {\n-    if (mutations.getMemoryUsed() == 0)\n+    if (mutations.getMemoryUsed() == 0) {\n       return;\n+    }\n     lastProcessingStartTime = System.currentTimeMillis();\n     writer.queueMutations(mutations);\n     mutations = new MutationSet();\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "bbd87a6693fc5cdbbe947b0821a4f05a18cf905b", "committedDate": "2021-01-19 08:07:07 -0500", "message": "Closes #1689: Don't catch Throwable (unless it's rethrown) (#1840)"}, {"oid": "675e41aaed0f8ae250d97a10dad35a8aef4c3e82", "committedDate": "2021-02-04 07:55:40 -0500", "message": "Rename master packages to manager. (#1904)"}, {"oid": "f2b0936029fcaadb925bd9c229403c82f0283211", "committedDate": "2021-07-09 12:22:20 -0400", "message": "Improve client table exceptions (#2195)"}, {"oid": "c9e3877373303997d42b465b2cdb62fd3fffd5d8", "committedDate": "2021-10-22 10:51:43 -0400", "message": "Make ThriftTransportPool a part of ClientContext (#2303)"}, {"oid": "b6a466348807fe0d23203f3776cbc3119d5a037d", "committedDate": "2021-11-09 15:25:15 -0500", "message": "Instrument code using OpenTelemetry (#2259)"}, {"oid": "fad597bf40bf3c6893e98d5ebd0e391859a3c7dc", "committedDate": "2021-12-10 16:59:07 -0500", "message": "Remove some useless null checks/assignments (#2377)"}, {"oid": "36fca0f3c8f7481e2ec400a486e6955026ba7af4", "committedDate": "2022-01-28 10:33:48 -0500", "message": "Modified ThreadPools to conditionally register metrics (#2432)"}, {"oid": "c46fa8f1e2eac80ffac3ef594afe3f7b9052fd8a", "committedDate": "2022-02-23 13:46:04 -0500", "message": "Move Tables class into Context (#2517)"}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "committedDate": "2022-03-04 07:59:03 -0500", "message": "Check scheduled tasks periodically for errors (#2524)"}, {"oid": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "committedDate": "2022-03-15 07:29:39 -0400", "message": "Set default UncaughtExceptionHandler in client, enable override (#2554)"}, {"oid": "8be98d6744962ccb9806800943dcd8cc6f2003c1", "committedDate": "2022-04-19 14:25:35 -0400", "message": "Use Thrift Multiplex components to host multiple services (#2620)"}, {"oid": "8e698a47eef0f32a261945ada0904db499891b66", "committedDate": "2022-05-13 17:47:39 -0400", "message": "Consolidated duplicate Thrift client code (#2647)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "committedDate": "2022-11-30 02:21:37 -0500", "message": "Update javadoc tag style to match google style guide (#3064)"}, {"oid": "72c5c46e711dbd484ff1b637b09170de05948a3c", "committedDate": "2022-12-14 16:54:00 -0500", "message": "Move TInfo to client.thrift, remove trace.thrift (#3119)"}, {"oid": "d9dc304ff7c1d8aa3a3be089ae74d5e18204d1a2", "committedDate": "2022-12-16 13:02:42 -0500", "message": "Replace copied HostAndPort with guava (#3129)"}, {"oid": "a643f1763c64e60f17dafdcb609e114746bc61c7", "committedDate": "2023-01-03 14:56:43 -0500", "message": "Decompose tablet thrift svcs main (#3107)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMTM0Nw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555101347", "body": "It seems like maybe calling `ThreadPools.getGeneralScheduledExecutorService` depends on the configuration having a value for `Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE`. Should this logic be moved into `ThreadPools.getGeneralScheduledExecutorService`?", "bodyText": "It seems like maybe calling ThreadPools.getGeneralScheduledExecutorService depends on the configuration having a value for Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE. Should this logic be moved into ThreadPools.getGeneralScheduledExecutorService?", "bodyHTML": "<p dir=\"auto\">It seems like maybe calling <code>ThreadPools.getGeneralScheduledExecutorService</code> depends on the configuration having a value for <code>Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE</code>. Should this logic be moved into <code>ThreadPools.getGeneralScheduledExecutorService</code>?</p>", "author": "brianloss", "createdAt": "2021-01-11T14:52:58Z", "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,20 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy cc = new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = cc.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      cc.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }", "originalCommit": "4b818173015c5e9c42246b11836060d86a34d5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE4NDE3MQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555184171", "bodyText": "IIRC this was specific to the issue of the property not being in the Map<String,String> from which the ConfigurationCopy is based upon and the fact that ConfigurationCopy does not provide the default value in get(Property) but all of the other implementations do. Putting it here resolved this specific issue. I could move it into ThreadPools.getGeneralScheduledExecutorService but it would not be used for the most part. I'm indifferent, I can move it if we have others that think it's a good idea.", "author": "dlmarion", "createdAt": "2021-01-11T16:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMTM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE4ODM2MQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555188361", "bodyText": "That explanation makes sense to me--I just didn't have enough context. Sorry for the noise.", "author": "brianloss", "createdAt": "2021-01-11T16:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMTM0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "7957d8240581ce74a942c4858cf452bbb2067b90", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex dc9523cbb6..d83f25edd2 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -66,7 +66,7 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n       cc.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n           Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n     }\n-    ThreadPools.getGeneralScheduledExecutorService(cc)\n+    ThreadPools.createGeneralScheduledExecutorService(cc)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, cc);\n           Set<String> contextsInUse = cc\n", "next_change": {"commit": "137f7859f81a89744da60c7b0849a1041b178119", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex d83f25edd2..cbc851468a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -60,16 +60,19 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    final ConfigurationCopy cc = new ConfigurationCopy(contextConfigSupplier.get());\n-    String size = cc.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    final ConfigurationCopy threadPoolProperties =\n+        new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n     if (null == size || size.isEmpty()) {\n-      cc.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n           Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n     }\n-    ThreadPools.createGeneralScheduledExecutorService(cc)\n+    ThreadPools.createGeneralScheduledExecutorService(threadPoolProperties)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, cc);\n-          Set<String> contextsInUse = cc\n+          ConfigurationCopy contextCleanerProperties =\n+              new ConfigurationCopy(contextConfigSupplier.get());\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, threadPoolProperties);\n+          Set<String> contextsInUse = contextCleanerProperties\n               .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n", "next_change": {"commit": "370bb25fb6fb640647a2e8ce0076a6e3600b3b79", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex cbc851468a..76eb0fdd8a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -56,24 +56,18 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n     AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(contextConfigSupplier);\n+    startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n-  private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    final ConfigurationCopy threadPoolProperties =\n-        new ConfigurationCopy(contextConfigSupplier.get());\n-    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    if (null == size || size.isEmpty()) {\n-      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n-          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n-    }\n-    ThreadPools.createGeneralScheduledExecutorService(threadPoolProperties)\n+  private static void startCleanupThread(final AccumuloConfiguration conf,\n+      final Supplier<Map<String,String>> contextConfigSupplier) {\n+    ThreadPools.createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          ConfigurationCopy contextCleanerProperties =\n-              new ConfigurationCopy(contextConfigSupplier.get());\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, threadPoolProperties);\n-          Set<String> contextsInUse = contextCleanerProperties\n-              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n+          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n+              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))\n+              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n", "next_change": {"commit": "5153181e5002cc4ea8ade6b747fac66659e64e99", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex 76eb0fdd8a..f7e556e808 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -65,7 +65,6 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n           Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))\n               .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex dc9523cbb6..f7e556e808 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -56,21 +56,17 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n     AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(contextConfigSupplier);\n+    startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n-  private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    final ConfigurationCopy cc = new ConfigurationCopy(contextConfigSupplier.get());\n-    String size = cc.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    if (null == size || size.isEmpty()) {\n-      cc.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n-          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n-    }\n-    ThreadPools.getGeneralScheduledExecutorService(cc)\n+  private static void startCleanupThread(final AccumuloConfiguration conf,\n+      final Supplier<Map<String,String>> contextConfigSupplier) {\n+    ThreadPools.createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, cc);\n-          Set<String> contextsInUse = cc\n-              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n+          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n+              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n", "next_change": {"commit": "0a64b442a92f728858066c2bc12312f96d41d22e", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex f7e556e808..e19c38b92d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -69,7 +70,7 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-        }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n+        }), 1, 1, MINUTES);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n", "next_change": {"commit": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex e19c38b92d..6baaa64aa1 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -71,6 +72,7 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 1, 1, MINUTES);\n+    ThreadPools.watchNonCriticalScheduledTask(future);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n", "next_change": {"commit": "1a0bb1e3d58583ab1f9a90dd1bbc33138345d85a", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex 6baaa64aa1..b9428e6f6e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -43,42 +42,61 @@ import org.slf4j.LoggerFactory;\n  * for all requested contexts. This class is used internally to Accumulo only, and should not be\n  * used by users in their configuration.\n  */\n-@SuppressWarnings({\"deprecation\", \"removal\"})\n public class DefaultContextClassLoaderFactory implements ContextClassLoaderFactory {\n \n   private static final AtomicBoolean isInstantiated = new AtomicBoolean(false);\n   private static final Logger LOG = LoggerFactory.getLogger(DefaultContextClassLoaderFactory.class);\n   private static final String className = DefaultContextClassLoaderFactory.class.getName();\n \n+  @SuppressWarnings(\"removal\")\n+  private static final Property VFS_CONTEXT_CLASSPATH_PROPERTY =\n+      Property.VFS_CONTEXT_CLASSPATH_PROPERTY;\n+\n   public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n     if (!isInstantiated.compareAndSet(false, true)) {\n       throw new IllegalStateException(\"Can only instantiate \" + className + \" once\");\n     }\n     Supplier<Map<String,String>> contextConfigSupplier =\n-        () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n-    AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n+        () -> accConf.getAllPropertiesWithPrefix(VFS_CONTEXT_CLASSPATH_PROPERTY);\n+    setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n     startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n+  @SuppressWarnings(\"deprecation\")\n+  private static void setContextConfig(Supplier<Map<String,String>> contextConfigSupplier) {\n+    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .setContextConfig(contextConfigSupplier);\n+  }\n+\n   private static void startCleanupThread(final AccumuloConfiguration conf,\n       final Supplier<Map<String,String>> contextConfigSupplier) {\n-    ScheduledFuture<?> future = ThreadPools.createGeneralScheduledExecutorService(conf)\n+    ScheduledFuture<?> future = ThreadPools.getClientThreadPools((t, e) -> {\n+      LOG.error(\"context classloader cleanup thread has failed.\", e);\n+    }).createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n           Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .map(p -> p.substring(VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-          AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n+          removeUnusedContexts(contextsInUse);\n         }), 1, 1, MINUTES);\n     ThreadPools.watchNonCriticalScheduledTask(future);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n+  @SuppressWarnings(\"deprecation\")\n+  private static void removeUnusedContexts(Set<String> contextsInUse) {\n+    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .removeUnusedContexts(contextsInUse);\n+  }\n+\n+  @SuppressWarnings(\"deprecation\")\n   @Override\n   public ClassLoader getClassLoader(String contextName) {\n-    return AccumuloVFSClassLoader.getContextClassLoader(contextName);\n+    return org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .getContextClassLoader(contextName);\n   }\n \n }\n", "next_change": {"commit": "cc44add8bcf9d69057f18d19e6fe9d6b9328575f", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\ndeleted file mode 100644\nindex b9428e6f6e..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ /dev/null\n", "chunk": "@@ -1,102 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.classloader;\n-\n-import static java.util.concurrent.TimeUnit.MINUTES;\n-\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.spi.common.ContextClassLoaderFactory;\n-import org.apache.accumulo.core.util.threads.ThreadPools;\n-import org.apache.accumulo.core.util.threads.Threads;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The default implementation of ContextClassLoaderFactory. This implementation is subject to change\n- * over time. It currently implements the legacy context class loading behavior based on Accumulo's\n- * custom class loaders and commons-vfs2. In future, it may simply return the system class loader\n- * for all requested contexts. This class is used internally to Accumulo only, and should not be\n- * used by users in their configuration.\n- */\n-public class DefaultContextClassLoaderFactory implements ContextClassLoaderFactory {\n-\n-  private static final AtomicBoolean isInstantiated = new AtomicBoolean(false);\n-  private static final Logger LOG = LoggerFactory.getLogger(DefaultContextClassLoaderFactory.class);\n-  private static final String className = DefaultContextClassLoaderFactory.class.getName();\n-\n-  @SuppressWarnings(\"removal\")\n-  private static final Property VFS_CONTEXT_CLASSPATH_PROPERTY =\n-      Property.VFS_CONTEXT_CLASSPATH_PROPERTY;\n-\n-  public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n-    if (!isInstantiated.compareAndSet(false, true)) {\n-      throw new IllegalStateException(\"Can only instantiate \" + className + \" once\");\n-    }\n-    Supplier<Map<String,String>> contextConfigSupplier =\n-        () -> accConf.getAllPropertiesWithPrefix(VFS_CONTEXT_CLASSPATH_PROPERTY);\n-    setContextConfig(contextConfigSupplier);\n-    LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(accConf, contextConfigSupplier);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  private static void setContextConfig(Supplier<Map<String,String>> contextConfigSupplier) {\n-    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .setContextConfig(contextConfigSupplier);\n-  }\n-\n-  private static void startCleanupThread(final AccumuloConfiguration conf,\n-      final Supplier<Map<String,String>> contextConfigSupplier) {\n-    ScheduledFuture<?> future = ThreadPools.getClientThreadPools((t, e) -> {\n-      LOG.error(\"context classloader cleanup thread has failed.\", e);\n-    }).createGeneralScheduledExecutorService(conf)\n-        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n-          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .map(p -> p.substring(VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n-              .collect(Collectors.toSet());\n-          LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-          removeUnusedContexts(contextsInUse);\n-        }), 1, 1, MINUTES);\n-    ThreadPools.watchNonCriticalScheduledTask(future);\n-    LOG.debug(\"Context cleanup timer started at 60s intervals\");\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  private static void removeUnusedContexts(Set<String> contextsInUse) {\n-    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .removeUnusedContexts(contextsInUse);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  @Override\n-  public ClassLoader getClassLoader(String contextName) {\n-    return org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .getContextClassLoader(contextName);\n-  }\n-\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "committedDate": "2022-03-04 07:59:03 -0500", "message": "Check scheduled tasks periodically for errors (#2524)"}, {"oid": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "committedDate": "2022-03-15 07:29:39 -0400", "message": "Set default UncaughtExceptionHandler in client, enable override (#2554)"}, {"oid": "1a0bb1e3d58583ab1f9a90dd1bbc33138345d85a", "committedDate": "2022-05-13 18:18:42 -0400", "message": "Minor little cleanups (#2695)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "cc44add8bcf9d69057f18d19e6fe9d6b9328575f", "committedDate": "2023-02-24 10:16:48 -0500", "message": "Remove deprecated AccumuloVFSClassLoader  (#3136)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTExMDgyMg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555110822", "body": "I like the fact that previously the timer thread would have `BatchWriter` in its name. Only `latency timer` makes it just a little harder to figure out when looking at a thread dump, IMO.\r\n```suggestion\r\n      executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"BatchWriterLatencyTimer\", () -> {\r\n```", "bodyText": "I like the fact that previously the timer thread would have BatchWriter in its name. Only latency timer makes it just a little harder to figure out when looking at a thread dump, IMO.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"latency timer\", () -> {\n          \n          \n            \n                  executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"BatchWriterLatencyTimer\", () -> {", "bodyHTML": "<p dir=\"auto\">I like the fact that previously the timer thread would have <code>BatchWriter</code> in its name. Only <code>latency timer</code> makes it just a little harder to figure out when looking at a thread dump, IMO.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      executor<span class=\"pl-k\">.</span>scheduleWithFixedDelay(<span class=\"pl-smi\">Threads</span><span class=\"pl-k\">.</span>createNamedRunnable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">latency timer</span><span class=\"pl-pds\">\"</span></span>, () <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      executor<span class=\"pl-k\">.</span>scheduleWithFixedDelay(<span class=\"pl-smi\">Threads</span><span class=\"pl-k\">.</span>createNamedRunnable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"x x-first x-last\">BatchWriterLatencyTimer</span><span class=\"pl-pds\">\"</span></span>, () <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "brianloss", "createdAt": "2021-01-11T15:06:03Z", "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java", "diffHunk": "@@ -209,20 +210,17 @@ public TabletServerBatchWriter(ClientContext context, BatchWriterConfig config)\n     this.writer = new MutationWriter(config.getMaxWriteThreads());\n \n     if (this.maxLatency != Long.MAX_VALUE) {\n-      jtimer.schedule(new TimerTask() {\n-        @Override\n-        public void run() {\n-          try {\n-            synchronized (TabletServerBatchWriter.this) {\n-              if ((System.currentTimeMillis() - lastProcessingStartTime)\n-                  > TabletServerBatchWriter.this.maxLatency)\n-                startProcessing();\n-            }\n-          } catch (Throwable t) {\n-            updateUnknownErrors(\"Max latency task failed \" + t.getMessage(), t);\n+      executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"latency timer\", () -> {", "originalCommit": "4b818173015c5e9c42246b11836060d86a34d5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE3NDg0NQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555174845", "bodyText": "That's a good catch, I can change the thread name.", "author": "dlmarion", "createdAt": "2021-01-11T16:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTExMDgyMg=="}], "type": "inlineReview", "revised_code": {"commit": "7957d8240581ce74a942c4858cf452bbb2067b90", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex 1a13f0a6e8..e4feb99d02 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -210,7 +211,7 @@ public class TabletServerBatchWriter implements AutoCloseable {\n     this.writer = new MutationWriter(config.getMaxWriteThreads());\n \n     if (this.maxLatency != Long.MAX_VALUE) {\n-      executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"latency timer\", () -> {\n+      executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"BatchWriterLatencyTimer\", () -> {\n         try {\n           synchronized (TabletServerBatchWriter.this) {\n             if ((System.currentTimeMillis() - lastProcessingStartTime)\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex 1a13f0a6e8..83f5d98891 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -210,7 +211,7 @@ public class TabletServerBatchWriter implements AutoCloseable {\n     this.writer = new MutationWriter(config.getMaxWriteThreads());\n \n     if (this.maxLatency != Long.MAX_VALUE) {\n-      executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"latency timer\", () -> {\n+      executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"BatchWriterLatencyTimer\", () -> {\n         try {\n           synchronized (TabletServerBatchWriter.this) {\n             if ((System.currentTimeMillis() - lastProcessingStartTime)\n", "next_change": {"commit": "bbd87a6693fc5cdbbe947b0821a4f05a18cf905b", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex 83f5d98891..f90cfca256 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -218,8 +218,8 @@ public class TabletServerBatchWriter implements AutoCloseable {\n                 > TabletServerBatchWriter.this.maxLatency)\n               startProcessing();\n           }\n-        } catch (Throwable t) {\n-          updateUnknownErrors(\"Max latency task failed \" + t.getMessage(), t);\n+        } catch (Exception e) {\n+          updateUnknownErrors(\"Max latency task failed \" + e.getMessage(), e);\n         }\n       }), 0, this.maxLatency / 4, TimeUnit.MILLISECONDS);\n     }\n", "next_change": {"commit": "0a64b442a92f728858066c2bc12312f96d41d22e", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex f90cfca256..9047622e6a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -221,7 +224,7 @@ public class TabletServerBatchWriter implements AutoCloseable {\n         } catch (Exception e) {\n           updateUnknownErrors(\"Max latency task failed \" + e.getMessage(), e);\n         }\n-      }), 0, this.maxLatency / 4, TimeUnit.MILLISECONDS);\n+      }), 0, this.maxLatency / 4, MILLISECONDS);\n     }\n   }\n \n", "next_change": {"commit": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex 9047622e6a..b2374bcf0a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -214,17 +216,18 @@ public class TabletServerBatchWriter implements AutoCloseable {\n     this.writer = new MutationWriter(config.getMaxWriteThreads());\n \n     if (this.maxLatency != Long.MAX_VALUE) {\n-      executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"BatchWriterLatencyTimer\", () -> {\n-        try {\n-          synchronized (TabletServerBatchWriter.this) {\n-            if ((System.currentTimeMillis() - lastProcessingStartTime)\n-                > TabletServerBatchWriter.this.maxLatency)\n-              startProcessing();\n-          }\n-        } catch (Exception e) {\n-          updateUnknownErrors(\"Max latency task failed \" + e.getMessage(), e);\n-        }\n-      }), 0, this.maxLatency / 4, MILLISECONDS);\n+      latencyTimerFuture = executor\n+          .scheduleWithFixedDelay(Threads.createNamedRunnable(\"BatchWriterLatencyTimer\", () -> {\n+            try {\n+              synchronized (TabletServerBatchWriter.this) {\n+                if ((System.currentTimeMillis() - lastProcessingStartTime)\n+                    > TabletServerBatchWriter.this.maxLatency)\n+                  startProcessing();\n+              }\n+            } catch (Exception e) {\n+              updateUnknownErrors(\"Max latency task failed \" + e.getMessage(), e);\n+            }\n+          }), 0, this.maxLatency / 4, MILLISECONDS);\n     }\n   }\n \n", "next_change": {"commit": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex b2374bcf0a..c5740c02f8 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -232,8 +234,9 @@ public class TabletServerBatchWriter implements AutoCloseable {\n   }\n \n   private synchronized void startProcessing() {\n-    if (mutations.getMemoryUsed() == 0)\n+    if (mutations.getMemoryUsed() == 0) {\n       return;\n+    }\n     lastProcessingStartTime = System.currentTimeMillis();\n     writer.queueMutations(mutations);\n     mutations = new MutationSet();\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "bbd87a6693fc5cdbbe947b0821a4f05a18cf905b", "committedDate": "2021-01-19 08:07:07 -0500", "message": "Closes #1689: Don't catch Throwable (unless it's rethrown) (#1840)"}, {"oid": "675e41aaed0f8ae250d97a10dad35a8aef4c3e82", "committedDate": "2021-02-04 07:55:40 -0500", "message": "Rename master packages to manager. (#1904)"}, {"oid": "f2b0936029fcaadb925bd9c229403c82f0283211", "committedDate": "2021-07-09 12:22:20 -0400", "message": "Improve client table exceptions (#2195)"}, {"oid": "c9e3877373303997d42b465b2cdb62fd3fffd5d8", "committedDate": "2021-10-22 10:51:43 -0400", "message": "Make ThriftTransportPool a part of ClientContext (#2303)"}, {"oid": "b6a466348807fe0d23203f3776cbc3119d5a037d", "committedDate": "2021-11-09 15:25:15 -0500", "message": "Instrument code using OpenTelemetry (#2259)"}, {"oid": "fad597bf40bf3c6893e98d5ebd0e391859a3c7dc", "committedDate": "2021-12-10 16:59:07 -0500", "message": "Remove some useless null checks/assignments (#2377)"}, {"oid": "36fca0f3c8f7481e2ec400a486e6955026ba7af4", "committedDate": "2022-01-28 10:33:48 -0500", "message": "Modified ThreadPools to conditionally register metrics (#2432)"}, {"oid": "c46fa8f1e2eac80ffac3ef594afe3f7b9052fd8a", "committedDate": "2022-02-23 13:46:04 -0500", "message": "Move Tables class into Context (#2517)"}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "committedDate": "2022-03-04 07:59:03 -0500", "message": "Check scheduled tasks periodically for errors (#2524)"}, {"oid": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "committedDate": "2022-03-15 07:29:39 -0400", "message": "Set default UncaughtExceptionHandler in client, enable override (#2554)"}, {"oid": "8be98d6744962ccb9806800943dcd8cc6f2003c1", "committedDate": "2022-04-19 14:25:35 -0400", "message": "Use Thrift Multiplex components to host multiple services (#2620)"}, {"oid": "8e698a47eef0f32a261945ada0904db499891b66", "committedDate": "2022-05-13 17:47:39 -0400", "message": "Consolidated duplicate Thrift client code (#2647)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "committedDate": "2022-11-30 02:21:37 -0500", "message": "Update javadoc tag style to match google style guide (#3064)"}, {"oid": "72c5c46e711dbd484ff1b637b09170de05948a3c", "committedDate": "2022-12-14 16:54:00 -0500", "message": "Move TInfo to client.thrift, remove trace.thrift (#3119)"}, {"oid": "d9dc304ff7c1d8aa3a3be089ae74d5e18204d1a2", "committedDate": "2022-12-16 13:02:42 -0500", "message": "Replace copied HostAndPort with guava (#3129)"}, {"oid": "a643f1763c64e60f17dafdcb609e114746bc61c7", "committedDate": "2023-01-03 14:56:43 -0500", "message": "Decompose tablet thrift svcs main (#3107)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTExNTcwOQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555115709", "body": "Not a super strong opinion, but when I first started reading the code I thought maybe these methods could be returning cached/shared executors. I suggest considering changing all of the methods in this class from \"get*\" to \"create*\" (or \"new*\" to match the pattern in the `java.util.concurrent.Executors` class) to make it explicit that they are always creating a resource.", "bodyText": "Not a super strong opinion, but when I first started reading the code I thought maybe these methods could be returning cached/shared executors. I suggest considering changing all of the methods in this class from \"get*\" to \"create*\" (or \"new*\" to match the pattern in the java.util.concurrent.Executors class) to make it explicit that they are always creating a resource.", "bodyHTML": "<p dir=\"auto\">Not a super strong opinion, but when I first started reading the code I thought maybe these methods could be returning cached/shared executors. I suggest considering changing all of the methods in this class from \"get*\" to \"create*\" (or \"new*\" to match the pattern in the <code>java.util.concurrent.Executors</code> class) to make it explicit that they are always creating a resource.</p>", "author": "brianloss", "createdAt": "2021-01-11T15:13:05Z", "path": "core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util.threads;\n+\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+\n+public class ThreadPools {\n+\n+  // the number of seconds before we allow a thread to terminate with non-use.\n+  public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n+\n+  /**\n+   * Get a thread pool based on a thread pool related property\n+   *\n+   * @param conf\n+   *          accumulo configuration\n+   * @param p\n+   *          thread pool related property\n+   * @return ExecutorService impl\n+   * @throws RuntimeException\n+   *           if property is not handled\n+   */\n+  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {", "originalCommit": "4b818173015c5e9c42246b11836060d86a34d5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE4NDcyMw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555184723", "bodyText": "I can change the method names to create*", "author": "dlmarion", "createdAt": "2021-01-11T16:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTExNTcwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "7957d8240581ce74a942c4858cf452bbb2067b90", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nindex 68f2a280dc..cb1d389aa8 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n", "chunk": "@@ -46,82 +46,82 @@ public class ThreadPools {\n    * @throws RuntimeException\n    *           if property is not handled\n    */\n-  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {\n+  public static ExecutorService createExecutorService(AccumuloConfiguration conf, Property p) {\n \n     switch (p) {\n       case GENERAL_SIMPLETIMER_THREADPOOL_SIZE:\n-        return getScheduledExecutorService(conf.getCount(p), \"SimpleTimer\", false);\n+        return createScheduledExecutorService(conf.getCount(p), \"SimpleTimer\", false);\n       case MASTER_BULK_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p),\n+        return createFixedThreadPool(conf.getCount(p),\n             conf.getTimeInMillis(Property.MASTER_BULK_THREADPOOL_TIMEOUT), TimeUnit.MILLISECONDS,\n             \"bulk import\", true);\n       case MASTER_RENAME_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"bulk move\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"bulk move\", false);\n       case MASTER_FATE_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p), \"Repo Runner\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"Repo Runner\", false);\n       case MASTER_STATUS_THREAD_POOL_SIZE:\n         int threads = conf.getCount(p);\n         if (threads == 0) {\n-          return getThreadPool(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n+          return createThreadPool(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n               \"GatherTableInformation\", new SynchronousQueue<Runnable>(), OptionalInt.empty(),\n               false);\n         } else {\n-          return getFixedThreadPool(threads, \"GatherTableInformation\", false);\n+          return createFixedThreadPool(threads, \"GatherTableInformation\", false);\n         }\n       case TSERV_WORKQ_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"distributed work queue\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"distributed work queue\", false);\n       case TSERV_MINC_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"minor compactor\",\n+        return createFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"minor compactor\",\n             true);\n       case TSERV_MIGRATE_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet migration\",\n-            true);\n+        return createFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS,\n+            \"tablet migration\", true);\n       case TSERV_ASSIGNMENT_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet assignment\",\n-            true);\n+        return createFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS,\n+            \"tablet assignment\", true);\n       case TSERV_SUMMARY_RETRIEVAL_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n+        return createThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n             \"summary file retriever\", true);\n       case TSERV_SUMMARY_REMOTE_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n+        return createThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n             \"summary remote\", true);\n       case TSERV_SUMMARY_PARTITION_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n+        return createThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n             \"summary partition\", true);\n       case GC_DELETE_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"deleting\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"deleting\", false);\n       case REPLICATION_WORKER_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"replication task\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"replication task\", false);\n       default:\n         throw new RuntimeException(\"Unhandled thread pool property: \" + p);\n     }\n   }\n \n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n+  public static ThreadPoolExecutor createFixedThreadPool(int numThreads, final String name,\n       boolean enableTracing) {\n-    return getFixedThreadPool(numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS, name,\n+    return createFixedThreadPool(numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS, name,\n         enableTracing);\n   }\n \n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n+  public static ThreadPoolExecutor createFixedThreadPool(int numThreads, final String name,\n       BlockingQueue<Runnable> queue, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS,\n-        name, queue, OptionalInt.empty(), enableTracing);\n+    return createThreadPool(numThreads, numThreads, DEFAULT_TIMEOUT_MILLISECS,\n+        TimeUnit.MILLISECONDS, name, queue, OptionalInt.empty(), enableTracing);\n   }\n \n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, long timeOut, TimeUnit units,\n-      final String name, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, timeOut, units, name,\n+  public static ThreadPoolExecutor createFixedThreadPool(int numThreads, long timeOut,\n+      TimeUnit units, final String name, boolean enableTracing) {\n+    return createThreadPool(numThreads, numThreads, timeOut, units, name,\n         new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n   }\n \n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n+  public static ThreadPoolExecutor createThreadPool(int coreThreads, int maxThreads, long timeOut,\n       TimeUnit units, final String name, boolean enableTracing) {\n-    return getThreadPool(coreThreads, maxThreads, timeOut, units, name,\n+    return createThreadPool(coreThreads, maxThreads, timeOut, units, name,\n         new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n   }\n \n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n+  public static ThreadPoolExecutor createThreadPool(int coreThreads, int maxThreads, long timeOut,\n       TimeUnit units, final String name, BlockingQueue<Runnable> queue, OptionalInt priority,\n       boolean enableTracing) {\n     ThreadPoolExecutor result = null;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nindex 68f2a280dc..cb1d389aa8 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n", "chunk": "@@ -46,82 +46,82 @@ public class ThreadPools {\n    * @throws RuntimeException\n    *           if property is not handled\n    */\n-  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {\n+  public static ExecutorService createExecutorService(AccumuloConfiguration conf, Property p) {\n \n     switch (p) {\n       case GENERAL_SIMPLETIMER_THREADPOOL_SIZE:\n-        return getScheduledExecutorService(conf.getCount(p), \"SimpleTimer\", false);\n+        return createScheduledExecutorService(conf.getCount(p), \"SimpleTimer\", false);\n       case MASTER_BULK_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p),\n+        return createFixedThreadPool(conf.getCount(p),\n             conf.getTimeInMillis(Property.MASTER_BULK_THREADPOOL_TIMEOUT), TimeUnit.MILLISECONDS,\n             \"bulk import\", true);\n       case MASTER_RENAME_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"bulk move\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"bulk move\", false);\n       case MASTER_FATE_THREADPOOL_SIZE:\n-        return getFixedThreadPool(conf.getCount(p), \"Repo Runner\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"Repo Runner\", false);\n       case MASTER_STATUS_THREAD_POOL_SIZE:\n         int threads = conf.getCount(p);\n         if (threads == 0) {\n-          return getThreadPool(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n+          return createThreadPool(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n               \"GatherTableInformation\", new SynchronousQueue<Runnable>(), OptionalInt.empty(),\n               false);\n         } else {\n-          return getFixedThreadPool(threads, \"GatherTableInformation\", false);\n+          return createFixedThreadPool(threads, \"GatherTableInformation\", false);\n         }\n       case TSERV_WORKQ_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"distributed work queue\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"distributed work queue\", false);\n       case TSERV_MINC_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"minor compactor\",\n+        return createFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"minor compactor\",\n             true);\n       case TSERV_MIGRATE_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet migration\",\n-            true);\n+        return createFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS,\n+            \"tablet migration\", true);\n       case TSERV_ASSIGNMENT_MAXCONCURRENT:\n-        return getFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"tablet assignment\",\n-            true);\n+        return createFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS,\n+            \"tablet assignment\", true);\n       case TSERV_SUMMARY_RETRIEVAL_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n+        return createThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n             \"summary file retriever\", true);\n       case TSERV_SUMMARY_REMOTE_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n+        return createThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n             \"summary remote\", true);\n       case TSERV_SUMMARY_PARTITION_THREADS:\n-        return getThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n+        return createThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n             \"summary partition\", true);\n       case GC_DELETE_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"deleting\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"deleting\", false);\n       case REPLICATION_WORKER_THREADS:\n-        return getFixedThreadPool(conf.getCount(p), \"replication task\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"replication task\", false);\n       default:\n         throw new RuntimeException(\"Unhandled thread pool property: \" + p);\n     }\n   }\n \n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n+  public static ThreadPoolExecutor createFixedThreadPool(int numThreads, final String name,\n       boolean enableTracing) {\n-    return getFixedThreadPool(numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS, name,\n+    return createFixedThreadPool(numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS, name,\n         enableTracing);\n   }\n \n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, final String name,\n+  public static ThreadPoolExecutor createFixedThreadPool(int numThreads, final String name,\n       BlockingQueue<Runnable> queue, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS,\n-        name, queue, OptionalInt.empty(), enableTracing);\n+    return createThreadPool(numThreads, numThreads, DEFAULT_TIMEOUT_MILLISECS,\n+        TimeUnit.MILLISECONDS, name, queue, OptionalInt.empty(), enableTracing);\n   }\n \n-  public static ThreadPoolExecutor getFixedThreadPool(int numThreads, long timeOut, TimeUnit units,\n-      final String name, boolean enableTracing) {\n-    return getThreadPool(numThreads, numThreads, timeOut, units, name,\n+  public static ThreadPoolExecutor createFixedThreadPool(int numThreads, long timeOut,\n+      TimeUnit units, final String name, boolean enableTracing) {\n+    return createThreadPool(numThreads, numThreads, timeOut, units, name,\n         new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n   }\n \n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n+  public static ThreadPoolExecutor createThreadPool(int coreThreads, int maxThreads, long timeOut,\n       TimeUnit units, final String name, boolean enableTracing) {\n-    return getThreadPool(coreThreads, maxThreads, timeOut, units, name,\n+    return createThreadPool(coreThreads, maxThreads, timeOut, units, name,\n         new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n   }\n \n-  public static ThreadPoolExecutor getThreadPool(int coreThreads, int maxThreads, long timeOut,\n+  public static ThreadPoolExecutor createThreadPool(int coreThreads, int maxThreads, long timeOut,\n       TimeUnit units, final String name, BlockingQueue<Runnable> queue, OptionalInt priority,\n       boolean enableTracing) {\n     ThreadPoolExecutor result = null;\n", "next_change": {"commit": "b6a466348807fe0d23203f3776cbc3119d5a037d", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nindex cb1d389aa8..db58204034 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n", "chunk": "@@ -46,98 +102,121 @@ public class ThreadPools {\n    * @throws RuntimeException\n    *           if property is not handled\n    */\n-  public static ExecutorService createExecutorService(AccumuloConfiguration conf, Property p) {\n+  public static ExecutorService createExecutorService(final AccumuloConfiguration conf,\n+      final Property p) {\n \n     switch (p) {\n       case GENERAL_SIMPLETIMER_THREADPOOL_SIZE:\n-        return createScheduledExecutorService(conf.getCount(p), \"SimpleTimer\", false);\n-      case MASTER_BULK_THREADPOOL_SIZE:\n+        return createScheduledExecutorService(conf.getCount(p), \"SimpleTimer\");\n+      case MANAGER_BULK_THREADPOOL_SIZE:\n         return createFixedThreadPool(conf.getCount(p),\n-            conf.getTimeInMillis(Property.MASTER_BULK_THREADPOOL_TIMEOUT), TimeUnit.MILLISECONDS,\n-            \"bulk import\", true);\n-      case MASTER_RENAME_THREADS:\n-        return createFixedThreadPool(conf.getCount(p), \"bulk move\", false);\n-      case MASTER_FATE_THREADPOOL_SIZE:\n-        return createFixedThreadPool(conf.getCount(p), \"Repo Runner\", false);\n-      case MASTER_STATUS_THREAD_POOL_SIZE:\n+            conf.getTimeInMillis(Property.MANAGER_BULK_THREADPOOL_TIMEOUT), TimeUnit.MILLISECONDS,\n+            \"bulk import\");\n+      case MANAGER_RENAME_THREADS:\n+        return createFixedThreadPool(conf.getCount(p), \"bulk move\");\n+      case MANAGER_FATE_THREADPOOL_SIZE:\n+        return createFixedThreadPool(conf.getCount(p), \"Repo Runner\");\n+      case MANAGER_STATUS_THREAD_POOL_SIZE:\n         int threads = conf.getCount(p);\n         if (threads == 0) {\n           return createThreadPool(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,\n-              \"GatherTableInformation\", new SynchronousQueue<Runnable>(), OptionalInt.empty(),\n-              false);\n+              \"GatherTableInformation\", new SynchronousQueue<Runnable>(), OptionalInt.empty());\n         } else {\n-          return createFixedThreadPool(threads, \"GatherTableInformation\", false);\n+          return createFixedThreadPool(threads, \"GatherTableInformation\");\n         }\n       case TSERV_WORKQ_THREADS:\n-        return createFixedThreadPool(conf.getCount(p), \"distributed work queue\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"distributed work queue\");\n       case TSERV_MINC_MAXCONCURRENT:\n-        return createFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS, \"minor compactor\",\n-            true);\n+        return createFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS,\n+            \"minor compactor\");\n       case TSERV_MIGRATE_MAXCONCURRENT:\n         return createFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS,\n-            \"tablet migration\", true);\n+            \"tablet migration\");\n       case TSERV_ASSIGNMENT_MAXCONCURRENT:\n         return createFixedThreadPool(conf.getCount(p), 0L, TimeUnit.MILLISECONDS,\n-            \"tablet assignment\", true);\n+            \"tablet assignment\");\n       case TSERV_SUMMARY_RETRIEVAL_THREADS:\n         return createThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary file retriever\", true);\n+            \"summary file retriever\");\n       case TSERV_SUMMARY_REMOTE_THREADS:\n         return createThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary remote\", true);\n+            \"summary remote\");\n       case TSERV_SUMMARY_PARTITION_THREADS:\n         return createThreadPool(conf.getCount(p), conf.getCount(p), 60, TimeUnit.SECONDS,\n-            \"summary partition\", true);\n+            \"summary partition\");\n       case GC_DELETE_THREADS:\n-        return createFixedThreadPool(conf.getCount(p), \"deleting\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"deleting\");\n       case REPLICATION_WORKER_THREADS:\n-        return createFixedThreadPool(conf.getCount(p), \"replication task\", false);\n+        return createFixedThreadPool(conf.getCount(p), \"replication task\");\n       default:\n         throw new RuntimeException(\"Unhandled thread pool property: \" + p);\n     }\n   }\n \n-  public static ThreadPoolExecutor createFixedThreadPool(int numThreads, final String name,\n-      boolean enableTracing) {\n-    return createFixedThreadPool(numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS, name,\n-        enableTracing);\n+  public static ThreadPoolExecutor createFixedThreadPool(int numThreads, final String name) {\n+    return createFixedThreadPool(numThreads, DEFAULT_TIMEOUT_MILLISECS, TimeUnit.MILLISECONDS,\n+        name);\n   }\n \n   public static ThreadPoolExecutor createFixedThreadPool(int numThreads, final String name,\n-      BlockingQueue<Runnable> queue, boolean enableTracing) {\n+      BlockingQueue<Runnable> queue) {\n     return createThreadPool(numThreads, numThreads, DEFAULT_TIMEOUT_MILLISECS,\n-        TimeUnit.MILLISECONDS, name, queue, OptionalInt.empty(), enableTracing);\n+        TimeUnit.MILLISECONDS, name, queue, OptionalInt.empty());\n   }\n \n   public static ThreadPoolExecutor createFixedThreadPool(int numThreads, long timeOut,\n-      TimeUnit units, final String name, boolean enableTracing) {\n+      TimeUnit units, final String name) {\n     return createThreadPool(numThreads, numThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n+        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty());\n   }\n \n   public static ThreadPoolExecutor createThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, boolean enableTracing) {\n+      TimeUnit units, final String name) {\n     return createThreadPool(coreThreads, maxThreads, timeOut, units, name,\n-        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty(), enableTracing);\n+        new LinkedBlockingQueue<Runnable>(), OptionalInt.empty());\n   }\n \n   public static ThreadPoolExecutor createThreadPool(int coreThreads, int maxThreads, long timeOut,\n-      TimeUnit units, final String name, BlockingQueue<Runnable> queue, OptionalInt priority,\n-      boolean enableTracing) {\n-    ThreadPoolExecutor result = null;\n-    if (enableTracing) {\n-      result = new TracingThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    } else {\n-      result = new ThreadPoolExecutor(coreThreads, maxThreads, timeOut, units, queue,\n-          new NamedThreadFactory(name, priority));\n-    }\n+      TimeUnit units, final String name, BlockingQueue<Runnable> queue, OptionalInt priority) {\n+    ThreadPoolExecutor result = new ThreadPoolExecutor(coreThreads, maxThreads, timeOut, units,\n+        queue, new NamedThreadFactory(name, priority)) {\n+\n+      @Override\n+      public void execute(Runnable arg0) {\n+        super.execute(Context.current().wrap(arg0));\n+      }\n+\n+      @Override\n+      public boolean remove(Runnable task) {\n+        return super.remove(Context.current().wrap(task));\n+      }\n+\n+      @Override\n+      public <T> Future<T> submit(Callable<T> task) {\n+        return super.submit(Context.current().wrap(task));\n+      }\n+\n+      @Override\n+      public <T> Future<T> submit(Runnable task, T result) {\n+        return super.submit(Context.current().wrap(task), result);\n+      }\n+\n+      @Override\n+      public Future<?> submit(Runnable task) {\n+        return super.submit(Context.current().wrap(task));\n+      }\n+    };\n     if (timeOut > 0) {\n       result.allowCoreThreadTimeOut(true);\n     }\n+    MetricsUtil.addExecutorServiceMetrics(result, name);\n     return result;\n   }\n \n+  /*\n+   * If you need the server-side shared ScheduledThreadPoolExecutor, then use\n+   * ServerContext.getScheduledExecutor()\n+   */\n   public static ScheduledThreadPoolExecutor\n       createGeneralScheduledExecutorService(AccumuloConfiguration conf) {\n     return (ScheduledThreadPoolExecutor) createExecutorService(conf,\n", "next_change": {"commit": "36fca0f3c8f7481e2ec400a486e6955026ba7af4", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nindex db58204034..25807f6a2f 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n", "chunk": "@@ -220,16 +337,51 @@ public class ThreadPools {\n   public static ScheduledThreadPoolExecutor\n       createGeneralScheduledExecutorService(AccumuloConfiguration conf) {\n     return (ScheduledThreadPoolExecutor) createExecutorService(conf,\n-        Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+        Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE, true);\n   }\n \n+  /**\n+   * Create a named ScheduledThreadPool\n+   *\n+   * @param numThreads\n+   *          number of threads\n+   * @param name\n+   *          thread pool name\n+   * @param emitThreadPoolMetrics\n+   *          When set to true will emit metrics and register the metrics in a static registry.\n+   *          After the thread pool is deleted, there will still be metrics objects related to it in\n+   *          the static registry. There is no way to clean these left over objects up therefore its\n+   *          recommended that this option only be set true for long lived thread pools. Creating\n+   *          lots of short lived thread pools and registering them can lead to out of memory errors\n+   *          over long time periods.\n+   * @return ScheduledThreadPoolExecutor\n+   */\n   public static ScheduledThreadPoolExecutor createScheduledExecutorService(int numThreads,\n-      final String name) {\n-    return createScheduledExecutorService(numThreads, name, OptionalInt.empty());\n+      final String name, boolean emitThreadPoolMetrics) {\n+    return createScheduledExecutorService(numThreads, name, OptionalInt.empty(),\n+        emitThreadPoolMetrics);\n   }\n \n-  public static ScheduledThreadPoolExecutor createScheduledExecutorService(int numThreads,\n-      final String name, OptionalInt priority) {\n+  /**\n+   * Create a named ScheduledThreadPool\n+   *\n+   * @param numThreads\n+   *          number of threads\n+   * @param name\n+   *          thread pool name\n+   * @param priority\n+   *          thread priority\n+   * @param emitThreadPoolMetrics\n+   *          When set to true will emit metrics and register the metrics in a static registry.\n+   *          After the thread pool is deleted, there will still be metrics objects related to it in\n+   *          the static registry. There is no way to clean these left over objects up therefore its\n+   *          recommended that this option only be set true for long lived thread pools. Creating\n+   *          lots of short lived thread pools and registering them can lead to out of memory errors\n+   *          over long time periods.\n+   * @return ScheduledThreadPoolExecutor\n+   */\n+  private static ScheduledThreadPoolExecutor createScheduledExecutorService(int numThreads,\n+      final String name, OptionalInt priority, boolean emitThreadPoolMetrics) {\n     ScheduledThreadPoolExecutor result =\n         new ScheduledThreadPoolExecutor(numThreads, new NamedThreadFactory(name, priority)) {\n \n", "next_change": {"commit": "0fdfee5322278d8833aec541d47bf778489394ac", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nindex 25807f6a2f..ac4ed3da80 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n", "chunk": "@@ -358,83 +386,58 @@ public class ThreadPools {\n    */\n   public static ScheduledThreadPoolExecutor createScheduledExecutorService(int numThreads,\n       final String name, boolean emitThreadPoolMetrics) {\n-    return createScheduledExecutorService(numThreads, name, OptionalInt.empty(),\n-        emitThreadPoolMetrics);\n-  }\n+    var result = new ScheduledThreadPoolExecutor(numThreads, new NamedThreadFactory(name)) {\n \n-  /**\n-   * Create a named ScheduledThreadPool\n-   *\n-   * @param numThreads\n-   *          number of threads\n-   * @param name\n-   *          thread pool name\n-   * @param priority\n-   *          thread priority\n-   * @param emitThreadPoolMetrics\n-   *          When set to true will emit metrics and register the metrics in a static registry.\n-   *          After the thread pool is deleted, there will still be metrics objects related to it in\n-   *          the static registry. There is no way to clean these left over objects up therefore its\n-   *          recommended that this option only be set true for long lived thread pools. Creating\n-   *          lots of short lived thread pools and registering them can lead to out of memory errors\n-   *          over long time periods.\n-   * @return ScheduledThreadPoolExecutor\n-   */\n-  private static ScheduledThreadPoolExecutor createScheduledExecutorService(int numThreads,\n-      final String name, OptionalInt priority, boolean emitThreadPoolMetrics) {\n-    ScheduledThreadPoolExecutor result =\n-        new ScheduledThreadPoolExecutor(numThreads, new NamedThreadFactory(name, priority)) {\n-\n-          @Override\n-          public void execute(Runnable command) {\n-            super.execute(Context.current().wrap(command));\n-          }\n-\n-          @Override\n-          public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n-            return super.schedule(Context.current().wrap(callable), delay, unit);\n-          }\n-\n-          @Override\n-          public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n-            return super.schedule(Context.current().wrap(command), delay, unit);\n-          }\n-\n-          @Override\n-          public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay,\n-              long period, TimeUnit unit) {\n-            return super.scheduleAtFixedRate(Context.current().wrap(command), initialDelay, period,\n-                unit);\n-          }\n-\n-          @Override\n-          public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay,\n-              long delay, TimeUnit unit) {\n-            return super.scheduleWithFixedDelay(Context.current().wrap(command), initialDelay,\n-                delay, unit);\n-          }\n-\n-          @Override\n-          public <T> Future<T> submit(Callable<T> task) {\n-            return super.submit(Context.current().wrap(task));\n-          }\n-\n-          @Override\n-          public <T> Future<T> submit(Runnable task, T result) {\n-            return super.submit(Context.current().wrap(task), result);\n-          }\n-\n-          @Override\n-          public Future<?> submit(Runnable task) {\n-            return super.submit(Context.current().wrap(task));\n-          }\n-\n-          @Override\n-          public boolean remove(Runnable task) {\n-            return super.remove(Context.current().wrap(task));\n-          }\n-\n-        };\n+      @Override\n+      public void execute(Runnable command) {\n+        super.execute(Context.current().wrap(command));\n+      }\n+\n+      @Override\n+      public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n+        return super.schedule(Context.current().wrap(callable), delay, unit);\n+      }\n+\n+      @Override\n+      public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+        return super.schedule(Context.current().wrap(command), delay, unit);\n+      }\n+\n+      @Override\n+      public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay,\n+          long period, TimeUnit unit) {\n+        return super.scheduleAtFixedRate(Context.current().wrap(command), initialDelay, period,\n+            unit);\n+      }\n+\n+      @Override\n+      public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay,\n+          long delay, TimeUnit unit) {\n+        return super.scheduleWithFixedDelay(Context.current().wrap(command), initialDelay, delay,\n+            unit);\n+      }\n+\n+      @Override\n+      public <T> Future<T> submit(Callable<T> task) {\n+        return super.submit(Context.current().wrap(task));\n+      }\n+\n+      @Override\n+      public <T> Future<T> submit(Runnable task, T result) {\n+        return super.submit(Context.current().wrap(task), result);\n+      }\n+\n+      @Override\n+      public Future<?> submit(Runnable task) {\n+        return super.submit(Context.current().wrap(task));\n+      }\n+\n+      @Override\n+      public boolean remove(Runnable task) {\n+        return super.remove(Context.current().wrap(task));\n+      }\n+\n+    };\n     if (emitThreadPoolMetrics) {\n       MetricsUtil.addExecutorServiceMetrics(result, name);\n     }\n", "next_change": {"commit": "b0e2fd0d9e2f7c9877edea47650e8f0b6683dd36", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nindex ac4ed3da80..642ec7ff83 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n", "chunk": "@@ -390,51 +389,49 @@ public class ThreadPools {\n \n       @Override\n       public void execute(Runnable command) {\n-        super.execute(Context.current().wrap(command));\n+        super.execute(TraceUtil.wrap(command));\n       }\n \n       @Override\n       public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n-        return super.schedule(Context.current().wrap(callable), delay, unit);\n+        return super.schedule(TraceUtil.wrap(callable), delay, unit);\n       }\n \n       @Override\n       public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n-        return super.schedule(Context.current().wrap(command), delay, unit);\n+        return super.schedule(TraceUtil.wrap(command), delay, unit);\n       }\n \n       @Override\n       public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay,\n           long period, TimeUnit unit) {\n-        return super.scheduleAtFixedRate(Context.current().wrap(command), initialDelay, period,\n-            unit);\n+        return super.scheduleAtFixedRate(TraceUtil.wrap(command), initialDelay, period, unit);\n       }\n \n       @Override\n       public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay,\n           long delay, TimeUnit unit) {\n-        return super.scheduleWithFixedDelay(Context.current().wrap(command), initialDelay, delay,\n-            unit);\n+        return super.scheduleWithFixedDelay(TraceUtil.wrap(command), initialDelay, delay, unit);\n       }\n \n       @Override\n       public <T> Future<T> submit(Callable<T> task) {\n-        return super.submit(Context.current().wrap(task));\n+        return super.submit(TraceUtil.wrap(task));\n       }\n \n       @Override\n       public <T> Future<T> submit(Runnable task, T result) {\n-        return super.submit(Context.current().wrap(task), result);\n+        return super.submit(TraceUtil.wrap(task), result);\n       }\n \n       @Override\n       public Future<?> submit(Runnable task) {\n-        return super.submit(Context.current().wrap(task));\n+        return super.submit(TraceUtil.wrap(task));\n       }\n \n       @Override\n       public boolean remove(Runnable task) {\n-        return super.remove(Context.current().wrap(task));\n+        return super.remove(TraceUtil.wrap(task));\n       }\n \n     };\n", "next_change": {"commit": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\nindex 642ec7ff83..73cb308251 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java\n", "chunk": "@@ -383,58 +527,59 @@ public class ThreadPools {\n    *          over long time periods.\n    * @return ScheduledThreadPoolExecutor\n    */\n-  public static ScheduledThreadPoolExecutor createScheduledExecutorService(int numThreads,\n+  public ScheduledThreadPoolExecutor createScheduledExecutorService(int numThreads,\n       final String name, boolean emitThreadPoolMetrics) {\n-    var result = new ScheduledThreadPoolExecutor(numThreads, new NamedThreadFactory(name)) {\n-\n-      @Override\n-      public void execute(Runnable command) {\n-        super.execute(TraceUtil.wrap(command));\n-      }\n-\n-      @Override\n-      public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n-        return super.schedule(TraceUtil.wrap(callable), delay, unit);\n-      }\n-\n-      @Override\n-      public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n-        return super.schedule(TraceUtil.wrap(command), delay, unit);\n-      }\n-\n-      @Override\n-      public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay,\n-          long period, TimeUnit unit) {\n-        return super.scheduleAtFixedRate(TraceUtil.wrap(command), initialDelay, period, unit);\n-      }\n-\n-      @Override\n-      public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay,\n-          long delay, TimeUnit unit) {\n-        return super.scheduleWithFixedDelay(TraceUtil.wrap(command), initialDelay, delay, unit);\n-      }\n-\n-      @Override\n-      public <T> Future<T> submit(Callable<T> task) {\n-        return super.submit(TraceUtil.wrap(task));\n-      }\n-\n-      @Override\n-      public <T> Future<T> submit(Runnable task, T result) {\n-        return super.submit(TraceUtil.wrap(task), result);\n-      }\n-\n-      @Override\n-      public Future<?> submit(Runnable task) {\n-        return super.submit(TraceUtil.wrap(task));\n-      }\n-\n-      @Override\n-      public boolean remove(Runnable task) {\n-        return super.remove(TraceUtil.wrap(task));\n-      }\n-\n-    };\n+    var result =\n+        new ScheduledThreadPoolExecutor(numThreads, new NamedThreadFactory(name, handler)) {\n+\n+          @Override\n+          public void execute(Runnable command) {\n+            super.execute(TraceUtil.wrap(command));\n+          }\n+\n+          @Override\n+          public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n+            return super.schedule(TraceUtil.wrap(callable), delay, unit);\n+          }\n+\n+          @Override\n+          public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+            return super.schedule(TraceUtil.wrap(command), delay, unit);\n+          }\n+\n+          @Override\n+          public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay,\n+              long period, TimeUnit unit) {\n+            return super.scheduleAtFixedRate(TraceUtil.wrap(command), initialDelay, period, unit);\n+          }\n+\n+          @Override\n+          public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay,\n+              long delay, TimeUnit unit) {\n+            return super.scheduleWithFixedDelay(TraceUtil.wrap(command), initialDelay, delay, unit);\n+          }\n+\n+          @Override\n+          public <T> Future<T> submit(Callable<T> task) {\n+            return super.submit(TraceUtil.wrap(task));\n+          }\n+\n+          @Override\n+          public <T> Future<T> submit(Runnable task, T result) {\n+            return super.submit(TraceUtil.wrap(task), result);\n+          }\n+\n+          @Override\n+          public Future<?> submit(Runnable task) {\n+            return super.submit(TraceUtil.wrap(task));\n+          }\n+\n+          @Override\n+          public boolean remove(Runnable task) {\n+            return super.remove(TraceUtil.wrap(task));\n+          }\n+\n+        };\n     if (emitThreadPoolMetrics) {\n       MetricsUtil.addExecutorServiceMetrics(result, name);\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "300c933baa5800fd3bdcee2793dd416aeb26a9e6", "committedDate": "2021-01-26 08:40:13 -0500", "message": "Deprecate/replace 'master.*' properties with 'manager.*'. (fixes #1640) (#1873)"}, {"oid": "62334515c982d7ccc8428f288c607eb3cf425761", "committedDate": "2021-09-17 15:26:30 -0400", "message": "Make threadpools marked as mutable resizeable (#2274)"}, {"oid": "e67ffa0a4be2140234fb3c0ea0742dff192bce91", "committedDate": "2021-09-21 12:28:29 -0400", "message": "Resize FaTE thread pool correctly, use method in more places"}, {"oid": "455d5cadbab9618a6fe8be2abd7e4465b562bf14", "committedDate": "2021-09-23 13:00:51 -0400", "message": "Recreated the SimpleTimer functionality with the new ThreadPools class (#2282)"}, {"oid": "b5ca15806659efbbd6f5d158be8648cc2cd13593", "committedDate": "2021-10-27 08:54:16 -0400", "message": "Replace hadoop metrics with micrometer (#2305)"}, {"oid": "b6a466348807fe0d23203f3776cbc3119d5a037d", "committedDate": "2021-11-09 15:25:15 -0500", "message": "Instrument code using OpenTelemetry (#2259)"}, {"oid": "240c60c7c8ec326338d15ecb3c1168cee7a54557", "committedDate": "2021-11-18 13:03:16 -0500", "message": "Resolve deprecation warnings in imports"}, {"oid": "36fca0f3c8f7481e2ec400a486e6955026ba7af4", "committedDate": "2022-01-28 10:33:48 -0500", "message": "Modified ThreadPools to conditionally register metrics (#2432)"}, {"oid": "0fdfee5322278d8833aec541d47bf778489394ac", "committedDate": "2022-01-31 05:09:14 -0500", "message": "Minor cleanup of ThreadPools"}, {"oid": "b0e2fd0d9e2f7c9877edea47650e8f0b6683dd36", "committedDate": "2022-01-31 07:55:35 -0500", "message": "Wrap and unwrap tasks in thread pools properly (#2442)"}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "committedDate": "2022-03-04 07:59:03 -0500", "message": "Check scheduled tasks periodically for errors (#2524)"}, {"oid": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "committedDate": "2022-03-15 07:29:39 -0400", "message": "Set default UncaughtExceptionHandler in client, enable override (#2554)"}, {"oid": "dd81d608bff88835676e756ffcb2a2f6b69c9be8", "committedDate": "2022-03-24 10:05:44 -0400", "message": "Add trace and debug log to consistency check (#2583)"}, {"oid": "6286a2542d30dc04647f402b1e32963358b80ff3", "committedDate": "2022-05-24 22:18:48 -0400", "message": "Rename GENERAL_SIMPLETIMER_THREADPOOL_SIZE (#2712)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "c0e94cc33f39587df415ca189e90dc20be468dca", "committedDate": "2022-08-09 08:02:05 -0400", "message": "Eventually Consistent scans / ScanServer feature (#2665)"}, {"oid": "b2897ff7832c67333f3714a329e189b8916c328e", "committedDate": "2022-11-01 17:18:15 +0000", "message": "address #3053 set ThreadPool creation logging to trace (#3054)"}, {"oid": "9bbde86a68c87f8ac75eac843c2aa1f82712420b", "committedDate": "2022-11-29 20:00:40 -0500", "message": "Remove deprecated replication (#3080)"}, {"oid": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "committedDate": "2022-11-30 02:21:37 -0500", "message": "Update javadoc tag style to match google style guide (#3064)"}, {"oid": "5c870af5015b3dfd8d3db3d5fc56d58d7c2584c0", "committedDate": "2022-11-30 04:40:29 -0500", "message": "Merge branch '2.1'"}, {"oid": "14186ad9156e803f5828819751f394c85e516fe8", "committedDate": "2022-12-16 07:53:22 -0500", "message": "Remove deprecated properties (#3106)"}, {"oid": "3d7d2a5809ee1a33b5d8fa097a2345f51b5924da", "committedDate": "2023-03-09 09:22:05 -0500", "message": "Remove some deprecated items (#3229)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEyMjc0OA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555122748", "body": "Just a nit, but it doesn't appear that the initialization of `thread` is any different based on the type of Runnable passed in. Why not move the initialization up? Maybe something like:\r\n```suggestion\r\n    Thread thread = new Thread(r, name);\r\n    if (r instanceof NamedRunnable) {\r\n      NamedRunnable nr = (NamedRunnable) r;\r\n      if (nr.getPriority().isPresent()) {\r\n        priority = nr.getPriority();\r\n      }\r\n    }\r\n    if (priority.isPresent()) {\r\n      thread.setPriority(priority.getAsInt());\r\n    }\r\n```", "bodyText": "Just a nit, but it doesn't appear that the initialization of thread is any different based on the type of Runnable passed in. Why not move the initialization up? Maybe something like:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Thread thread = null;\n          \n          \n            \n                if (r instanceof NamedRunnable) {\n          \n          \n            \n                  NamedRunnable nr = (NamedRunnable) r;\n          \n          \n            \n                  thread = new Thread(r, name);\n          \n          \n            \n                  if (nr.getPriority().isPresent()) {\n          \n          \n            \n                    thread.setPriority(nr.getPriority().getAsInt());\n          \n          \n            \n                  } else if (priority.isPresent()) {\n          \n          \n            \n                    thread.setPriority(priority.getAsInt());\n          \n          \n            \n                  }\n          \n          \n            \n                } else {\n          \n          \n            \n                  thread = new Thread(r, name);\n          \n          \n            \n                  if (priority.isPresent()) {\n          \n          \n            \n                    thread.setPriority(priority.getAsInt());\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                Thread thread = new Thread(r, name);\n          \n          \n            \n                if (r instanceof NamedRunnable) {\n          \n          \n            \n                  NamedRunnable nr = (NamedRunnable) r;\n          \n          \n            \n                  if (nr.getPriority().isPresent()) {\n          \n          \n            \n                    priority = nr.getPriority();\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                if (priority.isPresent()) {\n          \n          \n            \n                  thread.setPriority(priority.getAsInt());\n          \n          \n            \n                }", "bodyHTML": "<p dir=\"auto\">Just a nit, but it doesn't appear that the initialization of <code>thread</code> is any different based on the type of Runnable passed in. Why not move the initialization up? Maybe something like:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"49\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-smi\">Thread</span> thread <span class=\"pl-k\">=</span> <span class=\"pl-c1\">null</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"50\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">if</span> (r <span class=\"pl-k\">instanceof</span> <span class=\"pl-smi\">NamedRunnable</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"51\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-smi\">NamedRunnable</span> nr <span class=\"pl-k\">=</span> (<span class=\"pl-smi\">NamedRunnable</span>) r;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"52\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      thread <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Thread</span>(r, name);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"53\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-k\">if</span> (nr<span class=\"pl-k\">.</span>getPriority()<span class=\"pl-k\">.</span>isPresent()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"54\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        thread<span class=\"pl-k\">.</span>setPriority(nr<span class=\"pl-k\">.</span>getPriority()<span class=\"pl-k\">.</span>getAsInt());</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"55\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      } <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> (priority<span class=\"pl-k\">.</span>isPresent()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"56\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        thread<span class=\"pl-k\">.</span>setPriority(priority<span class=\"pl-k\">.</span>getAsInt());</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"57\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"58\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    } <span class=\"pl-k\">else</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"59\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      thread <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Thread</span>(r, name);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"60\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      <span class=\"pl-k\">if</span> (priority<span class=\"pl-k\">.</span>isPresent()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"61\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        thread<span class=\"pl-k\">.</span>setPriority(priority<span class=\"pl-k\">.</span>getAsInt());</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"62\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"63\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"49\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-smi\">Thread</span> thread <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Thread</span>(r, name);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"50\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">if</span> (r <span class=\"pl-k\">instanceof</span> <span class=\"pl-smi\">NamedRunnable</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"51\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-smi\">NamedRunnable</span> nr <span class=\"pl-k\">=</span> (<span class=\"pl-smi\">NamedRunnable</span>) r;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"52\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      <span class=\"pl-k\">if</span> (nr<span class=\"pl-k\">.</span>getPriority()<span class=\"pl-k\">.</span>isPresent()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"53\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        priority <span class=\"pl-k\">=</span> nr<span class=\"pl-k\">.</span>getPriority();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"54\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"55\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"56\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">if</span> (priority<span class=\"pl-k\">.</span>isPresent()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"57\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      thread<span class=\"pl-k\">.</span>setPriority(priority<span class=\"pl-k\">.</span>getAsInt());</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"58\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "brianloss", "createdAt": "2021-01-11T15:22:56Z", "path": "core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util.threads;\n+\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.OptionalInt;\n+\n+public class Threads {\n+\n+  public static Runnable createNamedRunnable(String name, Runnable r) {\n+    return new NamedRunnable(name, r);\n+  }\n+\n+  public static Runnable createNamedRunnable(String name, OptionalInt priority, Runnable r) {\n+    return new NamedRunnable(name, priority, r);\n+  }\n+\n+  private static final UncaughtExceptionHandler UEH = new AccumuloUncaughtExceptionHandler();\n+\n+  public static Thread createThread(String name, Runnable r) {\n+    return createThread(name, OptionalInt.empty(), r);\n+  }\n+\n+  public static Thread createThread(String name, OptionalInt priority, Runnable r) {\n+    Thread thread = null;\n+    if (r instanceof NamedRunnable) {\n+      NamedRunnable nr = (NamedRunnable) r;\n+      thread = new Thread(r, name);\n+      if (nr.getPriority().isPresent()) {\n+        thread.setPriority(nr.getPriority().getAsInt());\n+      } else if (priority.isPresent()) {\n+        thread.setPriority(priority.getAsInt());\n+      }\n+    } else {\n+      thread = new Thread(r, name);\n+      if (priority.isPresent()) {\n+        thread.setPriority(priority.getAsInt());\n+      }\n+    }", "originalCommit": "4b818173015c5e9c42246b11836060d86a34d5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE4ODc2Mw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555188763", "bodyText": "I made this change (in the next commit), but I modified your suggestion such that if the priority is set in the NamedRunnable it is not overridden by the priority parameter.", "author": "dlmarion", "createdAt": "2021-01-11T16:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEyMjc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE5MjY5NA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555192694", "bodyText": "I made this change (in the next commit), but I modified your suggestion such that if the priority is set in the NamedRunnable it is not overridden by the priority parameter.\n\nI think my suggestion would have done that too, since it overwrites the priority parameter on line 45, but if you missed that then my suggestion was too subtle so it's best not to use it. :)", "author": "brianloss", "createdAt": "2021-01-11T16:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEyMjc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE5NTkwMg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555195902", "bodyText": "Ah, I see it now. My change should be functionally equivalent.", "author": "dlmarion", "createdAt": "2021-01-11T16:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEyMjc0OA=="}], "type": "inlineReview", "revised_code": {"commit": "7957d8240581ce74a942c4858cf452bbb2067b90", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\nindex 7bc6f99f4f..10792169ab 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n", "chunk": "@@ -38,21 +38,19 @@ public class Threads {\n   }\n \n   public static Thread createThread(String name, OptionalInt priority, Runnable r) {\n-    Thread thread = null;\n+    Thread thread = new Thread(r, name);\n+    boolean prioritySet = false;\n     if (r instanceof NamedRunnable) {\n       NamedRunnable nr = (NamedRunnable) r;\n-      thread = new Thread(r, name);\n       if (nr.getPriority().isPresent()) {\n         thread.setPriority(nr.getPriority().getAsInt());\n-      } else if (priority.isPresent()) {\n-        thread.setPriority(priority.getAsInt());\n-      }\n-    } else {\n-      thread = new Thread(r, name);\n-      if (priority.isPresent()) {\n-        thread.setPriority(priority.getAsInt());\n+        prioritySet = true;\n       }\n     }\n+    // Don't override priority set in NamedRunnable, if set\n+    if (priority.isPresent() && !prioritySet) {\n+      thread.setPriority(priority.getAsInt());\n+    }\n     thread.setDaemon(true);\n     thread.setUncaughtExceptionHandler(UEH);\n     return thread;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\nindex 7bc6f99f4f..10792169ab 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n", "chunk": "@@ -38,21 +38,19 @@ public class Threads {\n   }\n \n   public static Thread createThread(String name, OptionalInt priority, Runnable r) {\n-    Thread thread = null;\n+    Thread thread = new Thread(r, name);\n+    boolean prioritySet = false;\n     if (r instanceof NamedRunnable) {\n       NamedRunnable nr = (NamedRunnable) r;\n-      thread = new Thread(r, name);\n       if (nr.getPriority().isPresent()) {\n         thread.setPriority(nr.getPriority().getAsInt());\n-      } else if (priority.isPresent()) {\n-        thread.setPriority(priority.getAsInt());\n-      }\n-    } else {\n-      thread = new Thread(r, name);\n-      if (priority.isPresent()) {\n-        thread.setPriority(priority.getAsInt());\n+        prioritySet = true;\n       }\n     }\n+    // Don't override priority set in NamedRunnable, if set\n+    if (priority.isPresent() && !prioritySet) {\n+      thread.setPriority(priority.getAsInt());\n+    }\n     thread.setDaemon(true);\n     thread.setUncaughtExceptionHandler(UEH);\n     return thread;\n", "next_change": {"commit": "ece553a3ef0f47ef321eb4541ba220d22b5f796a", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\nindex 10792169ab..2a05a4c6e7 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n", "chunk": "@@ -38,19 +36,8 @@ public class Threads {\n   }\n \n   public static Thread createThread(String name, OptionalInt priority, Runnable r) {\n-    Thread thread = new Thread(r, name);\n-    boolean prioritySet = false;\n-    if (r instanceof NamedRunnable) {\n-      NamedRunnable nr = (NamedRunnable) r;\n-      if (nr.getPriority().isPresent()) {\n-        thread.setPriority(nr.getPriority().getAsInt());\n-        prioritySet = true;\n-      }\n-    }\n-    // Don't override priority set in NamedRunnable, if set\n-    if (priority.isPresent() && !prioritySet) {\n-      thread.setPriority(priority.getAsInt());\n-    }\n+    Thread thread = new Thread(Context.current().wrap(r), name);\n+    priority.ifPresent(thread::setPriority);\n     thread.setDaemon(true);\n     thread.setUncaughtExceptionHandler(UEH);\n     return thread;\n", "next_change": {"commit": "b0e2fd0d9e2f7c9877edea47650e8f0b6683dd36", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\nindex 2a05a4c6e7..3478ffa986 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n", "chunk": "@@ -36,7 +36,7 @@ public class Threads {\n   }\n \n   public static Thread createThread(String name, OptionalInt priority, Runnable r) {\n-    Thread thread = new Thread(Context.current().wrap(r), name);\n+    Thread thread = new Thread(TraceUtil.wrap(r), name);\n     priority.ifPresent(thread::setPriority);\n     thread.setDaemon(true);\n     thread.setUncaughtExceptionHandler(UEH);\n", "next_change": {"commit": "b13ba9daf696b8088887c7ed5acfeec721572e60", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\nindex 3478ffa986..0d2597210d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n", "chunk": "@@ -36,10 +49,14 @@ public class Threads {\n   }\n \n   public static Thread createThread(String name, OptionalInt priority, Runnable r) {\n-    Thread thread = new Thread(TraceUtil.wrap(r), name);\n+    Thread thread = new AccumuloDaemonThread(TraceUtil.wrap(r), name);\n     priority.ifPresent(thread::setPriority);\n+    return thread;\n+  }\n+\n+  private static void configureThread(Thread thread, String name) {\n+    thread.setName(name);\n     thread.setDaemon(true);\n     thread.setUncaughtExceptionHandler(UEH);\n-    return thread;\n   }\n }\n", "next_change": {"commit": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\nindex 0d2597210d..c61c06331c 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java\n", "chunk": "@@ -25,38 +25,45 @@ import org.apache.accumulo.core.trace.TraceUtil;\n \n public class Threads {\n \n+  public static final UncaughtExceptionHandler UEH = new AccumuloUncaughtExceptionHandler();\n+\n   public static class AccumuloDaemonThread extends Thread {\n \n-    public AccumuloDaemonThread(Runnable target, String name) {\n+    public AccumuloDaemonThread(Runnable target, String name, UncaughtExceptionHandler ueh) {\n       super(target, name);\n-      configureThread(this, name);\n+      setDaemon(true);\n+      setUncaughtExceptionHandler(ueh);\n     }\n \n     public AccumuloDaemonThread(String name) {\n+      this(name, UEH);\n+    }\n+\n+    private AccumuloDaemonThread(String name, UncaughtExceptionHandler ueh) {\n       super(name);\n-      configureThread(this, name);\n+      setDaemon(true);\n+      setUncaughtExceptionHandler(ueh);\n     }\n+\n   }\n \n   public static Runnable createNamedRunnable(String name, Runnable r) {\n     return new NamedRunnable(name, r);\n   }\n \n-  private static final UncaughtExceptionHandler UEH = new AccumuloUncaughtExceptionHandler();\n-\n   public static Thread createThread(String name, Runnable r) {\n-    return createThread(name, OptionalInt.empty(), r);\n+    return createThread(name, OptionalInt.empty(), r, UEH);\n   }\n \n   public static Thread createThread(String name, OptionalInt priority, Runnable r) {\n-    Thread thread = new AccumuloDaemonThread(TraceUtil.wrap(r), name);\n+    return createThread(name, priority, r, UEH);\n+  }\n+\n+  public static Thread createThread(String name, OptionalInt priority, Runnable r,\n+      UncaughtExceptionHandler ueh) {\n+    Thread thread = new AccumuloDaemonThread(TraceUtil.wrap(r), name, ueh);\n     priority.ifPresent(thread::setPriority);\n     return thread;\n   }\n \n-  private static void configureThread(Thread thread, String name) {\n-    thread.setName(name);\n-    thread.setDaemon(true);\n-    thread.setUncaughtExceptionHandler(UEH);\n-  }\n }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "b6a466348807fe0d23203f3776cbc3119d5a037d", "committedDate": "2021-11-09 15:25:15 -0500", "message": "Instrument code using OpenTelemetry (#2259)"}, {"oid": "ece553a3ef0f47ef321eb4541ba220d22b5f796a", "committedDate": "2022-01-31 05:09:14 -0500", "message": "Remove unused priority in NamedRunnable"}, {"oid": "b0e2fd0d9e2f7c9877edea47650e8f0b6683dd36", "committedDate": "2022-01-31 07:55:35 -0500", "message": "Wrap and unwrap tasks in thread pools properly (#2442)"}, {"oid": "b13ba9daf696b8088887c7ed5acfeec721572e60", "committedDate": "2022-03-08 15:06:07 -0500", "message": "Modified Thread subclasses to follow current Thread standards (#2547)"}, {"oid": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "committedDate": "2022-03-15 07:29:39 -0400", "message": "Set default UncaughtExceptionHandler in client, enable override (#2554)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}]}, {"oid": "7957d8240581ce74a942c4858cf452bbb2067b90", "url": "https://github.com/apache/accumulo/commit/7957d8240581ce74a942c4858cf452bbb2067b90", "message": "re #1808: addressing PR comments", "committedDate": "2021-01-11T17:02:52Z", "type": "commit"}, {"oid": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "url": "https://github.com/apache/accumulo/commit/8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "message": "Merge branch 'main' into 1808-thread-errors", "committedDate": "2021-01-13T05:44:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MDQ0Mw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556290443", "body": "This updates the context using the ConfigurationCopy instead of the contextConfigSupplier, which would provide it on-demand. Using the ConfigurationCopy means it will get the same initial value every time the thread executes, and will never see the updated value of `VFS_CONTEXT_CLASSPATH_PROPERTY` if it changes.", "bodyText": "This updates the context using the ConfigurationCopy instead of the contextConfigSupplier, which would provide it on-demand. Using the ConfigurationCopy means it will get the same initial value every time the thread executes, and will never see the updated value of VFS_CONTEXT_CLASSPATH_PROPERTY if it changes.", "bodyHTML": "<p dir=\"auto\">This updates the context using the ConfigurationCopy instead of the contextConfigSupplier, which would provide it on-demand. Using the ConfigurationCopy means it will get the same initial value every time the thread executes, and will never see the updated value of <code>VFS_CONTEXT_CLASSPATH_PROPERTY</code> if it changes.</p>", "author": "ctubbsii", "createdAt": "2021-01-13T06:32:14Z", "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,20 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy cc = new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = cc.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      cc.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }\n+    ThreadPools.createGeneralScheduledExecutorService(cc)\n+        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, cc);\n+          Set<String> contextsInUse = cc\n+              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();", "originalCommit": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjUyODM4NQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556528385", "bodyText": "The ContextClassLoaderFactory is initialized on server process start (AbstractServer constructor). I don't believe that this property was ever dynamic, it's not the table context classpath property which could change, it's the property to load system jars from VFS.", "author": "dlmarion", "createdAt": "2021-01-13T13:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0NDE3Nw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556544177", "bodyText": "Interesting Then what is this thread supposed to be cleaning up?", "author": "ctubbsii", "createdAt": "2021-01-13T14:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU1Mjg3MQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556552871", "bodyText": "I read the code wrong, I think I need more coffee.", "author": "dlmarion", "createdAt": "2021-01-13T14:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU3MTE3Nw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556571177", "bodyText": "Resolved in latest commit.", "author": "dlmarion", "createdAt": "2021-01-13T14:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MDQ0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "137f7859f81a89744da60c7b0849a1041b178119", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex d83f25edd2..cbc851468a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -60,16 +60,19 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    final ConfigurationCopy cc = new ConfigurationCopy(contextConfigSupplier.get());\n-    String size = cc.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    final ConfigurationCopy threadPoolProperties =\n+        new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n     if (null == size || size.isEmpty()) {\n-      cc.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n           Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n     }\n-    ThreadPools.createGeneralScheduledExecutorService(cc)\n+    ThreadPools.createGeneralScheduledExecutorService(threadPoolProperties)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, cc);\n-          Set<String> contextsInUse = cc\n+          ConfigurationCopy contextCleanerProperties =\n+              new ConfigurationCopy(contextConfigSupplier.get());\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, threadPoolProperties);\n+          Set<String> contextsInUse = contextCleanerProperties\n               .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n", "next_change": {"commit": "370bb25fb6fb640647a2e8ce0076a6e3600b3b79", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex cbc851468a..76eb0fdd8a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -56,24 +56,18 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n     AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(contextConfigSupplier);\n+    startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n-  private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    final ConfigurationCopy threadPoolProperties =\n-        new ConfigurationCopy(contextConfigSupplier.get());\n-    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    if (null == size || size.isEmpty()) {\n-      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n-          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n-    }\n-    ThreadPools.createGeneralScheduledExecutorService(threadPoolProperties)\n+  private static void startCleanupThread(final AccumuloConfiguration conf,\n+      final Supplier<Map<String,String>> contextConfigSupplier) {\n+    ThreadPools.createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          ConfigurationCopy contextCleanerProperties =\n-              new ConfigurationCopy(contextConfigSupplier.get());\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, threadPoolProperties);\n-          Set<String> contextsInUse = contextCleanerProperties\n-              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n+          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n+              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))\n+              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n", "next_change": {"commit": "5153181e5002cc4ea8ade6b747fac66659e64e99", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex 76eb0fdd8a..f7e556e808 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -65,7 +65,6 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n           Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))\n               .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex d83f25edd2..f7e556e808 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -56,21 +56,17 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n     AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(contextConfigSupplier);\n+    startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n-  private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    final ConfigurationCopy cc = new ConfigurationCopy(contextConfigSupplier.get());\n-    String size = cc.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    if (null == size || size.isEmpty()) {\n-      cc.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n-          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n-    }\n-    ThreadPools.createGeneralScheduledExecutorService(cc)\n+  private static void startCleanupThread(final AccumuloConfiguration conf,\n+      final Supplier<Map<String,String>> contextConfigSupplier) {\n+    ThreadPools.createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, cc);\n-          Set<String> contextsInUse = cc\n-              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n+          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n+              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n", "next_change": {"commit": "0a64b442a92f728858066c2bc12312f96d41d22e", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex f7e556e808..e19c38b92d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -69,7 +70,7 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-        }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n+        }), 1, 1, MINUTES);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n", "next_change": {"commit": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex e19c38b92d..6baaa64aa1 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -71,6 +72,7 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 1, 1, MINUTES);\n+    ThreadPools.watchNonCriticalScheduledTask(future);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n", "next_change": {"commit": "1a0bb1e3d58583ab1f9a90dd1bbc33138345d85a", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex 6baaa64aa1..b9428e6f6e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -43,42 +42,61 @@ import org.slf4j.LoggerFactory;\n  * for all requested contexts. This class is used internally to Accumulo only, and should not be\n  * used by users in their configuration.\n  */\n-@SuppressWarnings({\"deprecation\", \"removal\"})\n public class DefaultContextClassLoaderFactory implements ContextClassLoaderFactory {\n \n   private static final AtomicBoolean isInstantiated = new AtomicBoolean(false);\n   private static final Logger LOG = LoggerFactory.getLogger(DefaultContextClassLoaderFactory.class);\n   private static final String className = DefaultContextClassLoaderFactory.class.getName();\n \n+  @SuppressWarnings(\"removal\")\n+  private static final Property VFS_CONTEXT_CLASSPATH_PROPERTY =\n+      Property.VFS_CONTEXT_CLASSPATH_PROPERTY;\n+\n   public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n     if (!isInstantiated.compareAndSet(false, true)) {\n       throw new IllegalStateException(\"Can only instantiate \" + className + \" once\");\n     }\n     Supplier<Map<String,String>> contextConfigSupplier =\n-        () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n-    AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n+        () -> accConf.getAllPropertiesWithPrefix(VFS_CONTEXT_CLASSPATH_PROPERTY);\n+    setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n     startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n+  @SuppressWarnings(\"deprecation\")\n+  private static void setContextConfig(Supplier<Map<String,String>> contextConfigSupplier) {\n+    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .setContextConfig(contextConfigSupplier);\n+  }\n+\n   private static void startCleanupThread(final AccumuloConfiguration conf,\n       final Supplier<Map<String,String>> contextConfigSupplier) {\n-    ScheduledFuture<?> future = ThreadPools.createGeneralScheduledExecutorService(conf)\n+    ScheduledFuture<?> future = ThreadPools.getClientThreadPools((t, e) -> {\n+      LOG.error(\"context classloader cleanup thread has failed.\", e);\n+    }).createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n           Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .map(p -> p.substring(VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-          AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n+          removeUnusedContexts(contextsInUse);\n         }), 1, 1, MINUTES);\n     ThreadPools.watchNonCriticalScheduledTask(future);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n+  @SuppressWarnings(\"deprecation\")\n+  private static void removeUnusedContexts(Set<String> contextsInUse) {\n+    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .removeUnusedContexts(contextsInUse);\n+  }\n+\n+  @SuppressWarnings(\"deprecation\")\n   @Override\n   public ClassLoader getClassLoader(String contextName) {\n-    return AccumuloVFSClassLoader.getContextClassLoader(contextName);\n+    return org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .getContextClassLoader(contextName);\n   }\n \n }\n", "next_change": {"commit": "cc44add8bcf9d69057f18d19e6fe9d6b9328575f", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\ndeleted file mode 100644\nindex b9428e6f6e..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ /dev/null\n", "chunk": "@@ -1,102 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.classloader;\n-\n-import static java.util.concurrent.TimeUnit.MINUTES;\n-\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.spi.common.ContextClassLoaderFactory;\n-import org.apache.accumulo.core.util.threads.ThreadPools;\n-import org.apache.accumulo.core.util.threads.Threads;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The default implementation of ContextClassLoaderFactory. This implementation is subject to change\n- * over time. It currently implements the legacy context class loading behavior based on Accumulo's\n- * custom class loaders and commons-vfs2. In future, it may simply return the system class loader\n- * for all requested contexts. This class is used internally to Accumulo only, and should not be\n- * used by users in their configuration.\n- */\n-public class DefaultContextClassLoaderFactory implements ContextClassLoaderFactory {\n-\n-  private static final AtomicBoolean isInstantiated = new AtomicBoolean(false);\n-  private static final Logger LOG = LoggerFactory.getLogger(DefaultContextClassLoaderFactory.class);\n-  private static final String className = DefaultContextClassLoaderFactory.class.getName();\n-\n-  @SuppressWarnings(\"removal\")\n-  private static final Property VFS_CONTEXT_CLASSPATH_PROPERTY =\n-      Property.VFS_CONTEXT_CLASSPATH_PROPERTY;\n-\n-  public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n-    if (!isInstantiated.compareAndSet(false, true)) {\n-      throw new IllegalStateException(\"Can only instantiate \" + className + \" once\");\n-    }\n-    Supplier<Map<String,String>> contextConfigSupplier =\n-        () -> accConf.getAllPropertiesWithPrefix(VFS_CONTEXT_CLASSPATH_PROPERTY);\n-    setContextConfig(contextConfigSupplier);\n-    LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(accConf, contextConfigSupplier);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  private static void setContextConfig(Supplier<Map<String,String>> contextConfigSupplier) {\n-    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .setContextConfig(contextConfigSupplier);\n-  }\n-\n-  private static void startCleanupThread(final AccumuloConfiguration conf,\n-      final Supplier<Map<String,String>> contextConfigSupplier) {\n-    ScheduledFuture<?> future = ThreadPools.getClientThreadPools((t, e) -> {\n-      LOG.error(\"context classloader cleanup thread has failed.\", e);\n-    }).createGeneralScheduledExecutorService(conf)\n-        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n-          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .map(p -> p.substring(VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n-              .collect(Collectors.toSet());\n-          LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-          removeUnusedContexts(contextsInUse);\n-        }), 1, 1, MINUTES);\n-    ThreadPools.watchNonCriticalScheduledTask(future);\n-    LOG.debug(\"Context cleanup timer started at 60s intervals\");\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  private static void removeUnusedContexts(Set<String> contextsInUse) {\n-    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .removeUnusedContexts(contextsInUse);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  @Override\n-  public ClassLoader getClassLoader(String contextName) {\n-    return org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .getContextClassLoader(contextName);\n-  }\n-\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "committedDate": "2022-03-04 07:59:03 -0500", "message": "Check scheduled tasks periodically for errors (#2524)"}, {"oid": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "committedDate": "2022-03-15 07:29:39 -0400", "message": "Set default UncaughtExceptionHandler in client, enable override (#2554)"}, {"oid": "1a0bb1e3d58583ab1f9a90dd1bbc33138345d85a", "committedDate": "2022-05-13 18:18:42 -0400", "message": "Minor little cleanups (#2695)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "cc44add8bcf9d69057f18d19e6fe9d6b9328575f", "committedDate": "2023-02-24 10:16:48 -0500", "message": "Remove deprecated AccumuloVFSClassLoader  (#3136)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MjY4OQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556292689", "body": "Would this work?\r\n\r\n```suggestion\r\n      task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", this::run);\r\n```", "bodyText": "Would this work?\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", () -> {\n          \n          \n            \n                    run();\n          \n          \n            \n                  });\n          \n          \n            \n                  task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", this::run);", "bodyHTML": "<p dir=\"auto\">Would this work?</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      task <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Threads</span><span class=\"pl-k\">.</span>createNamedRunnable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>failed mutationBatchWriterLatencyTimers handler<span class=\"pl-pds\">\"</span></span>, () <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        run();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">      });</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">      task <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Threads</span><span class=\"pl-k\">.</span>createNamedRunnable(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>failed mutationBatchWriterLatencyTimers handler<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">this</span><span class=\"pl-k\">::</span>run);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ctubbsii", "createdAt": "2021-01-13T06:38:59Z", "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java", "diffHunk": "@@ -571,13 +570,17 @@ private synchronized void addFailedMutations(MutationSet failedMutations) {\n     }\n   }\n \n-  private class FailedMutations extends TimerTask {\n+  private class FailedMutations {\n \n     private MutationSet recentFailures = null;\n     private long initTime;\n+    private final Runnable task;\n \n     FailedMutations() {\n-      jtimer.schedule(this, 0, 500);\n+      task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", () -> {\n+        run();\n+      });", "originalCommit": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjUyNDA4Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556524086", "bodyText": "That should work, I can make that change.", "author": "dlmarion", "createdAt": "2021-01-13T13:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MjY4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "30f63b14b8d638ed6d641d493379586cf5f9e42d", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex e4feb99d02..83f5d98891 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -577,9 +577,8 @@ public class TabletServerBatchWriter implements AutoCloseable {\n     private final Runnable task;\n \n     FailedMutations() {\n-      task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", () -> {\n-        run();\n-      });\n+      task =\n+          Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", this::run);\n       executor.scheduleWithFixedDelay(task, 0, 500, TimeUnit.MILLISECONDS);\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex e4feb99d02..83f5d98891 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -577,9 +577,8 @@ public class TabletServerBatchWriter implements AutoCloseable {\n     private final Runnable task;\n \n     FailedMutations() {\n-      task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", () -> {\n-        run();\n-      });\n+      task =\n+          Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", this::run);\n       executor.scheduleWithFixedDelay(task, 0, 500, TimeUnit.MILLISECONDS);\n     }\n \n", "next_change": {"commit": "0a64b442a92f728858066c2bc12312f96d41d22e", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex 83f5d98891..9047622e6a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -579,7 +580,7 @@ public class TabletServerBatchWriter implements AutoCloseable {\n     FailedMutations() {\n       task =\n           Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", this::run);\n-      executor.scheduleWithFixedDelay(task, 0, 500, TimeUnit.MILLISECONDS);\n+      executor.scheduleWithFixedDelay(task, 0, 500, MILLISECONDS);\n     }\n \n     private MutationSet init() {\n", "next_change": {"commit": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\nindex 9047622e6a..b2374bcf0a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n+++ b/core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java\n", "chunk": "@@ -576,14 +583,17 @@ public class TabletServerBatchWriter implements AutoCloseable {\n     private MutationSet recentFailures = null;\n     private long initTime;\n     private final Runnable task;\n+    private final ScheduledFuture<?> future;\n \n     FailedMutations() {\n       task =\n           Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", this::run);\n-      executor.scheduleWithFixedDelay(task, 0, 500, MILLISECONDS);\n+      future = executor.scheduleWithFixedDelay(task, 0, 500, MILLISECONDS);\n     }\n \n     private MutationSet init() {\n+      ThreadPools.ensureRunning(future,\n+          \"Background task that re-queues failed mutations has exited.\");\n       if (recentFailures == null) {\n         recentFailures = new MutationSet();\n         initTime = System.currentTimeMillis();\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "bbd87a6693fc5cdbbe947b0821a4f05a18cf905b", "committedDate": "2021-01-19 08:07:07 -0500", "message": "Closes #1689: Don't catch Throwable (unless it's rethrown) (#1840)"}, {"oid": "675e41aaed0f8ae250d97a10dad35a8aef4c3e82", "committedDate": "2021-02-04 07:55:40 -0500", "message": "Rename master packages to manager. (#1904)"}, {"oid": "f2b0936029fcaadb925bd9c229403c82f0283211", "committedDate": "2021-07-09 12:22:20 -0400", "message": "Improve client table exceptions (#2195)"}, {"oid": "c9e3877373303997d42b465b2cdb62fd3fffd5d8", "committedDate": "2021-10-22 10:51:43 -0400", "message": "Make ThriftTransportPool a part of ClientContext (#2303)"}, {"oid": "b6a466348807fe0d23203f3776cbc3119d5a037d", "committedDate": "2021-11-09 15:25:15 -0500", "message": "Instrument code using OpenTelemetry (#2259)"}, {"oid": "fad597bf40bf3c6893e98d5ebd0e391859a3c7dc", "committedDate": "2021-12-10 16:59:07 -0500", "message": "Remove some useless null checks/assignments (#2377)"}, {"oid": "36fca0f3c8f7481e2ec400a486e6955026ba7af4", "committedDate": "2022-01-28 10:33:48 -0500", "message": "Modified ThreadPools to conditionally register metrics (#2432)"}, {"oid": "c46fa8f1e2eac80ffac3ef594afe3f7b9052fd8a", "committedDate": "2022-02-23 13:46:04 -0500", "message": "Move Tables class into Context (#2517)"}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "committedDate": "2022-03-04 07:59:03 -0500", "message": "Check scheduled tasks periodically for errors (#2524)"}, {"oid": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "committedDate": "2022-03-15 07:29:39 -0400", "message": "Set default UncaughtExceptionHandler in client, enable override (#2554)"}, {"oid": "8be98d6744962ccb9806800943dcd8cc6f2003c1", "committedDate": "2022-04-19 14:25:35 -0400", "message": "Use Thrift Multiplex components to host multiple services (#2620)"}, {"oid": "8e698a47eef0f32a261945ada0904db499891b66", "committedDate": "2022-05-13 17:47:39 -0400", "message": "Consolidated duplicate Thrift client code (#2647)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "committedDate": "2022-11-30 02:21:37 -0500", "message": "Update javadoc tag style to match google style guide (#3064)"}, {"oid": "72c5c46e711dbd484ff1b637b09170de05948a3c", "committedDate": "2022-12-14 16:54:00 -0500", "message": "Move TInfo to client.thrift, remove trace.thrift (#3119)"}, {"oid": "d9dc304ff7c1d8aa3a3be089ae74d5e18204d1a2", "committedDate": "2022-12-16 13:02:42 -0500", "message": "Replace copied HostAndPort with guava (#3129)"}, {"oid": "a643f1763c64e60f17dafdcb609e114746bc61c7", "committedDate": "2023-01-03 14:56:43 -0500", "message": "Decompose tablet thrift svcs main (#3107)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MzY5Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556293696", "body": "Is it legal to switch to a Daemon thread after it has already started executing? Will this have any effect?", "bodyText": "Is it legal to switch to a Daemon thread after it has already started executing? Will this have any effect?", "bodyHTML": "<p dir=\"auto\">Is it legal to switch to a Daemon thread after it has already started executing? Will this have any effect?</p>", "author": "ctubbsii", "createdAt": "2021-01-13T06:42:00Z", "path": "core/src/main/java/org/apache/accumulo/core/util/Halt.java", "diffHunk": "@@ -51,9 +50,10 @@ public void run() {\n   public static void halt(final int status, Runnable runnable) {\n     try {\n       // give ourselves a little time to try and do something\n-      new Daemon() {\n+      new Thread() {\n         @Override\n         public void run() {\n+          setDaemon(true);", "originalCommit": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjUyMzA5MA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556523090", "bodyText": "Great catch. This won't work, I will fix.", "author": "dlmarion", "createdAt": "2021-01-13T13:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MzY5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "30f63b14b8d638ed6d641d493379586cf5f9e42d", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex 243ccf0733..15824e4c4e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -50,10 +51,9 @@ public class Halt {\n   public static void halt(final int status, Runnable runnable) {\n     try {\n       // give ourselves a little time to try and do something\n-      new Thread() {\n+      new Daemon() {\n         @Override\n         public void run() {\n-          setDaemon(true);\n           sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n           Runtime.getRuntime().halt(status);\n         }\n", "next_change": {"commit": "137f7859f81a89744da60c7b0849a1041b178119", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex 15824e4c4e..45d4f7296d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -49,15 +49,16 @@ public class Halt {\n   }\n \n   public static void halt(final int status, Runnable runnable) {\n+\n     try {\n       // give ourselves a little time to try and do something\n-      new Daemon() {\n+      Threads.createThread(\"Halt Thread\", new Runnable() {\n         @Override\n         public void run() {\n           sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n           Runtime.getRuntime().halt(status);\n         }\n-      }.start();\n+      }).start();\n \n       if (runnable != null)\n         runnable.run();\n", "next_change": {"commit": "5153181e5002cc4ea8ade6b747fac66659e64e99", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex 45d4f7296d..e9c097e218 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -52,12 +52,9 @@ public class Halt {\n \n     try {\n       // give ourselves a little time to try and do something\n-      Threads.createThread(\"Halt Thread\", new Runnable() {\n-        @Override\n-        public void run() {\n-          sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-          Runtime.getRuntime().halt(status);\n-        }\n+      Threads.createThread(\"Halt Thread\", () -> {\n+        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+        Runtime.getRuntime().halt(status);\n       }).start();\n \n       if (runnable != null)\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex 243ccf0733..e9c097e218 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -48,16 +49,13 @@ public class Halt {\n   }\n \n   public static void halt(final int status, Runnable runnable) {\n+\n     try {\n       // give ourselves a little time to try and do something\n-      new Thread() {\n-        @Override\n-        public void run() {\n-          setDaemon(true);\n-          sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-          Runtime.getRuntime().halt(status);\n-        }\n-      }.start();\n+      Threads.createThread(\"Halt Thread\", () -> {\n+        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+        Runtime.getRuntime().halt(status);\n+      }).start();\n \n       if (runnable != null)\n         runnable.run();\n", "next_change": {"commit": "0a64b442a92f728858066c2bc12312f96d41d22e", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex e9c097e218..bce13fe025 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -53,7 +52,7 @@ public class Halt {\n     try {\n       // give ourselves a little time to try and do something\n       Threads.createThread(\"Halt Thread\", () -> {\n-        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+        sleepUninterruptibly(100, MILLISECONDS);\n         Runtime.getRuntime().halt(status);\n       }).start();\n \n", "next_change": {"commit": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex bce13fe025..ec822b48cc 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -56,8 +56,9 @@ public class Halt {\n         Runtime.getRuntime().halt(status);\n       }).start();\n \n-      if (runnable != null)\n+      if (runnable != null) {\n         runnable.run();\n+      }\n       Runtime.getRuntime().halt(status);\n     } finally {\n       // In case something else decides to throw a Runtime exception\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "2dbdc085390794e7925740a81439c66dc3dfbb7c", "committedDate": "2022-10-20 00:16:54 -0400", "message": "Move o.a.a.fate to o.a.a.core.fate (#3035)"}, {"oid": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "committedDate": "2022-11-30 02:21:37 -0500", "message": "Update javadoc tag style to match google style guide (#3064)"}, {"oid": "6712d2500bd088d43bca4d207ef09d5e143de4d4", "committedDate": "2022-12-16 08:50:49 -0500", "message": "Replace UtilWaitThread.sleepUninterruptibly with guava equivalent (#3121)"}]}, {"oid": "30f63b14b8d638ed6d641d493379586cf5f9e42d", "url": "https://github.com/apache/accumulo/commit/30f63b14b8d638ed6d641d493379586cf5f9e42d", "message": "re #1808 - addressing PR comments", "committedDate": "2021-01-13T13:55:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0MTYwMQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556541601", "body": "We should avoid using Hadoop's Daemon. I doubt that is stable public API. Even if it is, we don't want to increase our dependency on Hadoop library code for this. It should be simple to construct the object assigned to a local variable, set it to daemon, and start it in 3 statements, rather than rely on a the Hadoop library.", "bodyText": "We should avoid using Hadoop's Daemon. I doubt that is stable public API. Even if it is, we don't want to increase our dependency on Hadoop library code for this. It should be simple to construct the object assigned to a local variable, set it to daemon, and start it in 3 statements, rather than rely on a the Hadoop library.", "bodyHTML": "<p dir=\"auto\">We should avoid using Hadoop's Daemon. I doubt that is stable public API. Even if it is, we don't want to increase our dependency on Hadoop library code for this. It should be simple to construct the object assigned to a local variable, set it to daemon, and start it in 3 statements, rather than rely on a the Hadoop library.</p>", "author": "ctubbsii", "createdAt": "2021-01-13T14:03:32Z", "path": "core/src/main/java/org/apache/accumulo/core/util/Halt.java", "diffHunk": "@@ -50,10 +51,9 @@ public void run() {\n   public static void halt(final int status, Runnable runnable) {\n     try {\n       // give ourselves a little time to try and do something\n-      new Thread() {\n+      new Daemon() {", "originalCommit": "30f63b14b8d638ed6d641d493379586cf5f9e42d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU1Mjk1Nw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556552957", "bodyText": "I didn't even notice that it was a Hadoop class.", "author": "dlmarion", "createdAt": "2021-01-13T14:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0MTYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU1NjYyMw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556556623", "bodyText": "We had one of our own, but I think you may have deleted it elsewhere in this PR (which is a good thing, as we don't really need a dedicated class for that, especially with all your thread factory stuff being consolidated into one place).", "author": "ctubbsii", "createdAt": "2021-01-13T14:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0MTYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU3MTExNw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556571117", "bodyText": "Resolved in latest commit.", "author": "dlmarion", "createdAt": "2021-01-13T14:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0MTYwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "137f7859f81a89744da60c7b0849a1041b178119", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex 15824e4c4e..45d4f7296d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -49,15 +49,16 @@ public class Halt {\n   }\n \n   public static void halt(final int status, Runnable runnable) {\n+\n     try {\n       // give ourselves a little time to try and do something\n-      new Daemon() {\n+      Threads.createThread(\"Halt Thread\", new Runnable() {\n         @Override\n         public void run() {\n           sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n           Runtime.getRuntime().halt(status);\n         }\n-      }.start();\n+      }).start();\n \n       if (runnable != null)\n         runnable.run();\n", "next_change": {"commit": "5153181e5002cc4ea8ade6b747fac66659e64e99", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex 45d4f7296d..e9c097e218 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -52,12 +52,9 @@ public class Halt {\n \n     try {\n       // give ourselves a little time to try and do something\n-      Threads.createThread(\"Halt Thread\", new Runnable() {\n-        @Override\n-        public void run() {\n-          sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-          Runtime.getRuntime().halt(status);\n-        }\n+      Threads.createThread(\"Halt Thread\", () -> {\n+        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+        Runtime.getRuntime().halt(status);\n       }).start();\n \n       if (runnable != null)\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex 15824e4c4e..e9c097e218 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -49,15 +49,13 @@ public class Halt {\n   }\n \n   public static void halt(final int status, Runnable runnable) {\n+\n     try {\n       // give ourselves a little time to try and do something\n-      new Daemon() {\n-        @Override\n-        public void run() {\n-          sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-          Runtime.getRuntime().halt(status);\n-        }\n-      }.start();\n+      Threads.createThread(\"Halt Thread\", () -> {\n+        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+        Runtime.getRuntime().halt(status);\n+      }).start();\n \n       if (runnable != null)\n         runnable.run();\n", "next_change": {"commit": "0a64b442a92f728858066c2bc12312f96d41d22e", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex e9c097e218..bce13fe025 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -53,7 +52,7 @@ public class Halt {\n     try {\n       // give ourselves a little time to try and do something\n       Threads.createThread(\"Halt Thread\", () -> {\n-        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+        sleepUninterruptibly(100, MILLISECONDS);\n         Runtime.getRuntime().halt(status);\n       }).start();\n \n", "next_change": {"commit": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex bce13fe025..ec822b48cc 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -56,8 +56,9 @@ public class Halt {\n         Runtime.getRuntime().halt(status);\n       }).start();\n \n-      if (runnable != null)\n+      if (runnable != null) {\n         runnable.run();\n+      }\n       Runtime.getRuntime().halt(status);\n     } finally {\n       // In case something else decides to throw a Runtime exception\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "2dbdc085390794e7925740a81439c66dc3dfbb7c", "committedDate": "2022-10-20 00:16:54 -0400", "message": "Move o.a.a.fate to o.a.a.core.fate (#3035)"}, {"oid": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "committedDate": "2022-11-30 02:21:37 -0500", "message": "Update javadoc tag style to match google style guide (#3064)"}, {"oid": "6712d2500bd088d43bca4d207ef09d5e143de4d4", "committedDate": "2022-12-16 08:50:49 -0500", "message": "Replace UtilWaitThread.sleepUninterruptibly with guava equivalent (#3121)"}]}, {"oid": "137f7859f81a89744da60c7b0849a1041b178119", "url": "https://github.com/apache/accumulo/commit/137f7859f81a89744da60c7b0849a1041b178119", "message": "re #1808 - don't use Hadoop Daemon class and other changes", "committedDate": "2021-01-13T14:41:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU3ODUwMg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556578502", "body": "Reading properties other than those that start with the VFS_CONTEXT_CLASSPATH_PROPERTY won't work here, because the contextConfigSupplier already filters out all other properties. So, you can't read the SIMPLETIMER properties from this map.", "bodyText": "Reading properties other than those that start with the VFS_CONTEXT_CLASSPATH_PROPERTY won't work here, because the contextConfigSupplier already filters out all other properties. So, you can't read the SIMPLETIMER properties from this map.", "bodyHTML": "<p dir=\"auto\">Reading properties other than those that start with the VFS_CONTEXT_CLASSPATH_PROPERTY won't work here, because the contextConfigSupplier already filters out all other properties. So, you can't read the SIMPLETIMER properties from this map.</p>", "author": "ctubbsii", "createdAt": "2021-01-13T14:53:52Z", "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,23 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy threadPoolProperties =\n+        new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }", "originalCommit": "137f7859f81a89744da60c7b0849a1041b178119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY1NTI4Mg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556655282", "bodyText": "Changed in latest commit", "author": "dlmarion", "createdAt": "2021-01-13T16:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU3ODUwMg=="}], "type": "inlineReview", "revised_code": {"commit": "370bb25fb6fb640647a2e8ce0076a6e3600b3b79", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex cbc851468a..76eb0fdd8a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -56,24 +56,18 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n     AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(contextConfigSupplier);\n+    startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n-  private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    final ConfigurationCopy threadPoolProperties =\n-        new ConfigurationCopy(contextConfigSupplier.get());\n-    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    if (null == size || size.isEmpty()) {\n-      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n-          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n-    }\n-    ThreadPools.createGeneralScheduledExecutorService(threadPoolProperties)\n+  private static void startCleanupThread(final AccumuloConfiguration conf,\n+      final Supplier<Map<String,String>> contextConfigSupplier) {\n+    ThreadPools.createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          ConfigurationCopy contextCleanerProperties =\n-              new ConfigurationCopy(contextConfigSupplier.get());\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, threadPoolProperties);\n-          Set<String> contextsInUse = contextCleanerProperties\n-              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n+          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n+              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))\n+              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n", "next_change": {"commit": "5153181e5002cc4ea8ade6b747fac66659e64e99", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex 76eb0fdd8a..f7e556e808 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -65,7 +65,6 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n           Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))\n               .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex cbc851468a..f7e556e808 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -56,24 +56,17 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n     AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(contextConfigSupplier);\n+    startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n-  private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    final ConfigurationCopy threadPoolProperties =\n-        new ConfigurationCopy(contextConfigSupplier.get());\n-    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    if (null == size || size.isEmpty()) {\n-      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n-          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n-    }\n-    ThreadPools.createGeneralScheduledExecutorService(threadPoolProperties)\n+  private static void startCleanupThread(final AccumuloConfiguration conf,\n+      final Supplier<Map<String,String>> contextConfigSupplier) {\n+    ThreadPools.createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          ConfigurationCopy contextCleanerProperties =\n-              new ConfigurationCopy(contextConfigSupplier.get());\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, threadPoolProperties);\n-          Set<String> contextsInUse = contextCleanerProperties\n-              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n+          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n+              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n", "next_change": {"commit": "0a64b442a92f728858066c2bc12312f96d41d22e", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex f7e556e808..e19c38b92d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -69,7 +70,7 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-        }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n+        }), 1, 1, MINUTES);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n", "next_change": {"commit": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex e19c38b92d..6baaa64aa1 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -71,6 +72,7 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 1, 1, MINUTES);\n+    ThreadPools.watchNonCriticalScheduledTask(future);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n", "next_change": {"commit": "1a0bb1e3d58583ab1f9a90dd1bbc33138345d85a", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex 6baaa64aa1..b9428e6f6e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -43,42 +42,61 @@ import org.slf4j.LoggerFactory;\n  * for all requested contexts. This class is used internally to Accumulo only, and should not be\n  * used by users in their configuration.\n  */\n-@SuppressWarnings({\"deprecation\", \"removal\"})\n public class DefaultContextClassLoaderFactory implements ContextClassLoaderFactory {\n \n   private static final AtomicBoolean isInstantiated = new AtomicBoolean(false);\n   private static final Logger LOG = LoggerFactory.getLogger(DefaultContextClassLoaderFactory.class);\n   private static final String className = DefaultContextClassLoaderFactory.class.getName();\n \n+  @SuppressWarnings(\"removal\")\n+  private static final Property VFS_CONTEXT_CLASSPATH_PROPERTY =\n+      Property.VFS_CONTEXT_CLASSPATH_PROPERTY;\n+\n   public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n     if (!isInstantiated.compareAndSet(false, true)) {\n       throw new IllegalStateException(\"Can only instantiate \" + className + \" once\");\n     }\n     Supplier<Map<String,String>> contextConfigSupplier =\n-        () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n-    AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n+        () -> accConf.getAllPropertiesWithPrefix(VFS_CONTEXT_CLASSPATH_PROPERTY);\n+    setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n     startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n+  @SuppressWarnings(\"deprecation\")\n+  private static void setContextConfig(Supplier<Map<String,String>> contextConfigSupplier) {\n+    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .setContextConfig(contextConfigSupplier);\n+  }\n+\n   private static void startCleanupThread(final AccumuloConfiguration conf,\n       final Supplier<Map<String,String>> contextConfigSupplier) {\n-    ScheduledFuture<?> future = ThreadPools.createGeneralScheduledExecutorService(conf)\n+    ScheduledFuture<?> future = ThreadPools.getClientThreadPools((t, e) -> {\n+      LOG.error(\"context classloader cleanup thread has failed.\", e);\n+    }).createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n           Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .map(p -> p.substring(VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-          AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n+          removeUnusedContexts(contextsInUse);\n         }), 1, 1, MINUTES);\n     ThreadPools.watchNonCriticalScheduledTask(future);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n+  @SuppressWarnings(\"deprecation\")\n+  private static void removeUnusedContexts(Set<String> contextsInUse) {\n+    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .removeUnusedContexts(contextsInUse);\n+  }\n+\n+  @SuppressWarnings(\"deprecation\")\n   @Override\n   public ClassLoader getClassLoader(String contextName) {\n-    return AccumuloVFSClassLoader.getContextClassLoader(contextName);\n+    return org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .getContextClassLoader(contextName);\n   }\n \n }\n", "next_change": {"commit": "cc44add8bcf9d69057f18d19e6fe9d6b9328575f", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\ndeleted file mode 100644\nindex b9428e6f6e..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ /dev/null\n", "chunk": "@@ -1,102 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.classloader;\n-\n-import static java.util.concurrent.TimeUnit.MINUTES;\n-\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.spi.common.ContextClassLoaderFactory;\n-import org.apache.accumulo.core.util.threads.ThreadPools;\n-import org.apache.accumulo.core.util.threads.Threads;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The default implementation of ContextClassLoaderFactory. This implementation is subject to change\n- * over time. It currently implements the legacy context class loading behavior based on Accumulo's\n- * custom class loaders and commons-vfs2. In future, it may simply return the system class loader\n- * for all requested contexts. This class is used internally to Accumulo only, and should not be\n- * used by users in their configuration.\n- */\n-public class DefaultContextClassLoaderFactory implements ContextClassLoaderFactory {\n-\n-  private static final AtomicBoolean isInstantiated = new AtomicBoolean(false);\n-  private static final Logger LOG = LoggerFactory.getLogger(DefaultContextClassLoaderFactory.class);\n-  private static final String className = DefaultContextClassLoaderFactory.class.getName();\n-\n-  @SuppressWarnings(\"removal\")\n-  private static final Property VFS_CONTEXT_CLASSPATH_PROPERTY =\n-      Property.VFS_CONTEXT_CLASSPATH_PROPERTY;\n-\n-  public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n-    if (!isInstantiated.compareAndSet(false, true)) {\n-      throw new IllegalStateException(\"Can only instantiate \" + className + \" once\");\n-    }\n-    Supplier<Map<String,String>> contextConfigSupplier =\n-        () -> accConf.getAllPropertiesWithPrefix(VFS_CONTEXT_CLASSPATH_PROPERTY);\n-    setContextConfig(contextConfigSupplier);\n-    LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(accConf, contextConfigSupplier);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  private static void setContextConfig(Supplier<Map<String,String>> contextConfigSupplier) {\n-    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .setContextConfig(contextConfigSupplier);\n-  }\n-\n-  private static void startCleanupThread(final AccumuloConfiguration conf,\n-      final Supplier<Map<String,String>> contextConfigSupplier) {\n-    ScheduledFuture<?> future = ThreadPools.getClientThreadPools((t, e) -> {\n-      LOG.error(\"context classloader cleanup thread has failed.\", e);\n-    }).createGeneralScheduledExecutorService(conf)\n-        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n-          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .map(p -> p.substring(VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n-              .collect(Collectors.toSet());\n-          LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-          removeUnusedContexts(contextsInUse);\n-        }), 1, 1, MINUTES);\n-    ThreadPools.watchNonCriticalScheduledTask(future);\n-    LOG.debug(\"Context cleanup timer started at 60s intervals\");\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  private static void removeUnusedContexts(Set<String> contextsInUse) {\n-    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .removeUnusedContexts(contextsInUse);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  @Override\n-  public ClassLoader getClassLoader(String contextName) {\n-    return org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .getContextClassLoader(contextName);\n-  }\n-\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "committedDate": "2022-03-04 07:59:03 -0500", "message": "Check scheduled tasks periodically for errors (#2524)"}, {"oid": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "committedDate": "2022-03-15 07:29:39 -0400", "message": "Set default UncaughtExceptionHandler in client, enable override (#2554)"}, {"oid": "1a0bb1e3d58583ab1f9a90dd1bbc33138345d85a", "committedDate": "2022-05-13 18:18:42 -0400", "message": "Minor little cleanups (#2695)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "cc44add8bcf9d69057f18d19e6fe9d6b9328575f", "committedDate": "2023-02-24 10:16:48 -0500", "message": "Remove deprecated AccumuloVFSClassLoader  (#3136)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU4MDgyMA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556580820", "body": "Placing it in a new ConfigurationCopy to use the method that strips the property prefix out seems a bit more work than the old code did. The contextConfigSupplier already filters matching items, so all we need to do is strip out the prefix. We can avoid creating a new ConfigurationCopy object for this.", "bodyText": "Placing it in a new ConfigurationCopy to use the method that strips the property prefix out seems a bit more work than the old code did. The contextConfigSupplier already filters matching items, so all we need to do is strip out the prefix. We can avoid creating a new ConfigurationCopy object for this.", "bodyHTML": "<p dir=\"auto\">Placing it in a new ConfigurationCopy to use the method that strips the property prefix out seems a bit more work than the old code did. The contextConfigSupplier already filters matching items, so all we need to do is strip out the prefix. We can avoid creating a new ConfigurationCopy object for this.</p>", "author": "ctubbsii", "createdAt": "2021-01-13T14:56:39Z", "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,23 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy threadPoolProperties =\n+        new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }\n+    ThreadPools.createGeneralScheduledExecutorService(threadPoolProperties)\n+        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n+          ConfigurationCopy contextCleanerProperties =\n+              new ConfigurationCopy(contextConfigSupplier.get());\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, threadPoolProperties);\n+          Set<String> contextsInUse = contextCleanerProperties\n+              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();", "originalCommit": "137f7859f81a89744da60c7b0849a1041b178119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY1NTMzNg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556655336", "bodyText": "Changed in latest commit", "author": "dlmarion", "createdAt": "2021-01-13T16:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU4MDgyMA=="}], "type": "inlineReview", "revised_code": {"commit": "370bb25fb6fb640647a2e8ce0076a6e3600b3b79", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex cbc851468a..76eb0fdd8a 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -56,24 +56,18 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n     AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(contextConfigSupplier);\n+    startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n-  private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    final ConfigurationCopy threadPoolProperties =\n-        new ConfigurationCopy(contextConfigSupplier.get());\n-    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    if (null == size || size.isEmpty()) {\n-      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n-          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n-    }\n-    ThreadPools.createGeneralScheduledExecutorService(threadPoolProperties)\n+  private static void startCleanupThread(final AccumuloConfiguration conf,\n+      final Supplier<Map<String,String>> contextConfigSupplier) {\n+    ThreadPools.createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          ConfigurationCopy contextCleanerProperties =\n-              new ConfigurationCopy(contextConfigSupplier.get());\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, threadPoolProperties);\n-          Set<String> contextsInUse = contextCleanerProperties\n-              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n+          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n+              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))\n+              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n", "next_change": {"commit": "5153181e5002cc4ea8ade6b747fac66659e64e99", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex 76eb0fdd8a..f7e556e808 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -65,7 +65,6 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n           Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))\n               .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex cbc851468a..f7e556e808 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -56,24 +56,17 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n     AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(contextConfigSupplier);\n+    startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n-  private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    final ConfigurationCopy threadPoolProperties =\n-        new ConfigurationCopy(contextConfigSupplier.get());\n-    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n-    if (null == size || size.isEmpty()) {\n-      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n-          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n-    }\n-    ThreadPools.createGeneralScheduledExecutorService(threadPoolProperties)\n+  private static void startCleanupThread(final AccumuloConfiguration conf,\n+      final Supplier<Map<String,String>> contextConfigSupplier) {\n+    ThreadPools.createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          ConfigurationCopy contextCleanerProperties =\n-              new ConfigurationCopy(contextConfigSupplier.get());\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, threadPoolProperties);\n-          Set<String> contextsInUse = contextCleanerProperties\n-              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n+          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n+              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n", "next_change": {"commit": "0a64b442a92f728858066c2bc12312f96d41d22e", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex f7e556e808..e19c38b92d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -69,7 +70,7 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-        }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n+        }), 1, 1, MINUTES);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n", "next_change": {"commit": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex e19c38b92d..6baaa64aa1 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -71,6 +72,7 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 1, 1, MINUTES);\n+    ThreadPools.watchNonCriticalScheduledTask(future);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n", "next_change": {"commit": "1a0bb1e3d58583ab1f9a90dd1bbc33138345d85a", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex 6baaa64aa1..b9428e6f6e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -43,42 +42,61 @@ import org.slf4j.LoggerFactory;\n  * for all requested contexts. This class is used internally to Accumulo only, and should not be\n  * used by users in their configuration.\n  */\n-@SuppressWarnings({\"deprecation\", \"removal\"})\n public class DefaultContextClassLoaderFactory implements ContextClassLoaderFactory {\n \n   private static final AtomicBoolean isInstantiated = new AtomicBoolean(false);\n   private static final Logger LOG = LoggerFactory.getLogger(DefaultContextClassLoaderFactory.class);\n   private static final String className = DefaultContextClassLoaderFactory.class.getName();\n \n+  @SuppressWarnings(\"removal\")\n+  private static final Property VFS_CONTEXT_CLASSPATH_PROPERTY =\n+      Property.VFS_CONTEXT_CLASSPATH_PROPERTY;\n+\n   public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n     if (!isInstantiated.compareAndSet(false, true)) {\n       throw new IllegalStateException(\"Can only instantiate \" + className + \" once\");\n     }\n     Supplier<Map<String,String>> contextConfigSupplier =\n-        () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n-    AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n+        () -> accConf.getAllPropertiesWithPrefix(VFS_CONTEXT_CLASSPATH_PROPERTY);\n+    setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n     startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n+  @SuppressWarnings(\"deprecation\")\n+  private static void setContextConfig(Supplier<Map<String,String>> contextConfigSupplier) {\n+    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .setContextConfig(contextConfigSupplier);\n+  }\n+\n   private static void startCleanupThread(final AccumuloConfiguration conf,\n       final Supplier<Map<String,String>> contextConfigSupplier) {\n-    ScheduledFuture<?> future = ThreadPools.createGeneralScheduledExecutorService(conf)\n+    ScheduledFuture<?> future = ThreadPools.getClientThreadPools((t, e) -> {\n+      LOG.error(\"context classloader cleanup thread has failed.\", e);\n+    }).createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n           Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .map(p -> p.substring(VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-          AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n+          removeUnusedContexts(contextsInUse);\n         }), 1, 1, MINUTES);\n     ThreadPools.watchNonCriticalScheduledTask(future);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n+  @SuppressWarnings(\"deprecation\")\n+  private static void removeUnusedContexts(Set<String> contextsInUse) {\n+    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .removeUnusedContexts(contextsInUse);\n+  }\n+\n+  @SuppressWarnings(\"deprecation\")\n   @Override\n   public ClassLoader getClassLoader(String contextName) {\n-    return AccumuloVFSClassLoader.getContextClassLoader(contextName);\n+    return org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .getContextClassLoader(contextName);\n   }\n \n }\n", "next_change": {"commit": "cc44add8bcf9d69057f18d19e6fe9d6b9328575f", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\ndeleted file mode 100644\nindex b9428e6f6e..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ /dev/null\n", "chunk": "@@ -1,102 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.classloader;\n-\n-import static java.util.concurrent.TimeUnit.MINUTES;\n-\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.spi.common.ContextClassLoaderFactory;\n-import org.apache.accumulo.core.util.threads.ThreadPools;\n-import org.apache.accumulo.core.util.threads.Threads;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The default implementation of ContextClassLoaderFactory. This implementation is subject to change\n- * over time. It currently implements the legacy context class loading behavior based on Accumulo's\n- * custom class loaders and commons-vfs2. In future, it may simply return the system class loader\n- * for all requested contexts. This class is used internally to Accumulo only, and should not be\n- * used by users in their configuration.\n- */\n-public class DefaultContextClassLoaderFactory implements ContextClassLoaderFactory {\n-\n-  private static final AtomicBoolean isInstantiated = new AtomicBoolean(false);\n-  private static final Logger LOG = LoggerFactory.getLogger(DefaultContextClassLoaderFactory.class);\n-  private static final String className = DefaultContextClassLoaderFactory.class.getName();\n-\n-  @SuppressWarnings(\"removal\")\n-  private static final Property VFS_CONTEXT_CLASSPATH_PROPERTY =\n-      Property.VFS_CONTEXT_CLASSPATH_PROPERTY;\n-\n-  public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n-    if (!isInstantiated.compareAndSet(false, true)) {\n-      throw new IllegalStateException(\"Can only instantiate \" + className + \" once\");\n-    }\n-    Supplier<Map<String,String>> contextConfigSupplier =\n-        () -> accConf.getAllPropertiesWithPrefix(VFS_CONTEXT_CLASSPATH_PROPERTY);\n-    setContextConfig(contextConfigSupplier);\n-    LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(accConf, contextConfigSupplier);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  private static void setContextConfig(Supplier<Map<String,String>> contextConfigSupplier) {\n-    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .setContextConfig(contextConfigSupplier);\n-  }\n-\n-  private static void startCleanupThread(final AccumuloConfiguration conf,\n-      final Supplier<Map<String,String>> contextConfigSupplier) {\n-    ScheduledFuture<?> future = ThreadPools.getClientThreadPools((t, e) -> {\n-      LOG.error(\"context classloader cleanup thread has failed.\", e);\n-    }).createGeneralScheduledExecutorService(conf)\n-        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n-          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .map(p -> p.substring(VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n-              .collect(Collectors.toSet());\n-          LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-          removeUnusedContexts(contextsInUse);\n-        }), 1, 1, MINUTES);\n-    ThreadPools.watchNonCriticalScheduledTask(future);\n-    LOG.debug(\"Context cleanup timer started at 60s intervals\");\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  private static void removeUnusedContexts(Set<String> contextsInUse) {\n-    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .removeUnusedContexts(contextsInUse);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  @Override\n-  public ClassLoader getClassLoader(String contextName) {\n-    return org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .getContextClassLoader(contextName);\n-  }\n-\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "committedDate": "2022-03-04 07:59:03 -0500", "message": "Check scheduled tasks periodically for errors (#2524)"}, {"oid": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "committedDate": "2022-03-15 07:29:39 -0400", "message": "Set default UncaughtExceptionHandler in client, enable override (#2554)"}, {"oid": "1a0bb1e3d58583ab1f9a90dd1bbc33138345d85a", "committedDate": "2022-05-13 18:18:42 -0400", "message": "Minor little cleanups (#2695)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "cc44add8bcf9d69057f18d19e6fe9d6b9328575f", "committedDate": "2023-02-24 10:16:48 -0500", "message": "Remove deprecated AccumuloVFSClassLoader  (#3136)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU4NDEyNw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556584127", "body": "With a lambda, this would be slightly shorter:\r\n\r\n```java\r\n      Threads.createThread(\"Halt Thread\", () -> {\r\n        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\r\n        Runtime.getRuntime().halt(status);\r\n      }).start();\r\n```", "bodyText": "With a lambda, this would be slightly shorter:\n      Threads.createThread(\"Halt Thread\", () -> {\n        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n        Runtime.getRuntime().halt(status);\n      }).start();", "bodyHTML": "<p dir=\"auto\">With a lambda, this would be slightly shorter:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"      Threads.createThread(&quot;Halt Thread&quot;, () -&gt; {\n        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n        Runtime.getRuntime().halt(status);\n      }).start();\n\"><pre>      <span class=\"pl-smi\">Threads</span><span class=\"pl-k\">.</span>createThread(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Halt Thread<span class=\"pl-pds\">\"</span></span>, () <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {\n        sleepUninterruptibly(<span class=\"pl-c1\">100</span>, <span class=\"pl-smi\">TimeUnit</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>MILLISECONDS</span>);\n        <span class=\"pl-smi\">Runtime</span><span class=\"pl-k\">.</span>getRuntime()<span class=\"pl-k\">.</span>halt(status);\n      })<span class=\"pl-k\">.</span>start();</pre></div>", "author": "ctubbsii", "createdAt": "2021-01-13T15:00:41Z", "path": "core/src/main/java/org/apache/accumulo/core/util/Halt.java", "diffHunk": "@@ -49,15 +49,16 @@ public void run() {\n   }\n \n   public static void halt(final int status, Runnable runnable) {\n+\n     try {\n       // give ourselves a little time to try and do something\n-      new Daemon() {\n+      Threads.createThread(\"Halt Thread\", new Runnable() {\n         @Override\n         public void run() {\n           sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n           Runtime.getRuntime().halt(status);\n         }\n-      }.start();\n+      }).start();", "originalCommit": "137f7859f81a89744da60c7b0849a1041b178119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY4OTUyNw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556689527", "bodyText": "Resolved in latest commit", "author": "dlmarion", "createdAt": "2021-01-13T17:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU4NDEyNw=="}], "type": "inlineReview", "revised_code": {"commit": "5153181e5002cc4ea8ade6b747fac66659e64e99", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex 45d4f7296d..e9c097e218 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -52,12 +52,9 @@ public class Halt {\n \n     try {\n       // give ourselves a little time to try and do something\n-      Threads.createThread(\"Halt Thread\", new Runnable() {\n-        @Override\n-        public void run() {\n-          sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-          Runtime.getRuntime().halt(status);\n-        }\n+      Threads.createThread(\"Halt Thread\", () -> {\n+        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+        Runtime.getRuntime().halt(status);\n       }).start();\n \n       if (runnable != null)\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex 45d4f7296d..e9c097e218 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -52,12 +52,9 @@ public class Halt {\n \n     try {\n       // give ourselves a little time to try and do something\n-      Threads.createThread(\"Halt Thread\", new Runnable() {\n-        @Override\n-        public void run() {\n-          sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-          Runtime.getRuntime().halt(status);\n-        }\n+      Threads.createThread(\"Halt Thread\", () -> {\n+        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+        Runtime.getRuntime().halt(status);\n       }).start();\n \n       if (runnable != null)\n", "next_change": {"commit": "0a64b442a92f728858066c2bc12312f96d41d22e", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex e9c097e218..bce13fe025 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -53,7 +52,7 @@ public class Halt {\n     try {\n       // give ourselves a little time to try and do something\n       Threads.createThread(\"Halt Thread\", () -> {\n-        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+        sleepUninterruptibly(100, MILLISECONDS);\n         Runtime.getRuntime().halt(status);\n       }).start();\n \n", "next_change": {"commit": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/util/Halt.java b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\nindex bce13fe025..ec822b48cc 100644\n--- a/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n+++ b/core/src/main/java/org/apache/accumulo/core/util/Halt.java\n", "chunk": "@@ -56,8 +56,9 @@ public class Halt {\n         Runtime.getRuntime().halt(status);\n       }).start();\n \n-      if (runnable != null)\n+      if (runnable != null) {\n         runnable.run();\n+      }\n       Runtime.getRuntime().halt(status);\n     } finally {\n       // In case something else decides to throw a Runtime exception\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "2dbdc085390794e7925740a81439c66dc3dfbb7c", "committedDate": "2022-10-20 00:16:54 -0400", "message": "Move o.a.a.fate to o.a.a.core.fate (#3035)"}, {"oid": "dbf202f2ddbef1ed46c1db9f229e44ad022d89d0", "committedDate": "2022-11-30 02:21:37 -0500", "message": "Update javadoc tag style to match google style guide (#3064)"}, {"oid": "6712d2500bd088d43bca4d207ef09d5e143de4d4", "committedDate": "2022-12-16 08:50:49 -0500", "message": "Replace UtilWaitThread.sleepUninterruptibly with guava equivalent (#3121)"}]}, {"oid": "370bb25fb6fb640647a2e8ce0076a6e3600b3b79", "url": "https://github.com/apache/accumulo/commit/370bb25fb6fb640647a2e8ce0076a6e3600b3b79", "message": "re #1808: Don't create two ConfigurationCopy instances", "committedDate": "2021-01-13T16:10:14Z", "type": "commit"}, {"oid": "c479969590703e3ce7f99485f7389fda24f03259", "url": "https://github.com/apache/accumulo/commit/c479969590703e3ce7f99485f7389fda24f03259", "message": "Merge branch 'main' into 1808-thread-errors", "committedDate": "2021-01-13T16:41:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY4MDE4MA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556680180", "body": "Two things are wrong with this filter line:\r\n\r\n1. This is using the enum `name()`, when it should be filtering on the enum's `getKey()` method, and\r\n2. It's not even necessary to execute this filter, because the contextConfigSupplier already performs this filter.", "bodyText": "Two things are wrong with this filter line:\n\nThis is using the enum name(), when it should be filtering on the enum's getKey() method, and\nIt's not even necessary to execute this filter, because the contextConfigSupplier already performs this filter.", "bodyHTML": "<p dir=\"auto\">Two things are wrong with this filter line:</p>\n<ol dir=\"auto\">\n<li>This is using the enum <code>name()</code>, when it should be filtering on the enum's <code>getKey()</code> method, and</li>\n<li>It's not even necessary to execute this filter, because the contextConfigSupplier already performs this filter.</li>\n</ol>", "author": "ctubbsii", "createdAt": "2021-01-13T16:56:24Z", "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -55,22 +56,21 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n         () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n     AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(contextConfigSupplier);\n+    startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n-  private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+  private static void startCleanupThread(final AccumuloConfiguration conf,\n+      final Supplier<Map<String,String>> contextConfigSupplier) {\n+    ThreadPools.createGeneralScheduledExecutorService(conf)\n+        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n+          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n+              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))", "originalCommit": "c479969590703e3ce7f99485f7389fda24f03259", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY4OTg1NA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556689854", "bodyText": "Thanks for catching that, I went down one path, then another, and left that in by mistake. Resolved in latest commit.", "author": "dlmarion", "createdAt": "2021-01-13T17:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY4MDE4MA=="}], "type": "inlineReview", "revised_code": {"commit": "5153181e5002cc4ea8ade6b747fac66659e64e99", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex 76eb0fdd8a..f7e556e808 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -65,7 +65,6 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n           Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))\n               .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "e62ace6a9d37572d95999f5412c6148efbba50b9", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex 76eb0fdd8a..f7e556e808 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -65,7 +65,6 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n           Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))\n               .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n", "next_change": {"commit": "0a64b442a92f728858066c2bc12312f96d41d22e", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex f7e556e808..e19c38b92d 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -69,7 +70,7 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-        }), 60_000, 60_000, TimeUnit.MILLISECONDS);\n+        }), 1, 1, MINUTES);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n", "next_change": {"commit": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex e19c38b92d..6baaa64aa1 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -71,6 +72,7 @@ public class DefaultContextClassLoaderFactory implements ContextClassLoaderFacto\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n           AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n         }), 1, 1, MINUTES);\n+    ThreadPools.watchNonCriticalScheduledTask(future);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n", "next_change": {"commit": "1a0bb1e3d58583ab1f9a90dd1bbc33138345d85a", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\nindex 6baaa64aa1..b9428e6f6e 100644\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n", "chunk": "@@ -43,42 +42,61 @@ import org.slf4j.LoggerFactory;\n  * for all requested contexts. This class is used internally to Accumulo only, and should not be\n  * used by users in their configuration.\n  */\n-@SuppressWarnings({\"deprecation\", \"removal\"})\n public class DefaultContextClassLoaderFactory implements ContextClassLoaderFactory {\n \n   private static final AtomicBoolean isInstantiated = new AtomicBoolean(false);\n   private static final Logger LOG = LoggerFactory.getLogger(DefaultContextClassLoaderFactory.class);\n   private static final String className = DefaultContextClassLoaderFactory.class.getName();\n \n+  @SuppressWarnings(\"removal\")\n+  private static final Property VFS_CONTEXT_CLASSPATH_PROPERTY =\n+      Property.VFS_CONTEXT_CLASSPATH_PROPERTY;\n+\n   public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n     if (!isInstantiated.compareAndSet(false, true)) {\n       throw new IllegalStateException(\"Can only instantiate \" + className + \" once\");\n     }\n     Supplier<Map<String,String>> contextConfigSupplier =\n-        () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n-    AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n+        () -> accConf.getAllPropertiesWithPrefix(VFS_CONTEXT_CLASSPATH_PROPERTY);\n+    setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n     startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n+  @SuppressWarnings(\"deprecation\")\n+  private static void setContextConfig(Supplier<Map<String,String>> contextConfigSupplier) {\n+    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .setContextConfig(contextConfigSupplier);\n+  }\n+\n   private static void startCleanupThread(final AccumuloConfiguration conf,\n       final Supplier<Map<String,String>> contextConfigSupplier) {\n-    ScheduledFuture<?> future = ThreadPools.createGeneralScheduledExecutorService(conf)\n+    ScheduledFuture<?> future = ThreadPools.getClientThreadPools((t, e) -> {\n+      LOG.error(\"context classloader cleanup thread has failed.\", e);\n+    }).createGeneralScheduledExecutorService(conf)\n         .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n           LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n           Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .map(p -> p.substring(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n+              .map(p -> p.substring(VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n               .collect(Collectors.toSet());\n           LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-          AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n+          removeUnusedContexts(contextsInUse);\n         }), 1, 1, MINUTES);\n     ThreadPools.watchNonCriticalScheduledTask(future);\n     LOG.debug(\"Context cleanup timer started at 60s intervals\");\n   }\n \n+  @SuppressWarnings(\"deprecation\")\n+  private static void removeUnusedContexts(Set<String> contextsInUse) {\n+    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .removeUnusedContexts(contextsInUse);\n+  }\n+\n+  @SuppressWarnings(\"deprecation\")\n   @Override\n   public ClassLoader getClassLoader(String contextName) {\n-    return AccumuloVFSClassLoader.getContextClassLoader(contextName);\n+    return org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n+        .getContextClassLoader(contextName);\n   }\n \n }\n", "next_change": {"commit": "cc44add8bcf9d69057f18d19e6fe9d6b9328575f", "changed_code": [{"header": "diff --git a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java b/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\ndeleted file mode 100644\nindex b9428e6f6e..0000000000\n--- a/core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java\n+++ /dev/null\n", "chunk": "@@ -1,102 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.accumulo.core.classloader;\n-\n-import static java.util.concurrent.TimeUnit.MINUTES;\n-\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-\n-import org.apache.accumulo.core.conf.AccumuloConfiguration;\n-import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.spi.common.ContextClassLoaderFactory;\n-import org.apache.accumulo.core.util.threads.ThreadPools;\n-import org.apache.accumulo.core.util.threads.Threads;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The default implementation of ContextClassLoaderFactory. This implementation is subject to change\n- * over time. It currently implements the legacy context class loading behavior based on Accumulo's\n- * custom class loaders and commons-vfs2. In future, it may simply return the system class loader\n- * for all requested contexts. This class is used internally to Accumulo only, and should not be\n- * used by users in their configuration.\n- */\n-public class DefaultContextClassLoaderFactory implements ContextClassLoaderFactory {\n-\n-  private static final AtomicBoolean isInstantiated = new AtomicBoolean(false);\n-  private static final Logger LOG = LoggerFactory.getLogger(DefaultContextClassLoaderFactory.class);\n-  private static final String className = DefaultContextClassLoaderFactory.class.getName();\n-\n-  @SuppressWarnings(\"removal\")\n-  private static final Property VFS_CONTEXT_CLASSPATH_PROPERTY =\n-      Property.VFS_CONTEXT_CLASSPATH_PROPERTY;\n-\n-  public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n-    if (!isInstantiated.compareAndSet(false, true)) {\n-      throw new IllegalStateException(\"Can only instantiate \" + className + \" once\");\n-    }\n-    Supplier<Map<String,String>> contextConfigSupplier =\n-        () -> accConf.getAllPropertiesWithPrefix(VFS_CONTEXT_CLASSPATH_PROPERTY);\n-    setContextConfig(contextConfigSupplier);\n-    LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(accConf, contextConfigSupplier);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  private static void setContextConfig(Supplier<Map<String,String>> contextConfigSupplier) {\n-    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .setContextConfig(contextConfigSupplier);\n-  }\n-\n-  private static void startCleanupThread(final AccumuloConfiguration conf,\n-      final Supplier<Map<String,String>> contextConfigSupplier) {\n-    ScheduledFuture<?> future = ThreadPools.getClientThreadPools((t, e) -> {\n-      LOG.error(\"context classloader cleanup thread has failed.\", e);\n-    }).createGeneralScheduledExecutorService(conf)\n-        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n-          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n-          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n-              .map(p -> p.substring(VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length()))\n-              .collect(Collectors.toSet());\n-          LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-          removeUnusedContexts(contextsInUse);\n-        }), 1, 1, MINUTES);\n-    ThreadPools.watchNonCriticalScheduledTask(future);\n-    LOG.debug(\"Context cleanup timer started at 60s intervals\");\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  private static void removeUnusedContexts(Set<String> contextsInUse) {\n-    org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .removeUnusedContexts(contextsInUse);\n-  }\n-\n-  @SuppressWarnings(\"deprecation\")\n-  @Override\n-  public ClassLoader getClassLoader(String contextName) {\n-    return org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader\n-        .getContextClassLoader(contextName);\n-  }\n-\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "e62ace6a9d37572d95999f5412c6148efbba50b9", "message": "Merge commit", "committedDate": null}, {"oid": "0a64b442a92f728858066c2bc12312f96d41d22e", "committedDate": "2022-02-23 23:34:08 -0500", "message": "Replace some calculation with TimeUnit (#2515)"}, {"oid": "7fb1b5df9e3abe18304039fb3e781b2617eec4b5", "committedDate": "2022-03-04 07:59:03 -0500", "message": "Check scheduled tasks periodically for errors (#2524)"}, {"oid": "dca3ae8d056a24510aa9d86347d9d6338613c4b3", "committedDate": "2022-03-15 07:29:39 -0400", "message": "Set default UncaughtExceptionHandler in client, enable override (#2554)"}, {"oid": "1a0bb1e3d58583ab1f9a90dd1bbc33138345d85a", "committedDate": "2022-05-13 18:18:42 -0400", "message": "Minor little cleanups (#2695)"}, {"oid": "cf57e343de77f416de10c22e0ed05ef37f433b36", "committedDate": "2022-06-14 03:47:04 -0400", "message": "Trivial: Use https in more places (#2774)"}, {"oid": "cc44add8bcf9d69057f18d19e6fe9d6b9328575f", "committedDate": "2023-02-24 10:16:48 -0500", "message": "Remove deprecated AccumuloVFSClassLoader  (#3136)"}]}, {"oid": "5153181e5002cc4ea8ade6b747fac66659e64e99", "url": "https://github.com/apache/accumulo/commit/5153181e5002cc4ea8ade6b747fac66659e64e99", "message": "re #1808 - simplify Halt daemon thread, remove errant filter command", "committedDate": "2021-01-13T17:08:50Z", "type": "commit"}, {"oid": "da18f062d8a64757f9bf0a31b09c91f7ac225866", "url": "https://github.com/apache/accumulo/commit/da18f062d8a64757f9bf0a31b09c91f7ac225866", "message": "Merge branch '1808-thread-errors' of github.com:dlmarion/accumulo into 1808-thread-errors", "committedDate": "2021-01-13T17:10:46Z", "type": "commit"}, {"oid": "35657242bedbc6c0850cfef9bdef44bd9de82256", "url": "https://github.com/apache/accumulo/commit/35657242bedbc6c0850cfef9bdef44bd9de82256", "message": "Merge branch 'main' into 1808-thread-errors", "committedDate": "2021-01-19T11:53:20Z", "type": "commit"}]}