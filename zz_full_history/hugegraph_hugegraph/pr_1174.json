{"pr_number": 1174, "pr_title": "Custom kout/kneighbor, multi-node-shortest-path, jaccard-similar and template paths", "pr_author": "zhoney", "pr_createdAt": "2020-09-15T03:28:55Z", "pr_url": "https://github.com/hugegraph/hugegraph/pull/1174", "merge_commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "timeline": [{"oid": "9eb68d856aa061de0fd3bb52c16e40ab18f5d8cc", "url": "https://github.com/hugegraph/hugegraph/commit/9eb68d856aa061de0fd3bb52c16e40ab18f5d8cc", "message": "upgrade api version to 58\n\nimplements: #1173\n\nChange-Id: I85aa1d4274554d65f85a0deb7ac596e65dbb503b", "committedDate": "2020-09-15T03:30:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxNjkzNA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r490916934", "body": "move Consumers to com/baidu/hugegraph/util", "bodyText": "move Consumers to com/baidu/hugegraph/util", "bodyHTML": "<p dir=\"auto\">move Consumers to com/baidu/hugegraph/util</p>", "author": "javeme", "createdAt": "2020-09-18T12:33:11Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/job/algorithm/Consumers.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.job.algorithm;\n+\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeException;\n+import com.baidu.hugegraph.task.TaskManager.ContextCallable;\n+import com.baidu.hugegraph.util.ExecutorUtil;\n+import com.baidu.hugegraph.util.Log;\n+\n+public class Consumers<V> {", "originalCommit": "3fc98af7e395491d35a619a7e26268e0e614b730", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkwNTc3MQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r491905771", "bodyText": "rebase #1183", "author": "javeme", "createdAt": "2020-09-21T09:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxNjkzNA=="}], "type": "inlineReview", "revised_code": {"commit": "ab1564a02ac53174e09ee92121ba12d84c188c2a", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/job/algorithm/Consumers.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/util/Consumers.java\nsimilarity index 88%\nrename from hugegraph-core/src/main/java/com/baidu/hugegraph/job/algorithm/Consumers.java\nrename to hugegraph-core/src/main/java/com/baidu/hugegraph/util/Consumers.java\nindex 1c68413f..aedb547f 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/job/algorithm/Consumers.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/util/Consumers.java\n", "chunk": "@@ -31,8 +31,6 @@ import org.slf4j.Logger;\n \n import com.baidu.hugegraph.HugeException;\n import com.baidu.hugegraph.task.TaskManager.ContextCallable;\n-import com.baidu.hugegraph.util.ExecutorUtil;\n-import com.baidu.hugegraph.util.Log;\n \n public class Consumers<V> {\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/job/algorithm/Consumers.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/util/Consumers.java\nsimilarity index 88%\nrename from hugegraph-core/src/main/java/com/baidu/hugegraph/job/algorithm/Consumers.java\nrename to hugegraph-core/src/main/java/com/baidu/hugegraph/util/Consumers.java\nindex 1c68413f..aedb547f 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/job/algorithm/Consumers.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/util/Consumers.java\n", "chunk": "@@ -31,8 +31,6 @@ import org.slf4j.Logger;\n \n import com.baidu.hugegraph.HugeException;\n import com.baidu.hugegraph.task.TaskManager.ContextCallable;\n-import com.baidu.hugegraph.util.ExecutorUtil;\n-import com.baidu.hugegraph.util.Log;\n \n public class Consumers<V> {\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "4763e876bcdf883df4f16d8b226eb0ed4284eb0c", "committedDate": "2022-11-09 18:24:54 +0800", "message": "support parallel: Louvain,LPA,Rings,K-Core,Fusiform (#15)"}, {"oid": "beda055142988798dceed6f8be7b0a0b616f05e6", "committedDate": "2022-11-09 18:24:54 +0800", "message": "fix parallel LPA not commit by threads (#16)"}, {"oid": "71109cffdee980f8fc320dde7bd396e21717960d", "committedDate": "2022-11-09 18:24:54 +0800", "message": "fix algorithm can't stop caused by threads exception (#18)"}, {"oid": "53025bd43bfe537a033597cea51720620089c25b", "committedDate": "2022-11-09 18:24:54 +0800", "message": "add BOTH direction support for triangle_count/cluster_coeffcient (#24)"}, {"oid": "353d90698ff27196a56b3cb85edf342bcd53a8ee", "committedDate": "2022-11-09 18:24:54 +0800", "message": "fix no auth with worker thread of olap algo (#27)"}, {"oid": "b1b12098feb726e46c781a2f171c77558db05fc1", "committedDate": "2022-11-09 18:24:54 +0800", "message": "adapt the latest version & clean code"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"oid": "ab1564a02ac53174e09ee92121ba12d84c188c2a", "url": "https://github.com/hugegraph/hugegraph/commit/ab1564a02ac53174e09ee92121ba12d84c188c2a", "message": "Add customized kout/kneighbor, template path, multi-node-shortest-path and jaccard similar\n\n* fix OLTP algorithm not check if source/target vertex exist (#1156)\n* support customized kout and kneighbor\n* support multi node shortest path API\n* support template paths api\n* support jaccard similars find oltp api\n* use multi-thread to accelerate customized kout/kneighbor, multi-node-shortest-path, jaccard-similar and template-paths\n* big depth and both direction use multi threads, otherwise single threead\n* fix shortest path api NLP\n\nChange-Id: I7eb4ceaccdc4a6b2a4a7b944edc83dff64a98f5d", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "5660ca98fd1017fbc9e8143532f6eef3564bda38", "url": "https://github.com/hugegraph/hugegraph/commit/5660ca98fd1017fbc9e8143532f6eef3564bda38", "message": "Szzq paths improve (#51)\n\n* template path use concurrent hashset to save paths in concurrent mode\r\n* support property filter for paths api\r\n\r\nChange-Id: I2e589f58cdfc48b4b8d16b7780b78cc17ab107d6", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "851760ba26dc70bd08634e8d389293021d75f62c", "url": "https://github.com/hugegraph/hugegraph/commit/851760ba26dc70bd08634e8d389293021d75f62c", "message": "fix configuration not supported with auth (#55)\n\nalso paths and template paths use single thread\r\n\r\nChange-Id: I4375c455f377d9e4d43c0284ec30da1725fdf6bc", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "64088e548bd4008f550d4a430153825920d79337", "url": "https://github.com/hugegraph/hugegraph/commit/64088e548bd4008f550d4a430153825920d79337", "message": "template path supports repeat times args (#57)\n\npaths supports nearest args\r\noltp multiple threads reuse\r\nadd multiple thread depth config\r\n\r\nChange-Id: I8c2f921ffb56302fb8d300c09a5a13857dac187a", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "b120508e30ba39e92fc9693b1eeab387de5e677b", "url": "https://github.com/hugegraph/hugegraph/commit/b120508e30ba39e92fc9693b1eeab387de5e677b", "message": "fix group perperty can't be empty\n\nChange-Id: I6d972894f3eec339181e5626bf45d01f36dbd4c0", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "e178508397470933745464a7cf82ca0a88068f35", "url": "https://github.com/hugegraph/hugegraph/commit/e178508397470933745464a7cf82ca0a88068f35", "message": "upgrade api version to 58\n\nimplements: #1173\n\nChange-Id: I85aa1d4274554d65f85a0deb7ac596e65dbb503b", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "e98555e8f31371672d9bfb57527c226dd274f4b8", "url": "https://github.com/hugegraph/hugegraph/commit/e98555e8f31371672d9bfb57527c226dd274f4b8", "message": "add Consumers class\n\nChange-Id: I73d877fbd2099d9e63ef29ee0a10df30354595f9", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "a0f44c002cb3eefcae5317f77b5b9601c0ae4e28", "url": "https://github.com/hugegraph/hugegraph/commit/a0f44c002cb3eefcae5317f77b5b9601c0ae4e28", "message": "move customized kout/kneighbor to kout/kneighbor\n\nChange-Id: Ib6fa985ff48fab203611218cc955079ad8cc90c3", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "924c5e174b626fba1be366c35c3713645cd28490", "url": "https://github.com/hugegraph/hugegraph/commit/924c5e174b626fba1be366c35c3713645cd28490", "message": "move jaccard similar into jaccard similarity\n\nChange-Id: Ia6ff5efd7e2a195f85427992b7bff875d30dec48", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "f31cf3adff9c7e1351744ce06a0cd057e96d3e23", "url": "https://github.com/hugegraph/hugegraph/commit/f31cf3adff9c7e1351744ce06a0cd057e96d3e23", "message": "improve\n\nChange-Id: Ib43614c252912427c6ddaeb52c974a59b06934e6", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "b9706e1777e47efff757b9e71a132da3c3793c30", "url": "https://github.com/hugegraph/hugegraph/commit/b9706e1777e47efff757b9e71a132da3c3793c30", "message": "improve\n\nChange-Id: I5ef4b33e8c5b4ade0b372d3810e596d335f37f29", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "ebe3157ef79189cc661c1a93cfbcb270a11d0750", "url": "https://github.com/hugegraph/hugegraph/commit/ebe3157ef79189cc661c1a93cfbcb270a11d0750", "message": "fix kout/kneighbor withVertex not work\n\nChange-Id: Icbc65aa24e069b67bd5653b79473da48e2f973c6", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "25cb47ad2f8ad21d0657cd96277f79ec37c981a2", "url": "https://github.com/hugegraph/hugegraph/commit/25cb47ad2f8ad21d0657cd96277f79ec37c981a2", "message": "rebase ramtable\n\nChange-Id: I606772946a2a55f7472274242fb18f4ca91c189a", "committedDate": "2020-09-21T10:04:17Z", "type": "commit"}, {"oid": "25cb47ad2f8ad21d0657cd96277f79ec37c981a2", "url": "https://github.com/hugegraph/hugegraph/commit/25cb47ad2f8ad21d0657cd96277f79ec37c981a2", "message": "rebase ramtable\n\nChange-Id: I606772946a2a55f7472274242fb18f4ca91c189a", "committedDate": "2020-09-21T10:04:17Z", "type": "forcePushed"}, {"oid": "bff5a6a67a3c1f0868bf2a23aefa3cecf13fb12e", "url": "https://github.com/hugegraph/hugegraph/commit/bff5a6a67a3c1f0868bf2a23aefa3cecf13fb12e", "message": "improve\n\nChange-Id: I4ab46bc68644d35fab1fa966e27a0d7ab87b433b", "committedDate": "2020-09-22T03:09:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIzODUxNg==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r494238516", "body": "add common method", "bodyText": "add common method", "bodyHTML": "<p dir=\"auto\">add common method</p>", "author": "javeme", "createdAt": "2020-09-24T11:29:08Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -0,0 +1,636 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.structure.HugeVertex;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.E;\n+import com.baidu.hugegraph.util.Log;\n+import com.google.common.collect.ImmutableList;\n+\n+public class TemplatePathsTraverser extends TpTraverser {\n+\n+    private static final Logger LOG = Log.logger(TemplatePathsTraverser.class);\n+\n+    public TemplatePathsTraverser(HugeGraph graph) {\n+        super(graph, \"template-paths\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<Path> templatePaths(Iterator<Vertex> sources,\n+                                   Iterator<Vertex> targets,\n+                                   List<RepeatEdgeStep> steps,\n+                                   boolean withRing,\n+                                   long capacity, long limit) {\n+        checkCapacity(capacity);\n+        checkLimit(limit);\n+\n+        List<Id> sourceList = new ArrayList<>();\n+        while (sources.hasNext()) {\n+            sourceList.add(((HugeVertex) sources.next()).id());\n+        }\n+        int sourceSize = sourceList.size();\n+        E.checkState(sourceSize >= 1 && sourceSize <= MAX_VERTICES,\n+                     \"The number of source vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+        List<Id> targetList = new ArrayList<>();\n+        while (targets.hasNext()) {\n+            targetList.add(((HugeVertex) targets.next()).id());\n+        }\n+        int targetSize = targetList.size();\n+        E.checkState(targetSize >= 1 && targetSize <= MAX_VERTICES,\n+                     \"The number of target vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+\n+        int totalSteps = 0;\n+        for (RepeatEdgeStep step : steps) {\n+            totalSteps += step.maxTimes;\n+        }\n+        Traverser traverser = totalSteps >= this.concurrentDepth() ?\n+                              new ConcurrentTraverser(sourceList, targetList,\n+                                                      steps, withRing,\n+                                                      capacity, limit) :\n+                              new SingleTraverser(sourceList, targetList,\n+                                                  steps, withRing,\n+                                                  capacity, limit);\n+\n+        do {\n+            // Forward\n+            traverser.forward();\n+            if (traverser.finish()) {\n+                return traverser.paths();\n+            }\n+\n+            // Backward\n+            traverser.backward();\n+            if (traverser.finish()) {\n+                return traverser.paths();\n+            }\n+        } while (true);\n+    }\n+\n+    private class Traverser {\n+\n+        protected final List<RepeatEdgeStep> steps;\n+        protected int stepCount;\n+        protected final long capacity;\n+        protected final long limit;\n+        protected int totalSteps;\n+        protected boolean withRing;\n+        protected int sourceIndex;\n+        protected int targetIndex;\n+\n+        protected boolean sourceFinishOneStep = false;\n+        protected boolean targetFinishOneStep = false;\n+\n+        public Traverser(List<RepeatEdgeStep> steps,\n+                         long capacity, long limit, boolean withRing) {\n+            this.steps = steps;\n+            this.capacity = capacity;\n+            this.limit = limit;\n+            this.withRing = withRing;\n+\n+            this.stepCount = 0;\n+            for (RepeatEdgeStep step : steps) {\n+                this.totalSteps += step.maxTimes;\n+            }\n+            this.sourceIndex = 0;\n+            this.targetIndex = this.steps.size() - 1;\n+        }\n+\n+        public void forward() {\n+        }\n+\n+        public void backward() {\n+        }\n+\n+        public Set<Path> paths() {\n+            return new PathSet();\n+        }\n+\n+        public int pathCount() {\n+            return 0;\n+        }\n+\n+        protected boolean finish() {\n+            return this.stepCount >= this.totalSteps || this.reachLimit();\n+        }\n+\n+        protected boolean lastStep() {\n+            return this.stepCount == this.totalSteps - 1;\n+        }\n+\n+        protected int accessedNodes() {\n+            return 0;\n+        }\n+\n+        protected boolean reachLimit() {\n+            checkCapacity(this.capacity, this.accessedNodes(),\n+                          \"template paths\");\n+            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        public boolean lastSuperStep() {\n+            return this.targetIndex == this.sourceIndex ||\n+                   this.targetIndex == this.sourceIndex + 1;\n+        }\n+    }\n+\n+    private class ConcurrentTraverser extends Traverser {\n+\n+        private ConcurrentMultiValuedMap<Id, Node> sources =\n+                new ConcurrentMultiValuedMap<>();\n+        private ConcurrentMultiValuedMap<Id, Node> targets =\n+                new ConcurrentMultiValuedMap<>();\n+        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n+                new ConcurrentMultiValuedMap<>();\n+        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n+                new ConcurrentMultiValuedMap<>();\n+\n+        private Set<Path> paths;\n+\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(steps, capacity, limit, withRing);\n+            for (Id id : sources) {\n+                this.sources.add(id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.targets.add(id, new Node(id));\n+            }\n+            this.paths = ConcurrentHashMap.newKeySet();\n+        }\n+\n+        /**\n+         * Search forward from sources\n+         */\n+        public void forward() {\n+            ConcurrentMultiValuedMap<Id, Node> newVertices =\n+                                               new ConcurrentMultiValuedMap<>();\n+            RepeatEdgeStep currentStep = null;\n+            // Find next step to forward\n+            for (int i = 0; i < this.steps.size(); i++) {\n+                RepeatEdgeStep step = this.steps.get(i);\n+                if (step.remainTimes() > 0) {\n+                    currentStep = step;\n+                    this.sourceIndex = i;\n+                    break;\n+                }\n+            }\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            // Re-init source all if last forward finished one super step and\n+            // not last super step\n+            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n+                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n+                this.sourceFinishOneStep = false;\n+            }\n+\n+            // Traversal vertices of previous level\n+            RepeatEdgeStep finalCurrentStep = currentStep;\n+            traverseIds(this.sources.keySet().iterator(), vid -> {", "originalCommit": "bff5a6a67a3c1f0868bf2a23aefa3cecf13fb12e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex ef51ccab..b7183282 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -132,165 +141,199 @@ public class TemplatePathsTraverser extends TpTraverser {\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targets.containsKey(target)) {\n-                            for (Node node : this.targets.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.sourcesAll.containsKey(target)) {\n+                    for (Node node : this.sourcesAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(target, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n+            }\n+        }\n+\n+        private void reInitAllIfNeeded(boolean forward) {\n+            if (forward) {\n+                // Re-init source all if last forward finished one super step\n+                // and not last super step\n+                if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n+                    this.sourcesAll = this.newMultiValueMap();\n+                    this.sourceFinishOneStep = false;\n+                }\n+            } else {\n+                // Re-init target all if last forward finished one super step\n+                // and not last super step\n+                if (this.targetFinishOneStep && !this.lastSuperStep()) {\n+                    this.targetsAll = this.newMultiValueMap();\n+                    this.targetFinishOneStep = false;\n+                }\n             }\n+        }\n \n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n+        private void reInitCurrentIfNeeded(RepeatEdgeStep step,\n+                                           boolean forward) {\n+            step.decreaseTimes();\n+            if (forward) {\n+                // Re-init sources\n+                if (step.remainTimes() > 0) {\n+                    this.sources = this.newVertices;\n+                } else {\n+                    this.sources = this.sourcesAll;\n+                    this.sourceFinishOneStep = true;\n+                }\n             } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n+                // Re-init targets\n+                if (step.remainTimes() > 0) {\n+                    this.targets = this.newVertices;\n+                } else {\n+                    this.targets = this.targetsAll;\n+                    this.targetFinishOneStep = true;\n+                }\n             }\n-            this.stepCount++;\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n+        public RepeatEdgeStep forwardStep() {\n             RepeatEdgeStep currentStep = null;\n-\n             // Find next step to backward\n-            for (int i = this.steps.size() - 1; i >= 0; i--) {\n+            for (int i = 0; i < this.steps.size(); i++) {\n                 RepeatEdgeStep step = this.steps.get(i);\n                 if (step.remainTimes() > 0) {\n                     currentStep = step;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex ef51ccab..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -82,419 +74,196 @@ public class TemplatePathsTraverser extends TpTraverser {\n         for (RepeatEdgeStep step : steps) {\n             totalSteps += step.maxTimes;\n         }\n-        Traverser traverser = totalSteps >= this.concurrentDepth() ?\n-                              new ConcurrentTraverser(sourceList, targetList,\n-                                                      steps, withRing,\n-                                                      capacity, limit) :\n-                              new SingleTraverser(sourceList, targetList,\n-                                                  steps, withRing,\n-                                                  capacity, limit);\n-\n+        TraverseStrategy strategy = TraverseStrategy.create(\n+                                    totalSteps >= this.concurrentDepth(),\n+                                    this.graph());\n+        Traverser traverser = new Traverser(this, strategy,\n+                                            sourceList, targetList, steps,\n+                                            withRing, capacity, limit);\n         do {\n             // Forward\n             traverser.forward();\n-            if (traverser.finish()) {\n+            if (traverser.finished()) {\n                 return traverser.paths();\n             }\n \n             // Backward\n             traverser.backward();\n-            if (traverser.finish()) {\n+            if (traverser.finished()) {\n                 return traverser.paths();\n             }\n         } while (true);\n     }\n \n-    private class Traverser {\n+    private static class Traverser extends PathTraverser {\n \n         protected final List<RepeatEdgeStep> steps;\n-        protected int stepCount;\n-        protected final long capacity;\n-        protected final long limit;\n-        protected int totalSteps;\n+\n         protected boolean withRing;\n+\n         protected int sourceIndex;\n         protected int targetIndex;\n \n         protected boolean sourceFinishOneStep = false;\n         protected boolean targetFinishOneStep = false;\n \n-        public Traverser(List<RepeatEdgeStep> steps,\n-                         long capacity, long limit, boolean withRing) {\n+        public Traverser(HugeTraverser traverser, TraverseStrategy strategy,\n+                         Collection<Id> sources, Collection<Id> targets,\n+                         List<RepeatEdgeStep> steps, boolean withRing,\n+                         long capacity, long limit) {\n+            super(traverser, strategy, sources, targets, capacity, limit);\n+\n             this.steps = steps;\n-            this.capacity = capacity;\n-            this.limit = limit;\n             this.withRing = withRing;\n-\n-            this.stepCount = 0;\n             for (RepeatEdgeStep step : steps) {\n                 this.totalSteps += step.maxTimes;\n             }\n+\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n-        }\n-\n-        public void forward() {\n-        }\n-\n-        public void backward() {\n-        }\n-\n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n-\n-        public int pathCount() {\n-            return 0;\n-        }\n-\n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n-        }\n-\n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n-        }\n \n-        protected int accessedNodes() {\n-            return 0;\n+            this.sourceFinishOneStep = false;\n+            this.targetFinishOneStep = false;\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public RepeatEdgeStep nextStep(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        @Override\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n-    }\n-\n-    private class ConcurrentTraverser extends Traverser {\n-\n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n \n-        private Set<Path> paths;\n+        @Override\n+        public void afterTraverse(EdgeStep step, boolean forward) {\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = ConcurrentHashMap.newKeySet();\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentStepIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n-            }\n-\n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        @Override\n+        protected void processOneForForward(Id sourceV, Id targetV) {\n+            for (Node source : this.sources.get(sourceV)) {\n+                // If have loop, skip target\n+                if (!this.withRing && source.contains(targetV)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targets.containsKey(target)) {\n-                            for (Node node : this.targets.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(targetV)) {\n+                    for (Node target : this.targetsAll.get(targetV)) {\n+                        List<Id> path = joinPath(source, target, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(targetV, path));\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n-            }\n \n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n-            } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n-            this.stepCount++;\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-\n-            // Find next step to backward\n-            for (int i = this.steps.size() - 1; i >= 0; i--) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.targetIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init target all if last forward finished one super step and\n-            // not last super step\n-            if (this.targetFinishOneStep && !this.lastSuperStep()) {\n-                this.targetsAll = new ConcurrentMultiValuedMap<>();\n-                this.targetFinishOneStep = false;\n-            }\n-\n-            currentStep.swithDirection();\n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.targets.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        @Override\n+        protected void processOneForBackward(Id sourceV, Id targetV) {\n+            for (Node source : this.targets.get(sourceV)) {\n+                // If have loop, skip target\n+                if (!this.withRing && source.contains(targetV)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n \n-                    for (Node n : this.targets.get(vid)) {\n-                        // If have loop, skip target\n-                        if (n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.lastStep() &&\n-                            this.sources.containsKey(target)) {\n-                            for (Node node : this.sources.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    Path newPath = new Path(target, path);\n-                                    newPath.reverse();\n-                                    this.paths.add(newPath);\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.sourcesAll.containsKey(targetV)) {\n+                    for (Node target : this.sourcesAll.get(targetV)) {\n+                        List<Id> path = joinPath(source, target, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(targetV, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            currentStep.swithDirection();\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.targetsAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n+        }\n \n-            currentStep.decreaseTimes();\n-            // Re-init targets\n-            if (currentStep.remainTimes() > 0) {\n-                this.targets = newVertices;\n+        private void reInitAllIfNeeded(boolean forward) {\n+            if (forward) {\n+                /*\n+                 * Re-init source all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n+                if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n+                    this.sourcesAll = this.newMultiValueMap();\n+                    this.sourceFinishOneStep = false;\n+                }\n             } else {\n-                this.targets = this.targetsAll;\n-                this.targetFinishOneStep = true;\n+                /*\n+                 * Re-init target all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n+                if (this.targetFinishOneStep && !this.lastSuperStep()) {\n+                    this.targetsAll = this.newMultiValueMap();\n+                    this.targetFinishOneStep = false;\n+                }\n             }\n-            this.stepCount++;\n         }\n \n         @Override\n-        public Set<Path> paths() {\n-            return this.paths;\n-        }\n-\n-        @Override\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n-            }\n-            return size;\n-        }\n-    }\n-\n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n-\n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        protected void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                 boolean forward) {\n+            RepeatEdgeStep currentStep = (RepeatEdgeStep) step;\n+            currentStep.decreaseTimes();\n+            if (forward) {\n+                // Re-init sources\n+                if (currentStep.remainTimes() > 0) {\n+                    this.sources = this.newVertices;\n+                } else {\n+                    this.sources = this.sourcesAll;\n+                    this.sourceFinishOneStep = true;\n+                }\n+            } else {\n+                // Re-init targets\n+                if (currentStep.remainTimes() > 0) {\n+                    this.targets = this.newVertices;\n+                } else {\n+                    this.targets = this.targetsAll;\n+                    this.targetFinishOneStep = true;\n+                }\n             }\n-            this.paths = new PathSet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n+        public RepeatEdgeStep forwardStep() {\n             RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n+            // Find next step to backward\n             for (int i = 0; i < this.steps.size(); i++) {\n                 RepeatEdgeStep step = this.steps.get(i);\n                 if (step.remainTimes() > 0) {\n                     currentStep = step;\n-                    this.sourceIndex = i;\n+                    this.targetIndex = i;\n                     break;\n                 }\n             }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = newMultivalueMap();\n-                this.sourceFinishOneStep = false;\n-            }\n-\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-\n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n-            } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+            return currentStep;\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n+        public RepeatEdgeStep backwardStep() {\n             RepeatEdgeStep currentStep = null;\n-\n             // Find next step to backward\n             for (int i = this.steps.size() - 1; i >= 0; i--) {\n                 RepeatEdgeStep step = this.steps.get(i);\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "url": "https://github.com/hugegraph/hugegraph/commit/8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "message": "extract common traverser from template paths traversers\n\nChange-Id: If6f0c1370a2376ef176ce2db39e002ae11590e8d", "committedDate": "2020-09-29T07:10:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5MTE1NA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496691154", "body": "rename pre to prev", "bodyText": "rename pre to prev", "bodyHTML": "<p dir=\"auto\">rename pre to prev</p>", "author": "javeme", "createdAt": "2020-09-29T12:52:53Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -551,6 +551,26 @@ public static void checkSkipDegree(long skipDegree, long degree,\n         return new MultivaluedHashMap<>();\n     }\n \n+    protected static List<Id> joinPath(Node pre, Node back, boolean ring) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex a2083a66..431d7f26 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -551,9 +560,9 @@ public class HugeTraverser {\n         return new MultivaluedHashMap<>();\n     }\n \n-    protected static List<Id> joinPath(Node pre, Node back, boolean ring) {\n+    protected static List<Id> joinPath(Node prev, Node back, boolean ring) {\n         // Get self path\n-        List<Id> path = pre.path();\n+        List<Id> path = prev.path();\n \n         // Get reversed other path\n         List<Id> backPath = back.path();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex a2083a66..8f6102f9 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -551,9 +432,9 @@ public class HugeTraverser {\n         return new MultivaluedHashMap<>();\n     }\n \n-    protected static List<Id> joinPath(Node pre, Node back, boolean ring) {\n+    protected static List<Id> joinPath(Node prev, Node back, boolean ring) {\n         // Get self path\n-        List<Id> path = pre.path();\n+        List<Id> path = prev.path();\n \n         // Get reversed other path\n         List<Id> backPath = back.path();\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "74b013ed211b6951cca82c778655c3d7a6839b56", "committedDate": "2020-11-18 21:30:34 +0800", "message": "oltp concurrent requests share multi executors instead of one executor (#1258)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "bc90cf9e0a636485efcd8949f665e3d8f311e1a0", "committedDate": "2021-01-07 14:36:39 +0800", "message": "add config for whether encoding number of primary keys (#1323)"}, {"oid": "de81038c2119634596e7d7f7cf23a245ed8e630f", "committedDate": "2021-05-12 14:15:05 +0800", "message": "refact: unify naming of degree for oltp algorithms (#1433)"}, {"oid": "718daa63679ce9984b870e9450c481cac8e4e414", "committedDate": "2021-05-21 20:30:48 +0800", "message": "refact: let kout degree applied to all labels & remove source vertex from kneighbor default results  (#1459)"}, {"oid": "9ef6796dc9c60679ffbe49e60fe31c7d23818f55", "committedDate": "2021-05-27 17:36:11 +0800", "message": "refact: remove source from kneighbor/kout results & unify 'degree ' error info (#1463)"}, {"oid": "d48b820a56eefe45c64f3e1d63bb2f001015e222", "committedDate": "2021-05-28 15:52:39 +0800", "message": "refact: unify kout/kneighbor get method with post (#1470)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "eef1f8b124557ecb3cdb4adf227721f424b9ad07", "committedDate": "2021-10-28 11:44:50 +0800", "message": "oltp traversal: optimize id2code for number id (#1623)"}, {"oid": "9f50e679830cd8a81a1bfef4fcc33afefab91a4e", "committedDate": "2021-12-15 19:33:56 +0800", "message": "refact: params improve for personal rank api (#1695)"}, {"oid": "a0ffdc47fbeb5872af05886561f6963159ac86c0", "committedDate": "2021-12-15 19:39:37 +0800", "message": "refact: early stop  & perf improve for paths traverser/api (#1694)"}, {"oid": "e9cef7425ddb12aa50a40c1fe1107a4b58041773", "committedDate": "2022-01-12 20:08:59 +0800", "message": "fix: useless ring detection removed valid path (#1723)"}, {"oid": "85b01b233392cd991739a035773629c7bf90e23b", "committedDate": "2022-04-25 19:13:30 +0800", "message": "chore: java 11 version support (#1653)"}, {"oid": "f6f8c3eda68554f8eefe53322955af8216260fe1", "committedDate": "2022-05-11 15:34:17 +0800", "message": "fix checkstyle core-util issue (#1855)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5NDA5NQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496694095", "body": "rename v to source", "bodyText": "rename v to source", "bodyHTML": "<p dir=\"auto\">rename v to source</p>", "author": "javeme", "createdAt": "2020-09-29T12:57:02Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -214,17 +214,18 @@ public class TemplatePathsTraverser extends TpTraverser {\n             this.traverseOne(v, step, false);\n         }\n \n-        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+        private void traverseOne(Id source, RepeatEdgeStep step,\n+                                 boolean forward) {\n             if (this.reachLimit()) {\n                 return;\n             }\n \n-            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            Iterator<Edge> edges = edgesOfVertex(source, step);\n             while (edges.hasNext()) {\n                 HugeEdge edge = (HugeEdge) edges.next();\n                 Id target = edge.id().otherVertexId();\n \n-                this.processOne(v, target, forward);\n+                this.processOne(source, target, forward);\n             }\n         }\n \n", "next_change": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex 1ec17203..e4063aab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -206,38 +144,8 @@ public class TemplatePathsTraverser extends TpTraverser {\n             this.stepCount++;\n         }\n \n-        private void forward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, true);\n-        }\n-\n-        private void backward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, false);\n-        }\n-\n-        private void traverseOne(Id source, RepeatEdgeStep step,\n-                                 boolean forward) {\n-            if (this.reachLimit()) {\n-                return;\n-            }\n-\n-            Iterator<Edge> edges = edgesOfVertex(source, step);\n-            while (edges.hasNext()) {\n-                HugeEdge edge = (HugeEdge) edges.next();\n-                Id target = edge.id().otherVertexId();\n-\n-                this.processOne(source, target, forward);\n-            }\n-        }\n-\n-        private void processOne(Id source, Id target, boolean forward) {\n-            if (forward) {\n-                processOneForForward(source, target);\n-            } else {\n-                processOneForBackward(source, target);\n-            }\n-        }\n-\n-        private void processOneForForward(Id sourceV, Id targetV) {\n+        @Override\n+        protected void processOneForForward(Id sourceV, Id targetV) {\n             for (Node source : this.sources.get(sourceV)) {\n                 // If have loop, skip target\n                 if (!this.withRing && source.contains(targetV)) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -118,138 +107,60 @@ public class TemplatePathsTraverser extends TpTraverser {\n         protected boolean sourceFinishOneStep = false;\n         protected boolean targetFinishOneStep = false;\n \n-        protected Map<Id, List<Node>> sources = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> sourcesAll = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> targets = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> targetsAll = this.newMultiValueMap();\n-\n-        protected Map<Id, List<Node>> newVertices;\n-\n-        private Set<Path> paths;\n-\n-        public Traverser(Collection<Id> sources, Collection<Id> targets,\n+        public Traverser(HugeTraverser traverser, TraverseStrategy strategy,\n+                         Collection<Id> sources, Collection<Id> targets,\n                          List<RepeatEdgeStep> steps, boolean withRing,\n                          long capacity, long limit) {\n+            super(traverser, strategy, sources, targets, capacity, limit);\n+\n             this.steps = steps;\n-            this.capacity = capacity;\n-            this.limit = limit;\n             this.withRing = withRing;\n-\n-            this.stepCount = 0;\n             for (RepeatEdgeStep step : steps) {\n                 this.totalSteps += step.maxTimes;\n             }\n+\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n \n-            for (Id id : sources) {\n-                this.addNode(this.sources, id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.addNode(this.targets, id, new Node(id));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-\n-            this.paths = this.newPathSet();\n-        }\n-\n-        public void forward() {\n-            RepeatEdgeStep currentStep = this.step(true);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(true);\n-\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.sources, currentStep, this::forward);\n-\n-            this.afterTraverse(currentStep, true);\n-        }\n-\n-        public void backward() {\n-            RepeatEdgeStep currentStep = this.step(false);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(false);\n-\n-            currentStep.swithDirection();\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.targets, currentStep, this::backward);\n-            currentStep.swithDirection();\n-\n-            this.afterTraverse(currentStep, false);\n+            this.sourceFinishOneStep = false;\n+            this.targetFinishOneStep = false;\n         }\n \n-        public RepeatEdgeStep step(boolean forward) {\n+        public RepeatEdgeStep nextStep(boolean forward) {\n             return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n+        @Override\n         public void beforeTraverse(boolean forward) {\n             this.clearNewVertices();\n             this.reInitAllIfNeeded(forward);\n         }\n \n-        public abstract void traverseOneLayer(\n-                             Map<Id, List<Node>> vertices,\n-                             RepeatEdgeStep step,\n-                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+        @Override\n+        public void afterTraverse(EdgeStep step, boolean forward) {\n \n-        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n             Map<Id, List<Node>> all = forward ? this.sourcesAll :\n                                                 this.targetsAll;\n             this.addNewVerticesToAll(all);\n-            this.reInitCurrentIfNeeded(step, forward);\n+            this.reInitCurrentStepIfNeeded(step, forward);\n             this.stepCount++;\n         }\n \n-        private void forward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, true);\n-        }\n-\n-        private void backward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, false);\n-        }\n-\n-        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n-            if (this.reachLimit()) {\n-                return;\n-            }\n-\n-            Iterator<Edge> edges = edgesOfVertex(v, step);\n-            while (edges.hasNext()) {\n-                HugeEdge edge = (HugeEdge) edges.next();\n-                Id target = edge.id().otherVertexId();\n-\n-                this.processOne(v, target, forward);\n-            }\n-        }\n-\n-        private void processOne(Id source, Id target, boolean forward) {\n-            if (forward) {\n-                processOneForForward(source, target);\n-            } else {\n-                processOneForBackward(source, target);\n-            }\n-        }\n-\n-        private void processOneForForward(Id source, Id target) {\n-            for (Node n : this.sources.get(source)) {\n+        @Override\n+        protected void processOneForForward(Id sourceV, Id targetV) {\n+            for (Node source : this.sources.get(sourceV)) {\n                 // If have loop, skip target\n-                if (!this.withRing && n.contains(target)) {\n+                if (!this.withRing && source.contains(targetV)) {\n                     continue;\n                 }\n \n                 // If cross point exists, path found, concat them\n                 if (this.lastSuperStep() &&\n-                    this.targetsAll.containsKey(target)) {\n-                    for (Node node : this.targetsAll.get(target)) {\n-                        List<Id> path = joinPath(n, node, this.withRing);\n+                    this.targetsAll.containsKey(targetV)) {\n+                    for (Node target : this.targetsAll.get(targetV)) {\n+                        List<Id> path = joinPath(source, target, this.withRing);\n                         if (!path.isEmpty()) {\n-                            this.paths.add(new Path(target, path));\n+                            this.paths.add(new Path(targetV, path));\n                             if (this.reachLimit()) {\n                                 return;\n                             }\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5NjMyNw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496696327", "body": "reInitCurrentStepIfNeeded", "bodyText": "reInitCurrentStepIfNeeded", "bodyHTML": "<p dir=\"auto\">reInitCurrentStepIfNeeded</p>", "author": "javeme", "createdAt": "2020-09-29T13:00:22Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targets.containsKey(target)) {\n-                            for (Node node : this.targets.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.sourcesAll.containsKey(target)) {\n+                    for (Node node : this.sourcesAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(target, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n+            }\n+        }\n+\n+        private void reInitAllIfNeeded(boolean forward) {\n+            if (forward) {\n+                // Re-init source all if last forward finished one super step\n+                // and not last super step\n+                if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n+                    this.sourcesAll = this.newMultiValueMap();\n+                    this.sourceFinishOneStep = false;\n+                }\n+            } else {\n+                // Re-init target all if last forward finished one super step\n+                // and not last super step\n+                if (this.targetFinishOneStep && !this.lastSuperStep()) {\n+                    this.targetsAll = this.newMultiValueMap();\n+                    this.targetFinishOneStep = false;\n+                }\n             }\n+        }\n \n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n+        private void reInitCurrentIfNeeded(RepeatEdgeStep step,", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -286,21 +287,25 @@ public class TemplatePathsTraverser extends TpTraverser {\n                 }\n \n                 // Add node to next start-nodes\n-                this.addNodeToNewVertices(target, new Node(target, n));\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n         }\n \n         private void reInitAllIfNeeded(boolean forward) {\n             if (forward) {\n-                // Re-init source all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init source all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n                     this.sourcesAll = this.newMultiValueMap();\n                     this.sourceFinishOneStep = false;\n                 }\n             } else {\n-                // Re-init target all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init target all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.targetFinishOneStep && !this.lastSuperStep()) {\n                     this.targetsAll = this.newMultiValueMap();\n                     this.targetFinishOneStep = false;\n", "next_change": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex 1ec17203..e4063aab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -313,12 +222,14 @@ public class TemplatePathsTraverser extends TpTraverser {\n             }\n         }\n \n-        private void reInitCurrentStepIfNeeded(RepeatEdgeStep step,\n-                                               boolean forward) {\n-            step.decreaseTimes();\n+        @Override\n+        protected void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                 boolean forward) {\n+            RepeatEdgeStep currentStep = (RepeatEdgeStep) step;\n+            currentStep.decreaseTimes();\n             if (forward) {\n                 // Re-init sources\n-                if (step.remainTimes() > 0) {\n+                if (currentStep.remainTimes() > 0) {\n                     this.sources = this.newVertices;\n                 } else {\n                     this.sources = this.sourcesAll;\n", "next_change": null}]}}, {"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -308,8 +313,8 @@ public class TemplatePathsTraverser extends TpTraverser {\n             }\n         }\n \n-        private void reInitCurrentIfNeeded(RepeatEdgeStep step,\n-                                           boolean forward) {\n+        private void reInitCurrentStepIfNeeded(RepeatEdgeStep step,\n+                                               boolean forward) {\n             step.decreaseTimes();\n             if (forward) {\n                 // Re-init sources\n", "next_change": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex 1ec17203..e4063aab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -313,12 +222,14 @@ public class TemplatePathsTraverser extends TpTraverser {\n             }\n         }\n \n-        private void reInitCurrentStepIfNeeded(RepeatEdgeStep step,\n-                                               boolean forward) {\n-            step.decreaseTimes();\n+        @Override\n+        protected void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                 boolean forward) {\n+            RepeatEdgeStep currentStep = (RepeatEdgeStep) step;\n+            currentStep.decreaseTimes();\n             if (forward) {\n                 // Re-init sources\n-                if (step.remainTimes() > 0) {\n+                if (currentStep.remainTimes() > 0) {\n                     this.sources = this.newVertices;\n                 } else {\n                     this.sources = this.sourcesAll;\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -286,21 +198,25 @@ public class TemplatePathsTraverser extends TpTraverser {\n                 }\n \n                 // Add node to next start-nodes\n-                this.addNodeToNewVertices(target, new Node(target, n));\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n         }\n \n         private void reInitAllIfNeeded(boolean forward) {\n             if (forward) {\n-                // Re-init source all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init source all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n                     this.sourcesAll = this.newMultiValueMap();\n                     this.sourceFinishOneStep = false;\n                 }\n             } else {\n-                // Re-init target all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init target all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.targetFinishOneStep && !this.lastSuperStep()) {\n                     this.targetsAll = this.newMultiValueMap();\n                     this.targetFinishOneStep = false;\n", "next_change": null}, {"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -308,12 +224,14 @@ public class TemplatePathsTraverser extends TpTraverser {\n             }\n         }\n \n-        private void reInitCurrentIfNeeded(RepeatEdgeStep step,\n-                                           boolean forward) {\n-            step.decreaseTimes();\n+        @Override\n+        protected void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                 boolean forward) {\n+            RepeatEdgeStep currentStep = (RepeatEdgeStep) step;\n+            currentStep.decreaseTimes();\n             if (forward) {\n                 // Re-init sources\n-                if (step.remainTimes() > 0) {\n+                if (currentStep.remainTimes() > 0) {\n                     this.sources = this.newVertices;\n                 } else {\n                     this.sources = this.sourcesAll;\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5NjgzMQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496696831", "body": "not finished last super step? or current step is not the last super step?\r\nand use /*", "bodyText": "not finished last super step? or current step is not the last super step?\nand use /*", "bodyHTML": "<p dir=\"auto\">not finished last super step? or current step is not the last super step?<br>\nand use /*</p>", "author": "javeme", "createdAt": "2020-09-29T13:01:08Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targets.containsKey(target)) {\n-                            for (Node node : this.targets.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.sourcesAll.containsKey(target)) {\n+                    for (Node node : this.sourcesAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(target, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n+            }\n+        }\n+\n+        private void reInitAllIfNeeded(boolean forward) {\n+            if (forward) {\n+                // Re-init source all if last forward finished one super step\n+                // and not last super step", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -286,21 +287,25 @@ public class TemplatePathsTraverser extends TpTraverser {\n                 }\n \n                 // Add node to next start-nodes\n-                this.addNodeToNewVertices(target, new Node(target, n));\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n         }\n \n         private void reInitAllIfNeeded(boolean forward) {\n             if (forward) {\n-                // Re-init source all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init source all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n                     this.sourcesAll = this.newMultiValueMap();\n                     this.sourceFinishOneStep = false;\n                 }\n             } else {\n-                // Re-init target all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init target all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.targetFinishOneStep && !this.lastSuperStep()) {\n                     this.targetsAll = this.newMultiValueMap();\n                     this.targetFinishOneStep = false;\n", "next_change": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex 1ec17203..e4063aab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -313,12 +222,14 @@ public class TemplatePathsTraverser extends TpTraverser {\n             }\n         }\n \n-        private void reInitCurrentStepIfNeeded(RepeatEdgeStep step,\n-                                               boolean forward) {\n-            step.decreaseTimes();\n+        @Override\n+        protected void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                 boolean forward) {\n+            RepeatEdgeStep currentStep = (RepeatEdgeStep) step;\n+            currentStep.decreaseTimes();\n             if (forward) {\n                 // Re-init sources\n-                if (step.remainTimes() > 0) {\n+                if (currentStep.remainTimes() > 0) {\n                     this.sources = this.newVertices;\n                 } else {\n                     this.sources = this.sourcesAll;\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -286,21 +198,25 @@ public class TemplatePathsTraverser extends TpTraverser {\n                 }\n \n                 // Add node to next start-nodes\n-                this.addNodeToNewVertices(target, new Node(target, n));\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n         }\n \n         private void reInitAllIfNeeded(boolean forward) {\n             if (forward) {\n-                // Re-init source all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init source all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n                     this.sourcesAll = this.newMultiValueMap();\n                     this.sourceFinishOneStep = false;\n                 }\n             } else {\n-                // Re-init target all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init target all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.targetFinishOneStep && !this.lastSuperStep()) {\n                     this.targetsAll = this.newMultiValueMap();\n                     this.targetFinishOneStep = false;\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5Njk0Mg==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496696942", "body": "ditto", "bodyText": "ditto", "bodyHTML": "<p dir=\"auto\">ditto</p>", "author": "javeme", "createdAt": "2020-09-29T13:01:17Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targets.containsKey(target)) {\n-                            for (Node node : this.targets.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.sourcesAll.containsKey(target)) {\n+                    for (Node node : this.sourcesAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(target, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n+            }\n+        }\n+\n+        private void reInitAllIfNeeded(boolean forward) {\n+            if (forward) {\n+                // Re-init source all if last forward finished one super step\n+                // and not last super step\n+                if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n+                    this.sourcesAll = this.newMultiValueMap();\n+                    this.sourceFinishOneStep = false;\n+                }\n+            } else {\n+                // Re-init target all if last forward finished one super step\n+                // and not last super step", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -286,21 +287,25 @@ public class TemplatePathsTraverser extends TpTraverser {\n                 }\n \n                 // Add node to next start-nodes\n-                this.addNodeToNewVertices(target, new Node(target, n));\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n         }\n \n         private void reInitAllIfNeeded(boolean forward) {\n             if (forward) {\n-                // Re-init source all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init source all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n                     this.sourcesAll = this.newMultiValueMap();\n                     this.sourceFinishOneStep = false;\n                 }\n             } else {\n-                // Re-init target all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init target all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.targetFinishOneStep && !this.lastSuperStep()) {\n                     this.targetsAll = this.newMultiValueMap();\n                     this.targetFinishOneStep = false;\n", "next_change": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex 1ec17203..e4063aab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -313,12 +222,14 @@ public class TemplatePathsTraverser extends TpTraverser {\n             }\n         }\n \n-        private void reInitCurrentStepIfNeeded(RepeatEdgeStep step,\n-                                               boolean forward) {\n-            step.decreaseTimes();\n+        @Override\n+        protected void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                 boolean forward) {\n+            RepeatEdgeStep currentStep = (RepeatEdgeStep) step;\n+            currentStep.decreaseTimes();\n             if (forward) {\n                 // Re-init sources\n-                if (step.remainTimes() > 0) {\n+                if (currentStep.remainTimes() > 0) {\n                     this.sources = this.newVertices;\n                 } else {\n                     this.sources = this.sourcesAll;\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -286,21 +198,25 @@ public class TemplatePathsTraverser extends TpTraverser {\n                 }\n \n                 // Add node to next start-nodes\n-                this.addNodeToNewVertices(target, new Node(target, n));\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n         }\n \n         private void reInitAllIfNeeded(boolean forward) {\n             if (forward) {\n-                // Re-init source all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init source all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n                     this.sourcesAll = this.newMultiValueMap();\n                     this.sourceFinishOneStep = false;\n                 }\n             } else {\n-                // Re-init target all if last forward finished one super step\n-                // and not last super step\n+                /*\n+                 * Re-init target all if last forward finished one super step\n+                 * and current step is not last super step\n+                 */\n                 if (this.targetFinishOneStep && !this.lastSuperStep()) {\n                     this.targetsAll = this.newMultiValueMap();\n                     this.targetFinishOneStep = false;\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5Nzk0OA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496697948", "body": "move to previous line", "bodyText": "move to previous line", "bodyHTML": "<p dir=\"auto\">move to previous line</p>", "author": "javeme", "createdAt": "2020-09-29T13:02:50Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEzNTM5Mg==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503135392", "bodyText": "move to previous line will exceed 80 char", "author": "zhoney", "createdAt": "2020-10-12T08:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5Nzk0OA=="}], "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -417,7 +422,8 @@ public class TemplatePathsTraverser extends TpTraverser {\n \n         public ConcurrentTraverser(Collection<Id> sources,\n                                    Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   List<RepeatEdgeStep> steps,\n+                                   boolean withRing,\n                                    long capacity, long limit) {\n             super(sources, targets, steps, withRing, capacity, limit);\n         }\n", "next_change": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex 1ec17203..e4063aab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -367,141 +278,6 @@ public class TemplatePathsTraverser extends TpTraverser {\n             return this.targetIndex == this.sourceIndex ||\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n-\n-        public void clearNewVertices() {\n-            this.newVertices = this.newMultiValueMap();\n-        }\n-\n-        public void addNodeToNewVertices(Id id, Node node) {\n-            this.addNode(this.newVertices, id, node);\n-        }\n-\n-        public abstract Map<Id, List<Node>> newMultiValueMap();\n-\n-        public abstract Set<Path> newPathSet();\n-\n-        public abstract void addNode(Map<Id, List<Node>> vertices,\n-                                     Id id, Node node);\n-\n-        public abstract void addNewVerticesToAll(Map<Id, List<Node>> targets);\n-\n-        public Set<Path> paths() {\n-            return this.paths;\n-        }\n-\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n-        }\n-\n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        private int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n-            }\n-            return size;\n-        }\n-    }\n-\n-    private class ConcurrentTraverser extends Traverser {\n-\n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps,\n-                                   boolean withRing,\n-                                   long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return new ConcurrentMultiValuedMap<>();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> consumer) {\n-            traverseIds(this.sources.keySet().iterator(), id -> {\n-                consumer.accept(id, step);\n-            });\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return ConcurrentHashMap.newKeySet();\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((ConcurrentMultiValuedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            ConcurrentMultiValuedMap<Id, Node> vertices =\n-                    (ConcurrentMultiValuedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n-    }\n-\n-    private class SingleTraverser extends Traverser {\n-\n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return newMultivalueMap();\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return new PathSet();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> consumer) {\n-            for (Id id : vertices.keySet()) {\n-                consumer.accept(id, step);\n-            }\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((MultivaluedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            MultivaluedMap<Id, Node> vertices =\n-                                     (MultivaluedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n     }\n \n     public static class RepeatEdgeStep extends EdgeStep {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -362,140 +280,6 @@ public class TemplatePathsTraverser extends TpTraverser {\n             return this.targetIndex == this.sourceIndex ||\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n-\n-        public void clearNewVertices() {\n-            this.newVertices = this.newMultiValueMap();\n-        }\n-\n-        public void addNodeToNewVertices(Id id, Node node) {\n-            this.addNode(this.newVertices, id, node);\n-        }\n-\n-        public abstract Map<Id, List<Node>> newMultiValueMap();\n-\n-        public abstract Set<Path> newPathSet();\n-\n-        public abstract void addNode(Map<Id, List<Node>> vertices,\n-                                     Id id, Node node);\n-\n-        public abstract void addNewVerticesToAll(Map<Id, List<Node>> targets);\n-\n-        public Set<Path> paths() {\n-            return this.paths;\n-        }\n-\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n-        }\n-\n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        private int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n-            }\n-            return size;\n-        }\n-    }\n-\n-    private class ConcurrentTraverser extends Traverser {\n-\n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return new ConcurrentMultiValuedMap<>();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n-            traverseIds(this.sources.keySet().iterator(), (id) -> {\n-                biConsumer.accept(id, step);\n-            });\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return ConcurrentHashMap.newKeySet();\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((ConcurrentMultiValuedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            ConcurrentMultiValuedMap<Id, Node> vertices =\n-                    (ConcurrentMultiValuedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n-    }\n-\n-    private class SingleTraverser extends Traverser {\n-\n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return newMultivalueMap();\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return new PathSet();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n-            for (Id id : vertices.keySet()) {\n-                biConsumer.accept(id, step);\n-            }\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((MultivaluedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            MultivaluedMap<Id, Node> vertices =\n-                                     (MultivaluedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n     }\n \n     public static class RepeatEdgeStep extends EdgeStep {\n", "next_change": {"commit": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex d22c01d3..3e4bdc5b 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -281,25 +279,4 @@ public class TemplatePathsTraverser extends HugeTraverser {\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n     }\n-\n-    public static class RepeatEdgeStep extends EdgeStep {\n-\n-        private int maxTimes = 1;\n-\n-        public RepeatEdgeStep(HugeGraph g, Directions direction,\n-                              List<String> labels,\n-                              Map<String, Object> properties, long degree,\n-                              long skipDegree, int maxTimes) {\n-            super(g, direction, labels, properties, degree, skipDegree);\n-            this.maxTimes = maxTimes;\n-        }\n-\n-        private int remainTimes() {\n-            return this.maxTimes;\n-        }\n-\n-        private void decreaseTimes() {\n-            this.maxTimes--;\n-        }\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5ODk3Ng==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496698976", "body": "use this \"this.traverseIds()\"\r\nand don't need \"()\" in \"(id)\"", "bodyText": "use this \"this.traverseIds()\"\nand don't need \"()\" in \"(id)\"", "bodyHTML": "<p dir=\"auto\">use this \"this.traverseIds()\"<br>\nand don't need \"()\" in \"(id)\"</p>", "author": "javeme", "createdAt": "2020-09-29T13:04:23Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = newMultivalueMap();\n-                this.sourceFinishOneStep = false;\n-            }\n-\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-\n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n-            } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        @Override\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return new ConcurrentMultiValuedMap<>();\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-\n-            // Find next step to backward\n-            for (int i = this.steps.size() - 1; i >= 0; i--) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.targetIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init target all if last forward finished one super step and\n-            // not last super step\n-            if (this.targetFinishOneStep && !this.lastSuperStep()) {\n-                this.targetsAll = newMultivalueMap();\n-                this.targetFinishOneStep = false;\n-            }\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n+            traverseIds(this.sources.keySet().iterator(), (id) -> {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -430,9 +436,9 @@ public class TemplatePathsTraverser extends TpTraverser {\n         @Override\n         public void traverseOneLayer(\n                     Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n-            traverseIds(this.sources.keySet().iterator(), (id) -> {\n-                biConsumer.accept(id, step);\n+                    BiConsumer<Id, RepeatEdgeStep> consumer) {\n+            traverseIds(this.sources.keySet().iterator(), id -> {\n+                consumer.accept(id, step);\n             });\n         }\n \n", "next_change": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex 1ec17203..e4063aab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -367,141 +278,6 @@ public class TemplatePathsTraverser extends TpTraverser {\n             return this.targetIndex == this.sourceIndex ||\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n-\n-        public void clearNewVertices() {\n-            this.newVertices = this.newMultiValueMap();\n-        }\n-\n-        public void addNodeToNewVertices(Id id, Node node) {\n-            this.addNode(this.newVertices, id, node);\n-        }\n-\n-        public abstract Map<Id, List<Node>> newMultiValueMap();\n-\n-        public abstract Set<Path> newPathSet();\n-\n-        public abstract void addNode(Map<Id, List<Node>> vertices,\n-                                     Id id, Node node);\n-\n-        public abstract void addNewVerticesToAll(Map<Id, List<Node>> targets);\n-\n-        public Set<Path> paths() {\n-            return this.paths;\n-        }\n-\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n-        }\n-\n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        private int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n-            }\n-            return size;\n-        }\n-    }\n-\n-    private class ConcurrentTraverser extends Traverser {\n-\n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps,\n-                                   boolean withRing,\n-                                   long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return new ConcurrentMultiValuedMap<>();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> consumer) {\n-            traverseIds(this.sources.keySet().iterator(), id -> {\n-                consumer.accept(id, step);\n-            });\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return ConcurrentHashMap.newKeySet();\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((ConcurrentMultiValuedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            ConcurrentMultiValuedMap<Id, Node> vertices =\n-                    (ConcurrentMultiValuedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n-    }\n-\n-    private class SingleTraverser extends Traverser {\n-\n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return newMultivalueMap();\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return new PathSet();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> consumer) {\n-            for (Id id : vertices.keySet()) {\n-                consumer.accept(id, step);\n-            }\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((MultivaluedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            MultivaluedMap<Id, Node> vertices =\n-                                     (MultivaluedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n     }\n \n     public static class RepeatEdgeStep extends EdgeStep {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -362,140 +280,6 @@ public class TemplatePathsTraverser extends TpTraverser {\n             return this.targetIndex == this.sourceIndex ||\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n-\n-        public void clearNewVertices() {\n-            this.newVertices = this.newMultiValueMap();\n-        }\n-\n-        public void addNodeToNewVertices(Id id, Node node) {\n-            this.addNode(this.newVertices, id, node);\n-        }\n-\n-        public abstract Map<Id, List<Node>> newMultiValueMap();\n-\n-        public abstract Set<Path> newPathSet();\n-\n-        public abstract void addNode(Map<Id, List<Node>> vertices,\n-                                     Id id, Node node);\n-\n-        public abstract void addNewVerticesToAll(Map<Id, List<Node>> targets);\n-\n-        public Set<Path> paths() {\n-            return this.paths;\n-        }\n-\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n-        }\n-\n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        private int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n-            }\n-            return size;\n-        }\n-    }\n-\n-    private class ConcurrentTraverser extends Traverser {\n-\n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return new ConcurrentMultiValuedMap<>();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n-            traverseIds(this.sources.keySet().iterator(), (id) -> {\n-                biConsumer.accept(id, step);\n-            });\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return ConcurrentHashMap.newKeySet();\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((ConcurrentMultiValuedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            ConcurrentMultiValuedMap<Id, Node> vertices =\n-                    (ConcurrentMultiValuedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n-    }\n-\n-    private class SingleTraverser extends Traverser {\n-\n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return newMultivalueMap();\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return new PathSet();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n-            for (Id id : vertices.keySet()) {\n-                biConsumer.accept(id, step);\n-            }\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((MultivaluedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            MultivaluedMap<Id, Node> vertices =\n-                                     (MultivaluedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n     }\n \n     public static class RepeatEdgeStep extends EdgeStep {\n", "next_change": {"commit": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex d22c01d3..3e4bdc5b 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -281,25 +279,4 @@ public class TemplatePathsTraverser extends HugeTraverser {\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n     }\n-\n-    public static class RepeatEdgeStep extends EdgeStep {\n-\n-        private int maxTimes = 1;\n-\n-        public RepeatEdgeStep(HugeGraph g, Directions direction,\n-                              List<String> labels,\n-                              Map<String, Object> properties, long degree,\n-                              long skipDegree, int maxTimes) {\n-            super(g, direction, labels, properties, degree, skipDegree);\n-            this.maxTimes = maxTimes;\n-        }\n-\n-        private int remainTimes() {\n-            return this.maxTimes;\n-        }\n-\n-        private void decreaseTimes() {\n-            this.maxTimes--;\n-        }\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5OTUxMw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496699513", "body": "just named consumer", "bodyText": "just named consumer", "bodyHTML": "<p dir=\"auto\">just named consumer</p>", "author": "javeme", "createdAt": "2020-09-29T13:05:12Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = newMultivalueMap();\n-                this.sourceFinishOneStep = false;\n-            }\n-\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-\n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n-            } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        @Override\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return new ConcurrentMultiValuedMap<>();\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-\n-            // Find next step to backward\n-            for (int i = this.steps.size() - 1; i >= 0; i--) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.targetIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init target all if last forward finished one super step and\n-            // not last super step\n-            if (this.targetFinishOneStep && !this.lastSuperStep()) {\n-                this.targetsAll = newMultivalueMap();\n-                this.targetFinishOneStep = false;\n-            }\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -430,9 +436,9 @@ public class TemplatePathsTraverser extends TpTraverser {\n         @Override\n         public void traverseOneLayer(\n                     Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n-            traverseIds(this.sources.keySet().iterator(), (id) -> {\n-                biConsumer.accept(id, step);\n+                    BiConsumer<Id, RepeatEdgeStep> consumer) {\n+            traverseIds(this.sources.keySet().iterator(), id -> {\n+                consumer.accept(id, step);\n             });\n         }\n \n", "next_change": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex 1ec17203..e4063aab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -367,141 +278,6 @@ public class TemplatePathsTraverser extends TpTraverser {\n             return this.targetIndex == this.sourceIndex ||\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n-\n-        public void clearNewVertices() {\n-            this.newVertices = this.newMultiValueMap();\n-        }\n-\n-        public void addNodeToNewVertices(Id id, Node node) {\n-            this.addNode(this.newVertices, id, node);\n-        }\n-\n-        public abstract Map<Id, List<Node>> newMultiValueMap();\n-\n-        public abstract Set<Path> newPathSet();\n-\n-        public abstract void addNode(Map<Id, List<Node>> vertices,\n-                                     Id id, Node node);\n-\n-        public abstract void addNewVerticesToAll(Map<Id, List<Node>> targets);\n-\n-        public Set<Path> paths() {\n-            return this.paths;\n-        }\n-\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n-        }\n-\n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        private int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n-            }\n-            return size;\n-        }\n-    }\n-\n-    private class ConcurrentTraverser extends Traverser {\n-\n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps,\n-                                   boolean withRing,\n-                                   long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return new ConcurrentMultiValuedMap<>();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> consumer) {\n-            traverseIds(this.sources.keySet().iterator(), id -> {\n-                consumer.accept(id, step);\n-            });\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return ConcurrentHashMap.newKeySet();\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((ConcurrentMultiValuedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            ConcurrentMultiValuedMap<Id, Node> vertices =\n-                    (ConcurrentMultiValuedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n-    }\n-\n-    private class SingleTraverser extends Traverser {\n-\n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return newMultivalueMap();\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return new PathSet();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> consumer) {\n-            for (Id id : vertices.keySet()) {\n-                consumer.accept(id, step);\n-            }\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((MultivaluedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            MultivaluedMap<Id, Node> vertices =\n-                                     (MultivaluedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n     }\n \n     public static class RepeatEdgeStep extends EdgeStep {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -362,140 +280,6 @@ public class TemplatePathsTraverser extends TpTraverser {\n             return this.targetIndex == this.sourceIndex ||\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n-\n-        public void clearNewVertices() {\n-            this.newVertices = this.newMultiValueMap();\n-        }\n-\n-        public void addNodeToNewVertices(Id id, Node node) {\n-            this.addNode(this.newVertices, id, node);\n-        }\n-\n-        public abstract Map<Id, List<Node>> newMultiValueMap();\n-\n-        public abstract Set<Path> newPathSet();\n-\n-        public abstract void addNode(Map<Id, List<Node>> vertices,\n-                                     Id id, Node node);\n-\n-        public abstract void addNewVerticesToAll(Map<Id, List<Node>> targets);\n-\n-        public Set<Path> paths() {\n-            return this.paths;\n-        }\n-\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n-        }\n-\n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        private int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n-            }\n-            return size;\n-        }\n-    }\n-\n-    private class ConcurrentTraverser extends Traverser {\n-\n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return new ConcurrentMultiValuedMap<>();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n-            traverseIds(this.sources.keySet().iterator(), (id) -> {\n-                biConsumer.accept(id, step);\n-            });\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return ConcurrentHashMap.newKeySet();\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((ConcurrentMultiValuedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            ConcurrentMultiValuedMap<Id, Node> vertices =\n-                    (ConcurrentMultiValuedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n-    }\n-\n-    private class SingleTraverser extends Traverser {\n-\n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return newMultivalueMap();\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return new PathSet();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n-            for (Id id : vertices.keySet()) {\n-                biConsumer.accept(id, step);\n-            }\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((MultivaluedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            MultivaluedMap<Id, Node> vertices =\n-                                     (MultivaluedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n     }\n \n     public static class RepeatEdgeStep extends EdgeStep {\n", "next_change": {"commit": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex d22c01d3..3e4bdc5b 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -281,25 +279,4 @@ public class TemplatePathsTraverser extends HugeTraverser {\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n     }\n-\n-    public static class RepeatEdgeStep extends EdgeStep {\n-\n-        private int maxTimes = 1;\n-\n-        public RepeatEdgeStep(HugeGraph g, Directions direction,\n-                              List<String> labels,\n-                              Map<String, Object> properties, long degree,\n-                              long skipDegree, int maxTimes) {\n-            super(g, direction, labels, properties, degree, skipDegree);\n-            this.maxTimes = maxTimes;\n-        }\n-\n-        private int remainTimes() {\n-            return this.maxTimes;\n-        }\n-\n-        private void decreaseTimes() {\n-            this.maxTimes--;\n-        }\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwMDQwMQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496700401", "body": "ditto", "bodyText": "ditto", "bodyHTML": "<p dir=\"auto\">ditto</p>", "author": "javeme", "createdAt": "2020-09-29T13:06:29Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = newMultivalueMap();\n-                this.sourceFinishOneStep = false;\n-            }\n-\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-\n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n-            } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        @Override\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return new ConcurrentMultiValuedMap<>();\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-\n-            // Find next step to backward\n-            for (int i = this.steps.size() - 1; i >= 0; i--) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.targetIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init target all if last forward finished one super step and\n-            // not last super step\n-            if (this.targetFinishOneStep && !this.lastSuperStep()) {\n-                this.targetsAll = newMultivalueMap();\n-                this.targetFinishOneStep = false;\n-            }\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n+            traverseIds(this.sources.keySet().iterator(), (id) -> {\n+                biConsumer.accept(id, step);\n+            });\n+        }\n \n-            currentStep.swithDirection();\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.targets.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n+        @Override\n+        public Set<Path> newPathSet() {\n+            return ConcurrentHashMap.newKeySet();\n+        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.sourcesAll.containsKey(target)) {\n-                            for (Node node : this.sourcesAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    Path newPath = new Path(target, path);\n-                                    newPath.reverse();\n-                                    this.paths.add(newPath);\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n+        @Override\n+        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n+            ((ConcurrentMultiValuedMap<Id, Node>) vertices).add(id, node);\n+        }\n \n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n+        @Override\n+        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n+            ConcurrentMultiValuedMap<Id, Node> vertices =\n+                    (ConcurrentMultiValuedMap<Id, Node>) targets;\n+            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n+                vertices.addAll(entry.getKey(), entry.getValue());\n             }\n+        }\n+    }\n \n-            currentStep.swithDirection();\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.targetsAll.addAll(entry.getKey(), entry.getValue());\n-            }\n+    private class SingleTraverser extends Traverser {\n \n-            currentStep.decreaseTimes();\n-            // Re-init targets\n-            if (currentStep.remainTimes() > 0) {\n-                this.targets = newVertices;\n-            } else {\n-                this.targets = this.targetsAll;\n-                this.targetFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n+                               List<RepeatEdgeStep> steps, boolean withRing,\n+                               long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n         @Override\n-        public Set<Path> paths() {\n-            return this.paths;\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return newMultivalueMap();\n         }\n \n         @Override\n-        public int pathCount() {\n-            return this.paths.size();\n+        public Set<Path> newPathSet() {\n+            return new PathSet();\n         }\n \n-        protected int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -477,9 +483,9 @@ public class TemplatePathsTraverser extends TpTraverser {\n         @Override\n         public void traverseOneLayer(\n                     Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n+                    BiConsumer<Id, RepeatEdgeStep> consumer) {\n             for (Id id : vertices.keySet()) {\n-                biConsumer.accept(id, step);\n+                consumer.accept(id, step);\n             }\n         }\n \n", "next_change": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex 1ec17203..e4063aab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -367,141 +278,6 @@ public class TemplatePathsTraverser extends TpTraverser {\n             return this.targetIndex == this.sourceIndex ||\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n-\n-        public void clearNewVertices() {\n-            this.newVertices = this.newMultiValueMap();\n-        }\n-\n-        public void addNodeToNewVertices(Id id, Node node) {\n-            this.addNode(this.newVertices, id, node);\n-        }\n-\n-        public abstract Map<Id, List<Node>> newMultiValueMap();\n-\n-        public abstract Set<Path> newPathSet();\n-\n-        public abstract void addNode(Map<Id, List<Node>> vertices,\n-                                     Id id, Node node);\n-\n-        public abstract void addNewVerticesToAll(Map<Id, List<Node>> targets);\n-\n-        public Set<Path> paths() {\n-            return this.paths;\n-        }\n-\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n-        }\n-\n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        private int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n-            }\n-            return size;\n-        }\n-    }\n-\n-    private class ConcurrentTraverser extends Traverser {\n-\n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps,\n-                                   boolean withRing,\n-                                   long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return new ConcurrentMultiValuedMap<>();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> consumer) {\n-            traverseIds(this.sources.keySet().iterator(), id -> {\n-                consumer.accept(id, step);\n-            });\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return ConcurrentHashMap.newKeySet();\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((ConcurrentMultiValuedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            ConcurrentMultiValuedMap<Id, Node> vertices =\n-                    (ConcurrentMultiValuedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n-    }\n-\n-    private class SingleTraverser extends Traverser {\n-\n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return newMultivalueMap();\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return new PathSet();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> consumer) {\n-            for (Id id : vertices.keySet()) {\n-                consumer.accept(id, step);\n-            }\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((MultivaluedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            MultivaluedMap<Id, Node> vertices =\n-                                     (MultivaluedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n     }\n \n     public static class RepeatEdgeStep extends EdgeStep {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -362,140 +280,6 @@ public class TemplatePathsTraverser extends TpTraverser {\n             return this.targetIndex == this.sourceIndex ||\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n-\n-        public void clearNewVertices() {\n-            this.newVertices = this.newMultiValueMap();\n-        }\n-\n-        public void addNodeToNewVertices(Id id, Node node) {\n-            this.addNode(this.newVertices, id, node);\n-        }\n-\n-        public abstract Map<Id, List<Node>> newMultiValueMap();\n-\n-        public abstract Set<Path> newPathSet();\n-\n-        public abstract void addNode(Map<Id, List<Node>> vertices,\n-                                     Id id, Node node);\n-\n-        public abstract void addNewVerticesToAll(Map<Id, List<Node>> targets);\n-\n-        public Set<Path> paths() {\n-            return this.paths;\n-        }\n-\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n-        }\n-\n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        private int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n-            }\n-            return size;\n-        }\n-    }\n-\n-    private class ConcurrentTraverser extends Traverser {\n-\n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return new ConcurrentMultiValuedMap<>();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n-            traverseIds(this.sources.keySet().iterator(), (id) -> {\n-                biConsumer.accept(id, step);\n-            });\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return ConcurrentHashMap.newKeySet();\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((ConcurrentMultiValuedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            ConcurrentMultiValuedMap<Id, Node> vertices =\n-                    (ConcurrentMultiValuedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n-    }\n-\n-    private class SingleTraverser extends Traverser {\n-\n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(sources, targets, steps, withRing, capacity, limit);\n-        }\n-\n-        @Override\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return newMultivalueMap();\n-        }\n-\n-        @Override\n-        public Set<Path> newPathSet() {\n-            return new PathSet();\n-        }\n-\n-        @Override\n-        public void traverseOneLayer(\n-                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n-                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n-            for (Id id : vertices.keySet()) {\n-                biConsumer.accept(id, step);\n-            }\n-        }\n-\n-        @Override\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            ((MultivaluedMap<Id, Node>) vertices).add(id, node);\n-        }\n-\n-        @Override\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            MultivaluedMap<Id, Node> vertices =\n-                                     (MultivaluedMap<Id, Node>) targets;\n-            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n     }\n \n     public static class RepeatEdgeStep extends EdgeStep {\n", "next_change": {"commit": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex d22c01d3..3e4bdc5b 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -281,25 +279,4 @@ public class TemplatePathsTraverser extends HugeTraverser {\n                    this.targetIndex == this.sourceIndex + 1;\n         }\n     }\n-\n-    public static class RepeatEdgeStep extends EdgeStep {\n-\n-        private int maxTimes = 1;\n-\n-        public RepeatEdgeStep(HugeGraph g, Directions direction,\n-                              List<String> labels,\n-                              Map<String, Object> properties, long degree,\n-                              long skipDegree, int maxTimes) {\n-            super(g, direction, labels, properties, degree, skipDegree);\n-            this.maxTimes = maxTimes;\n-        }\n-\n-        private int remainTimes() {\n-            return this.maxTimes;\n-        }\n-\n-        private void decreaseTimes() {\n-            this.maxTimes--;\n-        }\n-    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwMTU5OQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496701599", "body": "prefer nextStep", "bodyText": "prefer nextStep", "bodyHTML": "<p dir=\"auto\">prefer nextStep</p>", "author": "javeme", "createdAt": "2020-09-29T13:08:14Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -184,7 +184,7 @@ public class TemplatePathsTraverser extends TpTraverser {\n             this.afterTraverse(currentStep, false);\n         }\n \n-        public RepeatEdgeStep step(boolean forward) {\n+        public RepeatEdgeStep nextStep(boolean forward) {\n             return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n", "next_change": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex 1ec17203..e4063aab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -118,87 +106,37 @@ public class TemplatePathsTraverser extends TpTraverser {\n         protected boolean sourceFinishOneStep = false;\n         protected boolean targetFinishOneStep = false;\n \n-        protected Map<Id, List<Node>> sources = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> sourcesAll = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> targets = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> targetsAll = this.newMultiValueMap();\n-\n-        protected Map<Id, List<Node>> newVertices;\n-\n-        private Set<Path> paths;\n-\n         public Traverser(Collection<Id> sources, Collection<Id> targets,\n                          List<RepeatEdgeStep> steps, boolean withRing,\n-                         long capacity, long limit) {\n+                         long capacity, long limit, TraverseStrategy strategy) {\n+            super(sources, targets, capacity, limit, strategy);\n+\n             this.steps = steps;\n-            this.capacity = capacity;\n-            this.limit = limit;\n             this.withRing = withRing;\n-\n-            this.stepCount = 0;\n             for (RepeatEdgeStep step : steps) {\n                 this.totalSteps += step.maxTimes;\n             }\n+\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n \n-            for (Id id : sources) {\n-                this.addNode(this.sources, id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.addNode(this.targets, id, new Node(id));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-\n-            this.paths = this.newPathSet();\n-        }\n-\n-        public void forward() {\n-            RepeatEdgeStep currentStep = this.nextStep(true);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(true);\n-\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.sources, currentStep, this::forward);\n-\n-            this.afterTraverse(currentStep, true);\n-        }\n-\n-        public void backward() {\n-            RepeatEdgeStep currentStep = this.nextStep(false);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(false);\n-\n-            currentStep.swithDirection();\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.targets, currentStep, this::backward);\n-            currentStep.swithDirection();\n-\n-            this.afterTraverse(currentStep, false);\n+            this.sourceFinishOneStep = false;\n+            this.targetFinishOneStep = false;\n         }\n \n         public RepeatEdgeStep nextStep(boolean forward) {\n             return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n+        @Override\n         public void beforeTraverse(boolean forward) {\n             this.clearNewVertices();\n             this.reInitAllIfNeeded(forward);\n         }\n \n-        public abstract void traverseOneLayer(\n-                             Map<Id, List<Node>> vertices,\n-                             RepeatEdgeStep step,\n-                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+        @Override\n+        public void afterTraverse(EdgeStep step, boolean forward) {\n \n-        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n             Map<Id, List<Node>> all = forward ? this.sourcesAll :\n                                                 this.targetsAll;\n             this.addNewVerticesToAll(all);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -118,138 +107,60 @@ public class TemplatePathsTraverser extends TpTraverser {\n         protected boolean sourceFinishOneStep = false;\n         protected boolean targetFinishOneStep = false;\n \n-        protected Map<Id, List<Node>> sources = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> sourcesAll = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> targets = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> targetsAll = this.newMultiValueMap();\n-\n-        protected Map<Id, List<Node>> newVertices;\n-\n-        private Set<Path> paths;\n-\n-        public Traverser(Collection<Id> sources, Collection<Id> targets,\n+        public Traverser(HugeTraverser traverser, TraverseStrategy strategy,\n+                         Collection<Id> sources, Collection<Id> targets,\n                          List<RepeatEdgeStep> steps, boolean withRing,\n                          long capacity, long limit) {\n+            super(traverser, strategy, sources, targets, capacity, limit);\n+\n             this.steps = steps;\n-            this.capacity = capacity;\n-            this.limit = limit;\n             this.withRing = withRing;\n-\n-            this.stepCount = 0;\n             for (RepeatEdgeStep step : steps) {\n                 this.totalSteps += step.maxTimes;\n             }\n+\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n \n-            for (Id id : sources) {\n-                this.addNode(this.sources, id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.addNode(this.targets, id, new Node(id));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-\n-            this.paths = this.newPathSet();\n-        }\n-\n-        public void forward() {\n-            RepeatEdgeStep currentStep = this.step(true);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(true);\n-\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.sources, currentStep, this::forward);\n-\n-            this.afterTraverse(currentStep, true);\n-        }\n-\n-        public void backward() {\n-            RepeatEdgeStep currentStep = this.step(false);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(false);\n-\n-            currentStep.swithDirection();\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.targets, currentStep, this::backward);\n-            currentStep.swithDirection();\n-\n-            this.afterTraverse(currentStep, false);\n+            this.sourceFinishOneStep = false;\n+            this.targetFinishOneStep = false;\n         }\n \n-        public RepeatEdgeStep step(boolean forward) {\n+        public RepeatEdgeStep nextStep(boolean forward) {\n             return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n+        @Override\n         public void beforeTraverse(boolean forward) {\n             this.clearNewVertices();\n             this.reInitAllIfNeeded(forward);\n         }\n \n-        public abstract void traverseOneLayer(\n-                             Map<Id, List<Node>> vertices,\n-                             RepeatEdgeStep step,\n-                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+        @Override\n+        public void afterTraverse(EdgeStep step, boolean forward) {\n \n-        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n             Map<Id, List<Node>> all = forward ? this.sourcesAll :\n                                                 this.targetsAll;\n             this.addNewVerticesToAll(all);\n-            this.reInitCurrentIfNeeded(step, forward);\n+            this.reInitCurrentStepIfNeeded(step, forward);\n             this.stepCount++;\n         }\n \n-        private void forward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, true);\n-        }\n-\n-        private void backward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, false);\n-        }\n-\n-        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n-            if (this.reachLimit()) {\n-                return;\n-            }\n-\n-            Iterator<Edge> edges = edgesOfVertex(v, step);\n-            while (edges.hasNext()) {\n-                HugeEdge edge = (HugeEdge) edges.next();\n-                Id target = edge.id().otherVertexId();\n-\n-                this.processOne(v, target, forward);\n-            }\n-        }\n-\n-        private void processOne(Id source, Id target, boolean forward) {\n-            if (forward) {\n-                processOneForForward(source, target);\n-            } else {\n-                processOneForBackward(source, target);\n-            }\n-        }\n-\n-        private void processOneForForward(Id source, Id target) {\n-            for (Node n : this.sources.get(source)) {\n+        @Override\n+        protected void processOneForForward(Id sourceV, Id targetV) {\n+            for (Node source : this.sources.get(sourceV)) {\n                 // If have loop, skip target\n-                if (!this.withRing && n.contains(target)) {\n+                if (!this.withRing && source.contains(targetV)) {\n                     continue;\n                 }\n \n                 // If cross point exists, path found, concat them\n                 if (this.lastSuperStep() &&\n-                    this.targetsAll.containsKey(target)) {\n-                    for (Node node : this.targetsAll.get(target)) {\n-                        List<Id> path = joinPath(n, node, this.withRing);\n+                    this.targetsAll.containsKey(targetV)) {\n+                    for (Node target : this.targetsAll.get(targetV)) {\n+                        List<Id> path = joinPath(source, target, this.withRing);\n                         if (!path.isEmpty()) {\n-                            this.paths.add(new Path(target, path));\n+                            this.paths.add(new Path(targetV, path));\n                             if (this.reachLimit()) {\n                                 return;\n                             }\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwNDU4OQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496704589", "body": "rename source to sourceV, and rename n to source, same as target", "bodyText": "rename source to sourceV, and rename n to source, same as target", "bodyHTML": "<p dir=\"auto\">rename source to sourceV, and rename n to source, same as target</p>", "author": "javeme", "createdAt": "2020-09-29T13:12:38Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -236,20 +237,20 @@ public class TemplatePathsTraverser extends TpTraverser {\n             }\n         }\n \n-        private void processOneForForward(Id source, Id target) {\n-            for (Node n : this.sources.get(source)) {\n+        private void processOneForForward(Id sourceV, Id targetV) {\n+            for (Node source : this.sources.get(sourceV)) {\n                 // If have loop, skip target\n-                if (!this.withRing && n.contains(target)) {\n+                if (!this.withRing && source.contains(targetV)) {\n                     continue;\n                 }\n \n                 // If cross point exists, path found, concat them\n                 if (this.lastSuperStep() &&\n-                    this.targetsAll.containsKey(target)) {\n-                    for (Node node : this.targetsAll.get(target)) {\n-                        List<Id> path = joinPath(n, node, this.withRing);\n+                    this.targetsAll.containsKey(targetV)) {\n+                    for (Node target : this.targetsAll.get(targetV)) {\n+                        List<Id> path = joinPath(source, target, this.withRing);\n                         if (!path.isEmpty()) {\n-                            this.paths.add(new Path(target, path));\n+                            this.paths.add(new Path(targetV, path));\n                             if (this.reachLimit()) {\n                                 return;\n                             }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -118,138 +107,60 @@ public class TemplatePathsTraverser extends TpTraverser {\n         protected boolean sourceFinishOneStep = false;\n         protected boolean targetFinishOneStep = false;\n \n-        protected Map<Id, List<Node>> sources = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> sourcesAll = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> targets = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> targetsAll = this.newMultiValueMap();\n-\n-        protected Map<Id, List<Node>> newVertices;\n-\n-        private Set<Path> paths;\n-\n-        public Traverser(Collection<Id> sources, Collection<Id> targets,\n+        public Traverser(HugeTraverser traverser, TraverseStrategy strategy,\n+                         Collection<Id> sources, Collection<Id> targets,\n                          List<RepeatEdgeStep> steps, boolean withRing,\n                          long capacity, long limit) {\n+            super(traverser, strategy, sources, targets, capacity, limit);\n+\n             this.steps = steps;\n-            this.capacity = capacity;\n-            this.limit = limit;\n             this.withRing = withRing;\n-\n-            this.stepCount = 0;\n             for (RepeatEdgeStep step : steps) {\n                 this.totalSteps += step.maxTimes;\n             }\n+\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n \n-            for (Id id : sources) {\n-                this.addNode(this.sources, id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.addNode(this.targets, id, new Node(id));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-\n-            this.paths = this.newPathSet();\n-        }\n-\n-        public void forward() {\n-            RepeatEdgeStep currentStep = this.step(true);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(true);\n-\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.sources, currentStep, this::forward);\n-\n-            this.afterTraverse(currentStep, true);\n-        }\n-\n-        public void backward() {\n-            RepeatEdgeStep currentStep = this.step(false);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(false);\n-\n-            currentStep.swithDirection();\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.targets, currentStep, this::backward);\n-            currentStep.swithDirection();\n-\n-            this.afterTraverse(currentStep, false);\n+            this.sourceFinishOneStep = false;\n+            this.targetFinishOneStep = false;\n         }\n \n-        public RepeatEdgeStep step(boolean forward) {\n+        public RepeatEdgeStep nextStep(boolean forward) {\n             return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n+        @Override\n         public void beforeTraverse(boolean forward) {\n             this.clearNewVertices();\n             this.reInitAllIfNeeded(forward);\n         }\n \n-        public abstract void traverseOneLayer(\n-                             Map<Id, List<Node>> vertices,\n-                             RepeatEdgeStep step,\n-                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+        @Override\n+        public void afterTraverse(EdgeStep step, boolean forward) {\n \n-        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n             Map<Id, List<Node>> all = forward ? this.sourcesAll :\n                                                 this.targetsAll;\n             this.addNewVerticesToAll(all);\n-            this.reInitCurrentIfNeeded(step, forward);\n+            this.reInitCurrentStepIfNeeded(step, forward);\n             this.stepCount++;\n         }\n \n-        private void forward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, true);\n-        }\n-\n-        private void backward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, false);\n-        }\n-\n-        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n-            if (this.reachLimit()) {\n-                return;\n-            }\n-\n-            Iterator<Edge> edges = edgesOfVertex(v, step);\n-            while (edges.hasNext()) {\n-                HugeEdge edge = (HugeEdge) edges.next();\n-                Id target = edge.id().otherVertexId();\n-\n-                this.processOne(v, target, forward);\n-            }\n-        }\n-\n-        private void processOne(Id source, Id target, boolean forward) {\n-            if (forward) {\n-                processOneForForward(source, target);\n-            } else {\n-                processOneForBackward(source, target);\n-            }\n-        }\n-\n-        private void processOneForForward(Id source, Id target) {\n-            for (Node n : this.sources.get(source)) {\n+        @Override\n+        protected void processOneForForward(Id sourceV, Id targetV) {\n+            for (Node source : this.sources.get(sourceV)) {\n                 // If have loop, skip target\n-                if (!this.withRing && n.contains(target)) {\n+                if (!this.withRing && source.contains(targetV)) {\n                     continue;\n                 }\n \n                 // If cross point exists, path found, concat them\n                 if (this.lastSuperStep() &&\n-                    this.targetsAll.containsKey(target)) {\n-                    for (Node node : this.targetsAll.get(target)) {\n-                        List<Id> path = joinPath(n, node, this.withRing);\n+                    this.targetsAll.containsKey(targetV)) {\n+                    for (Node target : this.targetsAll.get(targetV)) {\n+                        List<Id> path = joinPath(source, target, this.withRing);\n                         if (!path.isEmpty()) {\n-                            this.paths.add(new Path(target, path));\n+                            this.paths.add(new Path(targetV, path));\n                             if (this.reachLimit()) {\n                                 return;\n                             }\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwODAxMg==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496708012", "body": "ditto", "bodyText": "ditto", "bodyHTML": "<p dir=\"auto\">ditto</p>", "author": "javeme", "createdAt": "2020-09-29T13:17:24Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -258,24 +259,24 @@ public class TemplatePathsTraverser extends TpTraverser {\n                 }\n \n                 // Add node to next start-nodes\n-                this.addNodeToNewVertices(target, new Node(target, n));\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n         }\n \n-        private void processOneForBackward(Id source, Id target) {\n-            for (Node n : this.targets.get(source)) {\n+        private void processOneForBackward(Id sourceV, Id targetV) {\n+            for (Node source : this.targets.get(sourceV)) {\n                 // If have loop, skip target\n-                if (!this.withRing && n.contains(target)) {\n+                if (!this.withRing && source.contains(targetV)) {\n                     continue;\n                 }\n \n                 // If cross point exists, path found, concat them\n                 if (this.lastSuperStep() &&\n-                    this.sourcesAll.containsKey(target)) {\n-                    for (Node node : this.sourcesAll.get(target)) {\n-                        List<Id> path = joinPath(n, node, this.withRing);\n+                    this.sourcesAll.containsKey(targetV)) {\n+                    for (Node target : this.sourcesAll.get(targetV)) {\n+                        List<Id> path = joinPath(source, target, this.withRing);\n                         if (!path.isEmpty()) {\n-                            Path newPath = new Path(target, path);\n+                            Path newPath = new Path(targetV, path);\n                             newPath.reverse();\n                             this.paths.add(newPath);\n                             if (this.reachLimit()) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -258,24 +169,25 @@ public class TemplatePathsTraverser extends TpTraverser {\n                 }\n \n                 // Add node to next start-nodes\n-                this.addNodeToNewVertices(target, new Node(target, n));\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n         }\n \n-        private void processOneForBackward(Id source, Id target) {\n-            for (Node n : this.targets.get(source)) {\n+        @Override\n+        protected void processOneForBackward(Id sourceV, Id targetV) {\n+            for (Node source : this.targets.get(sourceV)) {\n                 // If have loop, skip target\n-                if (!this.withRing && n.contains(target)) {\n+                if (!this.withRing && source.contains(targetV)) {\n                     continue;\n                 }\n \n                 // If cross point exists, path found, concat them\n                 if (this.lastSuperStep() &&\n-                    this.sourcesAll.containsKey(target)) {\n-                    for (Node node : this.sourcesAll.get(target)) {\n-                        List<Id> path = joinPath(n, node, this.withRing);\n+                    this.sourcesAll.containsKey(targetV)) {\n+                    for (Node target : this.sourcesAll.get(targetV)) {\n+                        List<Id> path = joinPath(source, target, this.withRing);\n                         if (!path.isEmpty()) {\n-                            Path newPath = new Path(target, path);\n+                            Path newPath = new Path(targetV, path);\n                             newPath.reverse();\n                             this.paths.add(newPath);\n                             if (this.reachLimit()) {\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwODYyOQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496708629", "body": "can we merge the two methods with one, and pass sourcesAll or targetsAll to that method", "bodyText": "can we merge the two methods with one, and pass sourcesAll or targetsAll to that method", "bodyHTML": "<p dir=\"auto\">can we merge the two methods with one, and pass sourcesAll or targetsAll to that method</p>", "author": "javeme", "createdAt": "2020-09-29T13:18:15Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -214,17 +214,18 @@ public class TemplatePathsTraverser extends TpTraverser {\n             this.traverseOne(v, step, false);\n         }\n \n-        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+        private void traverseOne(Id source, RepeatEdgeStep step,\n+                                 boolean forward) {\n             if (this.reachLimit()) {\n                 return;\n             }\n \n-            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            Iterator<Edge> edges = edgesOfVertex(source, step);\n             while (edges.hasNext()) {\n                 HugeEdge edge = (HugeEdge) edges.next();\n                 Id target = edge.id().otherVertexId();\n \n-                this.processOne(v, target, forward);\n+                this.processOne(source, target, forward);\n             }\n         }\n \n", "next_change": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex 1ec17203..e4063aab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -206,38 +144,8 @@ public class TemplatePathsTraverser extends TpTraverser {\n             this.stepCount++;\n         }\n \n-        private void forward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, true);\n-        }\n-\n-        private void backward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, false);\n-        }\n-\n-        private void traverseOne(Id source, RepeatEdgeStep step,\n-                                 boolean forward) {\n-            if (this.reachLimit()) {\n-                return;\n-            }\n-\n-            Iterator<Edge> edges = edgesOfVertex(source, step);\n-            while (edges.hasNext()) {\n-                HugeEdge edge = (HugeEdge) edges.next();\n-                Id target = edge.id().otherVertexId();\n-\n-                this.processOne(source, target, forward);\n-            }\n-        }\n-\n-        private void processOne(Id source, Id target, boolean forward) {\n-            if (forward) {\n-                processOneForForward(source, target);\n-            } else {\n-                processOneForBackward(source, target);\n-            }\n-        }\n-\n-        private void processOneForForward(Id sourceV, Id targetV) {\n+        @Override\n+        protected void processOneForForward(Id sourceV, Id targetV) {\n             for (Node source : this.sources.get(sourceV)) {\n                 // If have loop, skip target\n                 if (!this.withRing && source.contains(targetV)) {\n", "next_change": null}]}}, {"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..1ec17203 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -236,20 +237,20 @@ public class TemplatePathsTraverser extends TpTraverser {\n             }\n         }\n \n-        private void processOneForForward(Id source, Id target) {\n-            for (Node n : this.sources.get(source)) {\n+        private void processOneForForward(Id sourceV, Id targetV) {\n+            for (Node source : this.sources.get(sourceV)) {\n                 // If have loop, skip target\n-                if (!this.withRing && n.contains(target)) {\n+                if (!this.withRing && source.contains(targetV)) {\n                     continue;\n                 }\n \n                 // If cross point exists, path found, concat them\n                 if (this.lastSuperStep() &&\n-                    this.targetsAll.containsKey(target)) {\n-                    for (Node node : this.targetsAll.get(target)) {\n-                        List<Id> path = joinPath(n, node, this.withRing);\n+                    this.targetsAll.containsKey(targetV)) {\n+                    for (Node target : this.targetsAll.get(targetV)) {\n+                        List<Id> path = joinPath(source, target, this.withRing);\n                         if (!path.isEmpty()) {\n-                            this.paths.add(new Path(target, path));\n+                            this.paths.add(new Path(targetV, path));\n                             if (this.reachLimit()) {\n                                 return;\n                             }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\nindex b7183282..d22c01d3 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java\n", "chunk": "@@ -118,138 +107,60 @@ public class TemplatePathsTraverser extends TpTraverser {\n         protected boolean sourceFinishOneStep = false;\n         protected boolean targetFinishOneStep = false;\n \n-        protected Map<Id, List<Node>> sources = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> sourcesAll = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> targets = this.newMultiValueMap();\n-        protected Map<Id, List<Node>> targetsAll = this.newMultiValueMap();\n-\n-        protected Map<Id, List<Node>> newVertices;\n-\n-        private Set<Path> paths;\n-\n-        public Traverser(Collection<Id> sources, Collection<Id> targets,\n+        public Traverser(HugeTraverser traverser, TraverseStrategy strategy,\n+                         Collection<Id> sources, Collection<Id> targets,\n                          List<RepeatEdgeStep> steps, boolean withRing,\n                          long capacity, long limit) {\n+            super(traverser, strategy, sources, targets, capacity, limit);\n+\n             this.steps = steps;\n-            this.capacity = capacity;\n-            this.limit = limit;\n             this.withRing = withRing;\n-\n-            this.stepCount = 0;\n             for (RepeatEdgeStep step : steps) {\n                 this.totalSteps += step.maxTimes;\n             }\n+\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n \n-            for (Id id : sources) {\n-                this.addNode(this.sources, id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.addNode(this.targets, id, new Node(id));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-\n-            this.paths = this.newPathSet();\n-        }\n-\n-        public void forward() {\n-            RepeatEdgeStep currentStep = this.step(true);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(true);\n-\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.sources, currentStep, this::forward);\n-\n-            this.afterTraverse(currentStep, true);\n-        }\n-\n-        public void backward() {\n-            RepeatEdgeStep currentStep = this.step(false);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(false);\n-\n-            currentStep.swithDirection();\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.targets, currentStep, this::backward);\n-            currentStep.swithDirection();\n-\n-            this.afterTraverse(currentStep, false);\n+            this.sourceFinishOneStep = false;\n+            this.targetFinishOneStep = false;\n         }\n \n-        public RepeatEdgeStep step(boolean forward) {\n+        public RepeatEdgeStep nextStep(boolean forward) {\n             return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n+        @Override\n         public void beforeTraverse(boolean forward) {\n             this.clearNewVertices();\n             this.reInitAllIfNeeded(forward);\n         }\n \n-        public abstract void traverseOneLayer(\n-                             Map<Id, List<Node>> vertices,\n-                             RepeatEdgeStep step,\n-                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+        @Override\n+        public void afterTraverse(EdgeStep step, boolean forward) {\n \n-        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n             Map<Id, List<Node>> all = forward ? this.sourcesAll :\n                                                 this.targetsAll;\n             this.addNewVerticesToAll(all);\n-            this.reInitCurrentIfNeeded(step, forward);\n+            this.reInitCurrentStepIfNeeded(step, forward);\n             this.stepCount++;\n         }\n \n-        private void forward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, true);\n-        }\n-\n-        private void backward(Id v, RepeatEdgeStep step) {\n-            this.traverseOne(v, step, false);\n-        }\n-\n-        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n-            if (this.reachLimit()) {\n-                return;\n-            }\n-\n-            Iterator<Edge> edges = edgesOfVertex(v, step);\n-            while (edges.hasNext()) {\n-                HugeEdge edge = (HugeEdge) edges.next();\n-                Id target = edge.id().otherVertexId();\n-\n-                this.processOne(v, target, forward);\n-            }\n-        }\n-\n-        private void processOne(Id source, Id target, boolean forward) {\n-            if (forward) {\n-                processOneForForward(source, target);\n-            } else {\n-                processOneForBackward(source, target);\n-            }\n-        }\n-\n-        private void processOneForForward(Id source, Id target) {\n-            for (Node n : this.sources.get(source)) {\n+        @Override\n+        protected void processOneForForward(Id sourceV, Id targetV) {\n+            for (Node source : this.sources.get(sourceV)) {\n                 // If have loop, skip target\n-                if (!this.withRing && n.contains(target)) {\n+                if (!this.withRing && source.contains(targetV)) {\n                     continue;\n                 }\n \n                 // If cross point exists, path found, concat them\n                 if (this.lastSuperStep() &&\n-                    this.targetsAll.containsKey(target)) {\n-                    for (Node node : this.targetsAll.get(target)) {\n-                        List<Id> path = joinPath(n, node, this.withRing);\n+                    this.targetsAll.containsKey(targetV)) {\n+                    for (Node target : this.targetsAll.get(targetV)) {\n+                        List<Id> path = joinPath(source, target, this.withRing);\n                         if (!path.isEmpty()) {\n-                            this.paths.add(new Path(target, path));\n+                            this.paths.add(new Path(targetV, path));\n                             if (this.reachLimit()) {\n                                 return;\n                             }\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxMzExMQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496713111", "body": "keep origin", "bodyText": "keep origin", "bodyHTML": "<p dir=\"auto\">keep origin</p>", "author": "javeme", "createdAt": "2020-09-29T13:24:29Z", "path": "hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java", "diffHunk": "@@ -165,7 +165,7 @@ private HugeAuthenticator authenticator() {\n \n     @SuppressWarnings(\"unused\")\n     private void installLicense(HugeConfig config, String md5) {\n-        LicenseVerifier.instance().install(config, this, md5);\n+//        LicenseVerifier.instance().install(config, this, md5);", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java b/hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java\nindex c67192cd..d50df8c0 100644\n--- a/hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java\n+++ b/hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java\n", "chunk": "@@ -165,7 +165,7 @@ public final class GraphManager {\n \n     @SuppressWarnings(\"unused\")\n     private void installLicense(HugeConfig config, String md5) {\n-//        LicenseVerifier.instance().install(config, this, md5);\n+        LicenseVerifier.instance().install(config, this, md5);\n     }\n \n     private void closeTx(final Set<String> graphSourceNamesToCloseTxOn,\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java b/hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java\nindex c67192cd..d50df8c0 100644\n--- a/hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java\n+++ b/hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java\n", "chunk": "@@ -165,7 +165,7 @@ public final class GraphManager {\n \n     @SuppressWarnings(\"unused\")\n     private void installLicense(HugeConfig config, String md5) {\n-//        LicenseVerifier.instance().install(config, this, md5);\n+        LicenseVerifier.instance().install(config, this, md5);\n     }\n \n     private void closeTx(final Set<String> graphSourceNamesToCloseTxOn,\n", "next_change": {"commit": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "changed_code": [{"header": "diff --git a/hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java b/hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java\ndeleted file mode 100644\nindex d50df8c0..00000000\n--- a/hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java\n+++ /dev/null\n", "chunk": "@@ -1,301 +0,0 @@\n-/*\n- * Copyright 2017 HugeGraph Authors\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with this\n- * work for additional information regarding copyright ownership. The ASF\n- * licenses this file to You under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.baidu.hugegraph.core;\n-\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.apache.tinkerpop.gremlin.server.auth.AuthenticationException;\n-import org.apache.tinkerpop.gremlin.server.util.MetricManager;\n-import org.apache.tinkerpop.gremlin.structure.Graph;\n-import org.apache.tinkerpop.gremlin.structure.Transaction;\n-import org.apache.tinkerpop.gremlin.structure.util.GraphFactory;\n-import org.slf4j.Logger;\n-\n-import com.baidu.hugegraph.HugeFactory;\n-import com.baidu.hugegraph.HugeGraph;\n-import com.baidu.hugegraph.auth.HugeAuthenticator;\n-import com.baidu.hugegraph.auth.HugeFactoryAuthProxy;\n-import com.baidu.hugegraph.auth.HugeGraphAuthProxy;\n-import com.baidu.hugegraph.auth.UserManager;\n-import com.baidu.hugegraph.backend.BackendException;\n-import com.baidu.hugegraph.backend.cache.Cache;\n-import com.baidu.hugegraph.backend.cache.CacheManager;\n-import com.baidu.hugegraph.backend.id.IdGenerator;\n-import com.baidu.hugegraph.backend.store.BackendStoreSystemInfo;\n-import com.baidu.hugegraph.config.HugeConfig;\n-import com.baidu.hugegraph.config.ServerOptions;\n-import com.baidu.hugegraph.exception.NotSupportException;\n-import com.baidu.hugegraph.license.LicenseVerifier;\n-import com.baidu.hugegraph.metrics.MetricsUtil;\n-import com.baidu.hugegraph.metrics.ServerReporter;\n-import com.baidu.hugegraph.serializer.JsonSerializer;\n-import com.baidu.hugegraph.serializer.Serializer;\n-import com.baidu.hugegraph.server.RestServer;\n-import com.baidu.hugegraph.task.TaskManager;\n-import com.baidu.hugegraph.type.define.NodeRole;\n-import com.baidu.hugegraph.util.E;\n-import com.baidu.hugegraph.util.Log;\n-\n-public final class GraphManager {\n-\n-    private static final Logger LOG = Log.logger(RestServer.class);\n-\n-    private final Map<String, Graph> graphs;\n-    private final HugeAuthenticator authenticator;\n-\n-    public GraphManager(HugeConfig conf) {\n-        this.graphs = new ConcurrentHashMap<>();\n-        this.authenticator = HugeAuthenticator.loadAuthenticator(conf);\n-\n-        this.loadGraphs(conf.getMap(ServerOptions.GRAPHS));\n-        // this.installLicense(conf, \"\");\n-        this.waitGraphsStarted();\n-        this.checkBackendVersionOrExit();\n-        this.serverStarted(conf);\n-        this.addMetrics(conf);\n-    }\n-\n-    public void loadGraphs(final Map<String, String> graphConfs) {\n-        for (Map.Entry<String, String> conf : graphConfs.entrySet()) {\n-            String name = conf.getKey();\n-            String path = conf.getValue();\n-            HugeFactory.checkGraphName(name, \"rest-server.properties\");\n-            try {\n-                this.loadGraph(name, path);\n-            } catch (RuntimeException e) {\n-                LOG.error(\"Graph '{}' can't be loaded: '{}'\", name, path, e);\n-            }\n-        }\n-    }\n-\n-    public void waitGraphsStarted() {\n-        this.graphs.keySet().forEach(name -> {\n-            HugeGraph graph = this.graph(name);\n-            graph.waitStarted();\n-        });\n-    }\n-\n-    public Set<String> graphs() {\n-        return Collections.unmodifiableSet(this.graphs.keySet());\n-    }\n-\n-    public HugeGraph graph(String name) {\n-        Graph graph = this.graphs.get(name);\n-        if (graph == null) {\n-            return null;\n-        } else if (graph instanceof HugeGraph) {\n-            return (HugeGraph) graph;\n-        }\n-        throw new NotSupportException(\"graph instance of %s\", graph.getClass());\n-    }\n-\n-    public Serializer serializer(Graph g) {\n-        return JsonSerializer.instance();\n-    }\n-\n-    public void rollbackAll() {\n-        this.graphs.values().forEach(graph -> {\n-            if (graph.features().graph().supportsTransactions() &&\n-                graph.tx().isOpen()) {\n-                graph.tx().rollback();\n-            }\n-        });\n-    }\n-\n-    public void rollback(final Set<String> graphSourceNamesToCloseTxOn) {\n-        closeTx(graphSourceNamesToCloseTxOn, Transaction.Status.ROLLBACK);\n-    }\n-\n-    public void commitAll() {\n-        this.graphs.values().forEach(graph -> {\n-            if (graph.features().graph().supportsTransactions() &&\n-                graph.tx().isOpen()) {\n-                graph.tx().commit();\n-            }\n-        });\n-    }\n-\n-    public void commit(final Set<String> graphSourceNamesToCloseTxOn) {\n-        closeTx(graphSourceNamesToCloseTxOn, Transaction.Status.COMMIT);\n-    }\n-\n-    public boolean requireAuthentication() {\n-        if (this.authenticator == null) {\n-            return false;\n-        }\n-        return this.authenticator.requireAuthentication();\n-    }\n-\n-    public HugeAuthenticator.User authenticate(Map<String, String> credentials)\n-                                               throws AuthenticationException {\n-        return this.authenticator().authenticate(credentials);\n-    }\n-\n-    public UserManager userManager() {\n-        return this.authenticator().userManager();\n-    }\n-\n-    private HugeAuthenticator authenticator() {\n-        E.checkState(this.authenticator != null, \"Unconfigured authenticator\");\n-        return this.authenticator;\n-    }\n-\n-    @SuppressWarnings(\"unused\")\n-    private void installLicense(HugeConfig config, String md5) {\n-        LicenseVerifier.instance().install(config, this, md5);\n-    }\n-\n-    private void closeTx(final Set<String> graphSourceNamesToCloseTxOn,\n-                         final Transaction.Status tx) {\n-        final Set<Graph> graphsToCloseTxOn = new HashSet<>();\n-\n-        graphSourceNamesToCloseTxOn.forEach(name -> {\n-            if (this.graphs.containsKey(name)) {\n-                graphsToCloseTxOn.add(this.graphs.get(name));\n-            }\n-        });\n-\n-        graphsToCloseTxOn.forEach(graph -> {\n-            if (graph.features().graph().supportsTransactions() &&\n-                graph.tx().isOpen()) {\n-                if (tx == Transaction.Status.COMMIT) {\n-                    graph.tx().commit();\n-                } else {\n-                    graph.tx().rollback();\n-                }\n-            }\n-        });\n-    }\n-\n-    private void loadGraph(String name, String path) {\n-        final Graph graph = GraphFactory.open(path);\n-        this.graphs.put(name, graph);\n-        LOG.info(\"Graph '{}' was successfully configured via '{}'\", name, path);\n-\n-        if (this.requireAuthentication() &&\n-            !(graph instanceof HugeGraphAuthProxy)) {\n-            LOG.warn(\"You may need to support access control for '{}' with {}\",\n-                     path, HugeFactoryAuthProxy.GRAPH_FACTORY);\n-        }\n-    }\n-\n-    private void checkBackendVersionOrExit() {\n-        for (String graph : this.graphs()) {\n-            // TODO: close tx from main thread\n-            HugeGraph hugegraph = this.graph(graph);\n-            if (!hugegraph.backendStoreFeatures().supportsPersistence()) {\n-                hugegraph.initBackend();\n-            }\n-            BackendStoreSystemInfo info = hugegraph.backendStoreSystemInfo();\n-            if (!info.exists()) {\n-                throw new BackendException(\n-                          \"The backend store of '%s' has not been initialized\",\n-                          hugegraph.name());\n-            }\n-            if (!info.checkVersion()) {\n-                throw new BackendException(\n-                          \"The backend store version is inconsistent\");\n-            }\n-        }\n-    }\n-\n-    private void serverStarted(HugeConfig config) {\n-        String server = config.get(ServerOptions.SERVER_ID);\n-        String role = config.get(ServerOptions.SERVER_ROLE);\n-        E.checkArgument(server != null && !server.isEmpty(),\n-                        \"The server name can't be null or empty\");\n-        E.checkArgument(role != null && !role.isEmpty(),\n-                        \"The server role can't be null or empty\");\n-        NodeRole nodeRole = NodeRole.valueOf(role.toUpperCase());\n-        for (String graph : this.graphs()) {\n-            HugeGraph hugegraph = this.graph(graph);\n-            assert hugegraph != null;\n-            hugegraph.serverStarted(IdGenerator.of(server), nodeRole);\n-        }\n-    }\n-\n-    private void addMetrics(HugeConfig config) {\n-        final MetricManager metric = MetricManager.INSTANCE;\n-        // Force to add server reporter\n-        ServerReporter reporter = ServerReporter.instance(metric.getRegistry());\n-        reporter.start(60L, TimeUnit.SECONDS);\n-\n-        // Add metrics for MAX_WRITE_THREADS\n-        int maxWriteThreads = config.get(ServerOptions.MAX_WRITE_THREADS);\n-        MetricsUtil.registerGauge(RestServer.class, \"max-write-threads\", () -> {\n-            return maxWriteThreads;\n-        });\n-\n-        // Add metrics for caches\n-        @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n-        Map<String, Cache<?, ?>> caches = (Map) CacheManager.instance()\n-                                                            .caches();\n-        registerCacheMetrics(caches);\n-        final AtomicInteger lastCachesSize = new AtomicInteger(caches.size());\n-        MetricsUtil.registerGauge(Cache.class, \"instances\", () -> {\n-            int count = caches.size();\n-            if (count != lastCachesSize.get()) {\n-                // Update if caches changed (effect in the next report period)\n-                registerCacheMetrics(caches);\n-                lastCachesSize.set(count);\n-            }\n-            return count;\n-        });\n-\n-        // Add metrics for task\n-        MetricsUtil.registerGauge(TaskManager.class, \"workers\", () -> {\n-            return TaskManager.instance().workerPoolSize();\n-        });\n-        MetricsUtil.registerGauge(TaskManager.class, \"pending-tasks\", () -> {\n-            return TaskManager.instance().pendingTasks();\n-        });\n-    }\n-\n-    private static void registerCacheMetrics(Map<String, Cache<?, ?>> caches) {\n-        Set<String> names = MetricManager.INSTANCE.getRegistry().getNames();\n-        for (Map.Entry<String, Cache<?, ?>> entry : caches.entrySet()) {\n-            String key = entry.getKey();\n-            Cache<?, ?> cache = entry.getValue();\n-\n-            String hits = String.format(\"%s.%s\", key, \"hits\");\n-            String miss = String.format(\"%s.%s\", key, \"miss\");\n-            String exp = String.format(\"%s.%s\", key, \"expire\");\n-            String size = String.format(\"%s.%s\", key, \"size\");\n-            String cap = String.format(\"%s.%s\", key, \"capacity\");\n-\n-            // Avoid registering multiple times\n-            if (names.stream().anyMatch(name -> name.endsWith(hits))) {\n-                continue;\n-            }\n-\n-            MetricsUtil.registerGauge(Cache.class, hits, () -> cache.hits());\n-            MetricsUtil.registerGauge(Cache.class, miss, () -> cache.miss());\n-            MetricsUtil.registerGauge(Cache.class, exp, () -> cache.expire());\n-            MetricsUtil.registerGauge(Cache.class, size, () -> cache.size());\n-            MetricsUtil.registerGauge(Cache.class, cap, () -> cache.capacity());\n-        }\n-    }\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "9279bd721d71c4cb6305fd58c8b42ad2b20a36c8", "committedDate": "2020-11-23 14:02:45 +0800", "message": "Write snapshot explicity after truncate backend (#1275)"}, {"oid": "7f63b57043b61cf39bf1adb32771c090f316e559", "committedDate": "2021-02-10 17:20:01 +0800", "message": "Add multi-node auth information sharing function (#1350)"}, {"oid": "fb108f14c665611fa9394a4c57d7da72ff29b37b", "committedDate": "2021-03-03 19:44:27 +0800", "message": "refactor UserManager to AuthManager (#1363)"}, {"oid": "314fd8a6c9448bbee7d929ece61fc1d184e2a9a4", "committedDate": "2021-03-11 21:20:46 +0800", "message": "support: invalid cache through rpc (#1357)"}, {"oid": "acaeb3a43e08efbf09e67dacfc3db4e4730f7568", "committedDate": "2021-04-16 16:15:36 +0800", "message": "import hugegraph-rpc component (#1397)"}, {"oid": "461948ee262cc696853a8c8ba1306e6b371e3e89", "committedDate": "2021-06-01 12:31:01 +0800", "message": "add user-api test (#1456)"}, {"oid": "d213166eb2185cbb6bd8bd5d201b7167e7b98993", "committedDate": "2021-12-24 19:25:11 +0800", "message": "Support to create graph dynamically (#1065)"}, {"oid": "b6abf960400c620e04f90f573c7606af652b9cad", "committedDate": "2021-12-27 14:22:23 +0800", "message": "fix: can't dynamic create graph if auth enabled (#1708)"}, {"oid": "0580bae3e506a7a3600f231e6f0bfe588194f0e5", "committedDate": "2021-12-27 17:09:28 +0800", "message": "support clone graph without config param  (#1709)"}, {"oid": "7acd4fc0e4fd4eee19c121df9ef84f2d4c89772d", "committedDate": "2022-04-06 17:46:42 +0800", "message": "Add `graphs.enable_dynamic_create_drop` option (#1809)"}, {"oid": "85b01b233392cd991739a035773629c7bf90e23b", "committedDate": "2022-04-25 19:13:30 +0800", "message": "chore: java 11 version support (#1653)"}, {"oid": "8609968e6648d69189b6ea6d37b68b81e245e4dc", "committedDate": "2022-05-16 19:34:25 +0800", "message": "Improve some action for install snapshot and add peer (#1527)"}, {"oid": "2af01bc92ddfd69e654889b9f6e69a729d4f3043", "committedDate": "2022-06-02 16:42:46 +0800", "message": "Add system schema store (#1891)"}, {"oid": "1d4b834c59bd43f7a92b1c8b024c9efc2546e5f3", "committedDate": "2022-07-04 17:43:59 +0800", "message": "fix: can't shutdown when starting with exception (#1902)"}, {"oid": "2f11ea530f3e3b3f07f20773df54635b60da8350", "committedDate": "2022-07-09 17:32:45 +0800", "message": "Fix start  RpcServer NPE (#1921)"}, {"oid": "b699c5cd621ac91e53c08320c17902f401d3a391", "committedDate": "2022-10-08 19:27:38 +0800", "message": "refact: modify abnormal logs (#1948)"}, {"oid": "9b5950e4beab1f816d316065fc9ec5773db35668", "committedDate": "2022-10-21 21:40:28 +0800", "message": "fix(api): fix remoting rpc server not started (#1975)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxMzM4Mw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496713383", "body": "keep in one line", "bodyText": "keep in one line", "bodyHTML": "<p dir=\"auto\">keep in one line</p>", "author": "javeme", "createdAt": "2020-09-29T13:24:51Z", "path": "hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java", "diffHunk": "@@ -286,4 +288,23 @@ public String writeWeightedPaths(WeightedPaths paths,\n         return JsonUtil.toJson(ImmutableMap.of(\"paths\", paths.toMap(),\n                                                \"vertices\", vertices));\n     }\n+\n+    @Override\n+    public String writeNodesWithPath(String name, Set<Id> nodes,\n+                                     Collection<HugeTraverser.Path> paths,\n+                                     Iterator<Vertex> iterator,\n+                                     boolean countOnly) {\n+        List<Map<String, Object>> pathList;\n+        pathList = new ArrayList<>();", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java b/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java\nindex 2b09b9f9..e9dc3f27 100644\n--- a/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java\n+++ b/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java\n", "chunk": "@@ -294,8 +294,7 @@ public class JsonSerializer implements Serializer {\n                                      Collection<HugeTraverser.Path> paths,\n                                      Iterator<Vertex> iterator,\n                                      boolean countOnly) {\n-        List<Map<String, Object>> pathList;\n-        pathList = new ArrayList<>();\n+        List<Map<String, Object>> pathList = new ArrayList<>();\n         for (HugeTraverser.Path path : paths) {\n             pathList.add(path.toMap(false));\n         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java b/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java\nindex 2b09b9f9..e9dc3f27 100644\n--- a/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java\n+++ b/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java\n", "chunk": "@@ -294,8 +294,7 @@ public class JsonSerializer implements Serializer {\n                                      Collection<HugeTraverser.Path> paths,\n                                      Iterator<Vertex> iterator,\n                                      boolean countOnly) {\n-        List<Map<String, Object>> pathList;\n-        pathList = new ArrayList<>();\n+        List<Map<String, Object>> pathList = new ArrayList<>();\n         for (HugeTraverser.Path path : paths) {\n             pathList.add(path.toMap(false));\n         }\n", "next_change": {"commit": "e7a6e62922e66c37ee6cd9b7c1c493761d16bcd6", "changed_code": [{"header": "diff --git a/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java b/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java\nindex e9dc3f27..03d6cd88 100644\n--- a/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java\n+++ b/hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java\n", "chunk": "@@ -278,32 +293,34 @@ public class JsonSerializer implements Serializer {\n     @Override\n     public String writeWeightedPath(NodeWithWeight path,\n                                     Iterator<Vertex> vertices) {\n-        return JsonUtil.toJson(ImmutableMap.of(\"path\", path.toMap(),\n+        Map<String, Object> pathMap = path == null ?\n+                                      ImmutableMap.of() : path.toMap();\n+        return JsonUtil.toJson(ImmutableMap.of(\"path\", pathMap,\n                                                \"vertices\", vertices));\n     }\n \n     @Override\n     public String writeWeightedPaths(WeightedPaths paths,\n                                      Iterator<Vertex> vertices) {\n-        return JsonUtil.toJson(ImmutableMap.of(\"paths\", paths.toMap(),\n+        Map<Id, Map<String, Object>> pathMap = paths == null ?\n+                                               ImmutableMap.of() :\n+                                               paths.toMap();\n+        return JsonUtil.toJson(ImmutableMap.of(\"paths\", pathMap,\n                                                \"vertices\", vertices));\n     }\n \n     @Override\n-    public String writeNodesWithPath(String name, Set<Id> nodes,\n+    public String writeNodesWithPath(String name, List<Id> nodes, long size,\n                                      Collection<HugeTraverser.Path> paths,\n-                                     Iterator<Vertex> iterator,\n-                                     boolean countOnly) {\n+                                     Iterator<Vertex> vertices) {\n         List<Map<String, Object>> pathList = new ArrayList<>();\n         for (HugeTraverser.Path path : paths) {\n             pathList.add(path.toMap(false));\n         }\n \n         Map<String, Object> results;\n-        results = ImmutableMap.of(\"size\", nodes.size(),\n-                                  name, countOnly ? ImmutableSet.of() : nodes,\n-                                  \"paths\", pathList,\n-                                  \"vertices\", iterator);\n+        results = ImmutableMap.of(name, nodes, \"size\", size,\n+                                  \"paths\", pathList, \"vertices\", vertices);\n         return JsonUtil.toJson(results);\n     }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "eb062b2b026decd7b8256bda44004b193ee9b4a5", "committedDate": "2020-11-25 19:08:44 +0800", "message": "fix weighted shortest path result not stable (#1280)"}, {"oid": "fb108f14c665611fa9394a4c57d7da72ff29b37b", "committedDate": "2021-03-03 19:44:27 +0800", "message": "refactor UserManager to AuthManager (#1363)"}, {"oid": "ef37b3ac96b1fc8e82bca487b074abf79bba846d", "committedDate": "2021-07-22 23:53:49 +0800", "message": "support olap writeback for cassandra and rocksdb (#1506)"}, {"oid": "e7a6e62922e66c37ee6cd9b7c1c493761d16bcd6", "committedDate": "2021-08-02 17:56:51 +0800", "message": "optimize kout/kneighbor count (avoid copying set) (#1550)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxMzc2MQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496713761", "body": "remove empty line", "bodyText": "remove empty line", "bodyHTML": "<p dir=\"auto\">remove empty line</p>", "author": "javeme", "createdAt": "2020-09-29T13:25:22Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java", "diffHunk": "@@ -503,4 +503,21 @@ public static synchronized CoreOptions instance() {\n                     disallowEmpty(),\n                     \"./conf/computer.yaml\"\n             );\n+\n+    public static final ConfigOption<Integer> OLTP_CONCURRENT_THREADS =\n+            new ConfigOption<>(\n+                    \"oltp.concurrent_threads\",\n+                    \"Thread number to concurrently execute oltp algorithm.\",\n+                    rangeInt(0, 65535),\n+                    10\n+            );\n+\n+    public static final ConfigOption<Integer> OLTP_CONCURRENT_DEPTH =\n+            new ConfigOption<>(\n+                    \"oltp.concurrent_depth\",\n+                    \"The min depth to enable concurrent oltp algorithm.\",\n+                    rangeInt(0, 65535),\n+                    10\n+            );\n+", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java\nindex d8d02b48..38d6321d 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java\n", "chunk": "@@ -519,5 +519,4 @@ public class CoreOptions extends OptionHolder {\n                     rangeInt(0, 65535),\n                     10\n             );\n-\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java\nindex d8d02b48..0bb8ac92 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java\n", "chunk": "@@ -519,5 +586,4 @@ public class CoreOptions extends OptionHolder {\n                     rangeInt(0, 65535),\n                     10\n             );\n-\n }\n", "next_change": {"commit": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java\nindex 0bb8ac92..ddff4e60 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java\n", "chunk": "@@ -586,4 +624,14 @@ public class CoreOptions extends OptionHolder {\n                     rangeInt(0, 65535),\n                     10\n             );\n+\n+    public static final ConfigConvOption<String, CollectionType> OLTP_COLLECTION_TYPE =\n+            new ConfigConvOption<>(\n+                    \"oltp.collection_type\",\n+                    \"The implementation type of collections \" +\n+                    \"used in oltp algorithm.\",\n+                    allowValues(\"JCF\", \"EC\", \"FU\"),\n+                    CollectionType::valueOf,\n+                    \"EC\"\n+            );\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "636bcbbd0f826b02f2538d52dc5db6c188fa0f8d", "committedDate": "2020-11-05 10:48:19 +0800", "message": "Move lz4 decompress to backend executor (#1237)"}, {"oid": "ccf4a70a7e10c1fbe70521fee92342eeb0c7e48d", "committedDate": "2020-11-12 11:55:40 +0800", "message": "rename EXPIRED_DELETE_BATCH to TASK_TTL_DELETE_BATCH (#1253)"}, {"oid": "9279bd721d71c4cb6305fd58c8b42ad2b20a36c8", "committedDate": "2020-11-23 14:02:45 +0800", "message": "Write snapshot explicity after truncate backend (#1275)"}, {"oid": "bc90cf9e0a636485efcd8949f665e3d8f311e1a0", "committedDate": "2021-01-07 14:36:39 +0800", "message": "add config for whether encoding number of primary keys (#1323)"}, {"oid": "ec974d00ff1808300ef1c97d96da10bb1130f5b0", "committedDate": "2021-04-14 10:59:08 +0800", "message": "Add a callback 'onBusy' used to adaptive rate limit (#1401)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "0c51de548c5a54f374e63653bcee38ec34647dfb", "committedDate": "2021-06-21 21:46:13 +0800", "message": "feat(auth): support rate limit per user for audit log (#1493)"}, {"oid": "f22d03fdd608b0aa9384f3c90a3b628d49f1e63e", "committedDate": "2021-06-25 21:52:40 +0800", "message": "refact(auth): cache login role in auth client to avoid sending rpc repeatedly (#1507)"}, {"oid": "090bd281a391387f1e13da8f07beedf63bcde0d6", "committedDate": "2021-07-28 17:20:39 +0800", "message": "add option query.optimize_aggregate_by_index(set default false) (#1549)"}, {"oid": "cba3c23d7f01d9946a148903b514d519fbf68c36", "committedDate": "2021-08-11 20:04:55 +0800", "message": "Fix left range index (#1498)"}, {"oid": "7512587747fa02dc4475ddc1b380c32775936eea", "committedDate": "2021-10-15 12:23:25 +0800", "message": "Fix: quorum read if safe read (#1618)"}, {"oid": "f6a492c567f25a29c792bf89c4533c46a9976ed8", "committedDate": "2021-12-09 15:19:38 +0800", "message": "update cache_type default value (#1681)"}, {"oid": "5368f3205e25d4801ac59b353be38e631b4d2d0f", "committedDate": "2022-03-30 17:12:18 +0800", "message": "Spelling corrections (#1798)"}, {"oid": "8609968e6648d69189b6ea6d37b68b81e245e4dc", "committedDate": "2022-05-16 19:34:25 +0800", "message": "Improve some action for install snapshot and add peer (#1527)"}, {"oid": "2af01bc92ddfd69e654889b9f6e69a729d4f3043", "committedDate": "2022-06-02 16:42:46 +0800", "message": "Add system schema store (#1891)"}, {"oid": "19ef0ac203b06e2d5324927f970da133636be38f", "committedDate": "2022-10-31 12:05:22 +0800", "message": "remove word dependency to remove GPL license (#1998)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxNDMzNQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496714335", "body": "also refactor this class, and can we share code with templatepath?", "bodyText": "also refactor this class, and can we share code with templatepath?", "bodyHTML": "<p dir=\"auto\">also refactor this class, and can we share code with templatepath?</p>", "author": "javeme", "createdAt": "2020-09-29T13:26:07Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.structure.HugeVertex;\n+import com.baidu.hugegraph.util.E;\n+import com.baidu.hugegraph.util.Log;\n+\n+public class CollectionPathsTraverser extends TpTraverser {\n+\n+    private static final Logger LOG = Log.logger(CollectionPathsTraverser.class);\n+\n+    public CollectionPathsTraverser(HugeGraph graph) {\n+        super(graph, \"collection-paths\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<Path> paths(Iterator<Vertex> sources,\n+                                  Iterator<Vertex> targets,\n+                                  EdgeStep step, int depth, boolean nearest,\n+                                  long capacity, long limit) {\n+        checkCapacity(capacity);\n+        checkLimit(limit);\n+\n+        List<Id> sourceList = new ArrayList<>();\n+        while (sources.hasNext()) {\n+            sourceList.add(((HugeVertex) sources.next()).id());\n+        }\n+        int sourceSize = sourceList.size();\n+        E.checkState(sourceSize >= 1 && sourceSize <= MAX_VERTICES,\n+                     \"The number of source vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+        List<Id> targetList = new ArrayList<>();\n+        while (targets.hasNext()) {\n+            targetList.add(((HugeVertex) targets.next()).id());\n+        }\n+        int targetSize = targetList.size();\n+        E.checkState(targetSize >= 1 && targetSize <= MAX_VERTICES,\n+                     \"The number of target vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+        checkPositive(depth, \"max depth\");\n+\n+        Traverser traverser = depth >= this.concurrentDepth() ?\n+                              this.concurrentTraverser(sourceList, targetList,\n+                                                       step, nearest,\n+                                                       capacity, limit) :\n+                              this.singleTraverser(sourceList, targetList, step,\n+                                                   nearest, capacity, limit);\n+\n+        while (true) {\n+            if (--depth < 0 || traverser.reachLimit()) {\n+                break;\n+            }\n+            traverser.forward();\n+\n+            if (--depth < 0 || traverser.reachLimit()) {\n+                break;\n+            }\n+            traverser.backward();\n+        }\n+        return traverser.paths();\n+    }\n+\n+    private Traverser singleTraverser(List<Id> sources, List<Id> targets,\n+                                      EdgeStep step, boolean nearest,\n+                                      long capacity, long limit) {\n+        return nearest ? new SingleNearestTraverser(sources, targets, step,\n+                                                    capacity, limit) :\n+                         new SingleAllTraverser(sources, targets, step,\n+                                                capacity, limit);\n+    }\n+\n+    private Traverser concurrentTraverser(List<Id> sources, List<Id> targets,\n+                                          EdgeStep step, boolean nearest,\n+                                          long capacity, long limit) {\n+        return new ConcurrentTraverser(sources, targets, step, capacity, limit);", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\nindex 926dd63b..2f5a0c23 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n", "chunk": "@@ -75,509 +73,215 @@ public class CollectionPathsTraverser extends TpTraverser {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n-        Traverser traverser = depth >= this.concurrentDepth() ?\n-                              this.concurrentTraverser(sourceList, targetList,\n-                                                       step, nearest,\n-                                                       capacity, limit) :\n-                              this.singleTraverser(sourceList, targetList, step,\n-                                                   nearest, capacity, limit);\n-\n-        while (true) {\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n-            }\n-            traverser.forward();\n-\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n+        Traverser traverser;\n+\n+        TraverseStrategy strategy;\n+        if (depth >= this.concurrentDepth()) {\n+            strategy = new ConcurrentTraverseStrategy(this.graph());\n+            traverser = new Traverser(sourceList, targetList, step, depth,\n+                                      capacity, limit, strategy);\n+        } else {\n+            strategy = new SingleTraverseStrategy(this.graph());\n+            if (nearest) {\n+                traverser = new SingleNearestTraverser(sourceList, targetList,\n+                                                       step, depth, capacity,\n+                                                       limit, strategy);\n+            } else {\n+                traverser = new Traverser(sourceList, targetList, step,\n+                                          depth, capacity, limit, strategy);\n             }\n-            traverser.backward();\n         }\n-        return traverser.paths();\n-    }\n \n-    private Traverser singleTraverser(List<Id> sources, List<Id> targets,\n-                                      EdgeStep step, boolean nearest,\n-                                      long capacity, long limit) {\n-        return nearest ? new SingleNearestTraverser(sources, targets, step,\n-                                                    capacity, limit) :\n-                         new SingleAllTraverser(sources, targets, step,\n-                                                capacity, limit);\n-    }\n+        do {\n+            // Forward\n+            traverser.forward();\n+            if (traverser.finish()) {\n+                return traverser.paths();\n+            }\n \n-    private Traverser concurrentTraverser(List<Id> sources, List<Id> targets,\n-                                          EdgeStep step, boolean nearest,\n-                                          long capacity, long limit) {\n-        return new ConcurrentTraverser(sources, targets, step, capacity, limit);\n+            // Backward\n+            traverser.backward();\n+            if (traverser.finish()) {\n+                return traverser.paths();\n+            }\n+        } while (true);\n     }\n \n-    private class Traverser {\n+    private class Traverser extends PathTraverser {\n \n         protected final EdgeStep step;\n-        protected final long capacity;\n-        protected final long limit;\n \n-        public Traverser(EdgeStep step, long capacity, long limit) {\n+        public Traverser(Collection<Id> sources, Collection<Id> targets,\n+                         EdgeStep step, int depth, long capacity,\n+                         long limit, TraverseStrategy strategy) {\n+            super(sources, targets, capacity, limit, strategy);\n             this.step = step;\n-            this.capacity = capacity;\n-            this.limit = limit;\n-        }\n-\n-        public void forward() {\n-        }\n-\n-        public void backward() {\n+            this.totalSteps = depth;\n         }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n-\n-        public int pathCount() {\n-            return 0;\n-        }\n-\n-        protected int accessedNodes() {\n-            return 0;\n-        }\n-\n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"collection paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-    private class ConcurrentTraverser extends Traverser {\n-\n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n-\n-        private Set<Path> paths;\n-\n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets, EdgeStep step,\n-                                   long capacity, long limit) {\n-            super(step, capacity, limit);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-\n-            this.paths = ConcurrentHashMap.newKeySet();\n+        @Override\n+        public EdgeStep nextStep(boolean forward) {\n+            return this.step;\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            // Traversal vertices of previous level\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        @Override\n+        protected void processOneForForward(Id sourceV, Id targetV) {\n+            for (Node source : this.sources.get(sourceV)) {\n+                // If have loop, skip target\n+                if (source.contains(targetV)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, this.step);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.targetsAll.containsKey(targetV)) {\n+                    for (Node target : this.targetsAll.get(targetV)) {\n+                        List<Id> path = source.joinPath(target);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(targetV, path));\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            // Re-init sources\n-            this.sources = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            this.step.swithDirection();\n-            // Traversal vertices of previous level\n-            traverseIds(this.targets.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        @Override\n+        protected void processOneForBackward(Id sourceV, Id targetV) {\n+            for (Node source : this.targets.get(sourceV)) {\n+                // If have loop, skip target\n+                if (source.contains(targetV)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, this.step);\n \n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.targets.get(vid)) {\n-                        // If have loop, skip target\n-                        if (n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.sourcesAll.containsKey(target)) {\n-                            for (Node node : this.sourcesAll.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    Path newPath = new Path(target, path);\n-                                    newPath.reverse();\n-                                    this.paths.add(newPath);\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.sourcesAll.containsKey(targetV)) {\n+                    for (Node target : this.sourcesAll.get(targetV)) {\n+                        List<Id> path = source.joinPath(target);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(targetV, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n-            this.step.swithDirection();\n-\n-            // Re-init targets\n-            this.targets = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.targetsAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n \n-        @Override\n-        public Set<Path> paths() {\n-            return this.paths;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n+            }\n         }\n \n         @Override\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected int accessedNodes() {\n-            return this.sourcesAll.size() + this.targetsAll.size();\n+        protected void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                 boolean forward) {\n+            if (forward) {\n+                // Re-init sources\n+                this.sources = this.newVertices;\n+                // Record all passed vertices\n+                this.addNewVerticesToAll(this.sourcesAll);\n+            } else {\n+                // Re-init targets\n+                this.targets = this.newVertices;\n+                // Record all passed vertices\n+                this.addNewVerticesToAll(this.targetsAll);\n+            }\n         }\n     }\n \n-    private class SingleAllTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private PathSet paths;\n+    private class SingleNearestTraverser extends Traverser {\n \n-        public SingleAllTraverser(Collection<Id> sources,\n-                                  Collection<Id> targets,\n-                                  EdgeStep step, long capacity, long limit) {\n-            super(step, capacity, limit);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-            this.paths = new PathSet();\n+        public SingleNearestTraverser(Collection<Id> sources,\n+                                      Collection<Id> targets, EdgeStep step,\n+                                      int depth, long capacity, long limit,\n+                                      TraverseStrategy strategy) {\n+            super(sources, targets, step, depth, capacity, limit, strategy);\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, this.step);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            // Re-init targets\n-            this.sources = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+        @Override\n+        protected void processOneForForward(Id sourceV, Id targetV) {\n+            Node source = this.sources.get(sourceV).get(0);\n+            // If have loop, skip target\n+            if (source.contains(targetV)) {\n+                return;\n             }\n-        }\n-\n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            PathSet paths = new PathSet();\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            this.step.swithDirection();\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.targets.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, this.step);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.sourcesAll.containsKey(target)) {\n-                            for (Node node : this.sourcesAll.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    Path newPath = new Path(target, path);\n-                                    newPath.reverse();\n-                                    this.paths.add(newPath);\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n \n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n+            // If cross point exists, path found, concat them\n+            if (this.targetsAll.containsKey(targetV)) {\n+                Node node = this.targetsAll.get(targetV).get(0);\n+                List<Id> path = source.joinPath(node);\n+                if (!path.isEmpty()) {\n+                    this.paths.add(new Path(targetV, path));\n+                    if (this.reachLimit()) {\n+                        return;\n                     }\n                 }\n             }\n-            this.step.swithDirection();\n-\n-            // Re-init targets\n-            this.targets = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.targetsAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n \n-        @Override\n-        public Set<Path> paths() {\n-            return this.paths;\n+            // Add node to next start-nodes\n+            this.addNodeToNewVertices(targetV, new Node(targetV, source));\n         }\n \n         @Override\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected int accessedNodes() {\n-            return this.sourcesAll.size() + this.targetsAll.size();\n-        }\n-    }\n-\n-\n-    private class SingleNearestTraverser extends Traverser {\n-\n-        private Map<Id, Node> sources = new HashMap<>();\n-        private Map<Id, Node> targets = new HashMap<>();\n-        private Map<Id, Node> sourcesAll = new HashMap<>();\n-        private Map<Id, Node> targetsAll = new HashMap<>();\n-\n-        private PathSet paths;\n-\n-        public SingleNearestTraverser(Collection<Id> sources,\n-                                      Collection<Id> targets,\n-                                      EdgeStep step, long capacity,\n-                                      long limit) {\n-            super(step, capacity, limit);\n-            for (Id id : sources) {\n-                this.sources.put(id, new KNode(id, null));\n-            }\n-            for (Id id : targets) {\n-                this.targets.put(id, new KNode(id, null));\n+        protected void processOneForBackward(Id sourceV, Id targetV) {\n+            Node sourcee = this.targets.get(sourceV).get(0);\n+            // If have loop, skip target\n+            if (sourcee.contains(targetV)) {\n+                return;\n             }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-            this.paths = new PathSet();\n-        }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            LOG.info(\"Forward with sources size {} and sources all size {}\",\n-                     this.sources.size(), this.sourcesAll.size());\n-            Map<Id, Node> newVertices = new HashMap<>();\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, Node> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, this.step);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    Node n = entry.getValue();\n-                    // If have loop, skip target\n-                    if (n.contains(target)) {\n-                        continue;\n+            // If cross point exists, path found, concat them\n+            if (this.sourcesAll.containsKey(targetV)) {\n+                Node node = this.sourcesAll.get(targetV).get(0);\n+                List<Id> path = sourcee.joinPath(node);\n+                if (!path.isEmpty()) {\n+                    Path newPath = new Path(targetV, path);\n+                    newPath.reverse();\n+                    this.paths.add(newPath);\n+                    if (this.reachLimit()) {\n+                        return;\n                     }\n-\n-                    // If cross point exists, path found, concat them\n-                    if (this.targetsAll.containsKey(target)) {\n-                        Node node = this.targetsAll.get(target);\n-                        List<Id> path = n.joinPath(node);\n-                        if (!path.isEmpty()) {\n-                            this.paths.add(new Path(target, path));\n-                            if (this.reachLimit()) {\n-                                return;\n-                            }\n-                        }\n-                    }\n-\n-                    // Add node to next start-nodes\n-                    newVertices.putIfAbsent(target,\n-                                            new KNode(target, (KNode) n));\n                 }\n             }\n \n-            // Re-init targets\n-            this.sources = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, Node> entry : newVertices.entrySet()) {\n-                this.sourcesAll.putIfAbsent(entry.getKey(), entry.getValue());\n-            }\n-            LOG.info(\"Done forward with sources size {} and sources all size {}\",\n-                     this.sources.size(), this.sourcesAll.size());\n+            // Add node to next start-nodes\n+            this.addNodeToNewVertices(targetV, new Node(targetV, sourcee));\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            LOG.info(\"Backward with targets size {} and targets all size {}\",\n-                     this.targets.size(), this.targetsAll.size());\n-            Map<Id, Node> newVertices = new HashMap<>();\n-            this.step.swithDirection();\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, Node> entry : this.targets.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, this.step);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    Node n = entry.getValue();\n-                    // If have loop, skip target\n-                    if (n.contains(target)) {\n-                        continue;\n-                    }\n-\n-                    // If cross point exists, path found, concat them\n-                    if (this.sourcesAll.containsKey(target)) {\n-                        Node node = this.sourcesAll.get(target);\n-                        List<Id> path = n.joinPath(node);\n-                        if (!path.isEmpty()) {\n-                            Path newPath = new Path(target, path);\n-                            newPath.reverse();\n-                            this.paths.add(newPath);\n-                            if (this.reachLimit()) {\n-                                return;\n-                            }\n-                        }\n-                    }\n-\n-                    // Add node to next start-nodes\n-                    newVertices.putIfAbsent(target,\n-                                            new KNode(target, (KNode) n));\n-                }\n-            }\n-            this.step.swithDirection();\n-\n-            // Re-init targets\n-            this.targets = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, Node> entry : newVertices.entrySet()) {\n-                this.targetsAll.putIfAbsent(entry.getKey(), entry.getValue());\n+        @Override\n+        protected void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                 boolean forward) {\n+            if (forward) {\n+                // Re-init targets\n+                this.sources = this.newVertices;\n+                // Record all passed vertices\n+                this.addNewVerticesToAll(this.sourcesAll);\n+            } else {\n+                // Re-init targets\n+                this.targets = this.newVertices;\n+                // Record all passed vertices\n+                this.addNewVerticesToAll(this.targetsAll);\n             }\n-            LOG.info(\"Done backward with sources size {} and sources all size {}\",\n-                     this.targets.size(), this.targetsAll.size());\n         }\n \n         @Override\n-        public Set<Path> paths() {\n-            return this.paths;\n+        public void addNodeToNewVertices(Id id, Node node) {\n+            this.newVertices.putIfAbsent(id, ImmutableList.of(node));\n         }\n \n         @Override\n-        public int pathCount() {\n-            return this.paths.size();\n+        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n+            MultivaluedMap<Id, Node> vertices =\n+                                     (MultivaluedMap<Id, Node>) targets;\n+            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n+                vertices.putIfAbsent(entry.getKey(), entry.getValue());\n+            }\n         }\n \n         protected int accessedNodes() {\n", "next_change": {"commit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\nindex 2f5a0c23..3ae950c2 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n", "chunk": "@@ -277,10 +265,8 @@ public class CollectionPathsTraverser extends TpTraverser {\n \n         @Override\n         public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            MultivaluedMap<Id, Node> vertices =\n-                                     (MultivaluedMap<Id, Node>) targets;\n             for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n-                vertices.putIfAbsent(entry.getKey(), entry.getValue());\n+                targets.putIfAbsent(entry.getKey(), entry.getValue());\n             }\n         }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\nindex 926dd63b..6f198946 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n", "chunk": "@@ -75,509 +69,210 @@ public class CollectionPathsTraverser extends TpTraverser {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n-        Traverser traverser = depth >= this.concurrentDepth() ?\n-                              this.concurrentTraverser(sourceList, targetList,\n-                                                       step, nearest,\n-                                                       capacity, limit) :\n-                              this.singleTraverser(sourceList, targetList, step,\n-                                                   nearest, capacity, limit);\n+        TraverseStrategy strategy = TraverseStrategy.create(\n+                                    depth >= this.concurrentDepth(),\n+                                    this.graph());\n+        Traverser traverser;\n+        if (nearest) {\n+            traverser = new NearestTraverser(this, strategy,\n+                                             sourceList, targetList, step,\n+                                             depth, capacity, limit);\n+        } else {\n+            traverser = new Traverser(this, strategy,\n+                                      sourceList, targetList, step,\n+                                      depth, capacity, limit);\n+        }\n \n-        while (true) {\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n-            }\n+        do {\n+            // Forward\n             traverser.forward();\n-\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n+            if (traverser.finished()) {\n+                return traverser.paths();\n             }\n-            traverser.backward();\n-        }\n-        return traverser.paths();\n-    }\n \n-    private Traverser singleTraverser(List<Id> sources, List<Id> targets,\n-                                      EdgeStep step, boolean nearest,\n-                                      long capacity, long limit) {\n-        return nearest ? new SingleNearestTraverser(sources, targets, step,\n-                                                    capacity, limit) :\n-                         new SingleAllTraverser(sources, targets, step,\n-                                                capacity, limit);\n-    }\n-\n-    private Traverser concurrentTraverser(List<Id> sources, List<Id> targets,\n-                                          EdgeStep step, boolean nearest,\n-                                          long capacity, long limit) {\n-        return new ConcurrentTraverser(sources, targets, step, capacity, limit);\n+            // Backward\n+            traverser.backward();\n+            if (traverser.finished()) {\n+                return traverser.paths();\n+            }\n+        } while (true);\n     }\n \n-    private class Traverser {\n+    private static class Traverser extends PathTraverser {\n \n         protected final EdgeStep step;\n-        protected final long capacity;\n-        protected final long limit;\n \n-        public Traverser(EdgeStep step, long capacity, long limit) {\n+        public Traverser(HugeTraverser traverser, TraverseStrategy strategy,\n+                         Collection<Id> sources, Collection<Id> targets,\n+                         EdgeStep step, int depth, long capacity, long limit) {\n+            super(traverser, strategy, sources, targets, capacity, limit);\n             this.step = step;\n-            this.capacity = capacity;\n-            this.limit = limit;\n-        }\n-\n-        public void forward() {\n-        }\n-\n-        public void backward() {\n+            this.totalSteps = depth;\n         }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n-\n-        public int pathCount() {\n-            return 0;\n-        }\n-\n-        protected int accessedNodes() {\n-            return 0;\n-        }\n-\n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"collection paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-    private class ConcurrentTraverser extends Traverser {\n-\n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n-\n-        private Set<Path> paths;\n-\n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets, EdgeStep step,\n-                                   long capacity, long limit) {\n-            super(step, capacity, limit);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-\n-            this.paths = ConcurrentHashMap.newKeySet();\n+        @Override\n+        public EdgeStep nextStep(boolean forward) {\n+            return this.step;\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            // Traversal vertices of previous level\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        @Override\n+        protected void processOneForForward(Id sourceV, Id targetV) {\n+            for (Node source : this.sources.get(sourceV)) {\n+                // If have loop, skip target\n+                if (source.contains(targetV)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, this.step);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.targetsAll.containsKey(targetV)) {\n+                    for (Node target : this.targetsAll.get(targetV)) {\n+                        List<Id> path = source.joinPath(target);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(targetV, path));\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            // Re-init sources\n-            this.sources = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n             }\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            this.step.swithDirection();\n-            // Traversal vertices of previous level\n-            traverseIds(this.targets.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        @Override\n+        protected void processOneForBackward(Id sourceV, Id targetV) {\n+            for (Node source : this.targets.get(sourceV)) {\n+                // If have loop, skip target\n+                if (source.contains(targetV)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, this.step);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n \n-                    for (Node n : this.targets.get(vid)) {\n-                        // If have loop, skip target\n-                        if (n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.sourcesAll.containsKey(target)) {\n-                            for (Node node : this.sourcesAll.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    Path newPath = new Path(target, path);\n-                                    newPath.reverse();\n-                                    this.paths.add(newPath);\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.sourcesAll.containsKey(targetV)) {\n+                    for (Node target : this.sourcesAll.get(targetV)) {\n+                        List<Id> path = source.joinPath(target);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(targetV, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n-            this.step.swithDirection();\n-\n-            // Re-init targets\n-            this.targets = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.targetsAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-        }\n \n-        @Override\n-        public Set<Path> paths() {\n-            return this.paths;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(targetV, new Node(targetV, source));\n+            }\n         }\n \n         @Override\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected int accessedNodes() {\n-            return this.sourcesAll.size() + this.targetsAll.size();\n+        protected void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                 boolean forward) {\n+            if (forward) {\n+                // Re-init sources\n+                this.sources = this.newVertices;\n+                // Record all passed vertices\n+                this.addNewVerticesToAll(this.sourcesAll);\n+            } else {\n+                // Re-init targets\n+                this.targets = this.newVertices;\n+                // Record all passed vertices\n+                this.addNewVerticesToAll(this.targetsAll);\n+            }\n         }\n     }\n \n-    private class SingleAllTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n+    private class NearestTraverser extends Traverser {\n \n-        private PathSet paths;\n-\n-        public SingleAllTraverser(Collection<Id> sources,\n-                                  Collection<Id> targets,\n-                                  EdgeStep step, long capacity, long limit) {\n-            super(step, capacity, limit);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-            this.paths = new PathSet();\n+        public NearestTraverser(HugeTraverser traverser,\n+                                TraverseStrategy strategy,\n+                                Collection<Id> sources, Collection<Id> targets,\n+                                EdgeStep step, int depth, long capacity,\n+                                long limit) {\n+            super(traverser, strategy, sources, targets, step,\n+                  depth, capacity, limit);\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, this.step);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            // Re-init targets\n-            this.sources = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+        @Override\n+        protected void processOneForForward(Id sourceV, Id targetV) {\n+            Node source = this.sources.get(sourceV).get(0);\n+            // If have loop, skip target\n+            if (source.contains(targetV)) {\n+                return;\n             }\n-        }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            PathSet paths = new PathSet();\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            this.step.swithDirection();\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.targets.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, this.step);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.sourcesAll.containsKey(target)) {\n-                            for (Node node : this.sourcesAll.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    Path newPath = new Path(target, path);\n-                                    newPath.reverse();\n-                                    this.paths.add(newPath);\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n+            // If cross point exists, path found, concat them\n+            if (this.targetsAll.containsKey(targetV)) {\n+                Node node = this.targetsAll.get(targetV).get(0);\n+                List<Id> path = source.joinPath(node);\n+                if (!path.isEmpty()) {\n+                    this.paths.add(new Path(targetV, path));\n+                    if (this.reachLimit()) {\n+                        return;\n                     }\n                 }\n             }\n-            this.step.swithDirection();\n \n-            // Re-init targets\n-            this.targets = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.targetsAll.addAll(entry.getKey(), entry.getValue());\n-            }\n+            // Add node to next start-nodes\n+            this.addNodeToNewVertices(targetV, new Node(targetV, source));\n         }\n \n         @Override\n-        public Set<Path> paths() {\n-            return this.paths;\n-        }\n-\n-        @Override\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected int accessedNodes() {\n-            return this.sourcesAll.size() + this.targetsAll.size();\n-        }\n-    }\n-\n-\n-    private class SingleNearestTraverser extends Traverser {\n-\n-        private Map<Id, Node> sources = new HashMap<>();\n-        private Map<Id, Node> targets = new HashMap<>();\n-        private Map<Id, Node> sourcesAll = new HashMap<>();\n-        private Map<Id, Node> targetsAll = new HashMap<>();\n-\n-        private PathSet paths;\n-\n-        public SingleNearestTraverser(Collection<Id> sources,\n-                                      Collection<Id> targets,\n-                                      EdgeStep step, long capacity,\n-                                      long limit) {\n-            super(step, capacity, limit);\n-            for (Id id : sources) {\n-                this.sources.put(id, new KNode(id, null));\n+        protected void processOneForBackward(Id sourceV, Id targetV) {\n+            Node sourcee = this.targets.get(sourceV).get(0);\n+            // If have loop, skip target\n+            if (sourcee.contains(targetV)) {\n+                return;\n             }\n-            for (Id id : targets) {\n-                this.targets.put(id, new KNode(id, null));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-            this.paths = new PathSet();\n-        }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            LOG.info(\"Forward with sources size {} and sources all size {}\",\n-                     this.sources.size(), this.sourcesAll.size());\n-            Map<Id, Node> newVertices = new HashMap<>();\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, Node> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, this.step);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    Node n = entry.getValue();\n-                    // If have loop, skip target\n-                    if (n.contains(target)) {\n-                        continue;\n+            // If cross point exists, path found, concat them\n+            if (this.sourcesAll.containsKey(targetV)) {\n+                Node node = this.sourcesAll.get(targetV).get(0);\n+                List<Id> path = sourcee.joinPath(node);\n+                if (!path.isEmpty()) {\n+                    Path newPath = new Path(targetV, path);\n+                    newPath.reverse();\n+                    this.paths.add(newPath);\n+                    if (this.reachLimit()) {\n+                        return;\n                     }\n-\n-                    // If cross point exists, path found, concat them\n-                    if (this.targetsAll.containsKey(target)) {\n-                        Node node = this.targetsAll.get(target);\n-                        List<Id> path = n.joinPath(node);\n-                        if (!path.isEmpty()) {\n-                            this.paths.add(new Path(target, path));\n-                            if (this.reachLimit()) {\n-                                return;\n-                            }\n-                        }\n-                    }\n-\n-                    // Add node to next start-nodes\n-                    newVertices.putIfAbsent(target,\n-                                            new KNode(target, (KNode) n));\n                 }\n             }\n \n-            // Re-init targets\n-            this.sources = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, Node> entry : newVertices.entrySet()) {\n-                this.sourcesAll.putIfAbsent(entry.getKey(), entry.getValue());\n-            }\n-            LOG.info(\"Done forward with sources size {} and sources all size {}\",\n-                     this.sources.size(), this.sourcesAll.size());\n+            // Add node to next start-nodes\n+            this.addNodeToNewVertices(targetV, new Node(targetV, sourcee));\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            LOG.info(\"Backward with targets size {} and targets all size {}\",\n-                     this.targets.size(), this.targetsAll.size());\n-            Map<Id, Node> newVertices = new HashMap<>();\n-            this.step.swithDirection();\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, Node> entry : this.targets.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, this.step);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    Node n = entry.getValue();\n-                    // If have loop, skip target\n-                    if (n.contains(target)) {\n-                        continue;\n-                    }\n-\n-                    // If cross point exists, path found, concat them\n-                    if (this.sourcesAll.containsKey(target)) {\n-                        Node node = this.sourcesAll.get(target);\n-                        List<Id> path = n.joinPath(node);\n-                        if (!path.isEmpty()) {\n-                            Path newPath = new Path(target, path);\n-                            newPath.reverse();\n-                            this.paths.add(newPath);\n-                            if (this.reachLimit()) {\n-                                return;\n-                            }\n-                        }\n-                    }\n-\n-                    // Add node to next start-nodes\n-                    newVertices.putIfAbsent(target,\n-                                            new KNode(target, (KNode) n));\n-                }\n-            }\n-            this.step.swithDirection();\n-\n-            // Re-init targets\n-            this.targets = newVertices;\n-            // Record all passed vertices\n-            for (Map.Entry<Id, Node> entry : newVertices.entrySet()) {\n-                this.targetsAll.putIfAbsent(entry.getKey(), entry.getValue());\n+        @Override\n+        protected void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                 boolean forward) {\n+            if (forward) {\n+                // Re-init targets\n+                this.sources = this.newVertices;\n+                // Record all passed vertices\n+                this.addNewVerticesToAll(this.sourcesAll);\n+            } else {\n+                // Re-init targets\n+                this.targets = this.newVertices;\n+                // Record all passed vertices\n+                this.addNewVerticesToAll(this.targetsAll);\n             }\n-            LOG.info(\"Done backward with sources size {} and sources all size {}\",\n-                     this.targets.size(), this.targetsAll.size());\n         }\n \n         @Override\n-        public Set<Path> paths() {\n-            return this.paths;\n+        public void addNodeToNewVertices(Id id, Node node) {\n+            this.newVertices.putIfAbsent(id, ImmutableList.of(node));\n         }\n \n         @Override\n-        public int pathCount() {\n-            return this.paths.size();\n+        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n+            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n+                targets.putIfAbsent(entry.getKey(), entry.getValue());\n+            }\n         }\n \n         protected int accessedNodes() {\n", "next_change": {"commit": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\nindex 6f198946..8261e7e5 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n", "chunk": "@@ -275,6 +271,7 @@ public class CollectionPathsTraverser extends HugeTraverser {\n             }\n         }\n \n+        @Override\n         protected int accessedNodes() {\n             return this.sourcesAll.size() + this.targetsAll.size();\n         }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxNzEyMQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496717121", "body": "refactor with one method and call newSet() of Single and Concurrent", "bodyText": "refactor with one method and call newSet() of Single and Concurrent", "bodyHTML": "<p dir=\"auto\">refactor with one method and call newSet() of Single and Concurrent</p>", "author": "javeme", "createdAt": "2020-09-29T13:29:42Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKneighborTraverser.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.E;\n+\n+public class CustomizedKneighborTraverser extends TpTraverser {\n+\n+    public CustomizedKneighborTraverser(HugeGraph graph) {\n+        super(graph, \"kneighbor\");\n+    }\n+\n+    public Set<Node> customizedKneighbor(Id source, EdgeStep step,\n+                                         int maxDepth, long limit) {\n+        E.checkNotNull(source, \"source vertex id\");\n+        this.checkVertexExist(source, \"source vertex\");\n+        checkPositive(maxDepth, \"k-neighbor max_depth\");\n+        checkLimit(limit);\n+\n+        if (maxDepth >= this.concurrentDepth() &&\n+            step.direction == Directions.BOTH) {\n+            return this.customizedKneighborConcurrent(source, step,\n+                                                      maxDepth, limit);\n+        } else {\n+            return this.customizedKneighborSingle(source, step,\n+                                                  maxDepth, limit);\n+        }\n+    }\n+\n+    public Set<Node> customizedKneighborConcurrent(Id source, EdgeStep step,\n+                                                   int maxDepth, long limit) {\n+        Set<Node> latest = ConcurrentHashMap.newKeySet();\n+        Set<Node> all = ConcurrentHashMap.newKeySet();\n+\n+        Node sourceV = new KNode(source, null);\n+\n+        latest.add(sourceV);\n+        all.add(sourceV);\n+\n+        while (maxDepth-- > 0) {\n+            long remaining = limit == NO_LIMIT ? NO_LIMIT : limit - all.size();\n+            AtomicLong remain = new AtomicLong(remaining);\n+            latest = this.adjacentVertices(latest, step, all, remain);\n+            int size = all.size() + latest.size();\n+            if (limit != NO_LIMIT && size >= limit) {\n+                int subLength = (int) limit - all.size();\n+                Iterator<Node> iterator = latest.iterator();\n+                for (int i = 0; i < subLength && iterator.hasNext(); i++) {\n+                    all.add(iterator.next());\n+                }\n+                break;\n+            } else {\n+                all.addAll(latest);\n+            }\n+        }\n+\n+        return all;\n+    }\n+\n+    public Set<Node> customizedKneighborSingle(Id source, EdgeStep step,\n+                                               int maxDepth, long limit) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKneighborTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKneighborTraverser.java\nindex 6c810b92..f4c9e1e4 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKneighborTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKneighborTraverser.java\n", "chunk": "@@ -42,50 +40,16 @@ public class CustomizedKneighborTraverser extends TpTraverser {\n         checkPositive(maxDepth, \"k-neighbor max_depth\");\n         checkLimit(limit);\n \n-        if (maxDepth >= this.concurrentDepth() &&\n-            step.direction == Directions.BOTH) {\n-            return this.customizedKneighborConcurrent(source, step,\n-                                                      maxDepth, limit);\n-        } else {\n-            return this.customizedKneighborSingle(source, step,\n-                                                  maxDepth, limit);\n-        }\n-    }\n-\n-    public Set<Node> customizedKneighborConcurrent(Id source, EdgeStep step,\n-                                                   int maxDepth, long limit) {\n-        Set<Node> latest = ConcurrentHashMap.newKeySet();\n-        Set<Node> all = ConcurrentHashMap.newKeySet();\n-\n-        Node sourceV = new KNode(source, null);\n-\n-        latest.add(sourceV);\n-        all.add(sourceV);\n-\n-        while (maxDepth-- > 0) {\n-            long remaining = limit == NO_LIMIT ? NO_LIMIT : limit - all.size();\n-            AtomicLong remain = new AtomicLong(remaining);\n-            latest = this.adjacentVertices(latest, step, all, remain);\n-            int size = all.size() + latest.size();\n-            if (limit != NO_LIMIT && size >= limit) {\n-                int subLength = (int) limit - all.size();\n-                Iterator<Node> iterator = latest.iterator();\n-                for (int i = 0; i < subLength && iterator.hasNext(); i++) {\n-                    all.add(iterator.next());\n-                }\n-                break;\n-            } else {\n-                all.addAll(latest);\n-            }\n-        }\n-\n-        return all;\n+        boolean single = maxDepth < this.concurrentDepth() ||\n+                         step.direction != Directions.BOTH;\n+        return this.customizedKneighbor(source, step, maxDepth,\n+                                        limit, single);\n     }\n \n-    public Set<Node> customizedKneighborSingle(Id source, EdgeStep step,\n-                                               int maxDepth, long limit) {\n-        Set<Node> latest = newSet();\n-        Set<Node> all = newSet();\n+    public Set<Node> customizedKneighbor(Id source, EdgeStep step, int maxDepth,\n+                                         long limit, boolean single) {\n+        Set<Node> latest = newSet(single);\n+        Set<Node> all = newSet(single);\n \n         Node sourceV = new KNode(source, null);\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKneighborTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/KneighborTraverser.java\nsimilarity index 56%\nrename from hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKneighborTraverser.java\nrename to hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/KneighborTraverser.java\nindex 6c810b92..3c68021b 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKneighborTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/KneighborTraverser.java\n", "chunk": "@@ -21,71 +21,66 @@ package com.baidu.hugegraph.traversal.algorithm;\n \n import java.util.Iterator;\n import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.atomic.AtomicLong;\n \n import com.baidu.hugegraph.HugeGraph;\n import com.baidu.hugegraph.backend.id.Id;\n import com.baidu.hugegraph.type.define.Directions;\n import com.baidu.hugegraph.util.E;\n \n-public class CustomizedKneighborTraverser extends TpTraverser {\n+public class KneighborTraverser extends OltpTraverser {\n \n-    public CustomizedKneighborTraverser(HugeGraph graph) {\n-        super(graph, \"kneighbor\");\n+    public KneighborTraverser(HugeGraph graph) {\n+        super(graph);\n     }\n \n-    public Set<Node> customizedKneighbor(Id source, EdgeStep step,\n-                                         int maxDepth, long limit) {\n-        E.checkNotNull(source, \"source vertex id\");\n-        this.checkVertexExist(source, \"source vertex\");\n-        checkPositive(maxDepth, \"k-neighbor max_depth\");\n+    public Set<Id> kneighbor(Id sourceV, Directions dir,\n+                             String label, int depth,\n+                             long degree, long limit) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        this.checkVertexExist(sourceV, \"source vertex\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkPositive(depth, \"k-neighbor max_depth\");\n+        checkDegree(degree);\n         checkLimit(limit);\n \n-        if (maxDepth >= this.concurrentDepth() &&\n-            step.direction == Directions.BOTH) {\n-            return this.customizedKneighborConcurrent(source, step,\n-                                                      maxDepth, limit);\n-        } else {\n-            return this.customizedKneighborSingle(source, step,\n-                                                  maxDepth, limit);\n-        }\n-    }\n-\n-    public Set<Node> customizedKneighborConcurrent(Id source, EdgeStep step,\n-                                                   int maxDepth, long limit) {\n-        Set<Node> latest = ConcurrentHashMap.newKeySet();\n-        Set<Node> all = ConcurrentHashMap.newKeySet();\n-\n-        Node sourceV = new KNode(source, null);\n+        Id labelId = this.getEdgeLabelId(label);\n \n+        Set<Id> latest = newSet();\n         latest.add(sourceV);\n+\n+        Set<Id> all = newSet();\n         all.add(sourceV);\n \n-        while (maxDepth-- > 0) {\n+        while (depth-- > 0) {\n             long remaining = limit == NO_LIMIT ? NO_LIMIT : limit - all.size();\n-            AtomicLong remain = new AtomicLong(remaining);\n-            latest = this.adjacentVertices(latest, step, all, remain);\n-            int size = all.size() + latest.size();\n-            if (limit != NO_LIMIT && size >= limit) {\n-                int subLength = (int) limit - all.size();\n-                Iterator<Node> iterator = latest.iterator();\n-                for (int i = 0; i < subLength && iterator.hasNext(); i++) {\n-                    all.add(iterator.next());\n-                }\n+            latest = this.adjacentVertices(latest, dir, labelId, all,\n+                                           degree, remaining);\n+            all.addAll(latest);\n+            if (limit != NO_LIMIT && all.size() >= limit) {\n                 break;\n-            } else {\n-                all.addAll(latest);\n             }\n         }\n \n         return all;\n     }\n \n-    public Set<Node> customizedKneighborSingle(Id source, EdgeStep step,\n-                                               int maxDepth, long limit) {\n-        Set<Node> latest = newSet();\n-        Set<Node> all = newSet();\n+    public Set<Node> customizedKneighbor(Id source, EdgeStep step,\n+                                         int maxDepth, long limit) {\n+        E.checkNotNull(source, \"source vertex id\");\n+        this.checkVertexExist(source, \"source vertex\");\n+        checkPositive(maxDepth, \"k-neighbor max_depth\");\n+        checkLimit(limit);\n+\n+        boolean single = maxDepth < this.concurrentDepth() ||\n+                         step.direction != Directions.BOTH;\n+        return this.customizedKneighbor(source, step, maxDepth,\n+                                        limit, single);\n+    }\n+\n+    public Set<Node> customizedKneighbor(Id source, EdgeStep step, int maxDepth,\n+                                         long limit, boolean single) {\n+        Set<Node> latest = newSet(single);\n+        Set<Node> all = newSet(single);\n \n         Node sourceV = new KNode(source, null);\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxNzQ5MA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496717490", "body": "ditto", "bodyText": "ditto", "bodyHTML": "<p dir=\"auto\">ditto</p>", "author": "javeme", "createdAt": "2020-09-29T13:30:07Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKoutTraverser.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.baidu.hugegraph.HugeException;\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.CollectionUtil;\n+import com.baidu.hugegraph.util.E;\n+\n+public class CustomizedKoutTraverser extends TpTraverser {\n+\n+    public CustomizedKoutTraverser(HugeGraph graph) {\n+        super(graph, \"kout\");\n+    }\n+\n+    public Set<Node> customizedKout(Id source, EdgeStep step, int maxDepth,\n+                                    boolean nearest, long capacity,\n+                                    long limit) {\n+        E.checkNotNull(source, \"source vertex id\");\n+        this.checkVertexExist(source, \"source vertex\");\n+        checkPositive(maxDepth, \"k-out max_depth\");\n+        checkCapacity(capacity);\n+        checkLimit(limit);\n+\n+        Set<Node> results;\n+        if (maxDepth >= this.concurrentDepth() &&\n+            step.direction == Directions.BOTH) {\n+            results = this.customizedKoutConcurrent(source, step, maxDepth,\n+                                                    nearest, capacity);\n+        } else {\n+            results = this.customizedKoutSingle(source, step, maxDepth,\n+                                                nearest, capacity);\n+        }\n+\n+        if (limit != NO_LIMIT && results.size() > limit) {\n+            results = CollectionUtil.subSet(results, 0, (int) limit);\n+        }\n+\n+        return results;\n+    }\n+\n+    public Set<Node> customizedKoutConcurrent(Id source, EdgeStep step,\n+                                              int maxDepth, boolean nearest,\n+                                              long capacity) {\n+        Set<Node> latest = ConcurrentHashMap.newKeySet();\n+        Set<Node> all = ConcurrentHashMap.newKeySet();\n+\n+        Node sourceV = new KNode(source, null);\n+\n+        latest.add(sourceV);\n+        all.add(sourceV);\n+\n+        int depth = maxDepth;\n+        long remaining = capacity == NO_LIMIT ?\n+                         NO_LIMIT : capacity - latest.size();\n+        while (depth-- > 0) {\n+            AtomicLong remain = new AtomicLong(remaining);\n+            if (nearest) {\n+                latest = this.adjacentVertices(latest, step, all, remain);\n+                all.addAll(latest);\n+            } else {\n+                latest = this.adjacentVertices(latest, step, null, remain);\n+            }\n+            if (capacity != NO_LIMIT) {\n+                // Update 'remaining' value to record remaining capacity\n+                remaining -= latest.size();\n+                reachCapacity(remaining, capacity, depth);\n+            }\n+        }\n+\n+        return latest;\n+    }\n+\n+    public Set<Node> customizedKoutSingle(Id source, EdgeStep step,", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKoutTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKoutTraverser.java\nindex 4e0c521e..17a8bce2 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKoutTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKoutTraverser.java\n", "chunk": "@@ -62,43 +56,11 @@ public class CustomizedKoutTraverser extends TpTraverser {\n         return results;\n     }\n \n-    public Set<Node> customizedKoutConcurrent(Id source, EdgeStep step,\n-                                              int maxDepth, boolean nearest,\n-                                              long capacity) {\n-        Set<Node> latest = ConcurrentHashMap.newKeySet();\n-        Set<Node> all = ConcurrentHashMap.newKeySet();\n-\n-        Node sourceV = new KNode(source, null);\n-\n-        latest.add(sourceV);\n-        all.add(sourceV);\n-\n-        int depth = maxDepth;\n-        long remaining = capacity == NO_LIMIT ?\n-                         NO_LIMIT : capacity - latest.size();\n-        while (depth-- > 0) {\n-            AtomicLong remain = new AtomicLong(remaining);\n-            if (nearest) {\n-                latest = this.adjacentVertices(latest, step, all, remain);\n-                all.addAll(latest);\n-            } else {\n-                latest = this.adjacentVertices(latest, step, null, remain);\n-            }\n-            if (capacity != NO_LIMIT) {\n-                // Update 'remaining' value to record remaining capacity\n-                remaining -= latest.size();\n-                reachCapacity(remaining, capacity, depth);\n-            }\n-        }\n-\n-        return latest;\n-    }\n-\n-    public Set<Node> customizedKoutSingle(Id source, EdgeStep step,\n-                                          int maxDepth, boolean nearest,\n-                                          long capacity) {\n-        Set<Node> latest = newSet();\n-        Set<Node> all = newSet();\n+    public Set<Node> customizedKout(Id source, EdgeStep step, int maxDepth,\n+                                    boolean nearest, long capacity,\n+                                    boolean single) {\n+        Set<Node> latest = newSet(single);\n+        Set<Node> all = newSet(single);\n \n         Node sourceV = new KNode(source, null);\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKoutTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/KoutTraverser.java\nsimilarity index 57%\nrename from hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKoutTraverser.java\nrename to hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/KoutTraverser.java\nindex 4e0c521e..fcfddf6b 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKoutTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/KoutTraverser.java\n", "chunk": "@@ -30,75 +28,96 @@ import com.baidu.hugegraph.type.define.Directions;\n import com.baidu.hugegraph.util.CollectionUtil;\n import com.baidu.hugegraph.util.E;\n \n-public class CustomizedKoutTraverser extends TpTraverser {\n+public class KoutTraverser extends OltpTraverser {\n \n-    public CustomizedKoutTraverser(HugeGraph graph) {\n-        super(graph, \"kout\");\n+    public KoutTraverser(HugeGraph graph) {\n+        super(graph);\n     }\n \n-    public Set<Node> customizedKout(Id source, EdgeStep step, int maxDepth,\n-                                    boolean nearest, long capacity,\n-                                    long limit) {\n-        E.checkNotNull(source, \"source vertex id\");\n-        this.checkVertexExist(source, \"source vertex\");\n-        checkPositive(maxDepth, \"k-out max_depth\");\n+    public Set<Id> kout(Id sourceV, Directions dir, String label,\n+                        int depth, boolean nearest,\n+                        long degree, long capacity, long limit) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        this.checkVertexExist(sourceV, \"source vertex\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkPositive(depth, \"k-out max_depth\");\n+        checkDegree(degree);\n         checkCapacity(capacity);\n         checkLimit(limit);\n-\n-        Set<Node> results;\n-        if (maxDepth >= this.concurrentDepth() &&\n-            step.direction == Directions.BOTH) {\n-            results = this.customizedKoutConcurrent(source, step, maxDepth,\n-                                                    nearest, capacity);\n-        } else {\n-            results = this.customizedKoutSingle(source, step, maxDepth,\n-                                                nearest, capacity);\n+        if (capacity != NO_LIMIT) {\n+            // Capacity must > limit because sourceV is counted in capacity\n+            E.checkArgument(capacity >= limit && limit != NO_LIMIT,\n+                            \"Capacity can't be less than limit, \" +\n+                            \"but got capacity '%s' and limit '%s'\",\n+                            capacity, limit);\n         }\n \n-        if (limit != NO_LIMIT && results.size() > limit) {\n-            results = CollectionUtil.subSet(results, 0, (int) limit);\n-        }\n-\n-        return results;\n-    }\n-\n-    public Set<Node> customizedKoutConcurrent(Id source, EdgeStep step,\n-                                              int maxDepth, boolean nearest,\n-                                              long capacity) {\n-        Set<Node> latest = ConcurrentHashMap.newKeySet();\n-        Set<Node> all = ConcurrentHashMap.newKeySet();\n-\n-        Node sourceV = new KNode(source, null);\n+        Id labelId = this.getEdgeLabelId(label);\n \n+        Set<Id> latest = newSet();\n         latest.add(sourceV);\n+\n+        Set<Id> all = newSet();\n         all.add(sourceV);\n \n-        int depth = maxDepth;\n         long remaining = capacity == NO_LIMIT ?\n                          NO_LIMIT : capacity - latest.size();\n         while (depth-- > 0) {\n-            AtomicLong remain = new AtomicLong(remaining);\n+            // Just get limit nodes in last layer if limit < remaining capacity\n+            if (depth == 0 && limit != NO_LIMIT &&\n+                (limit < remaining || remaining == NO_LIMIT)) {\n+                remaining = limit;\n+            }\n             if (nearest) {\n-                latest = this.adjacentVertices(latest, step, all, remain);\n+                latest = this.adjacentVertices(latest, dir, labelId, all,\n+                                               degree, remaining);\n                 all.addAll(latest);\n             } else {\n-                latest = this.adjacentVertices(latest, step, null, remain);\n+                latest = this.adjacentVertices(latest, dir, labelId, null,\n+                                               degree, remaining);\n             }\n             if (capacity != NO_LIMIT) {\n                 // Update 'remaining' value to record remaining capacity\n                 remaining -= latest.size();\n-                reachCapacity(remaining, capacity, depth);\n+\n+                if (remaining <= 0 && depth > 0) {\n+                    throw new HugeException(\n+                              \"Reach capacity '%s' while remaining depth '%s'\",\n+                              capacity, depth);\n+                }\n             }\n         }\n \n         return latest;\n     }\n \n-    public Set<Node> customizedKoutSingle(Id source, EdgeStep step,\n-                                          int maxDepth, boolean nearest,\n-                                          long capacity) {\n-        Set<Node> latest = newSet();\n-        Set<Node> all = newSet();\n+    public Set<Node> customizedKout(Id source, EdgeStep step, int maxDepth,\n+                                    boolean nearest, long capacity,\n+                                    long limit) {\n+        E.checkNotNull(source, \"source vertex id\");\n+        this.checkVertexExist(source, \"source vertex\");\n+        checkPositive(maxDepth, \"k-out max_depth\");\n+        checkCapacity(capacity);\n+        checkLimit(limit);\n+\n+        Set<Node> results;\n+        boolean single = maxDepth < this.concurrentDepth() ||\n+                         step.direction != Directions.BOTH;\n+        results = this.customizedKout(source, step, maxDepth, nearest,\n+                                      capacity, single);\n+\n+        if (limit != NO_LIMIT && results.size() > limit) {\n+            results = CollectionUtil.subSet(results, 0, (int) limit);\n+        }\n+\n+        return results;\n+    }\n+\n+    public Set<Node> customizedKout(Id source, EdgeStep step, int maxDepth,\n+                                    boolean nearest, long capacity,\n+                                    boolean single) {\n+        Set<Node> latest = newSet(single);\n+        Set<Node> all = newSet(single);\n \n         Node sourceV = new KNode(source, null);\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxODA2Ng==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496718066", "body": "align", "bodyText": "align", "bodyHTML": "<p dir=\"auto\">align</p>", "author": "javeme", "createdAt": "2020-09-29T13:30:53Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java", "diffHunk": "@@ -194,7 +194,13 @@ public SimilarsMap fusiformSimilarity(Iterator<Vertex> vertices,\n     }\n \n     private static void checkGroupArgs(String groupProperty, int minGroups) {\n-        if (groupProperty != null) {\n+        if (groupProperty == null) {\n+            E.checkArgument(minGroups == 0,\n+                            \"Can not set min group count when \" +\n+                                    \"group property not set\");", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\nindex f601b226..17a534ab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\n", "chunk": "@@ -196,8 +196,8 @@ public class FusiformSimilarityTraverser extends HugeTraverser {\n     private static void checkGroupArgs(String groupProperty, int minGroups) {\n         if (groupProperty == null) {\n             E.checkArgument(minGroups == 0,\n-                            \"Can not set min group count when \" +\n-                                    \"group property not set\");\n+                            \"Can't set min group count when \" +\n+                            \"group property not set\");\n         } else {\n             E.checkArgument(!groupProperty.isEmpty(),\n                             \"The group property can't be empty\");\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\nindex f601b226..17a534ab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\n", "chunk": "@@ -196,8 +196,8 @@ public class FusiformSimilarityTraverser extends HugeTraverser {\n     private static void checkGroupArgs(String groupProperty, int minGroups) {\n         if (groupProperty == null) {\n             E.checkArgument(minGroups == 0,\n-                            \"Can not set min group count when \" +\n-                                    \"group property not set\");\n+                            \"Can't set min group count when \" +\n+                            \"group property not set\");\n         } else {\n             E.checkArgument(!groupProperty.isEmpty(),\n                             \"The group property can't be empty\");\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "b34a308981d66b6bd65e87f5f4cd5e427cfb7f3b", "committedDate": "2021-06-28 15:06:12 +0800", "message": "improve SimilarsMap implementation (#1523)"}, {"oid": "eef1f8b124557ecb3cdb4adf227721f424b9ad07", "committedDate": "2021-10-28 11:44:50 +0800", "message": "oltp traversal: optimize id2code for number id (#1623)"}, {"oid": "85b01b233392cd991739a035773629c7bf90e23b", "committedDate": "2022-04-25 19:13:30 +0800", "message": "chore: java 11 version support (#1653)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxODY0NA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496718644", "body": "Can't", "bodyText": "Can't", "bodyHTML": "<p dir=\"auto\">Can't</p>", "author": "javeme", "createdAt": "2020-09-29T13:31:40Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java", "diffHunk": "@@ -194,7 +194,13 @@ public SimilarsMap fusiformSimilarity(Iterator<Vertex> vertices,\n     }\n \n     private static void checkGroupArgs(String groupProperty, int minGroups) {\n-        if (groupProperty != null) {\n+        if (groupProperty == null) {\n+            E.checkArgument(minGroups == 0,\n+                            \"Can not set min group count when \" +", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\nindex f601b226..17a534ab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\n", "chunk": "@@ -196,8 +196,8 @@ public class FusiformSimilarityTraverser extends HugeTraverser {\n     private static void checkGroupArgs(String groupProperty, int minGroups) {\n         if (groupProperty == null) {\n             E.checkArgument(minGroups == 0,\n-                            \"Can not set min group count when \" +\n-                                    \"group property not set\");\n+                            \"Can't set min group count when \" +\n+                            \"group property not set\");\n         } else {\n             E.checkArgument(!groupProperty.isEmpty(),\n                             \"The group property can't be empty\");\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\nindex f601b226..17a534ab 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java\n", "chunk": "@@ -196,8 +196,8 @@ public class FusiformSimilarityTraverser extends HugeTraverser {\n     private static void checkGroupArgs(String groupProperty, int minGroups) {\n         if (groupProperty == null) {\n             E.checkArgument(minGroups == 0,\n-                            \"Can not set min group count when \" +\n-                                    \"group property not set\");\n+                            \"Can't set min group count when \" +\n+                            \"group property not set\");\n         } else {\n             E.checkArgument(!groupProperty.isEmpty(),\n                             \"The group property can't be empty\");\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "b34a308981d66b6bd65e87f5f4cd5e427cfb7f3b", "committedDate": "2021-06-28 15:06:12 +0800", "message": "improve SimilarsMap implementation (#1523)"}, {"oid": "eef1f8b124557ecb3cdb4adf227721f424b9ad07", "committedDate": "2021-10-28 11:44:50 +0800", "message": "oltp traversal: optimize id2code for number id (#1623)"}, {"oid": "85b01b233392cd991739a035773629c7bf90e23b", "committedDate": "2022-04-25 19:13:30 +0800", "message": "chore: java 11 version support (#1653)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMTI0OQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496721249", "body": "move  Iterator<Id> adjacentVertices() to line 293", "bodyText": "move  Iterator adjacentVertices() to line 293", "bodyHTML": "<p dir=\"auto\">move  Iterator adjacentVertices() to line 293</p>", "author": "javeme", "createdAt": "2020-09-29T13:35:09Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -259,6 +262,35 @@ public double jaccardSimilarity(Id vertex, Id other, Directions dir,\n         });\n     }\n \n+    protected Set<Node> adjacentVertices(Set<Node> vertices, EdgeStep step,", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21ea44cac2593462828060d846c5192bc76a78dd", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex a2083a66..431d7f26 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -262,6 +263,15 @@ public class HugeTraverser {\n         });\n     }\n \n+    protected Set<Id> adjacentVertices(Id source, EdgeStep step) {\n+        Set<Id> neighbors = new HashSet<>();\n+        Iterator<Edge> edges = this.edgesOfVertex(source, step);\n+        while (edges.hasNext()) {\n+            neighbors.add(((HugeEdge) edges.next()).id().otherVertexId());\n+        }\n+        return neighbors;\n+    }\n+\n     protected Set<Node> adjacentVertices(Set<Node> vertices, EdgeStep step,\n                                          Set<Node> excluded, long remaining) {\n         Set<Node> neighbors = newSet();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex a2083a66..8f6102f9 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -262,6 +135,15 @@ public class HugeTraverser {\n         });\n     }\n \n+    protected Set<Id> adjacentVertices(Id source, EdgeStep step) {\n+        Set<Id> neighbors = new HashSet<>();\n+        Iterator<Edge> edges = this.edgesOfVertex(source, step);\n+        while (edges.hasNext()) {\n+            neighbors.add(((HugeEdge) edges.next()).id().otherVertexId());\n+        }\n+        return neighbors;\n+    }\n+\n     protected Set<Node> adjacentVertices(Set<Node> vertices, EdgeStep step,\n                                          Set<Node> excluded, long remaining) {\n         Set<Node> neighbors = newSet();\n", "next_change": {"commit": "718daa63679ce9984b870e9450c481cac8e4e414", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex 8f6102f9..ec1fb3ad 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -152,11 +149,12 @@ public class HugeTraverser {\n             while (edges.hasNext()) {\n                 Id target = ((HugeEdge) edges.next()).id().otherVertexId();\n                 KNode kNode = new KNode(target, (KNode) source);\n-                if (excluded != null && excluded.contains(kNode)) {\n+                if ((excluded != null && excluded.contains(kNode)) ||\n+                    neighbors.contains(kNode)) {\n                     continue;\n                 }\n                 neighbors.add(kNode);\n-                if (--remaining <= 0L) {\n+                if (remaining != NO_LIMIT && --remaining <= 0L) {\n                     return neighbors;\n                 }\n             }\n", "next_change": {"commit": "9ef6796dc9c60679ffbe49e60fe31c7d23818f55", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex ec1fb3ad..0c85111d 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -141,16 +141,19 @@ public class HugeTraverser {\n         return neighbors;\n     }\n \n-    protected Set<Node> adjacentVertices(Set<Node> vertices, EdgeStep step,\n-                                         Set<Node> excluded, long remaining) {\n+    protected Set<Node> adjacentVertices(Id start, Set<Node> vertices,\n+                                         EdgeStep step, Set<Node> excluded,\n+                                         long remaining) {\n         Set<Node> neighbors = newSet();\n         for (Node source : vertices) {\n             Iterator<Edge> edges = this.edgesOfVertex(source.id(), step);\n             while (edges.hasNext()) {\n                 Id target = ((HugeEdge) edges.next()).id().otherVertexId();\n                 KNode kNode = new KNode(target, (KNode) source);\n-                if ((excluded != null && excluded.contains(kNode)) ||\n-                    neighbors.contains(kNode)) {\n+                boolean matchExcluded = (excluded != null &&\n+                                         excluded.contains(kNode));\n+                if (matchExcluded || neighbors.contains(kNode) ||\n+                    start.equals(kNode.id())) {\n                     continue;\n                 }\n                 neighbors.add(kNode);\n", "next_change": {"commit": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex 0c85111d..ada4854a 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -141,30 +155,7 @@ public class HugeTraverser {\n         return neighbors;\n     }\n \n-    protected Set<Node> adjacentVertices(Id start, Set<Node> vertices,\n-                                         EdgeStep step, Set<Node> excluded,\n-                                         long remaining) {\n-        Set<Node> neighbors = newSet();\n-        for (Node source : vertices) {\n-            Iterator<Edge> edges = this.edgesOfVertex(source.id(), step);\n-            while (edges.hasNext()) {\n-                Id target = ((HugeEdge) edges.next()).id().otherVertexId();\n-                KNode kNode = new KNode(target, (KNode) source);\n-                boolean matchExcluded = (excluded != null &&\n-                                         excluded.contains(kNode));\n-                if (matchExcluded || neighbors.contains(kNode) ||\n-                    start.equals(kNode.id())) {\n-                    continue;\n-                }\n-                neighbors.add(kNode);\n-                if (remaining != NO_LIMIT && --remaining <= 0L) {\n-                    return neighbors;\n-                }\n-            }\n-        }\n-        return neighbors;\n-    }\n-\n+    @Watched\n     protected Iterator<Edge> edgesOfVertex(Id source, Directions dir,\n                                            Id label, long limit) {\n         Id[] labels = {};\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "74b013ed211b6951cca82c778655c3d7a6839b56", "committedDate": "2020-11-18 21:30:34 +0800", "message": "oltp concurrent requests share multi executors instead of one executor (#1258)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "bc90cf9e0a636485efcd8949f665e3d8f311e1a0", "committedDate": "2021-01-07 14:36:39 +0800", "message": "add config for whether encoding number of primary keys (#1323)"}, {"oid": "de81038c2119634596e7d7f7cf23a245ed8e630f", "committedDate": "2021-05-12 14:15:05 +0800", "message": "refact: unify naming of degree for oltp algorithms (#1433)"}, {"oid": "718daa63679ce9984b870e9450c481cac8e4e414", "committedDate": "2021-05-21 20:30:48 +0800", "message": "refact: let kout degree applied to all labels & remove source vertex from kneighbor default results  (#1459)"}, {"oid": "9ef6796dc9c60679ffbe49e60fe31c7d23818f55", "committedDate": "2021-05-27 17:36:11 +0800", "message": "refact: remove source from kneighbor/kout results & unify 'degree ' error info (#1463)"}, {"oid": "d48b820a56eefe45c64f3e1d63bb2f001015e222", "committedDate": "2021-05-28 15:52:39 +0800", "message": "refact: unify kout/kneighbor get method with post (#1470)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "eef1f8b124557ecb3cdb4adf227721f424b9ad07", "committedDate": "2021-10-28 11:44:50 +0800", "message": "oltp traversal: optimize id2code for number id (#1623)"}, {"oid": "9f50e679830cd8a81a1bfef4fcc33afefab91a4e", "committedDate": "2021-12-15 19:33:56 +0800", "message": "refact: params improve for personal rank api (#1695)"}, {"oid": "a0ffdc47fbeb5872af05886561f6963159ac86c0", "committedDate": "2021-12-15 19:39:37 +0800", "message": "refact: early stop  & perf improve for paths traverser/api (#1694)"}, {"oid": "e9cef7425ddb12aa50a40c1fe1107a4b58041773", "committedDate": "2022-01-12 20:08:59 +0800", "message": "fix: useless ring detection removed valid path (#1723)"}, {"oid": "85b01b233392cd991739a035773629c7bf90e23b", "committedDate": "2022-04-25 19:13:30 +0800", "message": "chore: java 11 version support (#1653)"}, {"oid": "f6f8c3eda68554f8eefe53322955af8216260fe1", "committedDate": "2022-05-11 15:34:17 +0800", "message": "fix checkstyle core-util issue (#1855)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMjU4Ng==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496722586", "body": "prefer move kout/jaccardSimilarity out of this class", "bodyText": "prefer move kout/jaccardSimilarity out of this class", "bodyHTML": "<p dir=\"auto\">prefer move kout/jaccardSimilarity out of this class</p>", "author": "javeme", "createdAt": "2020-09-29T13:36:50Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -217,10 +218,12 @@ public double jaccardSimilarity(Id vertex, Id other, Directions dir,\n                                   vertex, dir, labelId, degree));\n         Set<Id> targetNeighbors = IteratorUtils.set(this.adjacentVertices(\n                                   other, dir, labelId, degree));\n-        int interNum = CollectionUtil.intersect(sourceNeighbors,\n-                                                targetNeighbors).size();\n-        int unionNum = CollectionUtil.union(sourceNeighbors,\n-                                            targetNeighbors).size();\n+        return jaccardSimilarity(sourceNeighbors, targetNeighbors);\n+    }\n+\n+    public double jaccardSimilarity(Set<Id> set1, Set<Id> set2) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex a2083a66..3ef436ee 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -90,146 +90,9 @@ public class HugeTraverser {\n         return this.graph;\n     }\n \n-    public Set<Id> kout(Id sourceV, Directions dir, String label,\n-                        int depth, boolean nearest,\n-                        long degree, long capacity, long limit) {\n-        E.checkNotNull(sourceV, \"source vertex id\");\n-        this.checkVertexExist(sourceV, \"source vertex\");\n-        E.checkNotNull(dir, \"direction\");\n-        checkPositive(depth, \"k-out max_depth\");\n-        checkDegree(degree);\n-        checkCapacity(capacity);\n-        checkLimit(limit);\n-        if (capacity != NO_LIMIT) {\n-            // Capacity must > limit because sourceV is counted in capacity\n-            E.checkArgument(capacity >= limit && limit != NO_LIMIT,\n-                            \"Capacity can't be less than limit, \" +\n-                            \"but got capacity '%s' and limit '%s'\",\n-                            capacity, limit);\n-        }\n-\n-        Id labelId = this.getEdgeLabelId(label);\n-\n-        Set<Id> latest = newSet();\n-        latest.add(sourceV);\n-\n-        Set<Id> all = newSet();\n-        all.add(sourceV);\n-\n-        long remaining = capacity == NO_LIMIT ?\n-                         NO_LIMIT : capacity - latest.size();\n-        while (depth-- > 0) {\n-            // Just get limit nodes in last layer if limit < remaining capacity\n-            if (depth == 0 && limit != NO_LIMIT &&\n-                (limit < remaining || remaining == NO_LIMIT)) {\n-                remaining = limit;\n-            }\n-            if (nearest) {\n-                latest = this.adjacentVertices(latest, dir, labelId, all,\n-                                               degree, remaining);\n-                all.addAll(latest);\n-            } else {\n-                latest = this.adjacentVertices(latest, dir, labelId, null,\n-                                               degree, remaining);\n-            }\n-            if (capacity != NO_LIMIT) {\n-                // Update 'remaining' value to record remaining capacity\n-                remaining -= latest.size();\n-\n-                if (remaining <= 0 && depth > 0) {\n-                    throw new HugeException(\n-                              \"Reach capacity '%s' while remaining depth '%s'\",\n-                              capacity, depth);\n-                }\n-            }\n-        }\n-\n-        return latest;\n-    }\n-\n-    public Set<Id> kneighbor(Id sourceV, Directions dir,\n-                             String label, int depth,\n-                             long degree, long limit) {\n-        E.checkNotNull(sourceV, \"source vertex id\");\n-        this.checkVertexExist(sourceV, \"source vertex\");\n-        E.checkNotNull(dir, \"direction\");\n-        checkPositive(depth, \"k-neighbor max_depth\");\n-        checkDegree(degree);\n-        checkLimit(limit);\n-\n-        Id labelId = this.getEdgeLabelId(label);\n-\n-        Set<Id> latest = newSet();\n-        latest.add(sourceV);\n-\n-        Set<Id> all = newSet();\n-        all.add(sourceV);\n-\n-        while (depth-- > 0) {\n-            long remaining = limit == NO_LIMIT ? NO_LIMIT : limit - all.size();\n-            latest = this.adjacentVertices(latest, dir, labelId, all,\n-                                           degree, remaining);\n-            all.addAll(latest);\n-            if (limit != NO_LIMIT && all.size() >= limit) {\n-                break;\n-            }\n-        }\n-\n-        return all;\n-    }\n-\n-    public Set<Id> sameNeighbors(Id vertex, Id other, Directions direction,\n-                                 String label, long degree, long limit) {\n-        E.checkNotNull(vertex, \"vertex id\");\n-        E.checkNotNull(other, \"the other vertex id\");\n-        this.checkVertexExist(vertex, \"vertex\");\n-        this.checkVertexExist(other, \"other vertex\");\n-        E.checkNotNull(direction, \"direction\");\n-        checkDegree(degree);\n-        checkLimit(limit);\n-\n-        Id labelId = this.getEdgeLabelId(label);\n-\n-        Set<Id> sourceNeighbors = IteratorUtils.set(this.adjacentVertices(\n-                                  vertex, direction, labelId, degree));\n-        Set<Id> targetNeighbors = IteratorUtils.set(this.adjacentVertices(\n-                                  other, direction, labelId, degree));\n-        Set<Id> sameNeighbors = (Set<Id>) CollectionUtil.intersect(\n-                                sourceNeighbors, targetNeighbors);\n-        if (limit != NO_LIMIT) {\n-            int end = Math.min(sameNeighbors.size(), (int) limit);\n-            sameNeighbors = CollectionUtil.subSet(sameNeighbors, 0, end);\n-        }\n-        return sameNeighbors;\n-    }\n-\n-    public double jaccardSimilarity(Id vertex, Id other, Directions dir,\n-                                    String label, long degree) {\n-        E.checkNotNull(vertex, \"vertex id\");\n-        E.checkNotNull(other, \"the other vertex id\");\n-        this.checkVertexExist(vertex, \"vertex\");\n-        this.checkVertexExist(other, \"other vertex\");\n-        E.checkNotNull(dir, \"direction\");\n-        checkDegree(degree);\n-\n-        Id labelId = this.getEdgeLabelId(label);\n-\n-        Set<Id> sourceNeighbors = IteratorUtils.set(this.adjacentVertices(\n-                                  vertex, dir, labelId, degree));\n-        Set<Id> targetNeighbors = IteratorUtils.set(this.adjacentVertices(\n-                                  other, dir, labelId, degree));\n-        return jaccardSimilarity(sourceNeighbors, targetNeighbors);\n-    }\n-\n-    public double jaccardSimilarity(Set<Id> set1, Set<Id> set2) {\n-        int interNum = CollectionUtil.intersect(set1, set2).size();\n-        int unionNum = CollectionUtil.union(set1, set2).size();\n-        return (double) interNum / unionNum;\n-    }\n-\n-    private Set<Id> adjacentVertices(Set<Id> vertices, Directions dir,\n-                                     Id label, Set<Id> excluded,\n-                                     long degree, long limit) {\n+    protected Set<Id> adjacentVertices(Set<Id> vertices, Directions dir,\n+                                       Id label, Set<Id> excluded,\n+                                       long degree, long limit) {\n         if (limit == 0) {\n             return ImmutableSet.of();\n         }\n", "next_change": {"commit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex 3ef436ee..8f6102f9 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -90,6 +92,14 @@ public class HugeTraverser {\n         return this.graph;\n     }\n \n+    protected int concurrentDepth() {\n+        return this.config().get(CoreOptions.OLTP_CONCURRENT_DEPTH);\n+    }\n+\n+    protected HugeConfig config() {\n+        return ((HugeConfig) this.graph().hugegraph().configuration());\n+    }\n+\n     protected Set<Id> adjacentVertices(Set<Id> vertices, Directions dir,\n                                        Id label, Set<Id> excluded,\n                                        long degree, long limit) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex a2083a66..8f6102f9 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -90,146 +92,17 @@ public class HugeTraverser {\n         return this.graph;\n     }\n \n-    public Set<Id> kout(Id sourceV, Directions dir, String label,\n-                        int depth, boolean nearest,\n-                        long degree, long capacity, long limit) {\n-        E.checkNotNull(sourceV, \"source vertex id\");\n-        this.checkVertexExist(sourceV, \"source vertex\");\n-        E.checkNotNull(dir, \"direction\");\n-        checkPositive(depth, \"k-out max_depth\");\n-        checkDegree(degree);\n-        checkCapacity(capacity);\n-        checkLimit(limit);\n-        if (capacity != NO_LIMIT) {\n-            // Capacity must > limit because sourceV is counted in capacity\n-            E.checkArgument(capacity >= limit && limit != NO_LIMIT,\n-                            \"Capacity can't be less than limit, \" +\n-                            \"but got capacity '%s' and limit '%s'\",\n-                            capacity, limit);\n-        }\n-\n-        Id labelId = this.getEdgeLabelId(label);\n-\n-        Set<Id> latest = newSet();\n-        latest.add(sourceV);\n-\n-        Set<Id> all = newSet();\n-        all.add(sourceV);\n-\n-        long remaining = capacity == NO_LIMIT ?\n-                         NO_LIMIT : capacity - latest.size();\n-        while (depth-- > 0) {\n-            // Just get limit nodes in last layer if limit < remaining capacity\n-            if (depth == 0 && limit != NO_LIMIT &&\n-                (limit < remaining || remaining == NO_LIMIT)) {\n-                remaining = limit;\n-            }\n-            if (nearest) {\n-                latest = this.adjacentVertices(latest, dir, labelId, all,\n-                                               degree, remaining);\n-                all.addAll(latest);\n-            } else {\n-                latest = this.adjacentVertices(latest, dir, labelId, null,\n-                                               degree, remaining);\n-            }\n-            if (capacity != NO_LIMIT) {\n-                // Update 'remaining' value to record remaining capacity\n-                remaining -= latest.size();\n-\n-                if (remaining <= 0 && depth > 0) {\n-                    throw new HugeException(\n-                              \"Reach capacity '%s' while remaining depth '%s'\",\n-                              capacity, depth);\n-                }\n-            }\n-        }\n-\n-        return latest;\n-    }\n-\n-    public Set<Id> kneighbor(Id sourceV, Directions dir,\n-                             String label, int depth,\n-                             long degree, long limit) {\n-        E.checkNotNull(sourceV, \"source vertex id\");\n-        this.checkVertexExist(sourceV, \"source vertex\");\n-        E.checkNotNull(dir, \"direction\");\n-        checkPositive(depth, \"k-neighbor max_depth\");\n-        checkDegree(degree);\n-        checkLimit(limit);\n-\n-        Id labelId = this.getEdgeLabelId(label);\n-\n-        Set<Id> latest = newSet();\n-        latest.add(sourceV);\n-\n-        Set<Id> all = newSet();\n-        all.add(sourceV);\n-\n-        while (depth-- > 0) {\n-            long remaining = limit == NO_LIMIT ? NO_LIMIT : limit - all.size();\n-            latest = this.adjacentVertices(latest, dir, labelId, all,\n-                                           degree, remaining);\n-            all.addAll(latest);\n-            if (limit != NO_LIMIT && all.size() >= limit) {\n-                break;\n-            }\n-        }\n-\n-        return all;\n+    protected int concurrentDepth() {\n+        return this.config().get(CoreOptions.OLTP_CONCURRENT_DEPTH);\n     }\n \n-    public Set<Id> sameNeighbors(Id vertex, Id other, Directions direction,\n-                                 String label, long degree, long limit) {\n-        E.checkNotNull(vertex, \"vertex id\");\n-        E.checkNotNull(other, \"the other vertex id\");\n-        this.checkVertexExist(vertex, \"vertex\");\n-        this.checkVertexExist(other, \"other vertex\");\n-        E.checkNotNull(direction, \"direction\");\n-        checkDegree(degree);\n-        checkLimit(limit);\n-\n-        Id labelId = this.getEdgeLabelId(label);\n-\n-        Set<Id> sourceNeighbors = IteratorUtils.set(this.adjacentVertices(\n-                                  vertex, direction, labelId, degree));\n-        Set<Id> targetNeighbors = IteratorUtils.set(this.adjacentVertices(\n-                                  other, direction, labelId, degree));\n-        Set<Id> sameNeighbors = (Set<Id>) CollectionUtil.intersect(\n-                                sourceNeighbors, targetNeighbors);\n-        if (limit != NO_LIMIT) {\n-            int end = Math.min(sameNeighbors.size(), (int) limit);\n-            sameNeighbors = CollectionUtil.subSet(sameNeighbors, 0, end);\n-        }\n-        return sameNeighbors;\n+    protected HugeConfig config() {\n+        return ((HugeConfig) this.graph().hugegraph().configuration());\n     }\n \n-    public double jaccardSimilarity(Id vertex, Id other, Directions dir,\n-                                    String label, long degree) {\n-        E.checkNotNull(vertex, \"vertex id\");\n-        E.checkNotNull(other, \"the other vertex id\");\n-        this.checkVertexExist(vertex, \"vertex\");\n-        this.checkVertexExist(other, \"other vertex\");\n-        E.checkNotNull(dir, \"direction\");\n-        checkDegree(degree);\n-\n-        Id labelId = this.getEdgeLabelId(label);\n-\n-        Set<Id> sourceNeighbors = IteratorUtils.set(this.adjacentVertices(\n-                                  vertex, dir, labelId, degree));\n-        Set<Id> targetNeighbors = IteratorUtils.set(this.adjacentVertices(\n-                                  other, dir, labelId, degree));\n-        return jaccardSimilarity(sourceNeighbors, targetNeighbors);\n-    }\n-\n-    public double jaccardSimilarity(Set<Id> set1, Set<Id> set2) {\n-        int interNum = CollectionUtil.intersect(set1, set2).size();\n-        int unionNum = CollectionUtil.union(set1, set2).size();\n-        return (double) interNum / unionNum;\n-    }\n-\n-    private Set<Id> adjacentVertices(Set<Id> vertices, Directions dir,\n-                                     Id label, Set<Id> excluded,\n-                                     long degree, long limit) {\n+    protected Set<Id> adjacentVertices(Set<Id> vertices, Directions dir,\n+                                       Id label, Set<Id> excluded,\n+                                       long degree, long limit) {\n         if (limit == 0) {\n             return ImmutableSet.of();\n         }\n", "next_change": {"commit": "d48b820a56eefe45c64f3e1d63bb2f001015e222", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex 8f6102f9..3ec1362b 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -93,16 +94,13 @@ public class HugeTraverser {\n     }\n \n     protected int concurrentDepth() {\n-        return this.config().get(CoreOptions.OLTP_CONCURRENT_DEPTH);\n+        return this.graph.option(CoreOptions.OLTP_CONCURRENT_DEPTH);\n     }\n \n-    protected HugeConfig config() {\n-        return ((HugeConfig) this.graph().hugegraph().configuration());\n-    }\n-\n-    protected Set<Id> adjacentVertices(Set<Id> vertices, Directions dir,\n-                                       Id label, Set<Id> excluded,\n-                                       long degree, long limit) {\n+    protected Set<Id> adjacentVertices(Id sourceV, Set<Id> vertices,\n+                                       Directions dir, Id label,\n+                                       Set<Id> excluded, long degree,\n+                                       long limit) {\n         if (limit == 0) {\n             return ImmutableSet.of();\n         }\n", "next_change": {"commit": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex 3ec1362b..ada4854a 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -97,6 +103,10 @@ public class HugeTraverser {\n         return this.graph.option(CoreOptions.OLTP_CONCURRENT_DEPTH);\n     }\n \n+    private CollectionType collectionType() {\n+        return this.graph.option(CoreOptions.OLTP_COLLECTION_TYPE);\n+    }\n+\n     protected Set<Id> adjacentVertices(Id sourceV, Set<Id> vertices,\n                                        Directions dir, Id label,\n                                        Set<Id> excluded, long degree,\n", "next_change": null}, {"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex 3ec1362b..ada4854a 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -105,7 +115,7 @@ public class HugeTraverser {\n             return ImmutableSet.of();\n         }\n \n-        Set<Id> neighbors = newSet();\n+        Set<Id> neighbors = newIdSet();\n         for (Id source : vertices) {\n             Iterator<Edge> edges = this.edgesOfVertex(source, dir,\n                                                       label, degree);\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "74b013ed211b6951cca82c778655c3d7a6839b56", "committedDate": "2020-11-18 21:30:34 +0800", "message": "oltp concurrent requests share multi executors instead of one executor (#1258)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "bc90cf9e0a636485efcd8949f665e3d8f311e1a0", "committedDate": "2021-01-07 14:36:39 +0800", "message": "add config for whether encoding number of primary keys (#1323)"}, {"oid": "de81038c2119634596e7d7f7cf23a245ed8e630f", "committedDate": "2021-05-12 14:15:05 +0800", "message": "refact: unify naming of degree for oltp algorithms (#1433)"}, {"oid": "718daa63679ce9984b870e9450c481cac8e4e414", "committedDate": "2021-05-21 20:30:48 +0800", "message": "refact: let kout degree applied to all labels & remove source vertex from kneighbor default results  (#1459)"}, {"oid": "9ef6796dc9c60679ffbe49e60fe31c7d23818f55", "committedDate": "2021-05-27 17:36:11 +0800", "message": "refact: remove source from kneighbor/kout results & unify 'degree ' error info (#1463)"}, {"oid": "d48b820a56eefe45c64f3e1d63bb2f001015e222", "committedDate": "2021-05-28 15:52:39 +0800", "message": "refact: unify kout/kneighbor get method with post (#1470)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "eef1f8b124557ecb3cdb4adf227721f424b9ad07", "committedDate": "2021-10-28 11:44:50 +0800", "message": "oltp traversal: optimize id2code for number id (#1623)"}, {"oid": "9f50e679830cd8a81a1bfef4fcc33afefab91a4e", "committedDate": "2021-12-15 19:33:56 +0800", "message": "refact: params improve for personal rank api (#1695)"}, {"oid": "a0ffdc47fbeb5872af05886561f6963159ac86c0", "committedDate": "2021-12-15 19:39:37 +0800", "message": "refact: early stop  & perf improve for paths traverser/api (#1694)"}, {"oid": "e9cef7425ddb12aa50a40c1fe1107a4b58041773", "committedDate": "2022-01-12 20:08:59 +0800", "message": "fix: useless ring detection removed valid path (#1723)"}, {"oid": "85b01b233392cd991739a035773629c7bf90e23b", "committedDate": "2022-04-25 19:13:30 +0800", "message": "chore: java 11 version support (#1653)"}, {"oid": "f6f8c3eda68554f8eefe53322955af8216260fe1", "committedDate": "2022-05-11 15:34:17 +0800", "message": "fix checkstyle core-util issue (#1855)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMzA5NQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496723095", "body": "ditto", "bodyText": "ditto", "bodyHTML": "<p dir=\"auto\">ditto</p>", "author": "javeme", "createdAt": "2020-09-29T13:37:31Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/JaccardSimilarTraverser.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.baidu.hugegraph.HugeException;\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.E;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class JaccardSimilarTraverser extends TpTraverser {\n+\n+    public JaccardSimilarTraverser(HugeGraph graph) {\n+        super(graph, \"jaccard-similar\");\n+    }\n+\n+    public Map<Id, Double> jaccardSimilars(Id source, EdgeStep step,\n+                                           int top, long capacity) {\n+        E.checkNotNull(source, \"source vertex id\");\n+        this.checkVertexExist(source, \"source vertex\");\n+        checkCapacity(capacity);\n+\n+        Map<Id, Double> results;\n+        if (3 >= this.concurrentDepth() &&\n+            step.direction == Directions.BOTH) {\n+            results = this.jaccardSimilarsConcurrent(source, step, capacity);\n+        } else {\n+            results = this.jaccardSimilarsSingle(source, step, capacity);\n+        }\n+\n+        if (top > 0) {\n+            results = HugeTraverser.topN(results, true, top);\n+        }\n+\n+        return results;\n+    }\n+\n+    public Map<Id, Double> jaccardSimilarsConcurrent(Id source, EdgeStep step,\n+                                                     long capacity) {\n+        AtomicLong count = new AtomicLong(0L);\n+        Set<Id> accessed = ConcurrentHashMap.newKeySet();\n+        accessed.add(source);\n+        reachCapacity(count.incrementAndGet(), capacity);\n+\n+        // Query neighbors\n+        Set<Id> layer1s = this.adjacentVertices(source, step);\n+        reachCapacity(count.get() + layer1s.size(), capacity);\n+        count.addAndGet(layer1s.size());\n+        if (layer1s.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+\n+        Map<Id, Double> results = new ConcurrentHashMap<>();\n+        Set<Id> layer2All = ConcurrentHashMap.newKeySet();\n+\n+        this.traverseIds(layer1s.iterator(), id -> {\n+            // Skip if accessed already\n+            if (accessed.contains(id)) {\n+                return;\n+            }\n+            Set<Id> layer2s = this.adjacentVertices(id, step);\n+            if (layer2s.isEmpty()) {\n+                results.put(id, 0.0D);\n+            }\n+\n+            layer2All.addAll(layer2s);\n+            reachCapacity(count.get() + layer2All.size(), capacity);\n+            double jaccardSimilarity = this.jaccardSimilarity(layer1s, layer2s);\n+            results.put(id, jaccardSimilarity);\n+            accessed.add(id);\n+        });\n+\n+        count.addAndGet(layer2All.size());\n+\n+        this.traverseIds(layer2All.iterator(), id -> {\n+            // Skip if accessed already\n+            if (accessed.contains(id)) {\n+                return;\n+            }\n+            Set<Id> layer3s = this.adjacentVertices(id, step);\n+            reachCapacity(count.get() + layer3s.size(), capacity);\n+            if (layer3s.isEmpty()) {\n+                results.put(id, 0.0D);\n+            }\n+\n+            double jaccardSimilarity = this.jaccardSimilarity(layer1s, layer3s);\n+            results.put(id, jaccardSimilarity);\n+            accessed.add(id);\n+        });\n+\n+        return results;\n+    }\n+\n+    public Map<Id, Double> jaccardSimilarsSingle(Id source, EdgeStep step,", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/JaccardSimilarTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/JaccardSimilarTraverser.java\nindex 59fbadfb..cc0571c6 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/JaccardSimilarTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/JaccardSimilarTraverser.java\n", "chunk": "@@ -119,7 +149,7 @@ public class JaccardSimilarTraverser extends TpTraverser {\n     public Map<Id, Double> jaccardSimilarsSingle(Id source, EdgeStep step,\n                                                  long capacity) {\n         long count = 0L;\n-        Set<Id> accessed = new HashSet<>();\n+        Set<Id> accessed = newIdSet();\n         accessed.add(source);\n         reachCapacity(++count, capacity);\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "52a8aae560aa22cc771d7890cbd631ab55915227", "committedDate": "2021-01-07 14:39:44 +0800", "message": "fix jaccard similarity nan (#1324)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "e7a6e62922e66c37ee6cd9b7c1c493761d16bcd6", "committedDate": "2021-08-02 17:56:51 +0800", "message": "optimize kout/kneighbor count (avoid copying set) (#1550)"}, {"oid": "f6f8c3eda68554f8eefe53322955af8216260fe1", "committedDate": "2022-05-11 15:34:17 +0800", "message": "fix checkstyle core-util issue (#1855)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"oid": "21ea44cac2593462828060d846c5192bc76a78dd", "url": "https://github.com/hugegraph/hugegraph/commit/21ea44cac2593462828060d846c5192bc76a78dd", "message": "improve\n\nChange-Id: I7d6912f33836ac9a36fd0dda82b446780675a390", "committedDate": "2020-10-12T13:10:10Z", "type": "commit"}, {"oid": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "url": "https://github.com/hugegraph/hugegraph/commit/876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "message": "extract path traverser for template paths and collection paths\n\nChange-Id: I5b7441f562106fa3810d6d844c897add3010ef30", "committedDate": "2020-10-13T12:31:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk3OTQxOQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503979419", "body": "no nearest when Concurrent?", "bodyText": "no nearest when Concurrent?", "bodyHTML": "<p dir=\"auto\">no nearest when Concurrent?</p>", "author": "javeme", "createdAt": "2020-10-13T14:04:05Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "diffHunk": "@@ -75,509 +73,215 @@ public CollectionPathsTraverser(HugeGraph graph) {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n-        Traverser traverser = depth >= this.concurrentDepth() ?\n-                              this.concurrentTraverser(sourceList, targetList,\n-                                                       step, nearest,\n-                                                       capacity, limit) :\n-                              this.singleTraverser(sourceList, targetList, step,\n-                                                   nearest, capacity, limit);\n-\n-        while (true) {\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n-            }\n-            traverser.forward();\n-\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n+        Traverser traverser;\n+\n+        TraverseStrategy strategy;\n+        if (depth >= this.concurrentDepth()) {\n+            strategy = new ConcurrentTraverseStrategy(this.graph());\n+            traverser = new Traverser(sourceList, targetList, step, depth,\n+                                      capacity, limit, strategy);\n+        } else {\n+            strategy = new SingleTraverseStrategy(this.graph());\n+            if (nearest) {\n+                traverser = new SingleNearestTraverser(sourceList, targetList,", "originalCommit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\nindex 2f5a0c23..3ae950c2 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n", "chunk": "@@ -74,22 +70,14 @@ public class CollectionPathsTraverser extends TpTraverser {\n         checkPositive(depth, \"max depth\");\n \n         Traverser traverser;\n-\n-        TraverseStrategy strategy;\n-        if (depth >= this.concurrentDepth()) {\n-            strategy = new ConcurrentTraverseStrategy(this.graph());\n-            traverser = new Traverser(sourceList, targetList, step, depth,\n-                                      capacity, limit, strategy);\n+        TraverseStrategy strategy = this.traverseStrategy(\n+                                    depth >= this.concurrentDepth());\n+        if (nearest) {\n+            traverser = new NearestTraverser(sourceList, targetList, step,\n+                                             depth, capacity, limit, strategy);\n         } else {\n-            strategy = new SingleTraverseStrategy(this.graph());\n-            if (nearest) {\n-                traverser = new SingleNearestTraverser(sourceList, targetList,\n-                                                       step, depth, capacity,\n-                                                       limit, strategy);\n-            } else {\n-                traverser = new Traverser(sourceList, targetList, step,\n-                                          depth, capacity, limit, strategy);\n-            }\n+            traverser = new Traverser(sourceList, targetList, step,\n+                                      depth, capacity, limit, strategy);\n         }\n \n         do {\n", "next_change": {"commit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\nindex 3ae950c2..7da8ea0e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n", "chunk": "@@ -69,40 +69,44 @@ public class CollectionPathsTraverser extends TpTraverser {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n+\n+        TraverseStrategy strategy = TraverseStrategy.create(\n+                                    depth >= this.concurrentDepth(),\n+                                    this.graph());\n         Traverser traverser;\n-        TraverseStrategy strategy = this.traverseStrategy(\n-                                    depth >= this.concurrentDepth());\n         if (nearest) {\n-            traverser = new NearestTraverser(sourceList, targetList, step,\n-                                             depth, capacity, limit, strategy);\n+            traverser = new NearestTraverser(this, strategy,\n+                                             sourceList, targetList, step,\n+                                             depth, capacity, limit);\n         } else {\n-            traverser = new Traverser(sourceList, targetList, step,\n-                                      depth, capacity, limit, strategy);\n+            traverser = new Traverser(this, strategy,\n+                                      sourceList, targetList, step,\n+                                      depth, capacity, limit);\n         }\n \n         do {\n             // Forward\n             traverser.forward();\n-            if (traverser.finish()) {\n+            if (traverser.finished()) {\n                 return traverser.paths();\n             }\n \n             // Backward\n             traverser.backward();\n-            if (traverser.finish()) {\n+            if (traverser.finished()) {\n                 return traverser.paths();\n             }\n         } while (true);\n     }\n \n-    private class Traverser extends PathTraverser {\n+    private static class Traverser extends PathTraverser {\n \n         protected final EdgeStep step;\n \n-        public Traverser(Collection<Id> sources, Collection<Id> targets,\n-                         EdgeStep step, int depth, long capacity,\n-                         long limit, TraverseStrategy strategy) {\n-            super(sources, targets, capacity, limit, strategy);\n+        public Traverser(HugeTraverser traverser, TraverseStrategy strategy,\n+                         Collection<Id> sources, Collection<Id> targets,\n+                         EdgeStep step, int depth, long capacity, long limit) {\n+            super(traverser, strategy, sources, targets, capacity, limit);\n             this.step = step;\n             this.totalSteps = depth;\n         }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\nindex 2f5a0c23..6f198946 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n", "chunk": "@@ -73,48 +69,43 @@ public class CollectionPathsTraverser extends TpTraverser {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n+        TraverseStrategy strategy = TraverseStrategy.create(\n+                                    depth >= this.concurrentDepth(),\n+                                    this.graph());\n         Traverser traverser;\n-\n-        TraverseStrategy strategy;\n-        if (depth >= this.concurrentDepth()) {\n-            strategy = new ConcurrentTraverseStrategy(this.graph());\n-            traverser = new Traverser(sourceList, targetList, step, depth,\n-                                      capacity, limit, strategy);\n+        if (nearest) {\n+            traverser = new NearestTraverser(this, strategy,\n+                                             sourceList, targetList, step,\n+                                             depth, capacity, limit);\n         } else {\n-            strategy = new SingleTraverseStrategy(this.graph());\n-            if (nearest) {\n-                traverser = new SingleNearestTraverser(sourceList, targetList,\n-                                                       step, depth, capacity,\n-                                                       limit, strategy);\n-            } else {\n-                traverser = new Traverser(sourceList, targetList, step,\n-                                          depth, capacity, limit, strategy);\n-            }\n+            traverser = new Traverser(this, strategy,\n+                                      sourceList, targetList, step,\n+                                      depth, capacity, limit);\n         }\n \n         do {\n             // Forward\n             traverser.forward();\n-            if (traverser.finish()) {\n+            if (traverser.finished()) {\n                 return traverser.paths();\n             }\n \n             // Backward\n             traverser.backward();\n-            if (traverser.finish()) {\n+            if (traverser.finished()) {\n                 return traverser.paths();\n             }\n         } while (true);\n     }\n \n-    private class Traverser extends PathTraverser {\n+    private static class Traverser extends PathTraverser {\n \n         protected final EdgeStep step;\n \n-        public Traverser(Collection<Id> sources, Collection<Id> targets,\n-                         EdgeStep step, int depth, long capacity,\n-                         long limit, TraverseStrategy strategy) {\n-            super(sources, targets, capacity, limit, strategy);\n+        public Traverser(HugeTraverser traverser, TraverseStrategy strategy,\n+                         Collection<Id> sources, Collection<Id> targets,\n+                         EdgeStep step, int depth, long capacity, long limit) {\n+            super(traverser, strategy, sources, targets, capacity, limit);\n             this.step = step;\n             this.totalSteps = depth;\n         }\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MDE0OA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503980148", "body": "unused empty line", "bodyText": "unused empty line", "bodyHTML": "<p dir=\"auto\">unused empty line</p>", "author": "javeme", "createdAt": "2020-10-13T14:05:01Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "diffHunk": "@@ -75,509 +73,215 @@ public CollectionPathsTraverser(HugeGraph graph) {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n-        Traverser traverser = depth >= this.concurrentDepth() ?\n-                              this.concurrentTraverser(sourceList, targetList,\n-                                                       step, nearest,\n-                                                       capacity, limit) :\n-                              this.singleTraverser(sourceList, targetList, step,\n-                                                   nearest, capacity, limit);\n-\n-        while (true) {\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n-            }\n-            traverser.forward();\n-\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n+        Traverser traverser;\n+", "originalCommit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3OTAzMw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509079033", "bodyText": "unused empty line", "author": "javeme", "createdAt": "2020-10-21T08:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MDE0OA=="}], "type": "inlineReview", "revised_code": {"commit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\nindex 2f5a0c23..3ae950c2 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n", "chunk": "@@ -74,22 +70,14 @@ public class CollectionPathsTraverser extends TpTraverser {\n         checkPositive(depth, \"max depth\");\n \n         Traverser traverser;\n-\n-        TraverseStrategy strategy;\n-        if (depth >= this.concurrentDepth()) {\n-            strategy = new ConcurrentTraverseStrategy(this.graph());\n-            traverser = new Traverser(sourceList, targetList, step, depth,\n-                                      capacity, limit, strategy);\n+        TraverseStrategy strategy = this.traverseStrategy(\n+                                    depth >= this.concurrentDepth());\n+        if (nearest) {\n+            traverser = new NearestTraverser(sourceList, targetList, step,\n+                                             depth, capacity, limit, strategy);\n         } else {\n-            strategy = new SingleTraverseStrategy(this.graph());\n-            if (nearest) {\n-                traverser = new SingleNearestTraverser(sourceList, targetList,\n-                                                       step, depth, capacity,\n-                                                       limit, strategy);\n-            } else {\n-                traverser = new Traverser(sourceList, targetList, step,\n-                                          depth, capacity, limit, strategy);\n-            }\n+            traverser = new Traverser(sourceList, targetList, step,\n+                                      depth, capacity, limit, strategy);\n         }\n \n         do {\n", "next_change": {"commit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\nindex 3ae950c2..7da8ea0e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n", "chunk": "@@ -69,40 +69,44 @@ public class CollectionPathsTraverser extends TpTraverser {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n+\n+        TraverseStrategy strategy = TraverseStrategy.create(\n+                                    depth >= this.concurrentDepth(),\n+                                    this.graph());\n         Traverser traverser;\n-        TraverseStrategy strategy = this.traverseStrategy(\n-                                    depth >= this.concurrentDepth());\n         if (nearest) {\n-            traverser = new NearestTraverser(sourceList, targetList, step,\n-                                             depth, capacity, limit, strategy);\n+            traverser = new NearestTraverser(this, strategy,\n+                                             sourceList, targetList, step,\n+                                             depth, capacity, limit);\n         } else {\n-            traverser = new Traverser(sourceList, targetList, step,\n-                                      depth, capacity, limit, strategy);\n+            traverser = new Traverser(this, strategy,\n+                                      sourceList, targetList, step,\n+                                      depth, capacity, limit);\n         }\n \n         do {\n             // Forward\n             traverser.forward();\n-            if (traverser.finish()) {\n+            if (traverser.finished()) {\n                 return traverser.paths();\n             }\n \n             // Backward\n             traverser.backward();\n-            if (traverser.finish()) {\n+            if (traverser.finished()) {\n                 return traverser.paths();\n             }\n         } while (true);\n     }\n \n-    private class Traverser extends PathTraverser {\n+    private static class Traverser extends PathTraverser {\n \n         protected final EdgeStep step;\n \n-        public Traverser(Collection<Id> sources, Collection<Id> targets,\n-                         EdgeStep step, int depth, long capacity,\n-                         long limit, TraverseStrategy strategy) {\n-            super(sources, targets, capacity, limit, strategy);\n+        public Traverser(HugeTraverser traverser, TraverseStrategy strategy,\n+                         Collection<Id> sources, Collection<Id> targets,\n+                         EdgeStep step, int depth, long capacity, long limit) {\n+            super(traverser, strategy, sources, targets, capacity, limit);\n             this.step = step;\n             this.totalSteps = depth;\n         }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\nindex 2f5a0c23..6f198946 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java\n", "chunk": "@@ -73,48 +69,43 @@ public class CollectionPathsTraverser extends TpTraverser {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n+        TraverseStrategy strategy = TraverseStrategy.create(\n+                                    depth >= this.concurrentDepth(),\n+                                    this.graph());\n         Traverser traverser;\n-\n-        TraverseStrategy strategy;\n-        if (depth >= this.concurrentDepth()) {\n-            strategy = new ConcurrentTraverseStrategy(this.graph());\n-            traverser = new Traverser(sourceList, targetList, step, depth,\n-                                      capacity, limit, strategy);\n+        if (nearest) {\n+            traverser = new NearestTraverser(this, strategy,\n+                                             sourceList, targetList, step,\n+                                             depth, capacity, limit);\n         } else {\n-            strategy = new SingleTraverseStrategy(this.graph());\n-            if (nearest) {\n-                traverser = new SingleNearestTraverser(sourceList, targetList,\n-                                                       step, depth, capacity,\n-                                                       limit, strategy);\n-            } else {\n-                traverser = new Traverser(sourceList, targetList, step,\n-                                          depth, capacity, limit, strategy);\n-            }\n+            traverser = new Traverser(this, strategy,\n+                                      sourceList, targetList, step,\n+                                      depth, capacity, limit);\n         }\n \n         do {\n             // Forward\n             traverser.forward();\n-            if (traverser.finish()) {\n+            if (traverser.finished()) {\n                 return traverser.paths();\n             }\n \n             // Backward\n             traverser.backward();\n-            if (traverser.finish()) {\n+            if (traverser.finished()) {\n                 return traverser.paths();\n             }\n         } while (true);\n     }\n \n-    private class Traverser extends PathTraverser {\n+    private static class Traverser extends PathTraverser {\n \n         protected final EdgeStep step;\n \n-        public Traverser(Collection<Id> sources, Collection<Id> targets,\n-                         EdgeStep step, int depth, long capacity,\n-                         long limit, TraverseStrategy strategy) {\n-            super(sources, targets, capacity, limit, strategy);\n+        public Traverser(HugeTraverser traverser, TraverseStrategy strategy,\n+                         Collection<Id> sources, Collection<Id> targets,\n+                         EdgeStep step, int depth, long capacity, long limit) {\n+            super(traverser, strategy, sources, targets, capacity, limit);\n             this.step = step;\n             this.totalSteps = depth;\n         }\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "645f1a363e29e9fff2febdde6ea9f7b8dea58811", "committedDate": "2020-11-05 17:27:33 +0800", "message": "cleanup warning for 0.11.2 (#1243)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MTg2NQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503981865", "body": "prefer rename to concurrent", "bodyText": "prefer rename to concurrent", "bodyHTML": "<p dir=\"auto\">prefer rename to concurrent</p>", "author": "javeme", "createdAt": "2020-10-13T14:07:15Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -540,7 +403,15 @@ public static void checkSkipDegree(long skipDegree, long degree,\n     }\n \n     protected static <V> Set<V> newSet() {\n-        return new HashSet<>();\n+        return newSet(true);\n+    }\n+\n+    protected static <V> Set<V> newSet(boolean single) {", "originalCommit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex 3ef436ee..c3ed9cbd 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -403,14 +403,14 @@ public class HugeTraverser {\n     }\n \n     protected static <V> Set<V> newSet() {\n-        return newSet(true);\n+        return newSet(false);\n     }\n \n-    protected static <V> Set<V> newSet(boolean single) {\n-        if (single) {\n-            return new HashSet<>();\n-        } else {\n+    protected static <V> Set<V> newSet(boolean concurrent) {\n+        if (concurrent) {\n             return ConcurrentHashMap.newKeySet();\n+        } else {\n+            return new HashSet<>();\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex 3ef436ee..8f6102f9 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -403,14 +413,14 @@ public class HugeTraverser {\n     }\n \n     protected static <V> Set<V> newSet() {\n-        return newSet(true);\n+        return newSet(false);\n     }\n \n-    protected static <V> Set<V> newSet(boolean single) {\n-        if (single) {\n-            return new HashSet<>();\n-        } else {\n+    protected static <V> Set<V> newSet(boolean concurrent) {\n+        if (concurrent) {\n             return ConcurrentHashMap.newKeySet();\n+        } else {\n+            return new HashSet<>();\n         }\n     }\n \n", "next_change": {"commit": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\nindex 8f6102f9..ada4854a 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java\n", "chunk": "@@ -420,12 +426,36 @@ public class HugeTraverser {\n         if (concurrent) {\n             return ConcurrentHashMap.newKeySet();\n         } else {\n-            return new HashSet<>();\n+            return collectionFactory.newSet();\n         }\n     }\n \n+    protected static <V> Set<V> newSet(int initialCapacity) {\n+        return collectionFactory.newSet(initialCapacity);\n+    }\n+\n+    protected static <V> Set<V> newSet(Collection<V> collection) {\n+        return collectionFactory.newSet(collection);\n+    }\n+\n+    protected static <V> List<V> newList() {\n+        return collectionFactory.newList();\n+    }\n+\n+    protected static <V> List<V> newList(int initialCapacity) {\n+        return collectionFactory.newList(initialCapacity);\n+    }\n+\n+    protected static <V> List<V> newList(Collection<V> collection) {\n+        return collectionFactory.newList(collection);\n+    }\n+\n     protected static <K, V> Map<K, V> newMap() {\n-        return new HashMap<>();\n+        return collectionFactory.newMap();\n+    }\n+\n+    protected static <K, V> Map<K, V> newMap(int initialCapacity) {\n+        return collectionFactory.newMap(initialCapacity);\n     }\n \n     protected static <K, V> MultivaluedMap<K, V> newMultivalueMap() {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "2f6147f3fdbf2566f8d00e7393265e57b81acad8", "committedDate": "2020-11-10 21:26:08 +0800", "message": "Fix weighted shortest path NPE (#1250)"}, {"oid": "74b013ed211b6951cca82c778655c3d7a6839b56", "committedDate": "2020-11-18 21:30:34 +0800", "message": "oltp concurrent requests share multi executors instead of one executor (#1258)"}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "bc90cf9e0a636485efcd8949f665e3d8f311e1a0", "committedDate": "2021-01-07 14:36:39 +0800", "message": "add config for whether encoding number of primary keys (#1323)"}, {"oid": "de81038c2119634596e7d7f7cf23a245ed8e630f", "committedDate": "2021-05-12 14:15:05 +0800", "message": "refact: unify naming of degree for oltp algorithms (#1433)"}, {"oid": "718daa63679ce9984b870e9450c481cac8e4e414", "committedDate": "2021-05-21 20:30:48 +0800", "message": "refact: let kout degree applied to all labels & remove source vertex from kneighbor default results  (#1459)"}, {"oid": "9ef6796dc9c60679ffbe49e60fe31c7d23818f55", "committedDate": "2021-05-27 17:36:11 +0800", "message": "refact: remove source from kneighbor/kout results & unify 'degree ' error info (#1463)"}, {"oid": "d48b820a56eefe45c64f3e1d63bb2f001015e222", "committedDate": "2021-05-28 15:52:39 +0800", "message": "refact: unify kout/kneighbor get method with post (#1470)"}, {"oid": "23e3c31a5445cd472e16c6a625a119ca0ab4b04d", "committedDate": "2021-06-09 17:36:47 +0800", "message": "Collection optimize for OLTP algorithm and HugeElement (#1409)"}, {"oid": "eef1f8b124557ecb3cdb4adf227721f424b9ad07", "committedDate": "2021-10-28 11:44:50 +0800", "message": "oltp traversal: optimize id2code for number id (#1623)"}, {"oid": "9f50e679830cd8a81a1bfef4fcc33afefab91a4e", "committedDate": "2021-12-15 19:33:56 +0800", "message": "refact: params improve for personal rank api (#1695)"}, {"oid": "a0ffdc47fbeb5872af05886561f6963159ac86c0", "committedDate": "2021-12-15 19:39:37 +0800", "message": "refact: early stop  & perf improve for paths traverser/api (#1694)"}, {"oid": "e9cef7425ddb12aa50a40c1fe1107a4b58041773", "committedDate": "2022-01-12 20:08:59 +0800", "message": "fix: useless ring detection removed valid path (#1723)"}, {"oid": "85b01b233392cd991739a035773629c7bf90e23b", "committedDate": "2022-04-25 19:13:30 +0800", "message": "chore: java 11 version support (#1653)"}, {"oid": "f6f8c3eda68554f8eefe53322955af8216260fe1", "committedDate": "2022-05-11 15:34:17 +0800", "message": "fix checkstyle core-util issue (#1855)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MjkwMQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503982901", "body": "add a new java file", "bodyText": "add a new java file", "bodyHTML": "<p dir=\"auto\">add a new java file</p>", "author": "javeme", "createdAt": "2020-10-13T14:08:35Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "diffHunk": "@@ -160,6 +177,199 @@ protected boolean match(Element elem, String key, Object value) {\n         return p.isPresent() && Objects.equal(p.value(), value);\n     }\n \n+    protected TraverseStrategy traverseStrategy(boolean single) {\n+        return single ? new SingleTraverseStrategy(this.graph()) :\n+                        new ConcurrentTraverseStrategy(this.graph());\n+\n+    }\n+\n+    public abstract class PathTraverser {", "originalCommit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\nindex 3a0b07e4..62429b6e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\n", "chunk": "@@ -177,199 +177,12 @@ public abstract class TpTraverser extends HugeTraverser\n         return p.isPresent() && Objects.equal(p.value(), value);\n     }\n \n-    protected TraverseStrategy traverseStrategy(boolean single) {\n-        return single ? new SingleTraverseStrategy(this.graph()) :\n-                        new ConcurrentTraverseStrategy(this.graph());\n+    protected TraverseStrategy traverseStrategy(boolean concurrent) {\n+        return concurrent ? new ConcurrentTraverseStrategy(this.graph()) :\n+                            new SingleTraverseStrategy(this.graph());\n \n     }\n \n-    public abstract class PathTraverser {\n-\n-        protected int stepCount;\n-        protected final long capacity;\n-        protected final long limit;\n-        protected int totalSteps; // TODO: delete or implement abstract method\n-\n-        protected Map<Id, List<Node>> sources;\n-        protected Map<Id, List<Node>> sourcesAll;\n-        protected Map<Id, List<Node>> targets;\n-        protected Map<Id, List<Node>> targetsAll;\n-\n-        protected Map<Id, List<Node>> newVertices;\n-\n-        protected Set<HugeTraverser.Path> paths;\n-\n-        protected TraverseStrategy traverseStrategy;\n-\n-        public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n-                             long capacity, long limit,\n-                             TraverseStrategy strategy) {\n-            this.traverseStrategy = strategy;\n-\n-            this.capacity = capacity;\n-            this.limit = limit;\n-\n-            this.stepCount = 0;\n-\n-            this.sources = this.newMultiValueMap();\n-            this.sourcesAll = this.newMultiValueMap();\n-            this.targets = this.newMultiValueMap();\n-            this.targetsAll = this.newMultiValueMap();\n-\n-            for (Id id : sources) {\n-                this.addNode(this.sources, id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.addNode(this.targets, id, new Node(id));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-\n-            this.paths = this.newPathSet();\n-        }\n-\n-        public void forward() {\n-            EdgeStep currentStep = this.nextStep(true);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(true);\n-\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.sources, currentStep, this::forward);\n-\n-            this.afterTraverse(currentStep, true);\n-        }\n-\n-        public void backward() {\n-            EdgeStep currentStep = this.nextStep(false);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(false);\n-\n-            currentStep.swithDirection();\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.targets, currentStep, this::backward);\n-            currentStep.swithDirection();\n-\n-            this.afterTraverse(currentStep, false);\n-        }\n-\n-        public abstract EdgeStep nextStep(boolean forward);\n-\n-        public void beforeTraverse(boolean forward) {\n-            this.clearNewVertices();\n-        }\n-\n-        public void traverseOneLayer(Map<Id, List<Node>> vertices,\n-                                     EdgeStep step,\n-                                     BiConsumer<Id, EdgeStep> consumer) {\n-            this.traverseStrategy.traverseOneLayer(vertices, step, consumer);\n-        }\n-\n-        public void afterTraverse(EdgeStep step, boolean forward) {\n-            this.reInitCurrentStepIfNeeded(step, forward);\n-            this.stepCount++;\n-        }\n-\n-        private void forward(Id v, EdgeStep step) {\n-            this.traverseOne(v, step, true);\n-        }\n-\n-        private void backward(Id v, EdgeStep step) {\n-            this.traverseOne(v, step, false);\n-        }\n-\n-        private void traverseOne(Id v, EdgeStep step, boolean forward) {\n-            if (this.reachLimit()) {\n-                return;\n-            }\n-\n-            Iterator<Edge> edges = edgesOfVertex(v, step);\n-            while (edges.hasNext()) {\n-                HugeEdge edge = (HugeEdge) edges.next();\n-                Id target = edge.id().otherVertexId();\n-\n-                this.processOne(v, target, forward);\n-            }\n-        }\n-\n-        private void processOne(Id source, Id target, boolean forward) {\n-            if (forward) {\n-                processOneForForward(source, target);\n-            } else {\n-                processOneForBackward(source, target);\n-            }\n-        }\n-\n-        protected abstract void processOneForForward(Id source, Id target);\n-\n-        protected abstract void processOneForBackward(Id source, Id target);\n-\n-        protected abstract void reInitCurrentStepIfNeeded(EdgeStep step,\n-                                                          boolean forward);\n-\n-        public void clearNewVertices() {\n-            this.newVertices = this.newMultiValueMap();\n-        }\n-\n-        public void addNodeToNewVertices(Id id, Node node) {\n-            this.addNode(this.newVertices, id, node);\n-        }\n-\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return this.traverseStrategy.newMultiValueMap();\n-        }\n-\n-        public Set<HugeTraverser.Path> newPathSet() {\n-            return this.traverseStrategy.newPathSet();\n-        }\n-\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            this.traverseStrategy.addNode(vertices, id, node);\n-        }\n-\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            this.traverseStrategy.addNewVerticesToAll(this.newVertices,\n-                                                      targets);\n-        }\n-\n-        public Set<HugeTraverser.Path> paths() {\n-            return this.paths;\n-        }\n-\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n-        }\n-\n-        protected boolean reachLimit() {\n-            HugeTraverser.checkCapacity(this.capacity, this.accessedNodes(),\n-                                        \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        protected int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n-            }\n-            return size;\n-        }\n-    }\n-\n     public class ConcurrentMultiValuedMap<K, V>\n            extends ConcurrentHashMap<K, List<V>> {\n \n", "next_change": {"commit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\nindex 62429b6e..cbf06f7d 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\n", "chunk": "@@ -177,12 +160,6 @@ public abstract class TpTraverser extends HugeTraverser\n         return p.isPresent() && Objects.equal(p.value(), value);\n     }\n \n-    protected TraverseStrategy traverseStrategy(boolean concurrent) {\n-        return concurrent ? new ConcurrentTraverseStrategy(this.graph()) :\n-                            new SingleTraverseStrategy(this.graph());\n-\n-    }\n-\n     public class ConcurrentMultiValuedMap<K, V>\n            extends ConcurrentHashMap<K, List<V>> {\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\ndeleted file mode 100644\nindex 3a0b07e4..00000000\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\n+++ /dev/null\n", "chunk": "@@ -1,402 +0,0 @@\n-/*\n- * Copyright 2017 HugeGraph Authors\n- *\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with this\n- * work for additional information regarding copyright ownership. The ASF\n- * licenses this file to You under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.baidu.hugegraph.traversal.algorithm;\n-\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n-\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.apache.tinkerpop.gremlin.structure.Edge;\n-import org.apache.tinkerpop.gremlin.structure.Element;\n-import org.apache.tinkerpop.gremlin.structure.Property;\n-import org.apache.tinkerpop.gremlin.structure.Vertex;\n-import org.apache.tinkerpop.gremlin.structure.util.CloseableIterator;\n-\n-import com.baidu.hugegraph.HugeGraph;\n-import com.baidu.hugegraph.backend.id.Id;\n-import com.baidu.hugegraph.config.CoreOptions;\n-import com.baidu.hugegraph.config.HugeConfig;\n-import com.baidu.hugegraph.iterator.FilterIterator;\n-import com.baidu.hugegraph.structure.HugeEdge;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.ConcurrentTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.SingleTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n-import com.baidu.hugegraph.util.Consumers;\n-\n-import jersey.repackaged.com.google.common.base.Objects;\n-\n-public abstract class TpTraverser extends HugeTraverser\n-                                  implements AutoCloseable {\n-\n-    protected static ExecutorService executor;\n-\n-    protected TpTraverser(HugeGraph graph) {\n-        super(graph);\n-    }\n-\n-    protected TpTraverser(HugeGraph graph, String name) {\n-        super(graph);\n-        if (executor == null) {\n-            int workers = this.config().get(CoreOptions.OLTP_CONCURRENT_THREADS);\n-            if (workers > 0) {\n-                executor = Consumers.newThreadPool(name, workers);\n-            }\n-        }\n-    }\n-\n-    protected int concurrentDepth() {\n-        if (executor == null) {\n-            return Integer.MAX_VALUE;\n-        }\n-        return this.config().get(CoreOptions.OLTP_CONCURRENT_DEPTH);\n-    }\n-\n-    protected HugeConfig config() {\n-        return ((HugeConfig) this.graph().hugegraph().configuration());\n-    }\n-\n-    @Override\n-    public void close() {\n-        if (executor != null) {\n-            executor.shutdown();\n-            executor = null;\n-        }\n-    }\n-\n-    protected Set<Node> adjacentVertices(Set<Node> latest, EdgeStep step,\n-                                         Set<Node> all, long remaining,\n-                                         boolean single) {\n-        if (single) {\n-            return this.adjacentVertices(latest, step, all, remaining);\n-        } else {\n-            AtomicLong remain = new AtomicLong(remaining);\n-            return this.adjacentVertices(latest, step, all, remain);\n-        }\n-    }\n-\n-    protected Set<Node> adjacentVertices(Set<Node> vertices, EdgeStep step,\n-                                         Set<Node> excluded,\n-                                         AtomicLong remaining) {\n-        Set<Node> neighbors = ConcurrentHashMap.newKeySet();\n-        this.traverseNodes(vertices.iterator(), v -> {\n-            Iterator<Edge> edges = this.edgesOfVertex(v.id(), step);\n-            while (edges.hasNext()) {\n-                Id target = ((HugeEdge) edges.next()).id().otherVertexId();\n-                KNode kNode = new KNode(target, (KNode) v);\n-                if (excluded != null && excluded.contains(kNode)) {\n-                    continue;\n-                }\n-                neighbors.add(kNode);\n-                if (remaining.decrementAndGet() <= 0L) {\n-                    return;\n-                }\n-            }\n-        });\n-        return neighbors;\n-    }\n-\n-    protected long traverseNodes(Iterator<Node> vertices,\n-                                 Consumer<Node> consumer) {\n-        return this.traverse(vertices, consumer, \"traverse-nodes\");\n-    }\n-\n-    protected long traversePairs(Iterator<Pair<Id, Id>> pairs,\n-                                 Consumer<Pair<Id, Id>> consumer) {\n-        return this.traverse(pairs, consumer, \"traverse-pairs\");\n-    }\n-\n-    protected long traverseIds(Iterator<Id> ids, Consumer<Id> consumer) {\n-        return this.traverse(ids, consumer, \"traverse-ids\");\n-    }\n-\n-    protected <K> long traverse(Iterator<K> iterator, Consumer<K> consumer,\n-                                String name) {\n-        Consumers<K> consumers = new Consumers<>(executor, consumer, null);\n-        consumers.start(name);\n-        long total = 0L;\n-        try {\n-            while (iterator.hasNext()) {\n-                total++;\n-                K v = iterator.next();\n-                consumers.provide(v);\n-            }\n-        } catch (Consumers.StopExecution e) {\n-            // pass\n-        } catch (Throwable e) {\n-            throw Consumers.wrapException(e);\n-        } finally {\n-            try {\n-                consumers.await();\n-            } catch (Throwable e) {\n-                Consumers.wrapException(e);\n-            } finally {\n-                CloseableIterator.closeIterator(iterator);\n-            }\n-        }\n-        return total;\n-    }\n-\n-    protected Iterator<Vertex> filter(Iterator<Vertex> vertices,\n-                                      String key, Object value) {\n-        return new FilterIterator<>(vertices, vertex -> {\n-            return match(vertex, key, value);\n-        });\n-    }\n-\n-    protected boolean match(Element elem, String key, Object value) {\n-        // check property key exists\n-        this.graph().propertyKey(key);\n-        // return true if property value exists & equals to specified value\n-        Property<Object> p = elem.property(key);\n-        return p.isPresent() && Objects.equal(p.value(), value);\n-    }\n-\n-    protected TraverseStrategy traverseStrategy(boolean single) {\n-        return single ? new SingleTraverseStrategy(this.graph()) :\n-                        new ConcurrentTraverseStrategy(this.graph());\n-\n-    }\n-\n-    public abstract class PathTraverser {\n-\n-        protected int stepCount;\n-        protected final long capacity;\n-        protected final long limit;\n-        protected int totalSteps; // TODO: delete or implement abstract method\n-\n-        protected Map<Id, List<Node>> sources;\n-        protected Map<Id, List<Node>> sourcesAll;\n-        protected Map<Id, List<Node>> targets;\n-        protected Map<Id, List<Node>> targetsAll;\n-\n-        protected Map<Id, List<Node>> newVertices;\n-\n-        protected Set<HugeTraverser.Path> paths;\n-\n-        protected TraverseStrategy traverseStrategy;\n-\n-        public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n-                             long capacity, long limit,\n-                             TraverseStrategy strategy) {\n-            this.traverseStrategy = strategy;\n-\n-            this.capacity = capacity;\n-            this.limit = limit;\n-\n-            this.stepCount = 0;\n-\n-            this.sources = this.newMultiValueMap();\n-            this.sourcesAll = this.newMultiValueMap();\n-            this.targets = this.newMultiValueMap();\n-            this.targetsAll = this.newMultiValueMap();\n-\n-            for (Id id : sources) {\n-                this.addNode(this.sources, id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.addNode(this.targets, id, new Node(id));\n-            }\n-            this.sourcesAll.putAll(this.sources);\n-            this.targetsAll.putAll(this.targets);\n-\n-            this.paths = this.newPathSet();\n-        }\n-\n-        public void forward() {\n-            EdgeStep currentStep = this.nextStep(true);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(true);\n-\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.sources, currentStep, this::forward);\n-\n-            this.afterTraverse(currentStep, true);\n-        }\n-\n-        public void backward() {\n-            EdgeStep currentStep = this.nextStep(false);\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            this.beforeTraverse(false);\n-\n-            currentStep.swithDirection();\n-            // Traversal vertices of previous level\n-            traverseOneLayer(this.targets, currentStep, this::backward);\n-            currentStep.swithDirection();\n-\n-            this.afterTraverse(currentStep, false);\n-        }\n-\n-        public abstract EdgeStep nextStep(boolean forward);\n-\n-        public void beforeTraverse(boolean forward) {\n-            this.clearNewVertices();\n-        }\n-\n-        public void traverseOneLayer(Map<Id, List<Node>> vertices,\n-                                     EdgeStep step,\n-                                     BiConsumer<Id, EdgeStep> consumer) {\n-            this.traverseStrategy.traverseOneLayer(vertices, step, consumer);\n-        }\n-\n-        public void afterTraverse(EdgeStep step, boolean forward) {\n-            this.reInitCurrentStepIfNeeded(step, forward);\n-            this.stepCount++;\n-        }\n-\n-        private void forward(Id v, EdgeStep step) {\n-            this.traverseOne(v, step, true);\n-        }\n-\n-        private void backward(Id v, EdgeStep step) {\n-            this.traverseOne(v, step, false);\n-        }\n-\n-        private void traverseOne(Id v, EdgeStep step, boolean forward) {\n-            if (this.reachLimit()) {\n-                return;\n-            }\n-\n-            Iterator<Edge> edges = edgesOfVertex(v, step);\n-            while (edges.hasNext()) {\n-                HugeEdge edge = (HugeEdge) edges.next();\n-                Id target = edge.id().otherVertexId();\n-\n-                this.processOne(v, target, forward);\n-            }\n-        }\n-\n-        private void processOne(Id source, Id target, boolean forward) {\n-            if (forward) {\n-                processOneForForward(source, target);\n-            } else {\n-                processOneForBackward(source, target);\n-            }\n-        }\n-\n-        protected abstract void processOneForForward(Id source, Id target);\n-\n-        protected abstract void processOneForBackward(Id source, Id target);\n-\n-        protected abstract void reInitCurrentStepIfNeeded(EdgeStep step,\n-                                                          boolean forward);\n-\n-        public void clearNewVertices() {\n-            this.newVertices = this.newMultiValueMap();\n-        }\n-\n-        public void addNodeToNewVertices(Id id, Node node) {\n-            this.addNode(this.newVertices, id, node);\n-        }\n-\n-        public Map<Id, List<Node>> newMultiValueMap() {\n-            return this.traverseStrategy.newMultiValueMap();\n-        }\n-\n-        public Set<HugeTraverser.Path> newPathSet() {\n-            return this.traverseStrategy.newPathSet();\n-        }\n-\n-        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n-            this.traverseStrategy.addNode(vertices, id, node);\n-        }\n-\n-        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n-            this.traverseStrategy.addNewVerticesToAll(this.newVertices,\n-                                                      targets);\n-        }\n-\n-        public Set<HugeTraverser.Path> paths() {\n-            return this.paths;\n-        }\n-\n-        public int pathCount() {\n-            return this.paths.size();\n-        }\n-\n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n-        }\n-\n-        protected boolean reachLimit() {\n-            HugeTraverser.checkCapacity(this.capacity, this.accessedNodes(),\n-                                        \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n-        }\n-\n-        protected int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n-            }\n-            return size;\n-        }\n-    }\n-\n-    public class ConcurrentMultiValuedMap<K, V>\n-           extends ConcurrentHashMap<K, List<V>> {\n-\n-        public ConcurrentMultiValuedMap() {\n-            super();\n-        }\n-\n-        public void add(K key, V value) {\n-            List<V> values = this.getValues(key);\n-            values.add(value);\n-        }\n-\n-        public void addAll(K key, List<V> value) {\n-            List<V> values = this.getValues(key);\n-            values.addAll(value);\n-        }\n-\n-        public List<V> getValues(K key) {\n-            List<V> values = this.get(key);\n-            if (values == null) {\n-                values = new CopyOnWriteArrayList<>();\n-                List<V> old = this.putIfAbsent(key, values);\n-                if (old != null) {\n-                    values = old;\n-                }\n-            }\n-            return values;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}]}, {"oid": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "url": "https://github.com/hugegraph/hugegraph/commit/9e8372a3adb05d109ed1c640a0087016ab0ad571", "message": "improve\n\nChange-Id: I760194b0f02a41873c2157a5ddf59dd4d1c3ceff", "committedDate": "2020-10-14T03:12:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjY0Mw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508436643", "body": "this.traverseOneLayer", "bodyText": "this.traverseOneLayer", "bodyHTML": "<p dir=\"auto\">this.traverseOneLayer</p>", "author": "javeme", "createdAt": "2020-10-20T11:52:29Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\nindex 6d770253..9551009e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n", "chunk": "@@ -88,7 +91,7 @@ public abstract class PathTraverser {\n         this.beforeTraverse(true);\n \n         // Traversal vertices of previous level\n-        traverseOneLayer(this.sources, currentStep, this::forward);\n+        this.traverseOneLayer(this.sources, currentStep, this::forward);\n \n         this.afterTraverse(currentStep, true);\n     }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\nindex 6d770253..9551009e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n", "chunk": "@@ -88,7 +91,7 @@ public abstract class PathTraverser {\n         this.beforeTraverse(true);\n \n         // Traversal vertices of previous level\n-        traverseOneLayer(this.sources, currentStep, this::forward);\n+        this.traverseOneLayer(this.sources, currentStep, this::forward);\n \n         this.afterTraverse(currentStep, true);\n     }\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNzUxMA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508437510", "body": "ditto", "bodyText": "ditto", "bodyHTML": "<p dir=\"auto\">ditto</p>", "author": "javeme", "createdAt": "2020-10-20T11:54:08Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\nindex 6d770253..9551009e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n", "chunk": "@@ -103,7 +106,7 @@ public abstract class PathTraverser {\n \n         currentStep.swithDirection();\n         // Traversal vertices of previous level\n-        traverseOneLayer(this.targets, currentStep, this::backward);\n+        this.traverseOneLayer(this.targets, currentStep, this::backward);\n         currentStep.swithDirection();\n \n         this.afterTraverse(currentStep, false);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\nindex 6d770253..9551009e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n", "chunk": "@@ -103,7 +106,7 @@ public abstract class PathTraverser {\n \n         currentStep.swithDirection();\n         // Traversal vertices of previous level\n-        traverseOneLayer(this.targets, currentStep, this::backward);\n+        this.traverseOneLayer(this.targets, currentStep, this::backward);\n         currentStep.swithDirection();\n \n         this.afterTraverse(currentStep, false);\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNzczNA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508437734", "body": "ditto", "bodyText": "ditto", "bodyHTML": "<p dir=\"auto\">ditto</p>", "author": "javeme", "createdAt": "2020-10-20T11:54:30Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);\n+        currentStep.swithDirection();\n+\n+        this.afterTraverse(currentStep, false);\n+    }\n+\n+    public abstract EdgeStep nextStep(boolean forward);\n+\n+    public void beforeTraverse(boolean forward) {\n+        this.clearNewVertices();\n+    }\n+\n+    public void traverseOneLayer(Map<Id, List<HugeTraverser.Node>> vertices,\n+                                 EdgeStep step,\n+                                 BiConsumer<Id, EdgeStep> consumer) {\n+        this.traverseStrategy.traverseOneLayer(vertices, step, consumer);\n+    }\n+\n+    public void afterTraverse(EdgeStep step, boolean forward) {\n+        this.reInitCurrentStepIfNeeded(step, forward);\n+        this.stepCount++;\n+    }\n+\n+    private void forward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, true);\n+    }\n+\n+    private void backward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, false);\n+    }\n+\n+    private void traverseOne(Id v, EdgeStep step, boolean forward) {\n+        if (this.reachLimit()) {\n+            return;\n+        }\n+\n+        Iterator<Edge> edges = this.edgesOfVertex(v, step);\n+        while (edges.hasNext()) {\n+            HugeEdge edge = (HugeEdge) edges.next();\n+            Id target = edge.id().otherVertexId();\n+\n+            this.processOne(v, target, forward);\n+        }\n+    }\n+\n+    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n+    }\n+\n+    private void processOne(Id source, Id target, boolean forward) {\n+        if (forward) {\n+            processOneForForward(source, target);", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\nindex 6d770253..9551009e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n", "chunk": "@@ -148,15 +151,11 @@ public abstract class PathTraverser {\n         }\n     }\n \n-    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n-        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n-    }\n-\n     private void processOne(Id source, Id target, boolean forward) {\n         if (forward) {\n-            processOneForForward(source, target);\n+            this.processOneForForward(source, target);\n         } else {\n-            processOneForBackward(source, target);\n+            this.processOneForBackward(source, target);\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\nindex 6d770253..9551009e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n", "chunk": "@@ -148,15 +151,11 @@ public abstract class PathTraverser {\n         }\n     }\n \n-    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n-        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n-    }\n-\n     private void processOne(Id source, Id target, boolean forward) {\n         if (forward) {\n-            processOneForForward(source, target);\n+            this.processOneForForward(source, target);\n         } else {\n-            processOneForBackward(source, target);\n+            this.processOneForBackward(source, target);\n         }\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNzc3Ng==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508437776", "body": "ditto", "bodyText": "ditto", "bodyHTML": "<p dir=\"auto\">ditto</p>", "author": "javeme", "createdAt": "2020-10-20T11:54:35Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);\n+        currentStep.swithDirection();\n+\n+        this.afterTraverse(currentStep, false);\n+    }\n+\n+    public abstract EdgeStep nextStep(boolean forward);\n+\n+    public void beforeTraverse(boolean forward) {\n+        this.clearNewVertices();\n+    }\n+\n+    public void traverseOneLayer(Map<Id, List<HugeTraverser.Node>> vertices,\n+                                 EdgeStep step,\n+                                 BiConsumer<Id, EdgeStep> consumer) {\n+        this.traverseStrategy.traverseOneLayer(vertices, step, consumer);\n+    }\n+\n+    public void afterTraverse(EdgeStep step, boolean forward) {\n+        this.reInitCurrentStepIfNeeded(step, forward);\n+        this.stepCount++;\n+    }\n+\n+    private void forward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, true);\n+    }\n+\n+    private void backward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, false);\n+    }\n+\n+    private void traverseOne(Id v, EdgeStep step, boolean forward) {\n+        if (this.reachLimit()) {\n+            return;\n+        }\n+\n+        Iterator<Edge> edges = this.edgesOfVertex(v, step);\n+        while (edges.hasNext()) {\n+            HugeEdge edge = (HugeEdge) edges.next();\n+            Id target = edge.id().otherVertexId();\n+\n+            this.processOne(v, target, forward);\n+        }\n+    }\n+\n+    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n+    }\n+\n+    private void processOne(Id source, Id target, boolean forward) {\n+        if (forward) {\n+            processOneForForward(source, target);\n+        } else {\n+            processOneForBackward(source, target);", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\nindex 6d770253..9551009e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n", "chunk": "@@ -148,15 +151,11 @@ public abstract class PathTraverser {\n         }\n     }\n \n-    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n-        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n-    }\n-\n     private void processOne(Id source, Id target, boolean forward) {\n         if (forward) {\n-            processOneForForward(source, target);\n+            this.processOneForForward(source, target);\n         } else {\n-            processOneForBackward(source, target);\n+            this.processOneForBackward(source, target);\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\nindex 6d770253..9551009e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n", "chunk": "@@ -148,15 +151,11 @@ public abstract class PathTraverser {\n         }\n     }\n \n-    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n-        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n-    }\n-\n     private void processOne(Id source, Id target, boolean forward) {\n         if (forward) {\n-            processOneForForward(source, target);\n+            this.processOneForForward(source, target);\n         } else {\n-            processOneForBackward(source, target);\n+            this.processOneForBackward(source, target);\n         }\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODI1Mw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508438253", "body": "finished", "bodyText": "finished", "bodyHTML": "<p dir=\"auto\">finished</p>", "author": "javeme", "createdAt": "2020-10-20T11:55:25Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);\n+        currentStep.swithDirection();\n+\n+        this.afterTraverse(currentStep, false);\n+    }\n+\n+    public abstract EdgeStep nextStep(boolean forward);\n+\n+    public void beforeTraverse(boolean forward) {\n+        this.clearNewVertices();\n+    }\n+\n+    public void traverseOneLayer(Map<Id, List<HugeTraverser.Node>> vertices,\n+                                 EdgeStep step,\n+                                 BiConsumer<Id, EdgeStep> consumer) {\n+        this.traverseStrategy.traverseOneLayer(vertices, step, consumer);\n+    }\n+\n+    public void afterTraverse(EdgeStep step, boolean forward) {\n+        this.reInitCurrentStepIfNeeded(step, forward);\n+        this.stepCount++;\n+    }\n+\n+    private void forward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, true);\n+    }\n+\n+    private void backward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, false);\n+    }\n+\n+    private void traverseOne(Id v, EdgeStep step, boolean forward) {\n+        if (this.reachLimit()) {\n+            return;\n+        }\n+\n+        Iterator<Edge> edges = this.edgesOfVertex(v, step);\n+        while (edges.hasNext()) {\n+            HugeEdge edge = (HugeEdge) edges.next();\n+            Id target = edge.id().otherVertexId();\n+\n+            this.processOne(v, target, forward);\n+        }\n+    }\n+\n+    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n+    }\n+\n+    private void processOne(Id source, Id target, boolean forward) {\n+        if (forward) {\n+            processOneForForward(source, target);\n+        } else {\n+            processOneForBackward(source, target);\n+        }\n+    }\n+\n+    protected abstract void processOneForForward(Id source, Id target);\n+\n+    protected abstract void processOneForBackward(Id source, Id target);\n+\n+    protected abstract void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                      boolean forward);\n+\n+    public void clearNewVertices() {\n+        this.newVertices = this.newMultiValueMap();\n+    }\n+\n+    public void addNodeToNewVertices(Id id, HugeTraverser.Node node) {\n+        this.addNode(this.newVertices, id, node);\n+    }\n+\n+    public Map<Id, List<HugeTraverser.Node>> newMultiValueMap() {\n+        return this.traverseStrategy.newMultiValueMap();\n+    }\n+\n+    public Set<HugeTraverser.Path> newPathSet() {\n+        return this.traverseStrategy.newPathSet();\n+    }\n+\n+    public void addNode(Map<Id, List<HugeTraverser.Node>> vertices, Id id,\n+                        HugeTraverser.Node node) {\n+        this.traverseStrategy.addNode(vertices, id, node);\n+    }\n+\n+    public void addNewVerticesToAll(Map<Id, List<HugeTraverser.Node>> targets) {\n+        this.traverseStrategy.addNewVerticesToAll(this.newVertices, targets);\n+    }\n+\n+    public Set<HugeTraverser.Path> paths() {\n+        return this.paths;\n+    }\n+\n+    public int pathCount() {\n+        return this.paths.size();\n+    }\n+\n+    protected boolean finish() {", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\nindex 6d770253..9551009e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n", "chunk": "@@ -200,7 +199,7 @@ public abstract class PathTraverser {\n         return this.paths.size();\n     }\n \n-    protected boolean finish() {\n+    protected boolean finished() {\n         return this.stepCount >= this.totalSteps || this.reachLimit();\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\nindex 6d770253..9551009e 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java\n", "chunk": "@@ -200,7 +199,7 @@ public abstract class PathTraverser {\n         return this.paths.size();\n     }\n \n-    protected boolean finish() {\n+    protected boolean finished() {\n         return this.stepCount >= this.totalSteps || this.reachLimit();\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ1NTgzNg==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508455836", "body": "delete it", "bodyText": "delete it", "bodyHTML": "<p dir=\"auto\">delete it</p>", "author": "javeme", "createdAt": "2020-10-20T12:25:02Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java", "diffHunk": "@@ -71,4 +74,9 @@ public void addNewVerticesToAll(Map<Id, List<Node>> newVertices,\n             vertices.addAll(entry.getKey(), entry.getValue());\n         }\n     }\n+\n+    @Override\n+    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return super.edgesOfVertex(source, edgeStep);\n+    }", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java\nindex fa48fb5c..9d202595 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java\n", "chunk": "@@ -74,9 +71,4 @@ public class ConcurrentTraverseStrategy extends TpTraverser\n             vertices.addAll(entry.getKey(), entry.getValue());\n         }\n     }\n-\n-    @Override\n-    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n-        return super.edgesOfVertex(source, edgeStep);\n-    }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java\nindex fa48fb5c..f856e0a4 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java\n", "chunk": "@@ -74,9 +71,4 @@ public class ConcurrentTraverseStrategy extends TpTraverser\n             vertices.addAll(entry.getKey(), entry.getValue());\n         }\n     }\n-\n-    @Override\n-    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n-        return super.edgesOfVertex(source, edgeStep);\n-    }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "eef1f8b124557ecb3cdb4adf227721f424b9ad07", "committedDate": "2021-10-28 11:44:50 +0800", "message": "oltp traversal: optimize id2code for number id (#1623)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ1NTk4MA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508455980", "body": "delete it", "bodyText": "delete it", "bodyHTML": "<p dir=\"auto\">delete it</p>", "author": "javeme", "createdAt": "2020-10-20T12:25:15Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java", "diffHunk": "@@ -44,4 +47,6 @@ public abstract void addNode(Map<Id, List<HugeTraverser.Node>> vertices,\n     public abstract void addNewVerticesToAll(\n                          Map<Id, List<HugeTraverser.Node>> newVertices,\n                          Map<Id, List<HugeTraverser.Node>> targets);\n+\n+    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep);", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\nindex 93a73b30..1ab5a8de 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n", "chunk": "@@ -48,5 +46,9 @@ public interface TraverseStrategy {\n                          Map<Id, List<HugeTraverser.Node>> newVertices,\n                          Map<Id, List<HugeTraverser.Node>> targets);\n \n-    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep);\n+    public static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n+        return concurrent ? new ConcurrentTraverseStrategy(graph) :\n+                            new SingleTraverseStrategy(graph);\n+\n+    }\n }\n", "next_change": {"commit": "20c1ff5252049df1ab2f4ad36d6e18af70c71690", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\nindex 1ab5a8de..cb81ad87 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n", "chunk": "@@ -49,6 +49,5 @@ public interface TraverseStrategy {\n     public static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n         return concurrent ? new ConcurrentTraverseStrategy(graph) :\n                             new SingleTraverseStrategy(graph);\n-\n     }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\nindex 93a73b30..cb81ad87 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n", "chunk": "@@ -48,5 +46,8 @@ public interface TraverseStrategy {\n                          Map<Id, List<HugeTraverser.Node>> newVertices,\n                          Map<Id, List<HugeTraverser.Node>> targets);\n \n-    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep);\n+    public static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n+        return concurrent ? new ConcurrentTraverseStrategy(graph) :\n+                            new SingleTraverseStrategy(graph);\n+    }\n }\n", "next_change": {"commit": "cc80d2774528f6858ba5f78642c00c7bd98cb5cf", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\nindex cb81ad87..9d69e5cb 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n", "chunk": "@@ -26,27 +26,25 @@ import java.util.function.BiConsumer;\n \n import com.baidu.hugegraph.HugeGraph;\n import com.baidu.hugegraph.backend.id.Id;\n-import com.baidu.hugegraph.traversal.algorithm.EdgeStep;\n+import com.baidu.hugegraph.traversal.algorithm.steps.EdgeStep;\n import com.baidu.hugegraph.traversal.algorithm.HugeTraverser;\n \n public interface TraverseStrategy {\n \n-    public abstract void traverseOneLayer(\n-                         Map<Id, List<HugeTraverser.Node>> vertices,\n-                         EdgeStep step, BiConsumer<Id, EdgeStep> consumer);\n+    void traverseOneLayer(Map<Id, List<HugeTraverser.Node>> vertices,\n+                          EdgeStep step, BiConsumer<Id, EdgeStep> consumer);\n \n-    public abstract Map<Id, List<HugeTraverser.Node>> newMultiValueMap();\n+    Map<Id, List<HugeTraverser.Node>> newMultiValueMap();\n \n-    public abstract Set<HugeTraverser.Path> newPathSet();\n+    Set<HugeTraverser.Path> newPathSet();\n \n-    public abstract void addNode(Map<Id, List<HugeTraverser.Node>> vertices,\n-                                 Id id, HugeTraverser.Node node);\n+    void addNode(Map<Id, List<HugeTraverser.Node>> vertices, Id id,\n+                 HugeTraverser.Node node);\n \n-    public abstract void addNewVerticesToAll(\n-                         Map<Id, List<HugeTraverser.Node>> newVertices,\n-                         Map<Id, List<HugeTraverser.Node>> targets);\n+    void addNewVerticesToAll(Map<Id, List<HugeTraverser.Node>> newVertices,\n+                             Map<Id, List<HugeTraverser.Node>> targets);\n \n-    public static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n+    static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n         return concurrent ? new ConcurrentTraverseStrategy(graph) :\n                             new SingleTraverseStrategy(graph);\n     }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "cc80d2774528f6858ba5f78642c00c7bd98cb5cf", "committedDate": "2022-10-30 16:16:21 +0800", "message": "fix redundant Checkstyle  (#1896)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"oid": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "url": "https://github.com/hugegraph/hugegraph/commit/4fd93f95cdac548c3d56f431d753a03e5ec6da69", "message": "normalize traverser\n\nChange-Id: I68226c55ca387ecfdd103e4af8b5e45faa9a934e", "committedDate": "2020-10-21T03:42:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3NjMzNA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509076334", "body": "also rename TpTraverser to OltpTraverser", "bodyText": "also rename TpTraverser to OltpTraverser", "bodyHTML": "<p dir=\"auto\">also rename TpTraverser to OltpTraverser</p>", "author": "javeme", "createdAt": "2020-10-21T08:12:12Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "diffHunk": "@@ -41,48 +38,34 @@\n import com.baidu.hugegraph.HugeGraph;\n import com.baidu.hugegraph.backend.id.Id;\n import com.baidu.hugegraph.config.CoreOptions;\n-import com.baidu.hugegraph.config.HugeConfig;\n import com.baidu.hugegraph.iterator.FilterIterator;\n import com.baidu.hugegraph.structure.HugeEdge;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.ConcurrentTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.SingleTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n import com.baidu.hugegraph.util.Consumers;\n \n import jersey.repackaged.com.google.common.base.Objects;\n \n public abstract class TpTraverser extends HugeTraverser\n                                   implements AutoCloseable {\n \n-    protected static ExecutorService executor;\n+    private static final String EXECUTOR_NAME = \"oltp\";", "originalCommit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "20c1ff5252049df1ab2f4ad36d6e18af70c71690", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\nsimilarity index 94%\nrename from hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\nrename to hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\nindex cbf06f7d..b35c1713 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\n", "chunk": "@@ -44,15 +44,21 @@ import com.baidu.hugegraph.util.Consumers;\n \n import jersey.repackaged.com.google.common.base.Objects;\n \n-public abstract class TpTraverser extends HugeTraverser\n-                                  implements AutoCloseable {\n+public abstract class OltpTraverser extends HugeTraverser\n+                                    implements AutoCloseable {\n \n     private static final String EXECUTOR_NAME = \"oltp\";\n     private static ExecutorService executor;\n \n-    protected TpTraverser(HugeGraph graph) {\n+    protected OltpTraverser(HugeGraph graph) {\n         super(graph);\n-        if (executor == null) {\n+        if (executor != null) {\n+            return;\n+        }\n+        synchronized (OltpTraverser.class) {\n+            if (executor != null) {\n+                return;\n+            }\n             int workers = this.config().get(CoreOptions.OLTP_CONCURRENT_THREADS);\n             if (workers > 0) {\n                 executor = Consumers.newThreadPool(EXECUTOR_NAME, workers);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\nsimilarity index 94%\nrename from hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\nrename to hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\nindex cbf06f7d..b35c1713 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\n", "chunk": "@@ -44,15 +44,21 @@ import com.baidu.hugegraph.util.Consumers;\n \n import jersey.repackaged.com.google.common.base.Objects;\n \n-public abstract class TpTraverser extends HugeTraverser\n-                                  implements AutoCloseable {\n+public abstract class OltpTraverser extends HugeTraverser\n+                                    implements AutoCloseable {\n \n     private static final String EXECUTOR_NAME = \"oltp\";\n     private static ExecutorService executor;\n \n-    protected TpTraverser(HugeGraph graph) {\n+    protected OltpTraverser(HugeGraph graph) {\n         super(graph);\n-        if (executor == null) {\n+        if (executor != null) {\n+            return;\n+        }\n+        synchronized (OltpTraverser.class) {\n+            if (executor != null) {\n+                return;\n+            }\n             int workers = this.config().get(CoreOptions.OLTP_CONCURRENT_THREADS);\n             if (workers > 0) {\n                 executor = Consumers.newThreadPool(EXECUTOR_NAME, workers);\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3NjYxMw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509076613", "body": "empty line", "bodyText": "empty line", "bodyHTML": "<p dir=\"auto\">empty line</p>", "author": "javeme", "createdAt": "2020-10-21T08:12:40Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java", "diffHunk": "@@ -48,5 +46,9 @@ public abstract void addNewVerticesToAll(\n                          Map<Id, List<HugeTraverser.Node>> newVertices,\n                          Map<Id, List<HugeTraverser.Node>> targets);\n \n-    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep);\n+    public static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n+        return concurrent ? new ConcurrentTraverseStrategy(graph) :\n+                            new SingleTraverseStrategy(graph);\n+", "originalCommit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "20c1ff5252049df1ab2f4ad36d6e18af70c71690", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\nindex 1ab5a8de..cb81ad87 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n", "chunk": "@@ -49,6 +49,5 @@ public interface TraverseStrategy {\n     public static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n         return concurrent ? new ConcurrentTraverseStrategy(graph) :\n                             new SingleTraverseStrategy(graph);\n-\n     }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\nindex 1ab5a8de..cb81ad87 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n", "chunk": "@@ -49,6 +49,5 @@ public interface TraverseStrategy {\n     public static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n         return concurrent ? new ConcurrentTraverseStrategy(graph) :\n                             new SingleTraverseStrategy(graph);\n-\n     }\n }\n", "next_change": {"commit": "cc80d2774528f6858ba5f78642c00c7bd98cb5cf", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\nindex cb81ad87..9d69e5cb 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java\n", "chunk": "@@ -26,27 +26,25 @@ import java.util.function.BiConsumer;\n \n import com.baidu.hugegraph.HugeGraph;\n import com.baidu.hugegraph.backend.id.Id;\n-import com.baidu.hugegraph.traversal.algorithm.EdgeStep;\n+import com.baidu.hugegraph.traversal.algorithm.steps.EdgeStep;\n import com.baidu.hugegraph.traversal.algorithm.HugeTraverser;\n \n public interface TraverseStrategy {\n \n-    public abstract void traverseOneLayer(\n-                         Map<Id, List<HugeTraverser.Node>> vertices,\n-                         EdgeStep step, BiConsumer<Id, EdgeStep> consumer);\n+    void traverseOneLayer(Map<Id, List<HugeTraverser.Node>> vertices,\n+                          EdgeStep step, BiConsumer<Id, EdgeStep> consumer);\n \n-    public abstract Map<Id, List<HugeTraverser.Node>> newMultiValueMap();\n+    Map<Id, List<HugeTraverser.Node>> newMultiValueMap();\n \n-    public abstract Set<HugeTraverser.Path> newPathSet();\n+    Set<HugeTraverser.Path> newPathSet();\n \n-    public abstract void addNode(Map<Id, List<HugeTraverser.Node>> vertices,\n-                                 Id id, HugeTraverser.Node node);\n+    void addNode(Map<Id, List<HugeTraverser.Node>> vertices, Id id,\n+                 HugeTraverser.Node node);\n \n-    public abstract void addNewVerticesToAll(\n-                         Map<Id, List<HugeTraverser.Node>> newVertices,\n-                         Map<Id, List<HugeTraverser.Node>> targets);\n+    void addNewVerticesToAll(Map<Id, List<HugeTraverser.Node>> newVertices,\n+                             Map<Id, List<HugeTraverser.Node>> targets);\n \n-    public static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n+    static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n         return concurrent ? new ConcurrentTraverseStrategy(graph) :\n                             new SingleTraverseStrategy(graph);\n     }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}, {"oid": "f6f44bb24e9d03224df89eeda027cef2db90b6b7", "committedDate": "2020-12-09 19:54:44 +0800", "message": "export new implemented oltp traversals (#1289)"}, {"oid": "cc80d2774528f6858ba5f78642c00c7bd98cb5cf", "committedDate": "2022-10-30 16:16:21 +0800", "message": "fix redundant Checkstyle  (#1896)"}, {"oid": "67a689c86cc29b2e8a9a638373e8be014bcbb46b", "committedDate": "2022-11-23 21:16:14 +0800", "message": "refact: adapt all to apache package and dependencies (Breaking Changes)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3ODYxMw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509078613", "body": "lock for null judgment and assignment", "bodyText": "lock for null judgment and assignment", "bodyHTML": "<p dir=\"auto\">lock for null judgment and assignment</p>", "author": "javeme", "createdAt": "2020-10-21T08:15:36Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "diffHunk": "@@ -41,48 +38,34 @@\n import com.baidu.hugegraph.HugeGraph;\n import com.baidu.hugegraph.backend.id.Id;\n import com.baidu.hugegraph.config.CoreOptions;\n-import com.baidu.hugegraph.config.HugeConfig;\n import com.baidu.hugegraph.iterator.FilterIterator;\n import com.baidu.hugegraph.structure.HugeEdge;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.ConcurrentTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.SingleTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n import com.baidu.hugegraph.util.Consumers;\n \n import jersey.repackaged.com.google.common.base.Objects;\n \n public abstract class TpTraverser extends HugeTraverser\n                                   implements AutoCloseable {\n \n-    protected static ExecutorService executor;\n+    private static final String EXECUTOR_NAME = \"oltp\";\n+    private static ExecutorService executor;\n \n     protected TpTraverser(HugeGraph graph) {\n         super(graph);\n-    }\n-\n-    protected TpTraverser(HugeGraph graph, String name) {\n-        super(graph);\n         if (executor == null) {\n             int workers = this.config().get(CoreOptions.OLTP_CONCURRENT_THREADS);\n             if (workers > 0) {\n-                executor = Consumers.newThreadPool(name, workers);\n+                executor = Consumers.newThreadPool(EXECUTOR_NAME, workers);", "originalCommit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "20c1ff5252049df1ab2f4ad36d6e18af70c71690", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\nsimilarity index 94%\nrename from hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\nrename to hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\nindex cbf06f7d..b35c1713 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\n", "chunk": "@@ -44,15 +44,21 @@ import com.baidu.hugegraph.util.Consumers;\n \n import jersey.repackaged.com.google.common.base.Objects;\n \n-public abstract class TpTraverser extends HugeTraverser\n-                                  implements AutoCloseable {\n+public abstract class OltpTraverser extends HugeTraverser\n+                                    implements AutoCloseable {\n \n     private static final String EXECUTOR_NAME = \"oltp\";\n     private static ExecutorService executor;\n \n-    protected TpTraverser(HugeGraph graph) {\n+    protected OltpTraverser(HugeGraph graph) {\n         super(graph);\n-        if (executor == null) {\n+        if (executor != null) {\n+            return;\n+        }\n+        synchronized (OltpTraverser.class) {\n+            if (executor != null) {\n+                return;\n+            }\n             int workers = this.config().get(CoreOptions.OLTP_CONCURRENT_THREADS);\n             if (workers > 0) {\n                 executor = Consumers.newThreadPool(EXECUTOR_NAME, workers);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "changed_code": [{"header": "diff --git a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\nsimilarity index 94%\nrename from hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\nrename to hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\nindex cbf06f7d..b35c1713 100644\n--- a/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java\n+++ b/hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/OltpTraverser.java\n", "chunk": "@@ -44,15 +44,21 @@ import com.baidu.hugegraph.util.Consumers;\n \n import jersey.repackaged.com.google.common.base.Objects;\n \n-public abstract class TpTraverser extends HugeTraverser\n-                                  implements AutoCloseable {\n+public abstract class OltpTraverser extends HugeTraverser\n+                                    implements AutoCloseable {\n \n     private static final String EXECUTOR_NAME = \"oltp\";\n     private static ExecutorService executor;\n \n-    protected TpTraverser(HugeGraph graph) {\n+    protected OltpTraverser(HugeGraph graph) {\n         super(graph);\n-        if (executor == null) {\n+        if (executor != null) {\n+            return;\n+        }\n+        synchronized (OltpTraverser.class) {\n+            if (executor != null) {\n+                return;\n+            }\n             int workers = this.config().get(CoreOptions.OLTP_CONCURRENT_THREADS);\n             if (workers > 0) {\n                 executor = Consumers.newThreadPool(EXECUTOR_NAME, workers);\n", "next_change": null}]}, "commits_in_main": [{"oid": "d5cc79b329ed540458f22ee5fb4a7a56c5ca9262", "message": "Merge commit", "committedDate": null}]}, {"oid": "20c1ff5252049df1ab2f4ad36d6e18af70c71690", "url": "https://github.com/hugegraph/hugegraph/commit/20c1ff5252049df1ab2f4ad36d6e18af70c71690", "message": "improve\n\nChange-Id: I882e472d001c40c0f1ffdc89c1c3c28bd6d34a17", "committedDate": "2020-10-21T08:26:56Z", "type": "commit"}]}