{"pr_number": 1235, "pr_title": "Add version migrations to fix entity type mismatches in db", "pr_author": "Nana-EC", "pr_createdAt": "2020-11-06T21:44:12Z", "pr_url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235", "merge_commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "timeline": [{"oid": "3159528dcbfc9d4a3b175de51b30401257205662", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3159528dcbfc9d4a3b175de51b30401257205662", "message": "Cleaned up\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-09T19:08:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNjQ1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520836458", "body": "Nit: \r\n```suggestion\r\n    void verifyEntityTypeMigrationInvalidEntities() throws Exception {\r\n```", "bodyText": "Nit:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void verifyEntityTypeMigrationInValidEntities() throws Exception {\n          \n          \n            \n                void verifyEntityTypeMigrationInvalidEntities() throws Exception {", "bodyHTML": "<p dir=\"auto\">Nit:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">void</span> <span class=\"x x-first x-last\">verifyEntityTypeMigrationInValidEntities</span>() throws <span class=\"pl-smi\">Exception</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">void</span> <span class=\"x x-first x-last\">verifyEntityTypeMigrationInvalidEntities</span>() throws <span class=\"pl-smi\">Exception</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ijungmann", "createdAt": "2020-11-10T19:56:19Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")\n+public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n+    @Resource\n+    private V1_31_1__Entity_Type_Mismatch migration;\n+\n+    @Resource\n+    private DataSource dataSource;\n+\n+    @Resource\n+    private EntityRepository entityRepository;\n+\n+    @Resource\n+    private MirrorProperties mirrorProperties;\n+\n+    @Resource\n+    private TransactionRepository transactionRepository;\n+\n+    @Resource\n+    private FlywayMigrationProperties flywayMigrationProperties;\n+\n+    @BeforeEach\n+    void before() {\n+        mirrorProperties.setStartDate(Instant.EPOCH);\n+        mirrorProperties.setEndDate(Instant.EPOCH.plusSeconds(1));\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationEmpty() throws Exception {\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(0, entityRepository.count());\n+        assertEquals(0, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        entityRepository.insertEntityId(entityId(1, EntityTypeEnum.ACCOUNT));\n+        entityRepository.insertEntityId(entityId(2, EntityTypeEnum.CONTRACT));\n+        entityRepository.insertEntityId(entityId(3, EntityTypeEnum.FILE));\n+        entityRepository.insertEntityId(entityId(4, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(5, EntityTypeEnum.TOKEN));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(5, entityRepository.count());\n+        assertEquals(5, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntities() throws Exception {", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NTY3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521475675", "bodyText": "Renamed", "author": "Nana-EC", "createdAt": "2020-11-11T16:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNjQ1OA=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\nsimilarity index 95%\nrename from hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\nrename to hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\nindex 379afd295..916ea5130 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\n", "chunk": "@@ -120,7 +120,7 @@ public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n     }\n \n     @Test\n-    void verifyEntityTypeMigrationInValidEntities() throws Exception {\n+    void verifyEntityTypeMigrationInvalidEntities() throws Exception {\n         flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n         flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nsimilarity index 86%\nrename from hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\nrename to hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nindex 379afd295..a4762c64e 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\n", "chunk": "@@ -113,17 +109,14 @@ public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n         transactionRepository.saveAll(transactionList);\n \n         // migration\n-        migration.migrate(new FlywayContext());\n+        migrate();\n \n         assertEquals(5, entityRepository.count());\n         assertEquals(5, transactionRepository.count());\n     }\n \n     @Test\n-    void verifyEntityTypeMigrationInValidEntities() throws Exception {\n-        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n-        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n-\n+    void verifyEntityTypeMigrationInvalidEntities() throws Exception {\n         EntityId typeMismatchedAccountEntityId = entityId(1, EntityTypeEnum.TOPIC);\n         EntityId typeMismatchedContractEntityId = entityId(2, EntityTypeEnum.TOKEN);\n         EntityId typeMismatchedFileEntityId = entityId(3, EntityTypeEnum.CONTRACT);\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzODcwNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520838705", "body": "Nit: I'm wondering if the variable name could be enhanced a little, I had to read the SQL to really understand the sentiment but I'm failing to come up with something better.", "bodyText": "Nit: I'm wondering if the variable name could be enhanced a little, I had to read the SQL to really understand the sentiment but I'm failing to come up with something better.", "bodyHTML": "<p dir=\"auto\">Nit: I'm wondering if the variable name could be enhanced a little, I had to read the SQL to really understand the sentiment but I'm failing to come up with something better.</p>", "author": "ijungmann", "createdAt": "2020-11-10T20:00:13Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NTgwMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521475800", "bodyText": "Took another hack at it", "author": "Nana-EC", "createdAt": "2020-11-11T16:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzODcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUwMzg4Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521503887", "bodyText": "Much better, thanks", "author": "ijungmann", "createdAt": "2020-11-11T17:02:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzODcwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -39,54 +38,47 @@ import org.springframework.context.annotation.Lazy;\n import org.springframework.jdbc.core.JdbcTemplate;\n import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n \n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n import com.hedera.mirror.importer.util.Utility;\n \n @Log4j2\n @Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n     private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n+    private final JdbcTemplate jdbcTemplate;\n \n     private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n             \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private final String ENTITY_MISMATCH_WHERE_CLAUSE_SQL = \"t.result = 22 and ((t.type = 11 and  e.fk_entity_type_id\" +\n+            \" <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and e.fk_entity_type_id <> 3) or (t\" +\n+            \".type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and e.fk_entity_type_id <> 5))\";\n+    private final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_MISMATCH_WHERE_CLAUSE_SQL +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and t\" +\n+            \".consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc, consensus_ns desc \" +\n             \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+    private final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n \n     AtomicLong entityIdCap;\n     AtomicLong timestampCap;\n     AtomicLong entityTransactionCount;\n     AtomicLong entityTransactionMismatchCount;\n \n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n                                          FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n+        this.jdbcTemplate = jdbcTemplate;\n         this.flywayMigrationProperties = flywayMigrationProperties;\n     }\n \n     @Override\n     public void migrate(Context context) throws Exception {\n         Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n \n         // retrieve max entityId value witness by transactions table.\n         Long maxEntityId = getMaxEntityId();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0MzMyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520843323", "body": "Nit: not sure how you feel about ternary operators, but this method could be replaced with one I believe.\r\n```suggestion\r\n        return expectedEntityType.getId() == currentEntityType ? 0 :  expectedEntityType.getId();\r\n```", "bodyText": "Nit: not sure how you feel about ternary operators, but this method could be replaced with one I believe.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return expectedEntityType.getId();\n          \n          \n            \n                    return expectedEntityType.getId() == currentEntityType ? 0 :  expectedEntityType.getId();", "bodyHTML": "<p dir=\"auto\">Nit: not sure how you feel about ternary operators, but this method could be replaced with one I believe.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">return</span> expectedEntityType<span class=\"pl-k\">.</span>getId();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> expectedEntityType<span class=\"pl-k\">.</span>getId()<span class=\"x x-first\"> </span><span class=\"pl-k x\">==</span><span class=\"x\"> currentEntityType </span><span class=\"pl-k x\">?</span><span class=\"x\"> </span><span class=\"pl-c1 x\">0</span><span class=\"x\"> </span><span class=\"pl-k x\">:</span><span class=\"x\">  expectedEntityType</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">getId()</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ijungmann", "createdAt": "2020-11-10T20:08:25Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NDQxOQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520874419", "bodyText": "I like ternary operators and prefer your suggestion. Thanks", "author": "Nana-EC", "createdAt": "2020-11-10T21:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0MzMyMw=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -230,11 +236,7 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n     private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n         // check if EntityTypeEnum matches given currentEntityType.\n         // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n+        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n     }\n \n     /***\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NTM2Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520845366", "body": "I understand incrementing the entity id cap by 1, I'm not sure I understand incrementing the timestamp cap though, if the cap is already set to the current time.", "bodyText": "I understand incrementing the entity id cap by 1, I'm not sure I understand incrementing the timestamp cap though, if the cap is already set to the current time.", "bodyHTML": "<p dir=\"auto\">I understand incrementing the entity id cap by 1, I'm not sure I understand incrementing the timestamp cap though, if the cap is already set to the current time.</p>", "author": "ijungmann", "createdAt": "2020-11-10T20:12:01Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3MzkwNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520873904", "bodyText": "True, +1 on timestamp is not needed", "author": "Nana-EC", "createdAt": "2020-11-10T21:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NTM2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -105,27 +103,24 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n         // transactions\n         // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n         // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n+        List<TypeMismatchedEntity> typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchedEntityList != null) {\n+            if (!typeMismatchedEntityList.isEmpty()) {\n+                batchUpdate(typeMismatchedEntityList);\n             }\n \n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+            typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n                     .getEntityMismatchReadPageSize());\n         }\n \n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n                         .get(), entityTransactionMismatchCount.get());\n \n         verifyNoEntityMismatchesExist();\n \n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+        log.info(\"Migration processed in {}.\", stopwatch);\n     }\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NjgzNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520846835", "body": "Nit:\r\n```suggestion\r\n    void verifyEntityTypeMigrationInvalidEntitiesMultiBatch() throws Exception {\r\n```", "bodyText": "Nit:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void verifyEntityTypeMigrationInValidEntitiesMultiBatch() throws Exception {\n          \n          \n            \n                void verifyEntityTypeMigrationInvalidEntitiesMultiBatch() throws Exception {", "bodyHTML": "<p dir=\"auto\">Nit:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">void</span> <span class=\"x x-first x-last\">verifyEntityTypeMigrationInValidEntitiesMultiBatch</span>() throws <span class=\"pl-smi\">Exception</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">void</span> <span class=\"x x-first x-last\">verifyEntityTypeMigrationInvalidEntitiesMultiBatch</span>() throws <span class=\"pl-smi\">Exception</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ijungmann", "createdAt": "2020-11-10T20:14:48Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")\n+public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n+    @Resource\n+    private V1_31_1__Entity_Type_Mismatch migration;\n+\n+    @Resource\n+    private DataSource dataSource;\n+\n+    @Resource\n+    private EntityRepository entityRepository;\n+\n+    @Resource\n+    private MirrorProperties mirrorProperties;\n+\n+    @Resource\n+    private TransactionRepository transactionRepository;\n+\n+    @Resource\n+    private FlywayMigrationProperties flywayMigrationProperties;\n+\n+    @BeforeEach\n+    void before() {\n+        mirrorProperties.setStartDate(Instant.EPOCH);\n+        mirrorProperties.setEndDate(Instant.EPOCH.plusSeconds(1));\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationEmpty() throws Exception {\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(0, entityRepository.count());\n+        assertEquals(0, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        entityRepository.insertEntityId(entityId(1, EntityTypeEnum.ACCOUNT));\n+        entityRepository.insertEntityId(entityId(2, EntityTypeEnum.CONTRACT));\n+        entityRepository.insertEntityId(entityId(3, EntityTypeEnum.FILE));\n+        entityRepository.insertEntityId(entityId(4, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(5, EntityTypeEnum.TOKEN));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(5, entityRepository.count());\n+        assertEquals(5, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        EntityId typeMismatchedAccountEntityId = entityId(1, EntityTypeEnum.TOPIC);\n+        EntityId typeMismatchedContractEntityId = entityId(2, EntityTypeEnum.TOKEN);\n+        EntityId typeMismatchedFileEntityId = entityId(3, EntityTypeEnum.CONTRACT);\n+        EntityId typeMismatchedTopicEntityId = entityId(4, EntityTypeEnum.ACCOUNT);\n+        EntityId typeMismatchedTokenEntityId = entityId(5, EntityTypeEnum.FILE);\n+        entityRepository.insertEntityId(typeMismatchedAccountEntityId);\n+        entityRepository.insertEntityId(typeMismatchedContractEntityId);\n+        entityRepository.insertEntityId(typeMismatchedFileEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTopicEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTokenEntityId);\n+        entityRepository.insertEntityId(entityId(50, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(100, EntityTypeEnum.TOPIC));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionList\n+                .add(transaction(70, 50, EntityTypeEnum.TOPIC, ResponseCodeEnum.INVALID_TOPIC_ID,\n+                        TransactionTypeEnum.CONSENSUSSUBMITMESSAGE));\n+        transactionList\n+                .add(transaction(80, 100, EntityTypeEnum.TOPIC, ResponseCodeEnum.TOPIC_EXPIRED,\n+                        TransactionTypeEnum.CONSENSUSSUBMITMESSAGE));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(7, entityRepository.count());\n+        assertEquals(7, transactionRepository.count());\n+\n+        assertAll(\n+                () -> assertThat(entityRepository.findById(typeMismatchedAccountEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.ACCOUNT.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedContractEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.CONTRACT.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedFileEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.FILE.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedTopicEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.TOPIC.getId()),\n+                () -> assertThat(entityRepository.findById(typeMismatchedTokenEntityId.getId())).isPresent().get()\n+                        .extracting(Entities::getEntityTypeId).isEqualTo(EntityTypeEnum.TOKEN.getId())\n+        );\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntitiesMultiBatch() throws Exception {", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NTk2Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521475967", "bodyText": "Renamed", "author": "Nana-EC", "createdAt": "2020-11-11T16:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0NjgzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\nsimilarity index 95%\nrename from hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\nrename to hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\nindex 379afd295..916ea5130 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\n", "chunk": "@@ -181,7 +179,7 @@ public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n     }\n \n     @Test\n-    void verifyEntityTypeMigrationInValidEntitiesMultiBatch() throws Exception {\n+    void verifyEntityTypeMigrationInvalidEntitiesMultiBatch() throws Exception {\n         flywayMigrationProperties.setEntityMismatchReadPageSize(4);\n         flywayMigrationProperties.setEntityMismatchWriteBatchSize(4);\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nsimilarity index 86%\nrename from hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\nrename to hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nindex 379afd295..a4762c64e 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\n", "chunk": "@@ -181,10 +172,7 @@ public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n     }\n \n     @Test\n-    void verifyEntityTypeMigrationInValidEntitiesMultiBatch() throws Exception {\n-        flywayMigrationProperties.setEntityMismatchReadPageSize(4);\n-        flywayMigrationProperties.setEntityMismatchWriteBatchSize(4);\n-\n+    void verifyEntityTypeMigrationInvalidEntitiesMultiBatch() throws Exception {\n         entityRepository.insertEntityId(entityId(1, EntityTypeEnum.ACCOUNT));\n         entityRepository.insertEntityId(entityId(2, EntityTypeEnum.CONTRACT));\n         entityRepository.insertEntityId(entityId(3, EntityTypeEnum.FILE));\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0OTA2Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520849063", "body": "I'm a little confused on not checking these last two in any of the invalid tests.  I'm sure it's a use case I'm just not understanding.", "bodyText": "I'm a little confused on not checking these last two in any of the invalid tests.  I'm sure it's a use case I'm just not understanding.", "bodyHTML": "<p dir=\"auto\">I'm a little confused on not checking these last two in any of the invalid tests.  I'm sure it's a use case I'm just not understanding.</p>", "author": "ijungmann", "createdAt": "2020-11-10T20:19:09Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")\n+public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n+    @Resource\n+    private V1_31_1__Entity_Type_Mismatch migration;\n+\n+    @Resource\n+    private DataSource dataSource;\n+\n+    @Resource\n+    private EntityRepository entityRepository;\n+\n+    @Resource\n+    private MirrorProperties mirrorProperties;\n+\n+    @Resource\n+    private TransactionRepository transactionRepository;\n+\n+    @Resource\n+    private FlywayMigrationProperties flywayMigrationProperties;\n+\n+    @BeforeEach\n+    void before() {\n+        mirrorProperties.setStartDate(Instant.EPOCH);\n+        mirrorProperties.setEndDate(Instant.EPOCH.plusSeconds(1));\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationEmpty() throws Exception {\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(0, entityRepository.count());\n+        assertEquals(0, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        entityRepository.insertEntityId(entityId(1, EntityTypeEnum.ACCOUNT));\n+        entityRepository.insertEntityId(entityId(2, EntityTypeEnum.CONTRACT));\n+        entityRepository.insertEntityId(entityId(3, EntityTypeEnum.FILE));\n+        entityRepository.insertEntityId(entityId(4, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(5, EntityTypeEnum.TOKEN));\n+\n+        List<Transaction> transactionList = new ArrayList<>();\n+        transactionList\n+                .add(transaction(1, 1, EntityTypeEnum.ACCOUNT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CRYPTOCREATEACCOUNT));\n+        transactionList\n+                .add(transaction(20, 2, EntityTypeEnum.CONTRACT, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONTRACTCREATEINSTANCE));\n+        transactionList\n+                .add(transaction(30, 3, EntityTypeEnum.FILE, ResponseCodeEnum.SUCCESS, TransactionTypeEnum.FILECREATE));\n+        transactionList\n+                .add(transaction(40, 4, EntityTypeEnum.TOPIC, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.CONSENSUSCREATETOPIC));\n+        transactionList\n+                .add(transaction(50, 5, EntityTypeEnum.TOKEN, ResponseCodeEnum.SUCCESS,\n+                        TransactionTypeEnum.TOKENCREATION));\n+        transactionRepository.saveAll(transactionList);\n+\n+        // migration\n+        migration.migrate(new FlywayContext());\n+\n+        assertEquals(5, entityRepository.count());\n+        assertEquals(5, transactionRepository.count());\n+    }\n+\n+    @Test\n+    void verifyEntityTypeMigrationInValidEntities() throws Exception {\n+        flywayMigrationProperties.setEntityMismatchReadPageSize(3);\n+        flywayMigrationProperties.setEntityMismatchWriteBatchSize(3);\n+\n+        EntityId typeMismatchedAccountEntityId = entityId(1, EntityTypeEnum.TOPIC);\n+        EntityId typeMismatchedContractEntityId = entityId(2, EntityTypeEnum.TOKEN);\n+        EntityId typeMismatchedFileEntityId = entityId(3, EntityTypeEnum.CONTRACT);\n+        EntityId typeMismatchedTopicEntityId = entityId(4, EntityTypeEnum.ACCOUNT);\n+        EntityId typeMismatchedTokenEntityId = entityId(5, EntityTypeEnum.FILE);\n+        entityRepository.insertEntityId(typeMismatchedAccountEntityId);\n+        entityRepository.insertEntityId(typeMismatchedContractEntityId);\n+        entityRepository.insertEntityId(typeMismatchedFileEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTopicEntityId);\n+        entityRepository.insertEntityId(typeMismatchedTokenEntityId);\n+        entityRepository.insertEntityId(entityId(50, EntityTypeEnum.TOPIC));\n+        entityRepository.insertEntityId(entityId(100, EntityTypeEnum.TOPIC));", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3Njg4MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520876881", "bodyText": "Left over, will remove.\nOriginally, these two are added to make it so the max entities in the table isn't actually a valid entity.\nI can actually take it out because by this migration any entities above the max valid entityId would have been delete in v1_31_1\nAlso originally I was going to do the delete after this migration.\nWill remove thanks", "author": "Nana-EC", "createdAt": "2020-11-10T21:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0OTA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUyMjA5MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521522091", "bodyText": "Cool, makes sense, thanks for the details.", "author": "ijungmann", "createdAt": "2020-11-11T17:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0OTA2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\nsimilarity index 95%\nrename from hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\nrename to hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\nindex 379afd295..916ea5130 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\n", "chunk": "@@ -134,8 +134,6 @@ public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n         entityRepository.insertEntityId(typeMismatchedFileEntityId);\n         entityRepository.insertEntityId(typeMismatchedTopicEntityId);\n         entityRepository.insertEntityId(typeMismatchedTokenEntityId);\n-        entityRepository.insertEntityId(entityId(50, EntityTypeEnum.TOPIC));\n-        entityRepository.insertEntityId(entityId(100, EntityTypeEnum.TOPIC));\n \n         List<Transaction> transactionList = new ArrayList<>();\n         transactionList\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nsimilarity index 86%\nrename from hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\nrename to hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nindex 379afd295..a4762c64e 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\n", "chunk": "@@ -134,8 +127,6 @@ public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n         entityRepository.insertEntityId(typeMismatchedFileEntityId);\n         entityRepository.insertEntityId(typeMismatchedTopicEntityId);\n         entityRepository.insertEntityId(typeMismatchedTokenEntityId);\n-        entityRepository.insertEntityId(entityId(50, EntityTypeEnum.TOPIC));\n-        entityRepository.insertEntityId(entityId(100, EntityTypeEnum.TOPIC));\n \n         List<Transaction> transactionList = new ArrayList<>();\n         transactionList\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MjA4Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520282086", "body": "Is this used somewhere?", "bodyText": "Is this used somewhere?", "bodyHTML": "<p dir=\"auto\">Is this used somewhere?</p>", "author": "steven-sheehy", "createdAt": "2020-11-10T04:41:04Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java", "diffHunk": "@@ -34,4 +34,14 @@\n     TOKEN(5);\n \n     private final int id;\n+\n+    public static EntityTypeEnum fromId(int id) {", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwODU3Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520908576", "bodyText": "Initially it was, seems in my refactors I no longer needed it. Will remove", "author": "Nana-EC", "createdAt": "2020-11-10T22:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MjA4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\nindex 72a5ce034..aaee46a98 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n", "chunk": "@@ -34,14 +34,4 @@ public enum EntityTypeEnum {\n     TOKEN(5);\n \n     private final int id;\n-\n-    public static EntityTypeEnum fromId(int id) {\n-        for (EntityTypeEnum entityTypeEnum : values()) {\n-            if (entityTypeEnum.getId() == id) {\n-                return entityTypeEnum;\n-            }\n-        }\n-\n-        return null;\n-    }\n }\n", "next_change": {"commit": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\nindex aaee46a98..72a5ce034 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n", "chunk": "@@ -34,4 +34,14 @@ public enum EntityTypeEnum {\n     TOKEN(5);\n \n     private final int id;\n+\n+    public static EntityTypeEnum fromId(int id) {\n+        for (EntityTypeEnum entityTypeEnum : values()) {\n+            if (entityTypeEnum.getId() == id) {\n+                return entityTypeEnum;\n+            }\n+        }\n+\n+        return null;\n+    }\n }\n", "next_change": {"commit": "3d689050d99226ce8472b047bbe2d7456c88b25b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\nindex 72a5ce034..aaee46a98 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n", "chunk": "@@ -34,14 +34,4 @@ public enum EntityTypeEnum {\n     TOKEN(5);\n \n     private final int id;\n-\n-    public static EntityTypeEnum fromId(int id) {\n-        for (EntityTypeEnum entityTypeEnum : values()) {\n-            if (entityTypeEnum.getId() == id) {\n-                return entityTypeEnum;\n-            }\n-        }\n-\n-        return null;\n-    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\nindex 72a5ce034..aaee46a98 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n", "chunk": "@@ -34,14 +34,4 @@ public enum EntityTypeEnum {\n     TOKEN(5);\n \n     private final int id;\n-\n-    public static EntityTypeEnum fromId(int id) {\n-        for (EntityTypeEnum entityTypeEnum : values()) {\n-            if (entityTypeEnum.getId() == id) {\n-                return entityTypeEnum;\n-            }\n-        }\n-\n-        return null;\n-    }\n }\n", "next_change": {"commit": "c7ab7343ce7a64ba5e6f0897f68067abc493eb1b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\nindex aaee46a98..4a19cfa04 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n", "chunk": "@@ -31,7 +31,8 @@ public enum EntityTypeEnum {\n     CONTRACT(2),\n     FILE(3),\n     TOPIC(4),\n-    TOKEN(5);\n+    TOKEN(5),\n+    SCHEDULE(6);\n \n     private final int id;\n }\n", "next_change": {"commit": "b1b558e5c1d776ba35edef5a22b5e1ce78774bc0", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\nindex 4a19cfa04..65e695da2 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n", "chunk": "@@ -35,4 +40,12 @@ public enum EntityTypeEnum {\n     SCHEDULE(6);\n \n     private final int id;\n+\n+    private static final Map<Integer, EntityTypeEnum> ID_MAP = Arrays.stream(values())\n+            .collect(Collectors.toUnmodifiableMap(EntityTypeEnum::getId, Function\n+                    .identity()));\n+\n+    public static EntityTypeEnum fromId(int id) {\n+        return ID_MAP.getOrDefault(id, UNKNOWN);\n+    }\n }\n", "next_change": {"commit": "43405e888c8f070ccf4978d61dc71ff1c59c6529", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityType.java\nsimilarity index 82%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityType.java\nindex 65e695da2..aa32557c0 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityTypeEnum.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/domain/EntityType.java\n", "chunk": "@@ -41,11 +41,11 @@ public enum EntityTypeEnum {\n \n     private final int id;\n \n-    private static final Map<Integer, EntityTypeEnum> ID_MAP = Arrays.stream(values())\n-            .collect(Collectors.toUnmodifiableMap(EntityTypeEnum::getId, Function\n+    private static final Map<Integer, EntityType> ID_MAP = Arrays.stream(values())\n+            .collect(Collectors.toUnmodifiableMap(EntityType::getId, Function\n                     .identity()));\n \n-    public static EntityTypeEnum fromId(int id) {\n+    public static EntityType fromId(int id) {\n         return ID_MAP.getOrDefault(id, UNKNOWN);\n     }\n }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}, {"oid": "4e6dcf6013cd1efe285cd38178c332ce46d00a80", "committedDate": "2021-01-11 10:42:50 -0600", "message": "Update copyright to 2021 (#1425)"}, {"oid": "c7ab7343ce7a64ba5e6f0897f68067abc493eb1b", "committedDate": "2021-01-22 18:40:00 -0600", "message": "Add schema and domain support for scheduled transactions (#1477)"}, {"oid": "0c3d94b17a2e300b36023ac8cd5ae76e4b1d397d", "committedDate": "2021-03-30 14:54:45 -0500", "message": "Update importer for revised scheduled transaction design (#1766)"}, {"oid": "b1b558e5c1d776ba35edef5a22b5e1ce78774bc0", "committedDate": "2021-10-28 12:41:48 -0500", "message": "Remove t_entity_types table (#2727)"}, {"oid": "43405e888c8f070ccf4978d61dc71ff1c59c6529", "committedDate": "2021-10-28 15:06:35 -0500", "message": "Rename EntityTypeEnum to EntityType in importer  (#2757)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzE1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520283153", "body": "Why not continue chaining and avoid the temporary `entitiesIterableAssert` variable?", "bodyText": "Why not continue chaining and avoid the temporary entitiesIterableAssert variable?", "bodyHTML": "<p dir=\"auto\">Why not continue chaining and avoid the temporary <code>entitiesIterableAssert</code> variable?</p>", "author": "steven-sheehy", "createdAt": "2020-11-10T04:45:16Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java", "diffHunk": "@@ -365,11 +366,13 @@ protected void assertEntities(EntityId... entityIds) {\n             return;\n         }\n \n-        assertEquals(entityIds.length, entityRepository.count());\n+        IterableAssert<Entities> entitiesIterableAssert = assertThat(entityRepository.findAll())\n+                .hasSize(entityIds.length)\n+                .allMatch(entity -> entity.getId() > 0)\n+                .allMatch(entity -> entity.getEntityTypeId() != null);\n \n-        // verify entities\n-        for (EntityId entityId : entityIds) {\n-            assertThat(entityRepository.findById(entityId.getId())).isPresent();\n-        }\n+        entitiesIterableAssert", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NjY4Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521476683", "bodyText": "Continued chaining. Intellisense error was misleading but since I didn't need the return chaining works fine.", "author": "Nana-EC", "createdAt": "2020-11-11T16:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MzE1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex 602cf55c4..e8bdc6977 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -366,12 +365,10 @@ public class AbstractEntityRecordItemListenerTest extends IntegrationTest {\n             return;\n         }\n \n-        IterableAssert<Entities> entitiesIterableAssert = assertThat(entityRepository.findAll())\n+        assertThat(entityRepository.findAll())\n                 .hasSize(entityIds.length)\n                 .allMatch(entity -> entity.getId() > 0)\n-                .allMatch(entity -> entity.getEntityTypeId() != null);\n-\n-        entitiesIterableAssert\n+                .allMatch(entity -> entity.getEntityTypeId() != null)\n                 .extracting(Entities::toEntityId)\n                 .containsExactlyInAnyOrder(entityIds);\n     }\n", "next_change": {"commit": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex e8bdc6977..c6f10e619 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -365,11 +365,11 @@ public class AbstractEntityRecordItemListenerTest extends IntegrationTest {\n             return;\n         }\n \n-        assertThat(entityRepository.findAll())\n-                .hasSize(entityIds.length)\n-                .allMatch(entity -> entity.getId() > 0)\n-                .allMatch(entity -> entity.getEntityTypeId() != null)\n-                .extracting(Entities::toEntityId)\n-                .containsExactlyInAnyOrder(entityIds);\n+        assertEquals(entityIds.length, entityRepository.count());\n+\n+        // verify entities\n+        for (EntityId entityId : entityIds) {\n+            assertThat(entityRepository.findById(entityId.getId())).isPresent();\n+        }\n     }\n }\n", "next_change": {"commit": "88f9d4a81c84f67f52a94920adca590bcb2ecb32", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex c6f10e619..602cf55c4 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -365,11 +366,13 @@ public class AbstractEntityRecordItemListenerTest extends IntegrationTest {\n             return;\n         }\n \n-        assertEquals(entityIds.length, entityRepository.count());\n+        IterableAssert<Entities> entitiesIterableAssert = assertThat(entityRepository.findAll())\n+                .hasSize(entityIds.length)\n+                .allMatch(entity -> entity.getId() > 0)\n+                .allMatch(entity -> entity.getEntityTypeId() != null);\n \n-        // verify entities\n-        for (EntityId entityId : entityIds) {\n-            assertThat(entityRepository.findById(entityId.getId())).isPresent();\n-        }\n+        entitiesIterableAssert\n+                .extracting(Entities::toEntityId)\n+                .containsExactlyInAnyOrder(entityIds);\n     }\n }\n", "next_change": {"commit": "3d689050d99226ce8472b047bbe2d7456c88b25b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex 602cf55c4..e8bdc6977 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -366,12 +365,10 @@ public class AbstractEntityRecordItemListenerTest extends IntegrationTest {\n             return;\n         }\n \n-        IterableAssert<Entities> entitiesIterableAssert = assertThat(entityRepository.findAll())\n+        assertThat(entityRepository.findAll())\n                 .hasSize(entityIds.length)\n                 .allMatch(entity -> entity.getId() > 0)\n-                .allMatch(entity -> entity.getEntityTypeId() != null);\n-\n-        entitiesIterableAssert\n+                .allMatch(entity -> entity.getEntityTypeId() != null)\n                 .extracting(Entities::toEntityId)\n                 .containsExactlyInAnyOrder(entityIds);\n     }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex 602cf55c4..e8bdc6977 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -366,12 +365,10 @@ public class AbstractEntityRecordItemListenerTest extends IntegrationTest {\n             return;\n         }\n \n-        IterableAssert<Entities> entitiesIterableAssert = assertThat(entityRepository.findAll())\n+        assertThat(entityRepository.findAll())\n                 .hasSize(entityIds.length)\n                 .allMatch(entity -> entity.getId() > 0)\n-                .allMatch(entity -> entity.getEntityTypeId() != null);\n-\n-        entitiesIterableAssert\n+                .allMatch(entity -> entity.getEntityTypeId() != null)\n                 .extracting(Entities::toEntityId)\n                 .containsExactlyInAnyOrder(entityIds);\n     }\n", "next_change": {"commit": "1df70a2dec17067f1f917f2a48f451d3567b3dd9", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex e8bdc6977..f87af2a53 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -372,4 +408,9 @@ public class AbstractEntityRecordItemListenerTest extends IntegrationTest {\n                 .extracting(Entities::toEntityId)\n                 .containsExactlyInAnyOrder(entityIds);\n     }\n+\n+    protected void assertEntity(Entities expected) {\n+        Entities actual = getEntity(expected.getId());\n+        assertThat(actual).isEqualTo(expected);\n+    }\n }\n", "next_change": {"commit": "615d3bd51a08c41bc61efd1f3ca430bbb61b2d33", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex f87af2a53..be4e76ef7 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -413,4 +385,21 @@ public class AbstractEntityRecordItemListenerTest extends IntegrationTest {\n         Entities actual = getEntity(expected.getId());\n         assertThat(actual).isEqualTo(expected);\n     }\n+\n+    private RecordFile recordFile(long consensusStart, long consensusEnd, String filename) {\n+        return RecordFile.builder()\n+                .consensusStart(consensusStart)\n+                .consensusEnd(consensusEnd)\n+                .count(0L)\n+                .digestAlgorithm(DigestAlgorithm.SHA384)\n+                .fileHash(UUID.randomUUID().toString())\n+                .hash(UUID.randomUUID().toString())\n+                .index(nextIndex++)\n+                .loadEnd(Instant.now().getEpochSecond())\n+                .loadStart(Instant.now().getEpochSecond())\n+                .name(filename)\n+                .nodeAccountId(NODE_ACCOUNT_ID)\n+                .previousHash(\"\")\n+                .build();\n+    }\n }\n", "next_change": {"commit": "d80154fcf0a2bd4f19c9ec108f0c4d916f3793a3", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex be4e76ef7..9fcb20b8b 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -402,4 +444,57 @@ public class AbstractEntityRecordItemListenerTest extends IntegrationTest {\n                 .previousHash(\"\")\n                 .build();\n     }\n+\n+    @SneakyThrows\n+    protected void buildContractFunctionResult(ContractFunctionResult.Builder builder) {\n+        builder.setBloom(ByteString.copyFromUtf8(\"bloom\"));\n+        builder.setContractCallResult(ByteString.copyFromUtf8(\"call result\"));\n+        builder.setContractID(CONTRACT_ID);\n+        builder.addCreatedContractIDs(CONTRACT_ID);\n+        builder.addCreatedContractIDs(CREATED_CONTRACT_ID);\n+        builder.setErrorMessage(\"call error message\");\n+        builder.setEvmAddress(BytesValue.of(DomainUtils.fromBytes(domainBuilder.create2EvmAddress())));\n+        builder.setGasUsed(30);\n+        builder.addLogInfo(ContractLoginfo.newBuilder()\n+                .setBloom(ByteString.copyFromUtf8(\"bloom\"))\n+                .setContractID(CONTRACT_ID)\n+                .setData(ByteString.copyFromUtf8(\"data\"))\n+                .addTopic(ByteString.copyFromUtf8(\"Topic0\"))\n+                .addTopic(ByteString.copyFromUtf8(\"Topic1\"))\n+                .addTopic(ByteString.copyFromUtf8(\"Topic2\"))\n+                .addTopic(ByteString.copyFromUtf8(\"Topic3\")).build());\n+        builder.addLogInfo(ContractLoginfo.newBuilder()\n+                .setBloom(ByteString.copyFromUtf8(\"bloom\"))\n+                .setContractID(CREATED_CONTRACT_ID)\n+                .setData(ByteString.copyFromUtf8(\"data\"))\n+                .addTopic(ByteString.copyFromUtf8(\"Topic0\"))\n+                .addTopic(ByteString.copyFromUtf8(\"Topic1\"))\n+                .addTopic(ByteString.copyFromUtf8(\"Topic2\"))\n+                .addTopic(ByteString.copyFromUtf8(\"Topic3\")).build());\n+        // 3 state changes, no value written, valid value written and zero value written\n+        builder.addStateChanges(com.hederahashgraph.api.proto.java.ContractStateChange.newBuilder()\n+                .setContractID(CONTRACT_ID)\n+                .addStorageChanges(StorageChange.newBuilder()\n+                        .setSlot(ByteString\n+                                .copyFromUtf8(\"0x000000000000000000\"))\n+                        .setValueRead(ByteString\n+                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n+                        .build())\n+                .addStorageChanges(StorageChange.newBuilder()\n+                        .setSlot(ByteString\n+                                .copyFromUtf8(\"0x000000000000000001\"))\n+                        .setValueRead(ByteString\n+                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n+                        .setValueWritten(BytesValue.of(ByteString\n+                                .copyFromUtf8(\"0x000000000000000000000000000000000000000000c2a8c408d0e29d623347c5\")))\n+                        .build())\n+                .addStorageChanges(StorageChange.newBuilder()\n+                        .setSlot(ByteString\n+                                .copyFromUtf8(\"0x00000000000000002\"))\n+                        .setValueRead(ByteString\n+                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n+                        .setValueWritten(BytesValue.of(ByteString.copyFromUtf8(\"0\")))\n+                        .build())\n+                .build());\n+    }\n }\n", "next_change": {"commit": "44a4bd8bcf4d6d650441123dee019036a5eca78c", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex 9fcb20b8b..afd29ab67 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -471,30 +492,5 @@ public abstract class AbstractEntityRecordItemListenerTest extends IntegrationTe\n                 .addTopic(ByteString.copyFromUtf8(\"Topic1\"))\n                 .addTopic(ByteString.copyFromUtf8(\"Topic2\"))\n                 .addTopic(ByteString.copyFromUtf8(\"Topic3\")).build());\n-        // 3 state changes, no value written, valid value written and zero value written\n-        builder.addStateChanges(com.hederahashgraph.api.proto.java.ContractStateChange.newBuilder()\n-                .setContractID(CONTRACT_ID)\n-                .addStorageChanges(StorageChange.newBuilder()\n-                        .setSlot(ByteString\n-                                .copyFromUtf8(\"0x000000000000000000\"))\n-                        .setValueRead(ByteString\n-                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n-                        .build())\n-                .addStorageChanges(StorageChange.newBuilder()\n-                        .setSlot(ByteString\n-                                .copyFromUtf8(\"0x000000000000000001\"))\n-                        .setValueRead(ByteString\n-                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n-                        .setValueWritten(BytesValue.of(ByteString\n-                                .copyFromUtf8(\"0x000000000000000000000000000000000000000000c2a8c408d0e29d623347c5\")))\n-                        .build())\n-                .addStorageChanges(StorageChange.newBuilder()\n-                        .setSlot(ByteString\n-                                .copyFromUtf8(\"0x00000000000000002\"))\n-                        .setValueRead(ByteString\n-                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n-                        .setValueWritten(BytesValue.of(ByteString.copyFromUtf8(\"0\")))\n-                        .build())\n-                .build());\n     }\n }\n", "next_change": {"commit": "7c7a4e50f3e3262436e69eb468b8d5fff556d48b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex afd29ab67..21f45ca9e 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -493,4 +496,33 @@ public abstract class AbstractEntityRecordItemListenerTest extends IntegrationTe\n                 .addTopic(ByteString.copyFromUtf8(\"Topic2\"))\n                 .addTopic(ByteString.copyFromUtf8(\"Topic3\")).build());\n     }\n+\n+    protected void buildContractStateChanges(ContractStateChanges.Builder builder) {\n+        // 3 state changes, no value written, valid value written and zero value written\n+        builder.addContractStateChanges(\n+            ContractStateChange.newBuilder()\n+                .setContractId(CONTRACT_ID)\n+                .addStorageChanges(StorageChange.newBuilder()\n+                        .setSlot(ByteString\n+                                .copyFromUtf8(\"0x000000000000000000\"))\n+                        .setValueRead(ByteString\n+                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n+                        .build())\n+                .addStorageChanges(StorageChange.newBuilder()\n+                        .setSlot(ByteString\n+                                .copyFromUtf8(\"0x000000000000000001\"))\n+                        .setValueRead(ByteString\n+                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n+                        .setValueWritten(BytesValue.of(ByteString\n+                                .copyFromUtf8(\"0x000000000000000000000000000000000000000000c2a8c408d0e29d623347c5\")))\n+                        .build())\n+                .addStorageChanges(StorageChange.newBuilder()\n+                        .setSlot(ByteString\n+                                .copyFromUtf8(\"0x00000000000000002\"))\n+                        .setValueRead(ByteString\n+                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n+                        .setValueWritten(BytesValue.of(ByteString.copyFromUtf8(\"0\")))\n+                        .build())\n+                .build());\n+    }\n }\n", "next_change": {"commit": "f369a6652c704d28f65d28f74414cd8b8c65b6f9", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex 21f45ca9e..f522187bd 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -500,29 +493,33 @@ public abstract class AbstractEntityRecordItemListenerTest extends IntegrationTe\n     protected void buildContractStateChanges(ContractStateChanges.Builder builder) {\n         // 3 state changes, no value written, valid value written and zero value written\n         builder.addContractStateChanges(\n-            ContractStateChange.newBuilder()\n-                .setContractId(CONTRACT_ID)\n-                .addStorageChanges(StorageChange.newBuilder()\n-                        .setSlot(ByteString\n-                                .copyFromUtf8(\"0x000000000000000000\"))\n-                        .setValueRead(ByteString\n-                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n-                        .build())\n-                .addStorageChanges(StorageChange.newBuilder()\n-                        .setSlot(ByteString\n-                                .copyFromUtf8(\"0x000000000000000001\"))\n-                        .setValueRead(ByteString\n-                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n-                        .setValueWritten(BytesValue.of(ByteString\n-                                .copyFromUtf8(\"0x000000000000000000000000000000000000000000c2a8c408d0e29d623347c5\")))\n-                        .build())\n-                .addStorageChanges(StorageChange.newBuilder()\n-                        .setSlot(ByteString\n-                                .copyFromUtf8(\"0x00000000000000002\"))\n-                        .setValueRead(ByteString\n-                                .copyFromUtf8(\"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n-                        .setValueWritten(BytesValue.of(ByteString.copyFromUtf8(\"0\")))\n-                        .build())\n-                .build());\n+                ContractStateChange.newBuilder()\n+                        .setContractId(CONTRACT_ID)\n+                        .addStorageChanges(StorageChange.newBuilder()\n+                                .setSlot(ByteString\n+                                        .copyFromUtf8(\"0x000000000000000000\"))\n+                                .setValueRead(ByteString\n+                                        .copyFromUtf8(\n+                                                \"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n+                                .build())\n+                        .addStorageChanges(StorageChange.newBuilder()\n+                                .setSlot(ByteString\n+                                        .copyFromUtf8(\"0x000000000000000001\"))\n+                                .setValueRead(ByteString\n+                                        .copyFromUtf8(\n+                                                \"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n+                                .setValueWritten(BytesValue.of(ByteString\n+                                        .copyFromUtf8(\n+                                                \"0x000000000000000000000000000000000000000000c2a8c408d0e29d623347c5\")))\n+                                .build())\n+                        .addStorageChanges(StorageChange.newBuilder()\n+                                .setSlot(ByteString\n+                                        .copyFromUtf8(\"0x00000000000000002\"))\n+                                .setValueRead(ByteString\n+                                        .copyFromUtf8(\n+                                                \"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n+                                .setValueWritten(BytesValue.of(ByteString.copyFromUtf8(\"0\")))\n+                                .build())\n+                        .build());\n     }\n }\n", "next_change": {"commit": "69ea7026eba77d2a53515f09b3bb85021194a82a", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\nindex f522187bd..802c83617 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/parser/record/entity/AbstractEntityRecordItemListenerTest.java\n", "chunk": "@@ -490,36 +488,19 @@ public abstract class AbstractEntityRecordItemListenerTest extends IntegrationTe\n                 .addTopic(ByteString.copyFromUtf8(\"Topic3\")).build());\n     }\n \n-    protected void buildContractStateChanges(ContractStateChanges.Builder builder) {\n-        // 3 state changes, no value written, valid value written and zero value written\n-        builder.addContractStateChanges(\n-                ContractStateChange.newBuilder()\n-                        .setContractId(CONTRACT_ID)\n-                        .addStorageChanges(StorageChange.newBuilder()\n-                                .setSlot(ByteString\n-                                        .copyFromUtf8(\"0x000000000000000000\"))\n-                                .setValueRead(ByteString\n-                                        .copyFromUtf8(\n-                                                \"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n-                                .build())\n-                        .addStorageChanges(StorageChange.newBuilder()\n-                                .setSlot(ByteString\n-                                        .copyFromUtf8(\"0x000000000000000001\"))\n-                                .setValueRead(ByteString\n-                                        .copyFromUtf8(\n-                                                \"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n-                                .setValueWritten(BytesValue.of(ByteString\n-                                        .copyFromUtf8(\n-                                                \"0x000000000000000000000000000000000000000000c2a8c408d0e29d623347c5\")))\n-                                .build())\n-                        .addStorageChanges(StorageChange.newBuilder()\n-                                .setSlot(ByteString\n-                                        .copyFromUtf8(\"0x00000000000000002\"))\n-                                .setValueRead(ByteString\n-                                        .copyFromUtf8(\n-                                                \"0xaf846d22986843e3d25981b94ce181adc556b334ccfdd8225762d7f709841df0\"))\n-                                .setValueWritten(BytesValue.of(ByteString.copyFromUtf8(\"0\")))\n-                                .build())\n-                        .build());\n+    protected TransactionID transactionId(Entity payer, long validStartTimestamp) {\n+        return transactionId(payer.toEntityId(), validStartTimestamp);\n+    }\n+\n+    protected TransactionID transactionId(EntityId payerAccountId, long validStartTimestamp) {\n+        var payer = AccountID.newBuilder()\n+                .setShardNum(payerAccountId.getShardNum())\n+                .setRealmNum(payerAccountId.getRealmNum())\n+                .setAccountNum(payerAccountId.getEntityNum())\n+                .build();\n+        return TransactionID.newBuilder()\n+                .setAccountID(payer)\n+                .setTransactionValidStart(TestUtils.toTimestamp(validStartTimestamp))\n+                .build();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}, {"oid": "a56ea83364b2c8e38746a5a5048555dad80741d3", "committedDate": "2021-01-05 09:24:38 -0600", "message": "Refactor Record File Reader (#1382)"}, {"oid": "7adb6e2c8964f72cc2e19c61c04ffd1bea4bc910", "committedDate": "2021-01-08 11:48:28 -0600", "message": "TimescaleDB: Add psql to timescaledb migration scripts (#1364)"}, {"oid": "4e6dcf6013cd1efe285cd38178c332ce46d00a80", "committedDate": "2021-01-11 10:42:50 -0600", "message": "Update copyright to 2021 (#1425)"}, {"oid": "f8cc374fa621d009de539eed4beb496edb58fecc", "committedDate": "2021-01-12 15:32:12 -0600", "message": "Utilize newTotalSupply field from HAPI (#1426)"}, {"oid": "819a776dc0db274add954aa0be3f5f2f5da9cea5", "committedDate": "2021-01-20 10:26:26 -0600", "message": "Support record file v5 (#1445)"}, {"oid": "1df70a2dec17067f1f917f2a48f451d3567b3dd9", "committedDate": "2021-02-11 18:45:51 -0600", "message": "Support new entity memo fields (#1567)"}, {"oid": "776d39ad57ee5647dbc899964a71777d420dfd55", "committedDate": "2021-02-18 16:38:32 -0600", "message": "Remove filesystem dependency (#1554)"}, {"oid": "615d3bd51a08c41bc61efd1f3ca430bbb61b2d33", "committedDate": "2021-02-22 17:15:37 -0600", "message": "Add block index to record file (#1595)"}, {"oid": "045079e27de5026fc5f168932b97c72f4654964d", "committedDate": "2021-03-25 14:00:46 -0500", "message": "Proto based balance file parser (#1713)"}, {"oid": "0c3d94b17a2e300b36023ac8cd5ae76e4b1d397d", "committedDate": "2021-03-30 14:54:45 -0500", "message": "Update importer for revised scheduled transaction design (#1766)"}, {"oid": "20e482b733372cfa7bee0bf06689af2e748b900c", "committedDate": "2021-04-05 12:59:13 -0500", "message": "Migrate and update t_entities to entity table (#1779)"}, {"oid": "419ed6e2bc0c8cd92e15e502be61b19c2a0a0fe3", "committedDate": "2021-06-16 09:38:13 -0500", "message": "Fix slow domain object ingestion (#2006)"}, {"oid": "59f084044fdc5b121cd0fe7a00ee93d4970cadf8", "committedDate": "2021-06-17 13:38:35 -0500", "message": "NFT Importer Support (#2109)"}, {"oid": "e2ec527e04def4539439fe8cbcba741ac88806d5", "committedDate": "2021-07-02 17:38:59 -0500", "message": "Add an alert for missing balance file (#2219)"}, {"oid": "643f0c788bf111205c08f13d5fd38c8e3ffc6e12", "committedDate": "2021-07-07 18:21:12 -0500", "message": "Custom fees importer (#2236)"}, {"oid": "f497f232b75986248e881745cd56edd6c9ab2d4b", "committedDate": "2021-10-20 10:27:38 -0500", "message": "Fix importer not persisting some account entity fields (#2720)"}, {"oid": "b1b4f1930ab66491b028bbee4e0220affb2ecc63", "committedDate": "2021-10-25 16:04:55 -0500", "message": "Update smart contract parsing logic (#2728)"}, {"oid": "b1b558e5c1d776ba35edef5a22b5e1ce78774bc0", "committedDate": "2021-10-28 12:41:48 -0500", "message": "Remove t_entity_types table (#2727)"}, {"oid": "43405e888c8f070ccf4978d61dc71ff1c59c6529", "committedDate": "2021-10-28 15:06:35 -0500", "message": "Rename EntityTypeEnum to EntityType in importer  (#2757)"}, {"oid": "36e34ddaa2ddc323636c47f3a84bd161b8b866ab", "committedDate": "2021-11-02 15:56:55 -0500", "message": "Remove minimal entity creation (#2781)"}, {"oid": "c656441678f0d3f285e4658e82583e1474e3729e", "committedDate": "2021-12-06 17:52:39 -0600", "message": "Add a hedera-mirror-common module (#2927)"}, {"oid": "69670ec12da1db17d9d96cc673d4f29e2a8b17ae", "committedDate": "2021-12-09 12:37:57 -0600", "message": "Add support for HIP-32 account auto creation (#2961)"}, {"oid": "751b5f6038521620a8d06cdd847eb9f70db7b46c", "committedDate": "2021-12-22 11:19:46 -0600", "message": "Fix auto created account alias not cached (#3057)"}, {"oid": "edbc305323be54431cf878edad534755ce072115", "committedDate": "2022-01-19 16:56:14 -0600", "message": "Add a get address book nodes gRPC API (#3141)"}, {"oid": "65b7f5080f7746a638793b600e0ce50fd106b33c", "committedDate": "2022-02-08 09:31:46 -0600", "message": "Support HIP-336 Allowance APIs (#3252)"}, {"oid": "ebe64bac7f644b34f32fb2e6d5a15877793db397", "committedDate": "2022-02-09 10:02:49 -0600", "message": "Update license year to 2022 (#3283)"}, {"oid": "2aa72885bea12c8afd94c65f7ad7cc8310686a74", "committedDate": "2022-03-01 19:57:59 -0600", "message": "Workaround alias not found issue (#3339)"}, {"oid": "8a200dc92435e7eddc55ee17a49d6a194dd84a71", "committedDate": "2022-03-08 15:42:09 -0300", "message": "Remove crypto transfer for initial balance (#3358)"}, {"oid": "a21d5c9f6e95a31bc9be3e3ecb8c6c95d237c37e", "committedDate": "2022-03-09 13:41:59 -0600", "message": "Add an errata migration (#3353)"}, {"oid": "d80154fcf0a2bd4f19c9ec108f0c4d916f3793a3", "committedDate": "2022-03-09 22:36:26 +0000", "message": "Add ContractResults support for all transaction types (#3285)"}, {"oid": "c16ad7207cfcdcafeae1849e5512ff587becf7c6", "committedDate": "2022-04-05 18:43:17 +0000", "message": "Support missing precompile contract function parameter details (#3473)"}, {"oid": "af3fd9f2a81d619f5d74a0d16a0bb301968eb2fd", "committedDate": "2022-04-12 10:40:35 -0500", "message": "Track NFT allowances at transfer granularity (#3529)"}, {"oid": "f6ecfe1250df9ad706e385352d73dde90e56ed54", "committedDate": "2022-04-18 18:05:25 -0300", "message": "03446 fix is approval value from transactions (#3563)"}, {"oid": "065dc03c1ff3886a5898e7a44fa893ee7d47133b", "committedDate": "2022-05-03 08:32:12 -0500", "message": "Add ethereum nonce and evm address to entity (#3677)"}, {"oid": "5c26c56e384fb3713461abdc4b3b1570ad20c6c5", "committedDate": "2022-05-03 16:21:32 -0500", "message": "HIP-16 Support contract expiry (#3701)"}, {"oid": "e59776f9da1ba897bfacb0211bb2195b9e262189", "committedDate": "2022-05-24 11:37:17 -0500", "message": "Fix surefire unable to catch test case failures (#3848)"}, {"oid": "fc466f22e878999bd45d9cafe2b5ebbaf8c7f57a", "committedDate": "2022-06-02 20:44:39 -0500", "message": "Persist node staking information (#3886)"}, {"oid": "5b12348d93f49a812f864c68ed69ba3efabcd661", "committedDate": "2022-06-03 09:47:51 -0500", "message": "Add entity staking fields (#3845)"}, {"oid": "834b5f7f264c67c8dc949449f7e1b4d1bcc279af", "committedDate": "2022-06-03 12:03:25 -0500", "message": "HIP-406 store staking rewards (#3854)"}, {"oid": "f29fc0e204beb96e08cdc74952b1dac8cb00e52a", "committedDate": "2022-06-21 08:42:38 -0500", "message": "Update staking field ingestion and show account staking fields in rest api (#3956)"}, {"oid": "99a20239472e7fb373ab23aca120a6b7f37b16ff", "committedDate": "2022-06-22 14:24:12 -0500", "message": "Support record stream v6 (#3916)"}, {"oid": "44a4bd8bcf4d6d650441123dee019036a5eca78c", "committedDate": "2022-07-15 16:07:43 -0500", "message": "HIP-513 download sidecar files (#4106)"}, {"oid": "7c7a4e50f3e3262436e69eb468b8d5fff556d48b", "committedDate": "2022-07-22 17:01:57 -0400", "message": "HIP-513 Add Persistence for Sidecar Data (#4107)"}, {"oid": "f369a6652c704d28f65d28f74414cd8b8c65b6f9", "committedDate": "2022-08-02 17:51:07 -0500", "message": "Merge contract and entity tables (#4227)"}, {"oid": "fdfe49817aa5f96d5b36e0238451a5cf05d8ad9f", "committedDate": "2022-08-10 21:07:52 -0500", "message": "Store current account balance (#4235)"}, {"oid": "2b66600d19da599d033be334a0951684353b98b5", "committedDate": "2022-10-07 09:34:27 -0500", "message": "Randomize node used to download data files (#4612)"}, {"oid": "69ea7026eba77d2a53515f09b3bb85021194a82a", "committedDate": "2022-11-15 10:50:26 -0600", "message": "Fix incorrect staking info and pending reward  (#4838)"}, {"oid": "2fedd6166240a93829916d2fcaa414223f36aafe", "committedDate": "2023-01-06 10:57:00 -0600", "message": "Fix major code smells (#5171)"}, {"oid": "df1991554c5730d45d57f3a59d70da5e6ed7ae78", "committedDate": "2023-01-09 15:14:59 -0500", "message": "Fix minor code smells (#5175)"}, {"oid": "9258c7ccc4516c5d6606606a9f5ff21237123189", "committedDate": "2023-01-27 15:30:40 -0600", "message": "Update copyright year in license to 2023 (#5284)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5ODk1NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520798955", "body": "This doesn't work here. Nor should you have transactions within the larger flyway transaction as it would leave the database in an inconsistent state.", "bodyText": "This doesn't work here. Nor should you have transactions within the larger flyway transaction as it would leave the database in an inconsistent state.", "bodyHTML": "<p dir=\"auto\">This doesn't work here. Nor should you have transactions within the larger flyway transaction as it would leave the database in an inconsistent state.</p>", "author": "steven-sheehy", "createdAt": "2020-11-10T18:55:54Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1NjM3OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520956379", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-11-11T00:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5ODk1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -165,55 +174,52 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n      * @return\n      * @throws SQLException\n      */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+    private List<TypeMismatchedEntity> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n         log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n                 \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n                 new Object[] {entityId, consensusTimestamp, pageSize},\n                 new RowMapper<>() {\n                     @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n                         return getTypeMismatchedEntity(rs);\n                     }\n                 });\n \n-        if (entityIdTypes.isEmpty()) {\n+        if (typeMismatchedEntities.isEmpty()) {\n             // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n             return null;\n         }\n \n         // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n \n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+        return typeMismatchedEntities;\n     }\n \n     /**\n      * Batch update entities with correct fk_entity_type_id\n      *\n-     * @param entityIdTypes List of mismatched entities\n+     * @param typeMismatchedEntities List of mismatched entities\n      * @return\n      */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n+        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n         return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n+                ENTITY_TYPE_UPDATE_SQL,\n+                typeMismatchedEntities,\n                 flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n                 new ParameterizedPreparedStatementSetter<>() {\n                     @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n+                        long id = typeMismatchedEntity.entityId;\n+                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n                         ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n                     }\n                 }\n         );\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNDc1OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520834759", "body": "You should move non join statements to a where clause for clarity. They produce the same query plan for inner joins either way.", "bodyText": "You should move non join statements to a where clause for clarity. They produce the same query plan for inner joins either way.", "bodyHTML": "<p dir=\"auto\">You should move non join statements to a where clause for clarity. They produce the same query plan for inner joins either way.</p>", "author": "steven-sheehy", "createdAt": "2020-11-10T19:53:11Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NzE2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521477160", "bodyText": "Moved out into where.\nAlso created a separate where string for easier reading.", "author": "Nana-EC", "createdAt": "2020-11-11T16:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNDc1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -39,54 +38,47 @@ import org.springframework.context.annotation.Lazy;\n import org.springframework.jdbc.core.JdbcTemplate;\n import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n \n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n import com.hedera.mirror.importer.util.Utility;\n \n @Log4j2\n @Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n     private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n+    private final JdbcTemplate jdbcTemplate;\n \n     private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n             \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private final String ENTITY_MISMATCH_WHERE_CLAUSE_SQL = \"t.result = 22 and ((t.type = 11 and  e.fk_entity_type_id\" +\n+            \" <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and e.fk_entity_type_id <> 3) or (t\" +\n+            \".type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and e.fk_entity_type_id <> 5))\";\n+    private final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_MISMATCH_WHERE_CLAUSE_SQL +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and t\" +\n+            \".consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc, consensus_ns desc \" +\n             \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+    private final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n \n     AtomicLong entityIdCap;\n     AtomicLong timestampCap;\n     AtomicLong entityTransactionCount;\n     AtomicLong entityTransactionMismatchCount;\n \n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n                                          FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n+        this.jdbcTemplate = jdbcTemplate;\n         this.flywayMigrationProperties = flywayMigrationProperties;\n     }\n \n     @Override\n     public void migrate(Context context) throws Exception {\n         Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n \n         // retrieve max entityId value witness by transactions table.\n         Long maxEntityId = getMaxEntityId();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNzE2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520837164", "body": "Just inject a `JdbcOperations` instead of the `DataSource`.", "bodyText": "Just inject a JdbcOperations instead of the DataSource.", "bodyHTML": "<p dir=\"auto\">Just inject a <code>JdbcOperations</code> instead of the <code>DataSource</code>.</p>", "author": "steven-sheehy", "createdAt": "2020-11-10T19:57:34Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NzM2NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521477364", "bodyText": "Injected JdbcOperations", "author": "Nana-EC", "createdAt": "2020-11-11T16:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzNzE2NA=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -39,54 +38,47 @@ import org.springframework.context.annotation.Lazy;\n import org.springframework.jdbc.core.JdbcTemplate;\n import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n \n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n import com.hedera.mirror.importer.util.Utility;\n \n @Log4j2\n @Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n     private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n+    private final JdbcTemplate jdbcTemplate;\n \n     private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n             \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private final String ENTITY_MISMATCH_WHERE_CLAUSE_SQL = \"t.result = 22 and ((t.type = 11 and  e.fk_entity_type_id\" +\n+            \" <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and e.fk_entity_type_id <> 3) or (t\" +\n+            \".type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and e.fk_entity_type_id <> 5))\";\n+    private final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_MISMATCH_WHERE_CLAUSE_SQL +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and t\" +\n+            \".consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc, consensus_ns desc \" +\n             \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+    private final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n \n     AtomicLong entityIdCap;\n     AtomicLong timestampCap;\n     AtomicLong entityTransactionCount;\n     AtomicLong entityTransactionMismatchCount;\n \n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n                                          FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n+        this.jdbcTemplate = jdbcTemplate;\n         this.flywayMigrationProperties = flywayMigrationProperties;\n     }\n \n     @Override\n     public void migrate(Context context) throws Exception {\n         Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n \n         // retrieve max entityId value witness by transactions table.\n         Long maxEntityId = getMaxEntityId();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NDA1Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520864053", "body": "Both these repositories are unused and should be removed.", "bodyText": "Both these repositories are unused and should be removed.", "bodyHTML": "<p dir=\"auto\">Both these repositories are unused and should be removed.</p>", "author": "steven-sheehy", "createdAt": "2020-11-10T20:47:48Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxMDEwMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520910100", "bodyText": "Left over, removed", "author": "Nana-EC", "createdAt": "2020-11-10T22:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NDA1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -39,54 +38,47 @@ import org.springframework.context.annotation.Lazy;\n import org.springframework.jdbc.core.JdbcTemplate;\n import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n \n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n import com.hedera.mirror.importer.util.Utility;\n \n @Log4j2\n @Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n     private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n+    private final JdbcTemplate jdbcTemplate;\n \n     private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n             \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private final String ENTITY_MISMATCH_WHERE_CLAUSE_SQL = \"t.result = 22 and ((t.type = 11 and  e.fk_entity_type_id\" +\n+            \" <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and e.fk_entity_type_id <> 3) or (t\" +\n+            \".type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and e.fk_entity_type_id <> 5))\";\n+    private final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_MISMATCH_WHERE_CLAUSE_SQL +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and t\" +\n+            \".consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc, consensus_ns desc \" +\n             \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+    private final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n \n     AtomicLong entityIdCap;\n     AtomicLong timestampCap;\n     AtomicLong entityTransactionCount;\n     AtomicLong entityTransactionMismatchCount;\n \n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n                                          FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n+        this.jdbcTemplate = jdbcTemplate;\n         this.flywayMigrationProperties = flywayMigrationProperties;\n     }\n \n     @Override\n     public void migrate(Context context) throws Exception {\n         Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n \n         // retrieve max entityId value witness by transactions table.\n         Long maxEntityId = getMaxEntityId();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NDc0NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520864745", "body": "Don't think we need to denote Nullable on non-API/internal methods", "bodyText": "Don't think we need to denote Nullable on non-API/internal methods", "bodyHTML": "<p dir=\"auto\">Don't think we need to denote Nullable on non-API/internal methods</p>", "author": "steven-sheehy", "createdAt": "2020-11-10T20:49:09Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NzUyNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521477524", "bodyText": "Removed", "author": "Nana-EC", "createdAt": "2020-11-11T16:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NDc0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -145,14 +140,28 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n     /**\n      * Gets the numbers of entity type mismatches found for a specific type of entity\n      *\n-     * @param args\n      * @return\n      */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entities found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n \n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n     }\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2ODExNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520868115", "body": "What's the point of backing up if we're going to drop it at the end? If something goes wrong the transaction will rollback.", "bodyText": "What's the point of backing up if we're going to drop it at the end? If something goes wrong the transaction will rollback.", "bodyHTML": "<p dir=\"auto\">What's the point of backing up if we're going to drop it at the end? If something goes wrong the transaction will rollback.</p>", "author": "steven-sheehy", "createdAt": "2020-11-10T20:55:37Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk1Njg3MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520956871", "bodyText": "Will removed, had toyed with the idea of leaving temp table around for a while, then deciding on dropping.\nGiven migration logic and verification I can remove temp table need.", "author": "Nana-EC", "createdAt": "2020-11-11T00:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2ODExNQ=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -105,27 +103,24 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n         // transactions\n         // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n         // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n+        List<TypeMismatchedEntity> typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchedEntityList != null) {\n+            if (!typeMismatchedEntityList.isEmpty()) {\n+                batchUpdate(typeMismatchedEntityList);\n             }\n \n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+            typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n                     .getEntityMismatchReadPageSize());\n         }\n \n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n                         .get(), entityTransactionMismatchCount.get());\n \n         verifyNoEntityMismatchesExist();\n \n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+        log.info(\"Migration processed in {}.\", stopwatch);\n     }\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NTk1Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520875957", "body": "Don't need to hardcode to seconds, can just log.info(\"{}\", stopwatch) and it will automatically use the biggest duration unit.", "bodyText": "Don't need to hardcode to seconds, can just log.info(\"{}\", stopwatch) and it will automatically use the biggest duration unit.", "bodyHTML": "<p dir=\"auto\">Don't need to hardcode to seconds, can just log.info(\"{}\", stopwatch) and it will automatically use the biggest duration unit.</p>", "author": "steven-sheehy", "createdAt": "2020-11-10T21:10:58Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3NzgyOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521477828", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-11-11T16:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NTk1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -105,27 +103,24 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n         // transactions\n         // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n         // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n+        List<TypeMismatchedEntity> typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchedEntityList != null) {\n+            if (!typeMismatchedEntityList.isEmpty()) {\n+                batchUpdate(typeMismatchedEntityList);\n             }\n \n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+            typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n                     .getEntityMismatchReadPageSize());\n         }\n \n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n                         .get(), entityTransactionMismatchCount.get());\n \n         verifyNoEntityMismatchesExist();\n \n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+        log.info(\"Migration processed in {}.\", stopwatch);\n     }\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NzI0NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520877244", "body": "Each of these is a full table scan since it doesn't use indexes. You can just do a single query with a group by. You can then use having to remove rows equal to zero and have a single throw statement.", "bodyText": "Each of these is a full table scan since it doesn't use indexes. You can just do a single query with a group by. You can then use having to remove rows equal to zero and have a single throw statement.", "bodyHTML": "<p dir=\"auto\">Each of these is a full table scan since it doesn't use indexes. You can just do a single query with a group by. You can then use having to remove rows equal to zero and have a single throw statement.</p>", "author": "steven-sheehy", "createdAt": "2020-11-10T21:13:26Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n+        return entityIdType;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3ODc1NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521478754", "bodyText": "Adopted single query. With group by letting me log  clearly each entity type that has mismatches whiles till having a single throw for if it's at all above 0", "author": "Nana-EC", "createdAt": "2020-11-11T16:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NzI0NA=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -289,44 +292,19 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n      */\n     private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n         log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n+        int entityMismatchCount = getMismatchCount();\n+        if (entityMismatchCount > 0) {\n+            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n         }\n     }\n \n     @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n+    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n+    private class TypeMismatchedEntity {\n         private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n+        private final int correctedEntityTypeId;\n         private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n+        private final int initialEntityTypeId;\n+        private final int transactionType;\n     }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3OTQ2OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520879469", "body": "Why do we need to confirm no entity mismatch unless the database migration has a bug? If it there is a bug in the migration do we really want to block/fail the deployment? We haven't done this in any previous migration", "bodyText": "Why do we need to confirm no entity mismatch unless the database migration has a bug? If it there is a bug in the migration do we really want to block/fail the deployment? We haven't done this in any previous migration", "bodyHTML": "<p dir=\"auto\">Why do we need to confirm no entity mismatch unless the database migration has a bug? If it there is a bug in the migration do we really want to block/fail the deployment? We haven't done this in any previous migration</p>", "author": "steven-sheehy", "createdAt": "2020-11-10T21:18:03Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n+        return entityIdType;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNjI5Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520926297", "bodyText": "In migrations where info is deleted/updated I think if there's a way to verify the final state is as expected we should utilize it.\nIf it's not we certainly should fail and prioritize accuracy, no?", "author": "Nana-EC", "createdAt": "2020-11-10T22:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3OTQ2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -275,11 +277,12 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n             return null;\n         }\n \n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n+        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n+                entityId,\n                 originalEntityType, transactionType);\n         entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n+        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n+        return typeMismatchedEntity;\n     }\n \n     /**\n", "next_change": null}, {"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -289,44 +292,19 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n      */\n     private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n         log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n+        int entityMismatchCount = getMismatchCount();\n+        if (entityMismatchCount > 0) {\n+            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n         }\n     }\n \n     @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n+    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n+    private class TypeMismatchedEntity {\n         private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n+        private final int correctedEntityTypeId;\n         private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n+        private final int initialEntityTypeId;\n+        private final int transactionType;\n     }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwNjYyMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520906623", "body": "```suggestion\r\n                        ps.setInt(1, entityIdType.correctedEntityTypeId);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    ps.setLong(1, entityIdType.correctedEntityTypeId);\n          \n          \n            \n                                    ps.setInt(1, entityIdType.correctedEntityTypeId);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        ps<span class=\"pl-k\">.</span><span class=\"x x-first x-last\">setLong</span>(<span class=\"pl-c1\">1</span>, entityIdType<span class=\"pl-k\">.</span>correctedEntityTypeId);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        ps<span class=\"pl-k\">.</span><span class=\"x x-first x-last\">setInt</span>(<span class=\"pl-c1\">1</span>, entityIdType<span class=\"pl-k\">.</span>correctedEntityTypeId);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "xin-hedera", "createdAt": "2020-11-10T22:11:39Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ3ODkwNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521478904", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-11-11T16:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwNjYyMw=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -165,55 +174,52 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n      * @return\n      * @throws SQLException\n      */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+    private List<TypeMismatchedEntity> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n         log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n                 \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n                 new Object[] {entityId, consensusTimestamp, pageSize},\n                 new RowMapper<>() {\n                     @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n                         return getTypeMismatchedEntity(rs);\n                     }\n                 });\n \n-        if (entityIdTypes.isEmpty()) {\n+        if (typeMismatchedEntities.isEmpty()) {\n             // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n             return null;\n         }\n \n         // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n \n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+        return typeMismatchedEntities;\n     }\n \n     /**\n      * Batch update entities with correct fk_entity_type_id\n      *\n-     * @param entityIdTypes List of mismatched entities\n+     * @param typeMismatchedEntities List of mismatched entities\n      * @return\n      */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n+        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n         return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n+                ENTITY_TYPE_UPDATE_SQL,\n+                typeMismatchedEntities,\n                 flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n                 new ParameterizedPreparedStatementSetter<>() {\n                     @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n+                        long id = typeMismatchedEntity.entityId;\n+                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n                         ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n                     }\n                 }\n         );\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwNzM2MA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520907360", "body": "```suggestion\r\n        private final int correctedEntityTypeId;\r\n        private final long entityId;\r\n        private final int initialEntityTypeId;\r\n        private final int transactionType;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private final long correctedEntityTypeId;\n          \n          \n            \n                    private final long entityId;\n          \n          \n            \n                    private final long initialEntityTypeId;\n          \n          \n            \n                    private final long transactionType;\n          \n          \n            \n                    private final int correctedEntityTypeId;\n          \n          \n            \n                    private final long entityId;\n          \n          \n            \n                    private final int initialEntityTypeId;\n          \n          \n            \n                    private final int transactionType;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k x x-first x-last\">long</span> correctedEntityTypeId;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">long</span> entityId;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k x x-first x-last\">long</span> initialEntityTypeId;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k x x-first x-last\">long</span> transactionType;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k x x-first x-last\">int</span> correctedEntityTypeId;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">long</span> entityId;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k x x-first x-last\">int</span> initialEntityTypeId;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">private</span> <span class=\"pl-k\">final</span> <span class=\"pl-k x x-first x-last\">int</span> transactionType;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "xin-hedera", "createdAt": "2020-11-10T22:13:02Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        if (expectedEntityType.getId() == currentEntityType) {\n+            return 0;\n+        }\n+\n+        return expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n+        return entityIdType;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n+                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n+        if (accountMismatchCount > 0) {\n+            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n+        }\n+\n+        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n+                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n+        if (contractMismatchCount > 0) {\n+            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n+        }\n+\n+        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n+                .getProtoId(), EntityTypeEnum.FILE.getId());\n+        if (fileMismatchCount > 0) {\n+            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n+        }\n+\n+        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n+                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n+        if (topicMismatchCount > 0) {\n+            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n+        }\n+\n+        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n+                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n+        if (tokenMismatchCount > 0) {\n+            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n+        }\n+    }\n+\n+    @Data\n+    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n+    private class EntityIdType {\n+        private final long consensusTimestamp;\n+        private final long correctedEntityTypeId;\n+        private final long entityId;\n+        private final long initialEntityTypeId;\n+        private final long transactionType;", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3Mjc3Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520972773", "bodyText": "Updating, only the entityId and timestamp need to be of type long", "author": "Nana-EC", "createdAt": "2020-11-11T00:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkwNzM2MA=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -289,44 +292,19 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n      */\n     private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n         log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n+        int entityMismatchCount = getMismatchCount();\n+        if (entityMismatchCount > 0) {\n+            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n         }\n     }\n \n     @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n+    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n+    private class TypeMismatchedEntity {\n         private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n+        private final int correctedEntityTypeId;\n         private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n+        private final int initialEntityTypeId;\n+        private final int transactionType;\n     }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDEzNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520914134", "body": "nit: order by consensus_ns desc is redundant since there won't be duplicate entity IDs in those successful create transactions", "bodyText": "nit: order by consensus_ns desc is redundant since there won't be duplicate entity IDs in those successful create transactions", "bodyHTML": "<p dir=\"auto\">nit: order by consensus_ns desc is redundant since there won't be duplicate entity IDs in those successful create transactions</p>", "author": "xin-hedera", "createdAt": "2020-11-10T22:27:13Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxNTUxMg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521015512", "bodyText": "the order by is to ensure that the search is done in desc order to support the batching of search", "author": "Nana-EC", "createdAt": "2020-11-11T01:58:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQyMDEzOA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521420138", "bodyText": "I got that part, I meant only order by id desc is needed for the reason I provided in the initial comment.", "author": "xin-hedera", "createdAt": "2020-11-11T15:03:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MDU3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521480575", "bodyText": "Sure, I guess that inherently works because entity id are created in asc id value over time.", "author": "Nana-EC", "createdAt": "2020-11-11T16:29:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUxMjU3MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521512571", "bodyText": "Updated", "author": "Nana-EC", "createdAt": "2020-11-11T17:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNDEzNA=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -39,54 +38,47 @@ import org.springframework.context.annotation.Lazy;\n import org.springframework.jdbc.core.JdbcTemplate;\n import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n \n import com.hedera.mirror.importer.domain.EntityTypeEnum;\n import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n import com.hedera.mirror.importer.util.Utility;\n \n @Log4j2\n @Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n     private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n+    private final JdbcTemplate jdbcTemplate;\n \n     private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n             \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private final String ENTITY_MISMATCH_WHERE_CLAUSE_SQL = \"t.result = 22 and ((t.type = 11 and  e.fk_entity_type_id\" +\n+            \" <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and e.fk_entity_type_id <> 3) or (t\" +\n+            \".type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and e.fk_entity_type_id <> 5))\";\n+    private final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_MISMATCH_WHERE_CLAUSE_SQL +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and t\" +\n+            \".consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc, consensus_ns desc \" +\n             \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+    private final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n \n     AtomicLong entityIdCap;\n     AtomicLong timestampCap;\n     AtomicLong entityTransactionCount;\n     AtomicLong entityTransactionMismatchCount;\n \n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n                                          FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n+        this.jdbcTemplate = jdbcTemplate;\n         this.flywayMigrationProperties = flywayMigrationProperties;\n     }\n \n     @Override\n     public void migrate(Context context) throws Exception {\n         Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n \n         // retrieve max entityId value witness by transactions table.\n         Long maxEntityId = getMaxEntityId();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMTYyNQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r520921625", "body": "these are already updated in `getTypeMismatchedEntity` and it's also possible updating them here would cause some rows to be reprocessed.", "bodyText": "these are already updated in getTypeMismatchedEntity and it's also possible updating them here would cause some rows to be reprocessed.", "bodyHTML": "<p dir=\"auto\">these are already updated in <code>getTypeMismatchedEntity</code> and it's also possible updating them here would cause some rows to be reprocessed.</p>", "author": "xin-hedera", "createdAt": "2020-11-10T22:44:06Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,332 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import javax.sql.DataSource;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final EntityRepository entityRepository;\n+    private final TransactionRepository transactionRepository;\n+    private final DataSource dataSource;\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n+            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n+            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n+    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n+                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.entityRepository = entityRepository;\n+        this.transactionRepository = transactionRepository;\n+        this.dataSource = dataSource;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+        jdbcTemplate = new JdbcTemplate(dataSource);\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (entityIdTypeList != null) {\n+            if (!entityIdTypeList.isEmpty()) {\n+                batchUpdate(entityIdTypeList);\n+            }\n+\n+            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n+                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        // drop temp table\n+        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n+\n+        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @param args\n+     * @return\n+     */\n+    private Long getMismatchCount(@Nullable Object... args) {\n+        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n+\n+        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount;\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n+                CREATED_ENTITIES_TRANSACTION_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (entityIdTypes.isEmpty()) {\n+            // no more rows to consider, return null\n+            return null;\n+        }\n+\n+        // remove nulls\n+        entityIdTypes.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n+                .size());\n+        return entityIdTypes;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param entityIdTypes List of mismatched entities\n+     * @return\n+     */\n+    @Transactional\n+    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n+        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITIES_TYPE_UPDATE_SQL,\n+                entityIdTypes,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n+                        long id = entityIdType.entityId;\n+                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+\n+                        // update filter counters\n+                        entityIdCap.set(id);\n+                        timestampCap.set(entityIdType.consensusTimestamp);", "originalCommit": "d27b1017ef360ad7f905b680b72c8ae9ebc15e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ4MTM0Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521481346", "bodyText": "Left over, single update occurs in getTypeMismatchedEntity() now", "author": "Nana-EC", "createdAt": "2020-11-11T16:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMTYyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "268b341265e3640631a626897a9ac82ccd2adbb6", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nsimilarity index 58%\nrename from hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\nrename to hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 39f2723c8..74683bfee 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -165,55 +174,52 @@ public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n      * @return\n      * @throws SQLException\n      */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+    private List<TypeMismatchedEntity> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n         log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n                 \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n                 new Object[] {entityId, consensusTimestamp, pageSize},\n                 new RowMapper<>() {\n                     @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n                         return getTypeMismatchedEntity(rs);\n                     }\n                 });\n \n-        if (entityIdTypes.isEmpty()) {\n+        if (typeMismatchedEntities.isEmpty()) {\n             // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n             return null;\n         }\n \n         // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n \n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+        return typeMismatchedEntities;\n     }\n \n     /**\n      * Batch update entities with correct fk_entity_type_id\n      *\n-     * @param entityIdTypes List of mismatched entities\n+     * @param typeMismatchedEntities List of mismatched entities\n      * @return\n      */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n+        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n         return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n+                ENTITY_TYPE_UPDATE_SQL,\n+                typeMismatchedEntities,\n                 flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n                 new ParameterizedPreparedStatementSetter<>() {\n                     @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n+                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n+                        long id = typeMismatchedEntity.entityId;\n+                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n                         ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n                     }\n                 }\n         );\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 39f2723c8..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,332 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import javax.sql.DataSource;\n-import lombok.Data;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-import org.springframework.lang.Nullable;\n-import org.springframework.transaction.annotation.Transactional;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.repository.EntityRepository;\n-import com.hedera.mirror.importer.repository.TransactionRepository;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_1__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final EntityRepository entityRepository;\n-    private final TransactionRepository transactionRepository;\n-    private final DataSource dataSource;\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private JdbcTemplate jdbcTemplate;\n-\n-    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n-            \"not null\";\n-    private final String CREATED_ENTITIES_TRANSACTION_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on (e.id = t.entity_id and t.result = 22 and \" +\n-            \"t.type in (8,11,17,24,29)) where e.id < ? and t.consensus_ns < ? order by id desc, consensus_ns desc \" +\n-            \"limit ?\";\n-    private final String ENTITIES_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-    private final String ENTITY_MISMATCH_COUNT_SQL = \"select count(*) from t_entities e join transaction t\" +\n-            \" on (e.id = t.entity_id and t.result = 22 and t.type = ? and e.fk_entity_type_id <> ?)\";\n-    private final String DROP_TEMP_ENTITIES_SQL = \"drop table if exists t_entities_archive\";\n-\n-    AtomicLong entityIdCap;\n-    AtomicLong timestampCap;\n-    AtomicLong entityTransactionCount;\n-    AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_1__Entity_Type_Mismatch(@Lazy EntityRepository entityRepository,\n-                                         @Lazy TransactionRepository transactionRepository, DataSource dataSource,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.entityRepository = entityRepository;\n-        this.transactionRepository = transactionRepository;\n-        this.dataSource = dataSource;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-        jdbcTemplate = new JdbcTemplate(dataSource);\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n-        // transactions\n-        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n-        // entity id and transaction timestamp are used to optimally search through tables\n-        List<EntityIdType> entityIdTypeList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n-                .get() + 1, flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (entityIdTypeList != null) {\n-            if (!entityIdTypeList.isEmpty()) {\n-                batchUpdate(entityIdTypeList);\n-            }\n-\n-            entityIdTypeList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {} s. {} total entities, {} mismatches encountered\",\n-                stopwatch.elapsed(TimeUnit.SECONDS), entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        // drop temp table\n-        jdbcTemplate.execute(DROP_TEMP_ENTITIES_SQL);\n-\n-        log.info(\"Migration processed in {} s.\", stopwatch.elapsed(TimeUnit.SECONDS));\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the numbers of entity type mismatches found for a specific type of entity\n-     *\n-     * @param args\n-     * @return\n-     */\n-    private Long getMismatchCount(@Nullable Object... args) {\n-        Long mismatchCount = jdbcTemplate.queryForObject(ENTITY_MISMATCH_COUNT_SQL, Long.class, args);\n-\n-        log.trace(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount;\n-    }\n-\n-    /**\n-     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n-     * and transactions table\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private List<EntityIdType> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<EntityIdType> entityIdTypes = jdbcTemplate.query(\n-                CREATED_ENTITIES_TRANSACTION_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public EntityIdType mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (entityIdTypes.isEmpty()) {\n-            // no more rows to consider, return null\n-            return null;\n-        }\n-\n-        // remove nulls\n-        entityIdTypes.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\", entityIdTypes\n-                .size());\n-        return entityIdTypes;\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param entityIdTypes List of mismatched entities\n-     * @return\n-     */\n-    @Transactional\n-    public int[][] batchUpdate(List<EntityIdType> entityIdTypes) {\n-        log.trace(\"batchUpdate {} entities \", entityIdTypes.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITIES_TYPE_UPDATE_SQL,\n-                entityIdTypes,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, EntityIdType entityIdType) throws SQLException {\n-                        long id = entityIdType.entityId;\n-                        ps.setLong(1, entityIdType.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-\n-                        // update filter counters\n-                        entityIdCap.set(id);\n-                        timestampCap.set(entityIdType.consensusTimestamp);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        if (expectedEntityType.getId() == currentEntityType) {\n-            return 0;\n-        }\n-\n-        return expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n-     * If entities object has no mismatch return null.\n-     * @param rs\n-     * @return EntityIdType object\n-     * @throws SQLException\n-     */\n-    private EntityIdType getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create EntityIdType with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        EntityIdType entityIdType = new EntityIdType(consensusTimestamp, correctedEntityType, entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", transactionType);\n-        return entityIdType;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        Long accountMismatchCount = getMismatchCount(TransactionTypeEnum.CRYPTOCREATEACCOUNT\n-                .getProtoId(), EntityTypeEnum.ACCOUNT.getId());\n-        if (accountMismatchCount > 0) {\n-            throw new MigrationSQLException(accountMismatchCount + \" Account type mismatches still remain\");\n-        }\n-\n-        Long contractMismatchCount = getMismatchCount(TransactionTypeEnum.CONTRACTCREATEINSTANCE\n-                .getProtoId(), EntityTypeEnum.CONTRACT.getId());\n-        if (contractMismatchCount > 0) {\n-            throw new MigrationSQLException(contractMismatchCount + \" Contract type mismatches still remain\");\n-        }\n-\n-        Long fileMismatchCount = getMismatchCount(TransactionTypeEnum.FILECREATE\n-                .getProtoId(), EntityTypeEnum.FILE.getId());\n-        if (fileMismatchCount > 0) {\n-            throw new MigrationSQLException(fileMismatchCount + \" Fie type mismatches still remain\");\n-        }\n-\n-        Long topicMismatchCount = getMismatchCount(TransactionTypeEnum.CONSENSUSCREATETOPIC\n-                .getProtoId(), EntityTypeEnum.TOPIC.getId());\n-        if (topicMismatchCount > 0) {\n-            throw new MigrationSQLException(topicMismatchCount + \" Topic type mismatches still remain\");\n-        }\n-\n-        Long tokenMismatchCount = getMismatchCount(TransactionTypeEnum.TOKENCREATION\n-                .getProtoId(), EntityTypeEnum.TOKEN.getId());\n-        if (tokenMismatchCount > 0) {\n-            throw new MigrationSQLException(tokenMismatchCount + \" Token type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of on Entities object with corresponding consensusTimestamp of create transaction\n-    private class EntityIdType {\n-        private final long consensusTimestamp;\n-        private final long correctedEntityTypeId;\n-        private final long entityId;\n-        private final long initialEntityTypeId;\n-        private final long transactionType;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"oid": "268b341265e3640631a626897a9ac82ccd2adbb6", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/268b341265e3640631a626897a9ac82ccd2adbb6", "message": "Addressed feedback 2\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-11T06:09:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzODU1NA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521538554", "body": "I'm generally hesitant to use default values, like I'm assuming the boolean continueSearch is being defaulted to false without it being stated anywhere.  That could just be a personal preference though.", "bodyText": "I'm generally hesitant to use default values, like I'm assuming the boolean continueSearch is being defaulted to false without it being stated anywhere.  That could just be a personal preference though.", "bodyHTML": "<p dir=\"auto\">I'm generally hesitant to use default values, like I'm assuming the boolean continueSearch is being defaulted to false without it being stated anywhere.  That could just be a personal preference though.</p>", "author": "ijungmann", "createdAt": "2020-11-11T17:56:11Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n+            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n+            \"limit ?\";\n+    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    private AtomicLong entityIdCap;\n+    private AtomicLong timestampCap;\n+    private AtomicLong entityTransactionCount;\n+    private AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        if (getMismatchCount() == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n+        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n+        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n+        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n+                .get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchSearchResult.isContinueSearch()) {\n+            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n+                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n+            }\n+\n+            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n+                    .get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the count of entity type mismatches found across all entities\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n+     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return new TypeMismatchSearchResult();", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4ODc1Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521588757", "bodyText": "Happy to remove the @noargs on the class and be explicit here w the following\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return new TypeMismatchSearchResult();\n          \n          \n            \n                        return new TypeMismatchSearchResult(null, false);", "author": "Nana-EC", "createdAt": "2020-11-11T19:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzODU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5NDM3MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521594371", "bodyText": "I'd prefer that.", "author": "ijungmann", "createdAt": "2020-11-11T19:39:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzODU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg0OTk0MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521849941", "bodyText": "Made the change but then blew this whole class away in the end.", "author": "Nana-EC", "createdAt": "2020-11-12T05:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUzODU1NA=="}], "type": "inlineReview", "revised_code": {"commit": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": {"commit": "3d689050d99226ce8472b047bbe2d7456c88b25b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nnew file mode 100644\nindex 000000000..74683bfee\n--- /dev/null\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -0,0 +1,310 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private final String ENTITY_MISMATCH_WHERE_CLAUSE_SQL = \"t.result = 22 and ((t.type = 11 and  e.fk_entity_type_id\" +\n+            \" <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and e.fk_entity_type_id <> 3) or (t\" +\n+            \".type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and e.fk_entity_type_id <> 5))\";\n+    private final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_MISMATCH_WHERE_CLAUSE_SQL +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and t\" +\n+            \".consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        int entityMismatch = getMismatchCount();\n+        if (entityMismatch == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<TypeMismatchedEntity> typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchedEntityList != null) {\n+            if (!typeMismatchedEntityList.isEmpty()) {\n+                batchUpdate(typeMismatchedEntityList);\n+            }\n+\n+            typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entities found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<TypeMismatchedEntity> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return null;\n+        }\n+\n+        // remove nulls\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+        return typeMismatchedEntities;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param typeMismatchedEntities List of mismatched entities\n+     * @return\n+     */\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n+        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITY_TYPE_UPDATE_SQL,\n+                typeMismatchedEntities,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n+                        long id = typeMismatchedEntity.entityId;\n+                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n+                entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n+        return typeMismatchedEntity;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        int entityMismatchCount = getMismatchCount();\n+        if (entityMismatchCount > 0) {\n+            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n+        }\n+    }\n+\n+    @Data\n+    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n+    private class TypeMismatchedEntity {\n+        private final long consensusTimestamp;\n+        private final int correctedEntityTypeId;\n+        private final long entityId;\n+        private final int initialEntityTypeId;\n+        private final int transactionType;\n+    }\n+}\n", "next_change": {"commit": "7968b291b082964abae72b59aef354d392895d0b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 74683bfee..55b0ce375 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -307,4 +312,12 @@ public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n         private final int initialEntityTypeId;\n         private final int transactionType;\n     }\n+\n+    @Data\n+    @AllArgsConstructor\n+    @NoArgsConstructor\n+    private class TypeMismatchSearchResult {\n+        private List<TypeMismatchedEntity> typeMismatchedEntities;\n+        private boolean continueSearch;\n+    }\n }\n", "next_change": {"commit": "4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU0MjQ4OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521542489", "body": "Is there a reason to do the granular type mismatch checks (`(t.type = 8 and e.fk_entity_type_id <> 2)`, etc) in the count SQL but not here?", "bodyText": "Is there a reason to do the granular type mismatch checks ((t.type = 8 and e.fk_entity_type_id <> 2), etc) in the count SQL but not here?", "bodyHTML": "<p dir=\"auto\">Is there a reason to do the granular type mismatch checks (<code>(t.type = 8 and e.fk_entity_type_id &lt;&gt; 2)</code>, etc) in the count SQL but not here?</p>", "author": "ijungmann", "createdAt": "2020-11-11T18:02:35Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n+            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU3ODQ1OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521578458", "bodyText": "Yeah, had wanted to share that logic, but if you do that and combine with paging logic on the search the result is that you don't know when you've hit the end.\nIt's difficult to reliably differentiate between not finding a a mismatch in the last batch search vs there's no more rows left to actually search.\nI didn't want to get down to relying on static id or time stamp numbers to determine this as it could be wrong.\nSo decided to leave it as is.\nUpside is we're ensured to consider every single entity that was said to have been created.", "author": "Nana-EC", "createdAt": "2020-11-11T19:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU0MjQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5NDA1NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521594055", "bodyText": "That makes sense, I'm okay with it then", "author": "ijungmann", "createdAt": "2020-11-11T19:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU0MjQ4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": {"commit": "3d689050d99226ce8472b047bbe2d7456c88b25b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nnew file mode 100644\nindex 000000000..74683bfee\n--- /dev/null\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -0,0 +1,310 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private final String ENTITY_MISMATCH_WHERE_CLAUSE_SQL = \"t.result = 22 and ((t.type = 11 and  e.fk_entity_type_id\" +\n+            \" <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and e.fk_entity_type_id <> 3) or (t\" +\n+            \".type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and e.fk_entity_type_id <> 5))\";\n+    private final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_MISMATCH_WHERE_CLAUSE_SQL +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and t\" +\n+            \".consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        int entityMismatch = getMismatchCount();\n+        if (entityMismatch == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<TypeMismatchedEntity> typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchedEntityList != null) {\n+            if (!typeMismatchedEntityList.isEmpty()) {\n+                batchUpdate(typeMismatchedEntityList);\n+            }\n+\n+            typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entities found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<TypeMismatchedEntity> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return null;\n+        }\n+\n+        // remove nulls\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+        return typeMismatchedEntities;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param typeMismatchedEntities List of mismatched entities\n+     * @return\n+     */\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n+        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITY_TYPE_UPDATE_SQL,\n+                typeMismatchedEntities,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n+                        long id = typeMismatchedEntity.entityId;\n+                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n+                entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n+        return typeMismatchedEntity;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        int entityMismatchCount = getMismatchCount();\n+        if (entityMismatchCount > 0) {\n+            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n+        }\n+    }\n+\n+    @Data\n+    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n+    private class TypeMismatchedEntity {\n+        private final long consensusTimestamp;\n+        private final int correctedEntityTypeId;\n+        private final long entityId;\n+        private final int initialEntityTypeId;\n+        private final int transactionType;\n+    }\n+}\n", "next_change": {"commit": "7968b291b082964abae72b59aef354d392895d0b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 74683bfee..55b0ce375 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -307,4 +312,12 @@ public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n         private final int initialEntityTypeId;\n         private final int transactionType;\n     }\n+\n+    @Data\n+    @AllArgsConstructor\n+    @NoArgsConstructor\n+    private class TypeMismatchSearchResult {\n+        private List<TypeMismatchedEntity> typeMismatchedEntities;\n+        private boolean continueSearch;\n+    }\n }\n", "next_change": {"commit": "4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NDE2Mw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521564163", "body": "private", "bodyText": "private", "bodyHTML": "<p dir=\"auto\">private</p>", "author": "steven-sheehy", "createdAt": "2020-11-11T18:42:18Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n+            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n+            \"limit ?\";\n+    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    private AtomicLong entityIdCap;\n+    private AtomicLong timestampCap;\n+    private AtomicLong entityTransactionCount;\n+    private AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        if (getMismatchCount() == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n+        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n+        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n+        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n+                .get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchSearchResult.isContinueSearch()) {\n+            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n+                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n+            }\n+\n+            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n+                    .get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the count of entity type mismatches found across all entities\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n+     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return new TypeMismatchSearchResult();\n+        }\n+\n+        // remove nulls\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+\n+        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param typeMismatchedEntities List of mismatched entities\n+     * @return\n+     */\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1MDE2NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521850165", "bodyText": "N/A, class removed.", "author": "Nana-EC", "createdAt": "2020-11-12T05:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2NDE2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": {"commit": "3d689050d99226ce8472b047bbe2d7456c88b25b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nnew file mode 100644\nindex 000000000..74683bfee\n--- /dev/null\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -0,0 +1,310 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private final String ENTITY_MISMATCH_WHERE_CLAUSE_SQL = \"t.result = 22 and ((t.type = 11 and  e.fk_entity_type_id\" +\n+            \" <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and e.fk_entity_type_id <> 3) or (t\" +\n+            \".type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and e.fk_entity_type_id <> 5))\";\n+    private final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_MISMATCH_WHERE_CLAUSE_SQL +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and t\" +\n+            \".consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        int entityMismatch = getMismatchCount();\n+        if (entityMismatch == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<TypeMismatchedEntity> typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchedEntityList != null) {\n+            if (!typeMismatchedEntityList.isEmpty()) {\n+                batchUpdate(typeMismatchedEntityList);\n+            }\n+\n+            typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entities found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<TypeMismatchedEntity> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return null;\n+        }\n+\n+        // remove nulls\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+        return typeMismatchedEntities;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param typeMismatchedEntities List of mismatched entities\n+     * @return\n+     */\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n+        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITY_TYPE_UPDATE_SQL,\n+                typeMismatchedEntities,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n+                        long id = typeMismatchedEntity.entityId;\n+                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n+                entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n+        return typeMismatchedEntity;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        int entityMismatchCount = getMismatchCount();\n+        if (entityMismatchCount > 0) {\n+            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n+        }\n+    }\n+\n+    @Data\n+    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n+    private class TypeMismatchedEntity {\n+        private final long consensusTimestamp;\n+        private final int correctedEntityTypeId;\n+        private final long entityId;\n+        private final int initialEntityTypeId;\n+        private final int transactionType;\n+    }\n+}\n", "next_change": {"commit": "7968b291b082964abae72b59aef354d392895d0b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 74683bfee..55b0ce375 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -307,4 +312,12 @@ public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n         private final int initialEntityTypeId;\n         private final int transactionType;\n     }\n+\n+    @Data\n+    @AllArgsConstructor\n+    @NoArgsConstructor\n+    private class TypeMismatchSearchResult {\n+        private List<TypeMismatchedEntity> typeMismatchedEntities;\n+        private boolean continueSearch;\n+    }\n }\n", "next_change": {"commit": "4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2ODE3NQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521568175", "body": "You'll need a custom cleanup.sql that's a copy of current sql so this doesn't break in the future.", "bodyText": "You'll need a custom cleanup.sql that's a copy of current sql so this doesn't break in the future.", "bodyHTML": "<p dir=\"auto\">You'll need a custom cleanup.sql that's a copy of current sql so this doesn't break in the future.</p>", "author": "steven-sheehy", "createdAt": "2020-11-11T18:49:51Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,298 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.sql.Connection;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import javax.sql.DataSource;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.configuration.Configuration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.1\")", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1MDQzMw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521850433", "bodyText": "Is this still applicable. Should be okay now with the modification to\n@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")", "author": "Nana-EC", "createdAt": "2020-11-12T05:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU2ODE3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\nsimilarity index 95%\nrename from hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\nrename to hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\nindex 9d3afa74e..379afd295 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V1_31_1__Entity_Type_MismatchTest.java\n", "chunk": "@@ -49,10 +49,10 @@ import com.hedera.mirror.importer.repository.EntityRepository;\n import com.hedera.mirror.importer.repository.TransactionRepository;\n \n @Log4j2\n-@TestPropertySource(properties = \"spring.flyway.target=1.31.1\")\n-class V_1_31_2__Entity_Type_MismatchTest extends IntegrationTest {\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.0\")\n+public class V1_31_1__Entity_Type_MismatchTest extends IntegrationTest {\n     @Resource\n-    private V1_31_2__Entity_Type_Mismatch migration;\n+    private V1_31_1__Entity_Type_Mismatch migration;\n \n     @Resource\n     private DataSource dataSource;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nsimilarity index 90%\nrename from hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\nrename to hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nindex 9d3afa74e..a4762c64e 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\n", "chunk": "@@ -50,12 +51,13 @@ import com.hedera.mirror.importer.repository.TransactionRepository;\n \n @Log4j2\n @TestPropertySource(properties = \"spring.flyway.target=1.31.1\")\n-class V_1_31_2__Entity_Type_MismatchTest extends IntegrationTest {\n-    @Resource\n-    private V1_31_2__Entity_Type_Mismatch migration;\n+class V_1_31_2__Remove_Invalid_EntitiesTest extends IntegrationTest {\n \n     @Resource\n-    private DataSource dataSource;\n+    private JdbcOperations jdbcOperations;\n+\n+    @Value(\"classpath:db/migration/V1.31.2__remove_invalid_entities.sql\")\n+    private File migrationSql;\n \n     @Resource\n     private EntityRepository entityRepository;\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwOTc1Nw==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521609757", "body": "Why are we limiting to these certain types here and in the search SQL? It should be all transaction types that are associated with one of the entity types. For example, a CONSENSUSUPDATETOPIC can certainly return an INVALID_TOPIC_ID.", "bodyText": "Why are we limiting to these certain types here and in the search SQL? It should be all transaction types that are associated with one of the entity types. For example, a CONSENSUSUPDATETOPIC can certainly return an INVALID_TOPIC_ID.", "bodyHTML": "<p dir=\"auto\">Why are we limiting to these certain types here and in the search SQL? It should be all transaction types that are associated with one of the entity types. For example, a CONSENSUSUPDATETOPIC can certainly return an INVALID_TOPIC_ID.</p>", "author": "steven-sheehy", "createdAt": "2020-11-11T20:09:18Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYzNTA2OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521635068", "bodyText": "True, but the additional transactions types aren't necessary to determine if an entity type is mismatched.\nEvery entity noted by a successful transaction create type should have a mapping in the t_entities table.\nThat's all you need to determine and correct the t_entities table.\nUpdated and deletes etc will all follow a create transaction, so it's sufficient to look at that.", "author": "Nana-EC", "createdAt": "2020-11-11T20:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwOTc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY0NjgzNg==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521646836", "bodyText": "Post offline discussion the tricky part here is the backfill problem. With missing historic data we can't rely on only create transactions as they may not be present.\nI see the need for all transactions, which can make the list exhaustive and sql long but will look into that", "author": "Nana-EC", "createdAt": "2020-11-11T21:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwOTc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1MDg2MQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521850861", "bodyText": "Went for an exclusive set. in CTE update I ignore system, unknown and freeze transaction - basically those that don't relate to an entity.\nThis way future entities added can be picked up.\nAlso update the transaction_types table with the corresponding entity_type", "author": "Nana-EC", "createdAt": "2020-11-12T05:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYwOTc1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": {"commit": "3d689050d99226ce8472b047bbe2d7456c88b25b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nnew file mode 100644\nindex 000000000..74683bfee\n--- /dev/null\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -0,0 +1,310 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private final String ENTITY_MISMATCH_WHERE_CLAUSE_SQL = \"t.result = 22 and ((t.type = 11 and  e.fk_entity_type_id\" +\n+            \" <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and e.fk_entity_type_id <> 3) or (t\" +\n+            \".type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and e.fk_entity_type_id <> 5))\";\n+    private final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_MISMATCH_WHERE_CLAUSE_SQL +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and t\" +\n+            \".consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        int entityMismatch = getMismatchCount();\n+        if (entityMismatch == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<TypeMismatchedEntity> typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchedEntityList != null) {\n+            if (!typeMismatchedEntityList.isEmpty()) {\n+                batchUpdate(typeMismatchedEntityList);\n+            }\n+\n+            typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entities found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<TypeMismatchedEntity> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return null;\n+        }\n+\n+        // remove nulls\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+        return typeMismatchedEntities;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param typeMismatchedEntities List of mismatched entities\n+     * @return\n+     */\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n+        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITY_TYPE_UPDATE_SQL,\n+                typeMismatchedEntities,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n+                        long id = typeMismatchedEntity.entityId;\n+                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n+                entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n+        return typeMismatchedEntity;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        int entityMismatchCount = getMismatchCount();\n+        if (entityMismatchCount > 0) {\n+            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n+        }\n+    }\n+\n+    @Data\n+    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n+    private class TypeMismatchedEntity {\n+        private final long consensusTimestamp;\n+        private final int correctedEntityTypeId;\n+        private final long entityId;\n+        private final int initialEntityTypeId;\n+        private final int transactionType;\n+    }\n+}\n", "next_change": {"commit": "7968b291b082964abae72b59aef354d392895d0b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 74683bfee..55b0ce375 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -307,4 +312,12 @@ public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n         private final int initialEntityTypeId;\n         private final int transactionType;\n     }\n+\n+    @Data\n+    @AllArgsConstructor\n+    @NoArgsConstructor\n+    private class TypeMismatchSearchResult {\n+        private List<TypeMismatchedEntity> typeMismatchedEntities;\n+        private boolean continueSearch;\n+    }\n }\n", "next_change": {"commit": "4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxMTIxNA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521611214", "body": "If we later add new transaction types but someone runs this migration after that point, it would miss those types. Perhaps we should auto-generate this SQL from the enums? Also, it would be less brittle and hard to understand.\r\n\r\nThat is, add an optional `EntityTypeEnum` field to `TransactionTypeEnum` that groups transactions types per which entity they are associated with. Then generate the SQL using that info.", "bodyText": "If we later add new transaction types but someone runs this migration after that point, it would miss those types. Perhaps we should auto-generate this SQL from the enums? Also, it would be less brittle and hard to understand.\nThat is, add an optional EntityTypeEnum field to TransactionTypeEnum that groups transactions types per which entity they are associated with. Then generate the SQL using that info.", "bodyHTML": "<p dir=\"auto\">If we later add new transaction types but someone runs this migration after that point, it would miss those types. Perhaps we should auto-generate this SQL from the enums? Also, it would be less brittle and hard to understand.</p>\n<p dir=\"auto\">That is, add an optional <code>EntityTypeEnum</code> field to <code>TransactionTypeEnum</code> that groups transactions types per which entity they are associated with. Then generate the SQL using that info.</p>", "author": "steven-sheehy", "createdAt": "2020-11-11T20:12:10Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY0NzU4Ng==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521647586", "bodyText": "Good point. Such a mapping is useful.\nEspecially given the exhaustive transactions type discussed.\nWill look into this.", "author": "Nana-EC", "createdAt": "2020-11-11T21:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxMTIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1MDk0OQ==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521850949", "bodyText": "Mapping now in db as noted", "author": "Nana-EC", "createdAt": "2020-11-12T05:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxMTIxNA=="}], "type": "inlineReview", "revised_code": {"commit": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": {"commit": "3d689050d99226ce8472b047bbe2d7456c88b25b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nnew file mode 100644\nindex 000000000..74683bfee\n--- /dev/null\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -0,0 +1,310 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private final String ENTITY_MISMATCH_WHERE_CLAUSE_SQL = \"t.result = 22 and ((t.type = 11 and  e.fk_entity_type_id\" +\n+            \" <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and e.fk_entity_type_id <> 3) or (t\" +\n+            \".type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and e.fk_entity_type_id <> 5))\";\n+    private final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_MISMATCH_WHERE_CLAUSE_SQL +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and t\" +\n+            \".consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        int entityMismatch = getMismatchCount();\n+        if (entityMismatch == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<TypeMismatchedEntity> typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchedEntityList != null) {\n+            if (!typeMismatchedEntityList.isEmpty()) {\n+                batchUpdate(typeMismatchedEntityList);\n+            }\n+\n+            typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entities found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<TypeMismatchedEntity> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return null;\n+        }\n+\n+        // remove nulls\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+        return typeMismatchedEntities;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param typeMismatchedEntities List of mismatched entities\n+     * @return\n+     */\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n+        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITY_TYPE_UPDATE_SQL,\n+                typeMismatchedEntities,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n+                        long id = typeMismatchedEntity.entityId;\n+                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n+                entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n+        return typeMismatchedEntity;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        int entityMismatchCount = getMismatchCount();\n+        if (entityMismatchCount > 0) {\n+            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n+        }\n+    }\n+\n+    @Data\n+    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n+    private class TypeMismatchedEntity {\n+        private final long consensusTimestamp;\n+        private final int correctedEntityTypeId;\n+        private final long entityId;\n+        private final int initialEntityTypeId;\n+        private final int transactionType;\n+    }\n+}\n", "next_change": {"commit": "7968b291b082964abae72b59aef354d392895d0b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 74683bfee..55b0ce375 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -307,4 +312,12 @@ public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n         private final int initialEntityTypeId;\n         private final int transactionType;\n     }\n+\n+    @Data\n+    @AllArgsConstructor\n+    @NoArgsConstructor\n+    private class TypeMismatchSearchResult {\n+        private List<TypeMismatchedEntity> typeMismatchedEntities;\n+        private boolean continueSearch;\n+    }\n }\n", "next_change": {"commit": "4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxNDQ3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521614478", "body": "We should use a DB cursor instead of using this complicated keyset pagination approach with stateful Atomics. The updating can be batched but the querying should not be. \r\n\r\nBesides being harder to understand and making the class stateful, this query will be slower since it's joining an un-indexed field. Keyset pagination only makes sense when using index fields. I ran this query in mainnet and a single page took a few minutes.\r\n\r\nThis would also allow you to reuse the sql that compares the entity type with the transaction type. It would also make the verification query completely unnecessary as it's the same SQL.", "bodyText": "We should use a DB cursor instead of using this complicated keyset pagination approach with stateful Atomics. The updating can be batched but the querying should not be.\nBesides being harder to understand and making the class stateful, this query will be slower since it's joining an un-indexed field. Keyset pagination only makes sense when using index fields. I ran this query in mainnet and a single page took a few minutes.\nThis would also allow you to reuse the sql that compares the entity type with the transaction type. It would also make the verification query completely unnecessary as it's the same SQL.", "bodyHTML": "<p dir=\"auto\">We should use a DB cursor instead of using this complicated keyset pagination approach with stateful Atomics. The updating can be batched but the querying should not be.</p>\n<p dir=\"auto\">Besides being harder to understand and making the class stateful, this query will be slower since it's joining an un-indexed field. Keyset pagination only makes sense when using index fields. I ran this query in mainnet and a single page took a few minutes.</p>\n<p dir=\"auto\">This would also allow you to reuse the sql that compares the entity type with the transaction type. It would also make the verification query completely unnecessary as it's the same SQL.</p>", "author": "steven-sheehy", "createdAt": "2020-11-11T20:18:47Z", "path": "hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java", "diffHunk": "@@ -0,0 +1,323 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.NoArgsConstructor;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n+            \"entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n+            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n+            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n+            \"e.fk_entity_type_id <> 5))\";\n+    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +", "originalCommit": "cafde28e9dae6c38fdeb67588e2c12d3397b8007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY0NzcxMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521647710", "bodyText": "Agreed, will look into this.", "author": "Nana-EC", "createdAt": "2020-11-11T21:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxNDQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1MTExMA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r521851110", "bodyText": "Cursor was a good idea.\nWith CTE update no longer needed as this class is gone", "author": "Nana-EC", "createdAt": "2020-11-12T05:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxNDQ3OA=="}], "type": "inlineReview", "revised_code": {"commit": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": {"commit": "3d689050d99226ce8472b047bbe2d7456c88b25b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nnew file mode 100644\nindex 000000000..74683bfee\n--- /dev/null\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -0,0 +1,310 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import com.google.common.base.Stopwatch;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.inject.Named;\n+import lombok.Data;\n+import lombok.extern.log4j.Log4j2;\n+import org.flywaydb.core.api.migration.BaseJavaMigration;\n+import org.flywaydb.core.api.migration.Context;\n+import org.springframework.context.annotation.Lazy;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n+import org.springframework.jdbc.core.RowMapper;\n+\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.exception.MigrationSQLException;\n+import com.hedera.mirror.importer.util.Utility;\n+\n+@Log4j2\n+@Named\n+public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n+    private final FlywayMigrationProperties flywayMigrationProperties;\n+    private final JdbcTemplate jdbcTemplate;\n+\n+    private final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where entity_id is \" +\n+            \"not null\";\n+    // where clause used by count that captures correct entityType to transactionType mapping\n+    private final String ENTITY_MISMATCH_WHERE_CLAUSE_SQL = \"t.result = 22 and ((t.type = 11 and  e.fk_entity_type_id\" +\n+            \" <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and e.fk_entity_type_id <> 3) or (t\" +\n+            \".type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and e.fk_entity_type_id <> 5))\";\n+    private final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n+            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_MISMATCH_WHERE_CLAUSE_SQL +\n+            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n+    private final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n+            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and t\" +\n+            \".consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc, consensus_ns desc \" +\n+            \"limit ?\";\n+    private final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n+\n+    AtomicLong entityIdCap;\n+    AtomicLong timestampCap;\n+    AtomicLong entityTransactionCount;\n+    AtomicLong entityTransactionMismatchCount;\n+\n+    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n+                                         FlywayMigrationProperties flywayMigrationProperties) {\n+        this.jdbcTemplate = jdbcTemplate;\n+        this.flywayMigrationProperties = flywayMigrationProperties;\n+    }\n+\n+    @Override\n+    public void migrate(Context context) throws Exception {\n+        Stopwatch stopwatch = Stopwatch.createStarted();\n+\n+        // retrieve max entityId value witness by transactions table.\n+        Long maxEntityId = getMaxEntityId();\n+        if (maxEntityId == null) {\n+            log.info(\"Empty transactions table. Skipping migration.\");\n+            return;\n+        }\n+\n+        int entityMismatch = getMismatchCount();\n+        if (entityMismatch == 0) {\n+            log.info(\"No entity mismatches. Skipping migration.\");\n+            return;\n+        }\n+\n+        entityIdCap = new AtomicLong(maxEntityId);\n+        Instant now = Instant.now();\n+        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n+        entityTransactionCount = new AtomicLong(0);\n+        entityTransactionMismatchCount = new AtomicLong(0);\n+\n+        // batch retrieve entities whose entity type does not match the type noted in the appropriate create\n+        // transactions\n+        // batch update retrieved entities and pull next set until no type mismatched entities are retrieved\n+        // entity id and transaction timestamp are used to optimally search through tables\n+        List<TypeMismatchedEntity> typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get() + 1, timestampCap\n+                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n+        while (typeMismatchedEntityList != null) {\n+            if (!typeMismatchedEntityList.isEmpty()) {\n+                batchUpdate(typeMismatchedEntityList);\n+            }\n+\n+            typeMismatchedEntityList = getEntityIdTypes(entityIdCap.get(), timestampCap.get(), flywayMigrationProperties\n+                    .getEntityMismatchReadPageSize());\n+        }\n+\n+        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n+                stopwatch, entityTransactionCount\n+                        .get(), entityTransactionMismatchCount.get());\n+\n+        verifyNoEntityMismatchesExist();\n+\n+        log.info(\"Migration processed in {}.\", stopwatch);\n+    }\n+\n+    /**\n+     * Retrieves max entityId found from all transactions.\n+     *\n+     * @return max entity id\n+     * @throws SQLException\n+     */\n+    private Long getMaxEntityId() throws SQLException {\n+        log.debug(\"Retrieve max entityId from transaction table\");\n+        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n+\n+        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n+        return maxEntityId;\n+    }\n+\n+    /**\n+     * Gets the numbers of entity type mismatches found for a specific type of entity\n+     *\n+     * @return\n+     */\n+    private int getMismatchCount() {\n+        AtomicInteger mismatchCount = new AtomicInteger(0);\n+        jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n+                new RowMapper<>() {\n+                    @Override\n+                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        int count = rs.getInt(\"count\");\n+                        if (count > 0) {\n+                            log.info(\"{} mismatched entities found of entity type {}, with transactionType {}\",\n+                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n+                        }\n+\n+                        mismatchCount.addAndGet(count);\n+                        return null;\n+                    }\n+                });\n+\n+        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n+        return mismatchCount.get();\n+    }\n+\n+    /**\n+     * Retrieves a list of EntityIdType objects that represent mismatches found between the entity type in t_entities\n+     * and transactions table\n+     *\n+     * @param entityId\n+     * @param consensusTimestamp\n+     * @param pageSize\n+     * @return\n+     * @throws SQLException\n+     */\n+    private List<TypeMismatchedEntity> getEntityIdTypes(long entityId, long consensusTimestamp, int pageSize) throws SQLException {\n+        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n+                \"size {}\", entityId, consensusTimestamp, pageSize);\n+        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n+                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n+                new Object[] {entityId, consensusTimestamp, pageSize},\n+                new RowMapper<>() {\n+                    @Override\n+                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n+                        return getTypeMismatchedEntity(rs);\n+                    }\n+                });\n+\n+        if (typeMismatchedEntities.isEmpty()) {\n+            // no more rows to consider, return null\n+            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                    typeMismatchedEntities.size());\n+            return null;\n+        }\n+\n+        // remove nulls\n+        typeMismatchedEntities.removeAll(Collections.singleton(null));\n+\n+        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n+                typeMismatchedEntities.size());\n+        return typeMismatchedEntities;\n+    }\n+\n+    /**\n+     * Batch update entities with correct fk_entity_type_id\n+     *\n+     * @param typeMismatchedEntities List of mismatched entities\n+     * @return\n+     */\n+    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n+        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n+        return jdbcTemplate.batchUpdate(\n+                ENTITY_TYPE_UPDATE_SQL,\n+                typeMismatchedEntities,\n+                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n+                new ParameterizedPreparedStatementSetter<>() {\n+                    @Override\n+                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n+                        long id = typeMismatchedEntity.entityId;\n+                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n+                        ps.setLong(2, id);\n+                    }\n+                }\n+        );\n+    }\n+\n+    /**\n+     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n+     * return 0 to signal equality, when mismatched return expectedType\n+     *\n+     * @param expectedEntityType\n+     * @param currentEntityType\n+     * @return\n+     */\n+    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n+        // check if EntityTypeEnum matches given currentEntityType.\n+        // Return 0 on match otherwise return expected EntityTypeEnum id\n+        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n+    }\n+\n+    /***\n+     * Get an EntityIdType object that represents a type mismatch of the result of t_entities and transaction table join\n+     * If entities object has no mismatch return null.\n+     * @param rs\n+     * @return EntityIdType object\n+     * @throws SQLException\n+     */\n+    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n+        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n+        int transactionType = rs.getInt(\"type\");\n+        long entityId = rs.getLong(\"id\");\n+        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n+        int correctedEntityType = 0;\n+        entityTransactionCount.incrementAndGet();\n+\n+        // update filter counters\n+        entityIdCap.set(entityId);\n+        timestampCap.set(consensusTimestamp);\n+\n+        // for each create transaction, verify expected entity type is matched in entity object.\n+        // If so exit early, if not create EntityIdType with subset of correct entity properties\n+        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n+        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n+            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n+        }\n+\n+        if (correctedEntityType == 0) {\n+            // no mismatch on entity, return null\n+            return null;\n+        }\n+\n+        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n+                entityId,\n+                originalEntityType, transactionType);\n+        entityTransactionMismatchCount.incrementAndGet();\n+        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n+        return typeMismatchedEntity;\n+    }\n+\n+    /**\n+     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n+     *\n+     * @throws SQLException\n+     */\n+    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n+        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n+        int entityMismatchCount = getMismatchCount();\n+        if (entityMismatchCount > 0) {\n+            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n+        }\n+    }\n+\n+    @Data\n+    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n+    private class TypeMismatchedEntity {\n+        private final long consensusTimestamp;\n+        private final int correctedEntityTypeId;\n+        private final long entityId;\n+        private final int initialEntityTypeId;\n+        private final int transactionType;\n+    }\n+}\n", "next_change": {"commit": "7968b291b082964abae72b59aef354d392895d0b", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\nindex 74683bfee..55b0ce375 100644\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n", "chunk": "@@ -307,4 +312,12 @@ public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n         private final int initialEntityTypeId;\n         private final int transactionType;\n     }\n+\n+    @Data\n+    @AllArgsConstructor\n+    @NoArgsConstructor\n+    private class TypeMismatchSearchResult {\n+        private List<TypeMismatchedEntity> typeMismatchedEntities;\n+        private boolean continueSearch;\n+    }\n }\n", "next_change": {"commit": "4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java b/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\ndeleted file mode 100644\nindex 55b0ce375..000000000\n--- a/hedera-mirror-importer/src/main/java/com/hedera/mirror/importer/migration/V1_31_2__Entity_Type_Mismatch.java\n+++ /dev/null\n", "chunk": "@@ -1,323 +0,0 @@\n-package com.hedera.mirror.importer.migration;\n-\n-/*-\n- * \u200c\n- * Hedera Mirror Node\n- * \u200b\n- * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n- * \u200b\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- * \u200d\n- */\n-\n-import com.google.common.base.Stopwatch;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.time.Instant;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicLong;\n-import javax.inject.Named;\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.NoArgsConstructor;\n-import lombok.extern.log4j.Log4j2;\n-import org.flywaydb.core.api.migration.BaseJavaMigration;\n-import org.flywaydb.core.api.migration.Context;\n-import org.springframework.context.annotation.Lazy;\n-import org.springframework.jdbc.core.JdbcTemplate;\n-import org.springframework.jdbc.core.ParameterizedPreparedStatementSetter;\n-import org.springframework.jdbc.core.RowMapper;\n-\n-import com.hedera.mirror.importer.domain.EntityTypeEnum;\n-import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n-import com.hedera.mirror.importer.exception.MigrationSQLException;\n-import com.hedera.mirror.importer.util.Utility;\n-\n-@Log4j2\n-@Named\n-public class V1_31_2__Entity_Type_Mismatch extends BaseJavaMigration {\n-    private final FlywayMigrationProperties flywayMigrationProperties;\n-    private final JdbcTemplate jdbcTemplate;\n-\n-    private static final String TRANSACTION_MAX_ENTITY_ID_SQL = \"select max(entity_id) from transaction where \" +\n-            \"entity_id is \" +\n-            \"not null\";\n-    // where clause used by count that captures correct entityType to transactionType mapping\n-    private static final String ENTITY_TYPE_MISMATCH_WHERE_CLAUSE = \"t.result = 22 and ((t.type = 11 and \" +\n-            \"e.fk_entity_type_id <> 1) or (t.type = 8 and e.fk_entity_type_id <> 2) or (t.type = 17 and \" +\n-            \"e.fk_entity_type_id <> 3) or (t.type = 24 and e.fk_entity_type_id <> 4) or (t.type = 29 and \" +\n-            \"e.fk_entity_type_id <> 5))\";\n-    private static final String ENTITY_TYPE_MISMATCH_COUNT_SQL = \"select e.fk_entity_type_id, t.type, count(*) from \" +\n-            \"t_entities e join transaction t on e.id = t.entity_id where \" + ENTITY_TYPE_MISMATCH_WHERE_CLAUSE +\n-            \" group by e.fk_entity_type_id, t.type having count(*) > 0\";\n-    private static final String ENTITY_TYPE_MISMATCH_SEARCH_SQL = \"select  e.id, e.fk_entity_type_id, t.type, \" +\n-            \"t.consensus_ns from t_entities e join transaction t on e.id = t.entity_id  where e.id < ? and \" +\n-            \"t.consensus_ns < ? and t.result = 22 and t.type in (8,11,17,24,29) order by id desc \" +\n-            \"limit ?\";\n-    private static final String ENTITY_TYPE_UPDATE_SQL = \"update t_entities set fk_entity_type_id = ? where id = ?\";\n-\n-    private AtomicLong entityIdCap;\n-    private AtomicLong timestampCap;\n-    private AtomicLong entityTransactionCount;\n-    private AtomicLong entityTransactionMismatchCount;\n-\n-    public V1_31_2__Entity_Type_Mismatch(@Lazy JdbcTemplate jdbcTemplate,\n-                                         FlywayMigrationProperties flywayMigrationProperties) {\n-        this.jdbcTemplate = jdbcTemplate;\n-        this.flywayMigrationProperties = flywayMigrationProperties;\n-    }\n-\n-    @Override\n-    public void migrate(Context context) throws Exception {\n-        Stopwatch stopwatch = Stopwatch.createStarted();\n-\n-        // retrieve max entityId value witness by transactions table.\n-        Long maxEntityId = getMaxEntityId();\n-        if (maxEntityId == null) {\n-            log.info(\"Empty transactions table. Skipping migration.\");\n-            return;\n-        }\n-\n-        if (getMismatchCount() == 0) {\n-            log.info(\"No entity mismatches. Skipping migration.\");\n-            return;\n-        }\n-\n-        entityIdCap = new AtomicLong(maxEntityId);\n-        Instant now = Instant.now();\n-        timestampCap = new AtomicLong(Utility.convertToNanosMax(now.getEpochSecond(), now.getNano()));\n-        entityTransactionCount = new AtomicLong(0);\n-        entityTransactionMismatchCount = new AtomicLong(0);\n-\n-        // batch retrieve entities whose entity type does not match the appropriate create transactions type\n-        // batch update retrieved entities and search for next set of mismatches until no type mismatched entities\n-        // are retrieved.  entity id and transaction timestamp are used to optimally search through tables\n-        TypeMismatchSearchResult typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap\n-                .get() + 1, timestampCap\n-                .get(), flywayMigrationProperties.getEntityMismatchReadPageSize());\n-        while (typeMismatchSearchResult.isContinueSearch()) {\n-            if (!typeMismatchSearchResult.getTypeMismatchedEntities().isEmpty()) {\n-                batchUpdate(typeMismatchSearchResult.getTypeMismatchedEntities());\n-            }\n-\n-            typeMismatchSearchResult = getTypeMismatchedEntities(entityIdCap.get(), timestampCap\n-                    .get(), flywayMigrationProperties\n-                    .getEntityMismatchReadPageSize());\n-        }\n-\n-        log.info(\"Entity mismatch correction completed in {}. {} total entities, {} mismatches encountered\",\n-                stopwatch, entityTransactionCount\n-                        .get(), entityTransactionMismatchCount.get());\n-\n-        verifyNoEntityMismatchesExist();\n-\n-        log.info(\"Migration processed in {}.\", stopwatch);\n-    }\n-\n-    /**\n-     * Retrieves max entityId found from all transactions.\n-     *\n-     * @return max entity id\n-     * @throws SQLException\n-     */\n-    private Long getMaxEntityId() throws SQLException {\n-        log.debug(\"Retrieve max entityId from transaction table\");\n-        Long maxEntityId = jdbcTemplate.queryForObject(TRANSACTION_MAX_ENTITY_ID_SQL, Long.class);\n-\n-        log.info(\"Retrieved max EntityId {} from transaction table\", maxEntityId);\n-        return maxEntityId;\n-    }\n-\n-    /**\n-     * Gets the count of entity type mismatches found across all entities\n-     *\n-     * @return\n-     */\n-    private int getMismatchCount() {\n-        AtomicInteger mismatchCount = new AtomicInteger(0);\n-        jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_COUNT_SQL,\n-                new RowMapper<>() {\n-                    @Override\n-                    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        int count = rs.getInt(\"count\");\n-                        if (count > 0) {\n-                            log.info(\"{} mismatched entity found of entity type {}, with transactionType {}\",\n-                                    count, rs.getInt(\"fk_entity_type_id\"), rs.getInt(\"type\"));\n-                        }\n-\n-                        mismatchCount.addAndGet(count);\n-                        return null;\n-                    }\n-                });\n-\n-        log.debug(\"Retrieved {} mismatched entities\", mismatchCount);\n-        return mismatchCount.get();\n-    }\n-\n-    /**\n-     * Retrieves a TypeMismatchSearchResult containing the list of TypeMismatchedEntity objects that represent\n-     * mismatches found between the entity type in t_entities and transactions table for the given page size search\n-     *\n-     * @param entityId\n-     * @param consensusTimestamp\n-     * @param pageSize\n-     * @return\n-     * @throws SQLException\n-     */\n-    private TypeMismatchSearchResult getTypeMismatchedEntities(long entityId, long consensusTimestamp, int pageSize) {\n-        log.info(\"Retrieve entityIdTypes for create transactions below entityId {} and before timestamp {} with page \" +\n-                \"size {}\", entityId, consensusTimestamp, pageSize);\n-        List<TypeMismatchedEntity> typeMismatchedEntities = jdbcTemplate.query(\n-                ENTITY_TYPE_MISMATCH_SEARCH_SQL,\n-                new Object[] {entityId, consensusTimestamp, pageSize},\n-                new RowMapper<>() {\n-                    @Override\n-                    public TypeMismatchedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {\n-                        return getTypeMismatchedEntity(rs);\n-                    }\n-                });\n-\n-        if (typeMismatchedEntities.isEmpty()) {\n-            // no more rows to consider, return null\n-            log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                    typeMismatchedEntities.size());\n-            return new TypeMismatchSearchResult();\n-        }\n-\n-        // remove nulls\n-        typeMismatchedEntities.removeAll(Collections.singleton(null));\n-\n-        log.debug(\"Retrieved {} entities with mismatch type from t_entities and transaction join\",\n-                typeMismatchedEntities.size());\n-\n-        return new TypeMismatchSearchResult(typeMismatchedEntities, true);\n-    }\n-\n-    /**\n-     * Batch update entities with correct fk_entity_type_id\n-     *\n-     * @param typeMismatchedEntities List of mismatched entities\n-     * @return\n-     */\n-    public int[][] batchUpdate(List<TypeMismatchedEntity> typeMismatchedEntities) {\n-        log.trace(\"batchUpdate {} entities \", typeMismatchedEntities.size());\n-        return jdbcTemplate.batchUpdate(\n-                ENTITY_TYPE_UPDATE_SQL,\n-                typeMismatchedEntities,\n-                flywayMigrationProperties.getEntityMismatchWriteBatchSize(),\n-                new ParameterizedPreparedStatementSetter<>() {\n-                    @Override\n-                    public void setValues(PreparedStatement ps, TypeMismatchedEntity typeMismatchedEntity) throws SQLException {\n-                        long id = typeMismatchedEntity.entityId;\n-                        ps.setInt(1, typeMismatchedEntity.correctedEntityTypeId);\n-                        ps.setLong(2, id);\n-                    }\n-                }\n-        );\n-    }\n-\n-    /**\n-     * Retrieve the correct entityType number based on comparison between expected and current values When matched\n-     * return 0 to signal equality, when mismatched return expectedType\n-     *\n-     * @param expectedEntityType\n-     * @param currentEntityType\n-     * @return\n-     */\n-    private int getCorrectedEntityType(EntityTypeEnum expectedEntityType, int currentEntityType) {\n-        // check if EntityTypeEnum matches given currentEntityType.\n-        // Return 0 on match otherwise return expected EntityTypeEnum id\n-        return expectedEntityType.getId() == currentEntityType ? 0 : expectedEntityType.getId();\n-    }\n-\n-    /***\n-     * Get an TypeMismatchedEntity object that represents a type mismatch of the result of t_entities and transaction\n-     * table join. If entities object has no mismatch return null.\n-     * @param rs\n-     * @return TypeMismatchedEntity object\n-     * @throws SQLException\n-     */\n-    private TypeMismatchedEntity getTypeMismatchedEntity(ResultSet rs) throws SQLException {\n-        int originalEntityType = rs.getInt(\"fk_entity_type_id\");\n-        int transactionType = rs.getInt(\"type\");\n-        long entityId = rs.getLong(\"id\");\n-        long consensusTimestamp = rs.getLong(\"consensus_ns\");\n-        int correctedEntityType = 0;\n-        entityTransactionCount.incrementAndGet();\n-\n-        // update filter counters\n-        entityIdCap.set(entityId);\n-        timestampCap.set(consensusTimestamp);\n-\n-        // for each create transaction, verify expected entity type is matched in entity object.\n-        // If so exit early, if not create TypeMismatchedEntity with subset of correct entity properties\n-        if (transactionType == TransactionTypeEnum.CRYPTOCREATEACCOUNT.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.ACCOUNT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONTRACTCREATEINSTANCE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.CONTRACT, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.FILECREATE.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.FILE, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.CONSENSUSCREATETOPIC.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOPIC, originalEntityType);\n-        } else if (transactionType == TransactionTypeEnum.TOKENCREATION.getProtoId()) {\n-            correctedEntityType = getCorrectedEntityType(EntityTypeEnum.TOKEN, originalEntityType);\n-        }\n-\n-        if (correctedEntityType == 0) {\n-            // no mismatch on entity, return null\n-            return null;\n-        }\n-\n-        TypeMismatchedEntity typeMismatchedEntity = new TypeMismatchedEntity(consensusTimestamp, correctedEntityType,\n-                entityId,\n-                originalEntityType, transactionType);\n-        entityTransactionMismatchCount.incrementAndGet();\n-        log.info(\"Entity type mismatch encountered: {}\", typeMismatchedEntity);\n-        return typeMismatchedEntity;\n-    }\n-\n-    /**\n-     * Confirm no type mismatches exist on accounts, contracts, files, topics and tokens entities\n-     *\n-     * @throws SQLException\n-     */\n-    private void verifyNoEntityMismatchesExist() throws MigrationSQLException {\n-        log.info(\"Verifying no further entity mismatches exist for accounts, contracts, files, topics and tokens ...\");\n-        int entityMismatchCount = getMismatchCount();\n-        if (entityMismatchCount > 0) {\n-            throw new MigrationSQLException(entityMismatchCount + \" Entity type mismatches still remain\");\n-        }\n-    }\n-\n-    @Data\n-    // Custom Subset of a type mismatched Entities object with corresponding consensusTimestamp of create transaction\n-    private class TypeMismatchedEntity {\n-        private final long consensusTimestamp;\n-        private final int correctedEntityTypeId;\n-        private final long entityId;\n-        private final int initialEntityTypeId;\n-        private final int transactionType;\n-    }\n-\n-    @Data\n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    private class TypeMismatchSearchResult {\n-        private List<TypeMismatchedEntity> typeMismatchedEntities;\n-        private boolean continueSearch;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"oid": "9cd402f6d7192e23001ae1682fce95a6173eb0d5", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/9cd402f6d7192e23001ae1682fce95a6173eb0d5", "message": "Add version migrations to fix entity type mismatches in db\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "88f9d4a81c84f67f52a94920adca590bcb2ecb32", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/88f9d4a81c84f67f52a94920adca590bcb2ecb32", "message": "Cleaned up\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "f7ca3eadb88f6c7187cd4d0450fe98d3e75ab2d9", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/f7ca3eadb88f6c7187cd4d0450fe98d3e75ab2d9", "message": "Renamed sql migration\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "e9c2cb723b1f5f8b275748fad84d9d9809162606", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/e9c2cb723b1f5f8b275748fad84d9d9809162606", "message": "Addressed feedback 1\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "3d689050d99226ce8472b047bbe2d7456c88b25b", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/3d689050d99226ce8472b047bbe2d7456c88b25b", "message": "Addressed feedback 2\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "8f8fd323edb4583b79f3f5907f01a353a806cb33", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/8f8fd323edb4583b79f3f5907f01a353a806cb33", "message": "Cleaned up object rename leftover\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "7968b291b082964abae72b59aef354d392895d0b", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7968b291b082964abae72b59aef354d392895d0b", "message": "Fix code smells\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/4003b23bb8d5cbfacbba39a9f581f13bb06475d5", "message": "Substitued java magration for sql migration w cte. Added entity_type to t_transaction_types\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:27:48Z", "type": "commit"}, {"oid": "7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "message": "Updated migration number\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:30:06Z", "type": "commit"}, {"oid": "7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "message": "Updated migration number\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T19:30:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MTA3OA==", "url": "https://github.com/hashgraph/hedera-mirror-node/pull/1235#discussion_r522371078", "body": "This class name no longer matches the sql name", "bodyText": "This class name no longer matches the sql name", "bodyHTML": "<p dir=\"auto\">This class name no longer matches the sql name</p>", "author": "steven-sheehy", "createdAt": "2020-11-12T19:35:28Z", "path": "hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package com.hedera.mirror.importer.migration;\n+\n+/*-\n+ * \u200c\n+ * Hedera Mirror Node\n+ * \u200b\n+ * Copyright (C) 2019 - 2020 Hedera Hashgraph, LLC\n+ * \u200b\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * \u200d\n+ */\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.hederahashgraph.api.proto.java.ResponseCodeEnum;\n+import java.io.File;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Resource;\n+import lombok.extern.log4j.Log4j2;\n+import org.apache.commons.io.FileUtils;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.jdbc.core.JdbcOperations;\n+import org.springframework.test.context.TestPropertySource;\n+\n+import com.hedera.mirror.importer.IntegrationTest;\n+import com.hedera.mirror.importer.MirrorProperties;\n+import com.hedera.mirror.importer.domain.Entities;\n+import com.hedera.mirror.importer.domain.EntityId;\n+import com.hedera.mirror.importer.domain.EntityTypeEnum;\n+import com.hedera.mirror.importer.domain.Transaction;\n+import com.hedera.mirror.importer.domain.TransactionTypeEnum;\n+import com.hedera.mirror.importer.repository.EntityRepository;\n+import com.hedera.mirror.importer.repository.TransactionRepository;\n+\n+@Log4j2\n+@TestPropertySource(properties = \"spring.flyway.target=1.31.1\")\n+class V_1_31_2__Entity_Type_MismatchTest extends IntegrationTest {", "originalCommit": "7ea5ca642f770d6cf10b0e8e3eceeb34f9eec75e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "cb54c5cd7c18de9194a270cf03f86315c332e3b7", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nsimilarity index 99%\nrename from hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\nrename to hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nindex 9743b978d..a4762c64e 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\n", "chunk": "@@ -51,7 +51,7 @@ import com.hedera.mirror.importer.repository.TransactionRepository;\n \n @Log4j2\n @TestPropertySource(properties = \"spring.flyway.target=1.31.1\")\n-class V_1_31_2__Entity_Type_MismatchTest extends IntegrationTest {\n+class V_1_31_2__Remove_Invalid_EntitiesTest extends IntegrationTest {\n \n     @Resource\n     private JdbcOperations jdbcOperations;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "changed_code": [{"header": "diff --git a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nsimilarity index 99%\nrename from hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\nrename to hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\nindex 9743b978d..a4762c64e 100644\n--- a/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Entity_Type_MismatchTest.java\n+++ b/hedera-mirror-importer/src/test/java/com/hedera/mirror/importer/migration/V_1_31_2__Remove_Invalid_EntitiesTest.java\n", "chunk": "@@ -51,7 +51,7 @@ import com.hedera.mirror.importer.repository.TransactionRepository;\n \n @Log4j2\n @TestPropertySource(properties = \"spring.flyway.target=1.31.1\")\n-class V_1_31_2__Entity_Type_MismatchTest extends IntegrationTest {\n+class V_1_31_2__Remove_Invalid_EntitiesTest extends IntegrationTest {\n \n     @Resource\n     private JdbcOperations jdbcOperations;\n", "next_change": null}]}, "commits_in_main": [{"oid": "294c468a951f27eb8a94f6f5fe6d4926b6bf58cd", "message": "Merge commit", "committedDate": null}]}, {"oid": "cb54c5cd7c18de9194a270cf03f86315c332e3b7", "url": "https://github.com/hashgraph/hedera-mirror-node/commit/cb54c5cd7c18de9194a270cf03f86315c332e3b7", "message": "Renamed test class to match sql\n\nSigned-off-by: Nana-EC <56320167+Nana-EC@users.noreply.github.com>", "committedDate": "2020-11-12T20:30:47Z", "type": "commit"}]}