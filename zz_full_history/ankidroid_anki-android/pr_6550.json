{"pr_number": 6550, "pr_title": "Change whiteboard pen color while reviewing ", "pr_author": "infinyte7", "pr_createdAt": "2020-06-25T06:42:35Z", "pr_url": "https://github.com/ankidroid/Anki-Android/pull/6550", "timeline": [{"oid": "77d6abfbb12a4898098d59bb06670aa9aaec63f6", "url": "https://github.com/ankidroid/Anki-Android/commit/77d6abfbb12a4898098d59bb06670aa9aaec63f6", "message": "\tWhiteboard pen color", "committedDate": "2020-06-25T06:36:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4MTg5NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445381894", "body": "You can make this a local variable", "bodyText": "You can make this a local variable", "bodyHTML": "<p dir=\"auto\">You can make this a local variable</p>", "author": "david-allison-1", "createdAt": "2020-06-25T08:09:01Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java", "diffHunk": "@@ -79,6 +79,7 @@\n     private boolean mPrefFullscreenReview = false;\n     private static final int ADD_NOTE = 12;\n     private static final int REQUEST_AUDIO_PERMISSION = 0;\n+    private LinearLayout colorPalette;", "originalCommit": "77d6abfbb12a4898098d59bb06670aa9aaec63f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e541b3ede91ca0bf8b1995deb32bd1a8f28ac1fb", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex b20fd9c1b..237cc98f6 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -79,11 +79,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n     private boolean mPrefFullscreenReview = false;\n     private static final int ADD_NOTE = 12;\n     private static final int REQUEST_AUDIO_PERMISSION = 0;\n-    private LinearLayout colorPalette;\n \n-    // Deck picker reset scheduler before opening the reviewer. So\n-    // first reset is useless.\n-    private boolean mSchedResetDone = false;\n \n     private ActionButtons mActionButtons = new ActionButtons(this);\n \n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 237cc98f6..fe439beef 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -79,7 +79,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n     private boolean mPrefFullscreenReview = false;\n     private static final int ADD_NOTE = 12;\n     private static final int REQUEST_AUDIO_PERMISSION = 0;\n-\n+    private LinearLayout colorPalette;\n \n     private ActionButtons mActionButtons = new ActionButtons(this);\n \n", "next_change": {"commit": "2f0af8ff7c5cc18d850aa1fc8c1bdd2c39a6bb1c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex fe439beef..8f968e484 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -84,13 +87,13 @@ public class Reviewer extends AbstractFlashcardViewer {\n     private ActionButtons mActionButtons = new ActionButtons(this);\n \n \n-    private CollectionTask.TaskListener mRescheduleCardHandler = new ScheduleCollectionTaskListener() {\n+    private TaskListener mRescheduleCardHandler = new ScheduleCollectionTaskListener() {\n         protected int getToastResourceId() {\n             return R.plurals.reschedule_cards_dialog_acknowledge;\n         }\n     };\n \n-    private CollectionTask.TaskListener mResetProgressCardHandler = new ScheduleCollectionTaskListener() {\n+    private TaskListener mResetProgressCardHandler = new ScheduleCollectionTaskListener() {\n         protected int getToastResourceId() {\n             return R.plurals.reset_cards_dialog_acknowledge;\n         }\n", "next_change": {"commit": "1f785c1b8c324266fdf652e84c9d9309d7278392", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 8f968e484..43b1cb3fe 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -84,23 +101,43 @@ public class Reviewer extends AbstractFlashcardViewer {\n     private static final int REQUEST_AUDIO_PERMISSION = 0;\n     private LinearLayout colorPalette;\n \n-    private ActionButtons mActionButtons = new ActionButtons(this);\n+    // TODO: Consider extracting to ViewModel\n+    // Card counts\n+    private SpannableString newCount;\n+    private SpannableString lrnCount;\n+    private SpannableString revCount;\n \n+    private TextView mTextBarNew;\n+    private TextView mTextBarLearn;\n+    private TextView mTextBarReview;\n \n-    private TaskListener mRescheduleCardHandler = new ScheduleCollectionTaskListener() {\n+    private boolean mPrefHideDueCount;\n+\n+    // ETA\n+    private int eta;\n+    private boolean mPrefShowETA;\n+\n+\n+    // Preferences from the collection\n+    private boolean mShowRemainingCardCount;\n+\n+    private final ActionButtons mActionButtons = new ActionButtons(this);\n+\n+\n+    private final TaskListener mRescheduleCardHandler = new ScheduleCollectionTaskListener() {\n         protected int getToastResourceId() {\n             return R.plurals.reschedule_cards_dialog_acknowledge;\n         }\n     };\n \n-    private TaskListener mResetProgressCardHandler = new ScheduleCollectionTaskListener() {\n+    private final TaskListener mResetProgressCardHandler = new ScheduleCollectionTaskListener() {\n         protected int getToastResourceId() {\n             return R.plurals.reset_cards_dialog_acknowledge;\n         }\n     };\n \n     @VisibleForTesting\n-    protected PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n+    protected final PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n \n     /** We need to listen for and handle reschedules / resets very similarly */\n     abstract class ScheduleCollectionTaskListener extends NextCardHandler {\n", "next_change": {"commit": "3e7983670370141b6dc2e1ab3d7a4036c0585def", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 43b1cb3fe..e87f13ef1 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -140,16 +146,16 @@ public class Reviewer extends AbstractFlashcardViewer {\n     protected final PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n \n     /** We need to listen for and handle reschedules / resets very similarly */\n-    abstract class ScheduleCollectionTaskListener extends NextCardHandler {\n+    abstract class ScheduleCollectionTaskListener extends NextCardHandler<PairWithBoolean<Card[]>> {\n \n         abstract protected int getToastResourceId();\n \n \n         @Override\n-        public void onPostExecute(TaskData result) {\n+        public void onPostExecute(PairWithBoolean<Card[]> result) {\n             super.onPostExecute(result);\n             invalidateOptionsMenu();\n-            int cardCount = result.getObjArray().length;\n+            int cardCount = result.other.length;\n             UIUtils.showThemedToast(Reviewer.this,\n                     getResources().getQuantityString(getToastResourceId(), cardCount, cardCount), true);\n         }\n", "next_change": {"commit": "d8c66722e7c9fdabf35cfa795cdfc6a59ef66f88", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex e87f13ef1..0d50c258b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -157,7 +151,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n             invalidateOptionsMenu();\n             int cardCount = result.other.length;\n             UIUtils.showThemedToast(Reviewer.this,\n-                    getResources().getQuantityString(getToastResourceId(), cardCount, cardCount), true);\n+                    getResources().getQuantityString(mToastResourceId, cardCount, cardCount), true);\n         }\n     }\n \n", "next_change": {"commit": "f692b10de3bbc75e37075b4cc42b04cbada3bef6", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 0d50c258b..b590ec2df 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -149,7 +147,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n         public void onPostExecute(PairWithBoolean<Card[]> result) {\n             super.onPostExecute(result);\n             invalidateOptionsMenu();\n-            int cardCount = result.other.length;\n+            int cardCount = result.value.length;\n             UIUtils.showThemedToast(Reviewer.this,\n                     getResources().getQuantityString(mToastResourceId, cardCount, cardCount), true);\n         }\n", "next_change": {"commit": "22e0854ccc348a1ac395e1b9a73245a34621545f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex b590ec2df..c05ba102d 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -144,10 +144,10 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n \n         @Override\n-        public void onPostExecute(PairWithBoolean<Card[]> result) {\n+        public void onPostExecute(Computation<Card[]> result) {\n             super.onPostExecute(result);\n             invalidateOptionsMenu();\n-            int cardCount = result.value.length;\n+            int cardCount = result.mValue.length;\n             UIUtils.showThemedToast(Reviewer.this,\n                     getResources().getQuantityString(mToastResourceId, cardCount, cardCount), true);\n         }\n", "next_change": {"commit": "8f423418a4b5aa3c754d94fdcf04017ea602894c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex c05ba102d..4db6c54bc 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -147,7 +146,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n         public void onPostExecute(Computation<Card[]> result) {\n             super.onPostExecute(result);\n             invalidateOptionsMenu();\n-            int cardCount = result.mValue.length;\n+            int cardCount = result.getValue().length;\n             UIUtils.showThemedToast(Reviewer.this,\n                     getResources().getQuantityString(mToastResourceId, cardCount, cardCount), true);\n         }\n", "next_change": {"commit": "562cfac72209132f9f22ff707276d0a46c3ecfbc", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 4db6c54bc..5f4d4da7c 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -143,7 +148,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n \n         @Override\n-        public void onPostExecute(Computation<Card[]> result) {\n+        public void onPostExecute(Computation<? extends Card[]> result) {\n             super.onPostExecute(result);\n             invalidateOptionsMenu();\n             int cardCount = result.getValue().length;\n", "next_change": {"commit": "c88bc2e14bf2691c597b8702f701801c99632e2a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 5f4d4da7c..cf8e87806 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -136,25 +137,14 @@ public class Reviewer extends AbstractFlashcardViewer {\n     \n     private final Onboarding.Reviewer mOnboarding = new Onboarding.Reviewer(this);\n \n-    /** We need to listen for and handle reschedules / resets very similarly */\n-    class ScheduleCollectionTaskListener extends NextCardHandler<Computation<? extends Card[]>> {\n-\n-        private final @PluralsRes int mToastResourceId;\n-\n-\n-        protected ScheduleCollectionTaskListener(@PluralsRes int toastResourceId) {\n-            mToastResourceId = toastResourceId;\n-        }\n-\n-\n-        @Override\n-        public void onPostExecute(Computation<? extends Card[]> result) {\n-            super.onPostExecute(result);\n+    protected TaskListenerBuilder<Card, Computation<? extends Card[]>> scheduleCollectionTaskHandler(@PluralsRes int toastResourceId) {\n+        return nextCardHandler().alsoExecuteAfter(result -> {\n+            // BUG: If the method crashes, this will crash\n             invalidateOptionsMenu();\n             int cardCount = result.getValue().length;\n             UIUtils.showThemedToast(Reviewer.this,\n-                    getResources().getQuantityString(mToastResourceId, cardCount, cardCount), true);\n-        }\n+                    getResources().getQuantityString(toastResourceId, cardCount, cardCount), true);\n+        });\n     }\n \n     @Override\n", "next_change": {"commit": "a316393d837034884fd4ceacef44572111f93ea5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex cf8e87806..88cffa24f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -137,12 +139,13 @@ public class Reviewer extends AbstractFlashcardViewer {\n     \n     private final Onboarding.Reviewer mOnboarding = new Onboarding.Reviewer(this);\n \n-    protected TaskListenerBuilder<Card, Computation<? extends Card[]>> scheduleCollectionTaskHandler(@PluralsRes int toastResourceId) {\n+    protected <T extends Computation<? extends NextCard<? extends Card[]>>> TaskListenerBuilder<Unit, T>\n+    scheduleCollectionTaskHandler(@PluralsRes int toastResourceId) {\n         return nextCardHandler().alsoExecuteAfter(result -> {\n             // BUG: If the method crashes, this will crash\n             invalidateOptionsMenu();\n-            int cardCount = result.getValue().length;\n-            UIUtils.showThemedToast(Reviewer.this,\n+            int cardCount = result.getValue().getResult().length;\n+            UIUtils.showThemedToast(this,\n                     getResources().getQuantityString(toastResourceId, cardCount, cardCount), true);\n         });\n     }\n", "next_change": {"commit": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\ndeleted file mode 100644\nindex 88cffa24f..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ /dev/null\n", "chunk": "@@ -1,1510 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\n-\n-package com.ichi2.anki;\n-\n-import android.Manifest;\n-import android.animation.Animator;\n-import android.animation.AnimatorListenerAdapter;\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.SharedPreferences;\n-import android.content.pm.PackageManager;\n-import android.content.res.ColorStateList;\n-import android.graphics.drawable.Drawable;\n-import android.os.Build;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.Message;\n-import android.text.SpannableString;\n-import android.text.style.UnderlineSpan;\n-import android.view.KeyEvent;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.SubMenu;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.webkit.WebView;\n-import android.webkit.JavascriptInterface;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-import android.widget.TextView;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.DrawableRes;\n-import androidx.annotation.IdRes;\n-import androidx.annotation.MenuRes;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.PluralsRes;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.appcompat.view.menu.MenuBuilder;\n-import androidx.appcompat.app.ActionBar;\n-import androidx.core.app.ActivityCompat;\n-import androidx.core.content.ContextCompat;\n-import androidx.core.content.res.ResourcesCompat;\n-import androidx.core.view.ActionProvider;\n-import androidx.core.view.MenuItemCompat;\n-import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;\n-\n-import com.ichi2.anki.cardviewer.CardAppearance;\n-import com.ichi2.anki.cardviewer.Gesture;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.multimediacard.AudioView;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.reviewer.AnswerButtons;\n-import com.ichi2.anki.reviewer.AutomaticAnswerAction;\n-import com.ichi2.anki.reviewer.FullScreenMode;\n-import com.ichi2.anki.reviewer.PeripheralKeymap;\n-import com.ichi2.anki.reviewer.ReviewerUi;\n-import com.ichi2.anki.servicelayer.SchedulerService;\n-import com.ichi2.anki.servicelayer.SchedulerService.NextCard;\n-import com.ichi2.anki.servicelayer.TaskListenerBuilder;\n-import com.ichi2.anki.workarounds.FirefoxSnackbarWorkaround;\n-import com.ichi2.anki.reviewer.ActionButtons;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.sched.Counts;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.utils.AndroidUiUtils;\n-import com.ichi2.utils.Computation;\n-import com.ichi2.utils.FunctionalInterfaces.Consumer;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.utils.ViewGroupUtils;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import kotlin.Unit;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.reviewer.CardMarker.*;\n-import static com.ichi2.anim.ActivityTransitionAnimation.Direction.*;\n-\n-\n-public class Reviewer extends AbstractFlashcardViewer {\n-    private boolean mHasDrawerSwipeConflicts = false;\n-    private boolean mShowWhiteboard = true;\n-    private boolean mPrefFullscreenReview = false;\n-    private static final int ADD_NOTE = 12;\n-    private static final int REQUEST_AUDIO_PERMISSION = 0;\n-    private LinearLayout mColorPalette;\n-\n-    // TODO: Consider extracting to ViewModel\n-    // Card counts\n-    private SpannableString mNewCount;\n-    private SpannableString mLrnCount;\n-    private SpannableString mRevCount;\n-\n-    private TextView mTextBarNew;\n-    private TextView mTextBarLearn;\n-    private TextView mTextBarReview;\n-\n-    private boolean mPrefHideDueCount;\n-\n-    // ETA\n-    private int mEta;\n-    private boolean mPrefShowETA;\n-\n-\n-    // Preferences from the collection\n-    private boolean mShowRemainingCardCount;\n-\n-    private final ActionButtons mActionButtons = new ActionButtons(this);\n-\n-\n-    @VisibleForTesting\n-    protected final PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n-    \n-    private final Onboarding.Reviewer mOnboarding = new Onboarding.Reviewer(this);\n-\n-    protected <T extends Computation<? extends NextCard<? extends Card[]>>> TaskListenerBuilder<Unit, T>\n-    scheduleCollectionTaskHandler(@PluralsRes int toastResourceId) {\n-        return nextCardHandler().alsoExecuteAfter(result -> {\n-            // BUG: If the method crashes, this will crash\n-            invalidateOptionsMenu();\n-            int cardCount = result.getValue().getResult().length;\n-            UIUtils.showThemedToast(this,\n-                    getResources().getQuantityString(toastResourceId, cardCount, cardCount), true);\n-        });\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        if (showedActivityFailedScreen(savedInstanceState)) {\n-            return;\n-        }\n-        Timber.d(\"onCreate()\");\n-        super.onCreate(savedInstanceState);\n-\n-        if (FirefoxSnackbarWorkaround.handledLaunchFromWebBrowser(getIntent(), this)) {\n-            this.setResult(RESULT_CANCELED);\n-            finishWithAnimation(END);\n-            return;\n-        }\n-\n-        if (Intent.ACTION_VIEW.equals(getIntent().getAction())) {\n-            Timber.d(\"onCreate() :: received Intent with action = %s\", getIntent().getAction());\n-            selectDeckFromExtra();\n-        }\n-\n-        mColorPalette = findViewById(R.id.whiteboard_editor);\n-\n-        startLoadingCollection();\n-    }\n-\n-\n-    @Override\n-    protected int getFlagToDisplay() {\n-        int actualValue = super.getFlagToDisplay();\n-        if (actualValue == FLAG_NONE) {\n-            return FLAG_NONE;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_FLAG);\n-        if (isShownInActionBar != null && isShownInActionBar) {\n-            return FLAG_NONE;\n-        }\n-        return actualValue;\n-    }\n-\n-\n-    @Override\n-    protected WebView createWebView() {\n-        WebView ret = super.createWebView();\n-        if (AndroidUiUtils.isRunningOnTv(this)) {\n-            ret.setFocusable(false);\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    protected void recreateWebView() {\n-        super.recreateWebView();\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-    @Override\n-    protected boolean shouldDisplayMark() {\n-        boolean markValue = super.shouldDisplayMark();\n-        if (!markValue) {\n-            return false;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_MARK);\n-        //If we don't know, show it.\n-        //Otherwise, if it's in the action bar, don't show it again.\n-        return isShownInActionBar == null || !isShownInActionBar;\n-    }\n-\n-    private void selectDeckFromExtra() {\n-        Bundle extras = getIntent().getExtras();\n-        if (extras == null || !extras.containsKey(\"deckId\")) {\n-            // deckId is not set, load default\n-            return;\n-        }\n-        long did = extras.getLong(\"deckId\", Long.MIN_VALUE);\n-\n-        Timber.d(\"selectDeckFromExtra() with deckId = %d\", did);\n-\n-        // Clear the undo history when selecting a new deck\n-        if (getCol().getDecks().selected() != did) {\n-            getCol().clearUndo();\n-        }\n-        // Select the deck\n-        getCol().getDecks().select(did);\n-        // Reset the schedule so that we get the counts for the currently selected deck\n-        getCol().getSched().deferReset();\n-    }\n-\n-    @Override\n-    protected void setTitle() {\n-        String title;\n-        if (colIsOpen()) {\n-            title = Decks.basename(getCol().getDecks().current().getString(\"name\"));\n-        } else {\n-            Timber.e(\"Could not set title in reviewer because collection closed\");\n-            title = \"\";\n-        }\n-        getSupportActionBar().setTitle(title);\n-        super.setTitle(title);\n-        getSupportActionBar().setSubtitle(\"\");\n-    }\n-\n-    @Override\n-    protected int getContentViewAttr(FullScreenMode fullscreenMode) {\n-        switch (fullscreenMode) {\n-            case BUTTONS_ONLY:\n-                return R.layout.reviewer_fullscreen;\n-            case FULLSCREEN_ALL_GONE:\n-                return R.layout.reviewer_fullscreen_noanswers;\n-            default:\n-                return R.layout.reviewer;\n-        }\n-    }\n-\n-    @Override\n-    protected boolean fitsSystemWindows() {\n-        return !getFullscreenMode().isFullScreenReview();\n-    }\n-\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        // Load the first card and start reviewing. Uses the answer card\n-        // task to load a card, but since we send null\n-        // as the card to answer, no card will be answered.\n-\n-        mPrefWhiteboard = MetaDB.getWhiteboardState(this, getParentDid());\n-        if (mPrefWhiteboard) {\n-            //DEFECT: Slight inefficiency here, as we set the database using these methods\n-            boolean whiteboardVisibility = MetaDB.getWhiteboardVisibility(this, getParentDid());\n-            setWhiteboardEnabledState(true);\n-            setWhiteboardVisibility(whiteboardVisibility);\n-        }\n-\n-        col.getSched().deferReset();     // Reset schedule in case card was previously loaded\n-        getCol().startTimebox();\n-        new SchedulerService.GetCard().runWithHandler(answerCardHandler(false));\n-\n-        disableDrawerSwipeOnConflicts();\n-        // Add a weak reference to current activity so that scheduler can talk to to Activity\n-        mSched.setContext(new WeakReference<>(this));\n-\n-        // Set full screen/immersive mode if needed\n-        if (mPrefFullscreenReview) {\n-            setFullScreen(this);\n-        }\n-\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        // 100ms was not enough on my device (Honor 9 Lite -  Android Pie)\n-        delayedHide(1000);\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-        int itemId = item.getItemId();\n-        if (itemId == android.R.id.home) {\n-            Timber.i(\"Reviewer:: Home button pressed\");\n-            closeReviewer(RESULT_OK, true);\n-        } else if (itemId == R.id.action_undo) {\n-            Timber.i(\"Reviewer:: Undo button pressed\");\n-            if (mShowWhiteboard && mWhiteboard != null && !mWhiteboard.undoEmpty()) {\n-                mWhiteboard.undo();\n-            } else {\n-                undo();\n-            }\n-        } else if (itemId == R.id.action_reset_card_progress) {\n-            Timber.i(\"Reviewer:: Reset progress button pressed\");\n-            showResetCardDialog();\n-        } else if (itemId == R.id.action_mark_card) {\n-            Timber.i(\"Reviewer:: Mark button pressed\");\n-            onMark(mCurrentCard);\n-        } else if (itemId == R.id.action_replay) {\n-            Timber.i(\"Reviewer:: Replay audio button pressed (from menu)\");\n-            playSounds(true);\n-        } else if (itemId == R.id.action_toggle_mic_tool_bar) {\n-            Timber.i(\"Reviewer:: Record mic\");\n-            // Check permission to record and request if not granted\n-            openOrToggleMicToolbar();\n-        } else if (itemId == R.id.action_tag) {\n-            Timber.i(\"Reviewer:: Tag button pressed\");\n-            showTagsDialog();\n-        } else if (itemId == R.id.action_edit) {\n-            Timber.i(\"Reviewer:: Edit note button pressed\");\n-            editCard();\n-            return true;\n-        } else if (itemId == R.id.action_bury) {\n-            Timber.i(\"Reviewer:: Bury button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Bury card due to no submenu\");\n-                buryCard();\n-            }\n-        } else if (itemId == R.id.action_suspend) {\n-            Timber.i(\"Reviewer:: Suspend button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Suspend card due to no submenu\");\n-                suspendCard();\n-            }\n-        } else if (itemId == R.id.action_delete) {\n-            Timber.i(\"Reviewer:: Delete note button pressed\");\n-            showDeleteNoteDialog();\n-        } else if (itemId == R.id.action_change_whiteboard_pen_color) {\n-            Timber.i(\"Reviewer:: Pen Color button pressed\");\n-            if (mColorPalette.getVisibility() == View.GONE) {\n-                mColorPalette.setVisibility(View.VISIBLE);\n-            } else {\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else if (itemId == R.id.action_save_whiteboard) {\n-            Timber.i(\"Reviewer:: Save whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                try {\n-                    String savedWhiteboardFileName = mWhiteboard.saveWhiteboard(getCol().getTime()).getPath();\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_saved, savedWhiteboardFileName), true);\n-                } catch (Exception e) {\n-                    Timber.w(e);\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_save_failed, e.getLocalizedMessage()), true);\n-                }\n-            }\n-        } else if (itemId == R.id.action_clear_whiteboard) {\n-            Timber.i(\"Reviewer:: Clear whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                mWhiteboard.clear();\n-            }\n-        } else if (itemId == R.id.action_hide_whiteboard) {// toggle whiteboard visibility\n-            Timber.i(\"Reviewer:: Whiteboard visibility set to %b\", !mShowWhiteboard);\n-            setWhiteboardVisibility(!mShowWhiteboard);\n-            refreshActionBar();\n-        } else if (itemId == R.id.action_toggle_whiteboard) {\n-            toggleWhiteboard();\n-        } else if (itemId == R.id.action_search_dictionary) {\n-            Timber.i(\"Reviewer:: Search dictionary button pressed\");\n-            lookUpOrSelectText();\n-        } else if (itemId == R.id.action_open_deck_options) {\n-            Intent i = new Intent(this, DeckOptions.class);\n-            startActivityForResultWithAnimation(i, DECK_OPTIONS, FADE);\n-        } else if (itemId == R.id.action_select_tts) {\n-            Timber.i(\"Reviewer:: Select TTS button pressed\");\n-            showSelectTtsDialogue();\n-        } else if (itemId == R.id.action_add_note_reviewer) {\n-            Timber.i(\"Reviewer:: Add note button pressed\");\n-            addNote();\n-        } else if (itemId == R.id.action_flag_zero) {\n-            Timber.i(\"Reviewer:: No flag\");\n-            onFlag(mCurrentCard, FLAG_NONE);\n-        } else if (itemId == R.id.action_flag_one) {\n-            Timber.i(\"Reviewer:: Flag one\");\n-            onFlag(mCurrentCard, FLAG_RED);\n-        } else if (itemId == R.id.action_flag_two) {\n-            Timber.i(\"Reviewer:: Flag two\");\n-            onFlag(mCurrentCard, FLAG_ORANGE);\n-        } else if (itemId == R.id.action_flag_three) {\n-            Timber.i(\"Reviewer:: Flag three\");\n-            onFlag(mCurrentCard, FLAG_GREEN);\n-        } else if (itemId == R.id.action_flag_four) {\n-            Timber.i(\"Reviewer:: Flag four\");\n-            onFlag(mCurrentCard, FLAG_BLUE);\n-        } else if (itemId == R.id.action_flag_five) {\n-            Timber.i(\"Reviewer:: Flag five\");\n-            onFlag(mCurrentCard, FLAG_PINK);\n-        } else if (itemId == R.id.action_flag_six) {\n-            Timber.i(\"Reviewer:: Flag six\");\n-            onFlag(mCurrentCard, FLAG_TURQUOISE);\n-        } else if (itemId == R.id.action_flag_seven) {\n-            Timber.i(\"Reviewer:: Flag seven\");\n-            onFlag(mCurrentCard, FLAG_PURPLE);\n-        } else if (itemId == R.id.action_card_info) {\n-            Timber.i(\"Card Viewer:: Card Info\");\n-            openCardInfo();\n-        } else {\n-            return super.onOptionsItemSelected(item);\n-        }\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void toggleWhiteboard() {\n-        mPrefWhiteboard = ! mPrefWhiteboard;\n-        Timber.i(\"Reviewer:: Whiteboard enabled state set to %b\", mPrefWhiteboard);\n-        //Even though the visibility is now stored in its own setting, we want it to be dependent\n-        //on the enabled status\n-        setWhiteboardEnabledState(mPrefWhiteboard);\n-        setWhiteboardVisibility(mPrefWhiteboard);\n-        if (!mPrefWhiteboard) {\n-            mColorPalette.setVisibility(View.GONE);\n-        }\n-        refreshActionBar();\n-    }\n-\n-\n-    @Override\n-    protected void replayVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        // COULD_BE_BETTER: this shows \"Failed\" if nothing was recorded\n-\n-        mMicToolBar.togglePlay();\n-    }\n-\n-\n-    @Override\n-    protected void recordVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        mMicToolBar.toggleRecord();\n-    }\n-\n-\n-    /**\n-     *\n-     * @return Whether the mic toolbar is usable\n-     */\n-    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n-    @VisibleForTesting\n-    public boolean openMicToolbar() {\n-        if (mMicToolBar == null || mMicToolBar.getVisibility() != View.VISIBLE) {\n-            openOrToggleMicToolbar();\n-        }\n-        return mMicToolBar != null;\n-    }\n-\n-\n-    protected void openOrToggleMicToolbar() {\n-        if (!Permissions.canRecordAudio(this)) {\n-            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.RECORD_AUDIO},\n-                    REQUEST_AUDIO_PERMISSION);\n-        } else {\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-\n-    private void toggleMicToolBar() {\n-        if (mMicToolBar != null) {\n-            // It exists swap visibility status\n-            if (mMicToolBar.getVisibility() != View.VISIBLE) {\n-                mMicToolBar.setVisibility(View.VISIBLE);\n-            } else {\n-                mMicToolBar.setVisibility(View.GONE);\n-            }\n-        } else {\n-            // Record mic tool bar does not exist yet\n-            mTempAudioPath = AudioView.generateTempAudioFile(this);\n-            if (mTempAudioPath == null) {\n-                return;\n-            }\n-            mMicToolBar = AudioView.createRecorderInstance(this, R.drawable.ic_play_arrow_white_24dp, R.drawable.ic_pause_white_24dp,\n-                        R.drawable.ic_stop_white_24dp, R.drawable.ic_rec, R.drawable.ic_rec_stop, mTempAudioPath);\n-            if (mMicToolBar == null) {\n-                mTempAudioPath = null;\n-                return;\n-            }\n-            FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-            mMicToolBar.setLayoutParams(lp2);\n-            LinearLayout micToolBarLayer = findViewById(R.id.mic_tool_bar_layer);\n-            micToolBarLayer.addView(mMicToolBar);\n-        }\n-    }\n-\n-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n-        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n-        if ((requestCode == REQUEST_AUDIO_PERMISSION) &&\n-                (permissions.length >= 1) && (grantResults[0] == PackageManager.PERMISSION_GRANTED)) {\n-            // Get get audio record permission, so we can create the record tool bar\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-    private void showRescheduleCardDialog() {\n-        Consumer<Integer> runnable = days -> {\n-            List<Long> cardIds = Collections.singletonList(mCurrentCard.getId());\n-            new SchedulerService.RescheduleCards(cardIds, days).runWithHandler(scheduleCollectionTaskHandler(R.plurals.reschedule_cards_dialog_acknowledge));\n-        };\n-        RescheduleDialog dialog = RescheduleDialog.rescheduleSingleCard(getResources(), mCurrentCard, runnable);\n-\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void showResetCardDialog() {\n-        // Show confirmation dialog before resetting card progress\n-        Timber.i(\"showResetCardDialog() Reset progress button pressed\");\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getResources().getString(R.string.reset_card_dialog_title);\n-        String message = getResources().getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"NoteEditor:: ResetProgress button pressed\");\n-            List<Long> cardIds = Collections.singletonList(mCurrentCard.getId());\n-            new SchedulerService.ResetCards(cardIds).runWithHandler(scheduleCollectionTaskHandler(R.plurals.reset_cards_dialog_acknowledge));\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void addNote() {\n-        Intent intent = new Intent(this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD);\n-        startActivityForResultWithAnimation(intent, ADD_NOTE, START);\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public boolean onMenuOpened(int featureId, Menu menu) {\n-        new Handler().post(() -> {\n-            for (int i = 0; i < menu.size(); i++) {\n-                MenuItem menuItem = menu.getItem(i);\n-                shouldUseDefaultColor(menuItem);\n-            }\n-        });\n-        return super.onMenuOpened(featureId, menu);\n-    }\n-\n-    /**\n-     * This Method changes the color of icon if user taps in overflow button.\n-     */\n-    private void shouldUseDefaultColor(MenuItem menuItem) {\n-        Drawable drawable = menuItem.getIcon();\n-\n-        if (drawable != null && !menuItem.hasSubMenu() && !isFlagResource(menuItem.getItemId())) {\n-            drawable.mutate();\n-            drawable.setTint(ResourcesCompat.getColor(getResources(), R.color.material_blue_600, null));\n-        }\n-    }\n-\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public void onPanelClosed(int featureId, @NonNull Menu menu) {\n-        new Handler().postDelayed(this::refreshActionBar, 100);\n-    }\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(Menu menu) {\n-        // NOTE: This is called every time a new question is shown via invalidate options menu\n-        getMenuInflater().inflate(R.menu.reviewer, menu);\n-\n-        displayIconsOnTv(menu);\n-        displayIcons(menu);\n-\n-        mActionButtons.setCustomButtonsStatus(menu);\n-        int alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem markCardIcon = menu.findItem(R.id.action_mark_card);\n-        if (mCurrentCard != null && mCurrentCard.note().hasTag(\"marked\")) {\n-            markCardIcon.setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white);\n-        } else {\n-            markCardIcon.setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_border_white);\n-        }\n-        markCardIcon.getIcon().mutate().setAlpha(alpha);\n-\n-        // 1643 - currently null on a TV\n-        @Nullable MenuItem flag_icon = menu.findItem(R.id.action_flag);\n-        if (flag_icon != null) {\n-            if (mCurrentCard != null) {\n-                switch (mCurrentCard.userFlag()) {\n-                    case 1:\n-                        flag_icon.setIcon(R.drawable.ic_flag_red);\n-                        break;\n-                    case 2:\n-                        flag_icon.setIcon(R.drawable.ic_flag_orange);\n-                        break;\n-                    case 3:\n-                        flag_icon.setIcon(R.drawable.ic_flag_green);\n-                        break;\n-                    case 4:\n-                        flag_icon.setIcon(R.drawable.ic_flag_blue);\n-                        break;\n-                    case 5:\n-                        flag_icon.setIcon(R.drawable.ic_flag_pink);\n-                        break;\n-                    case 6:\n-                        flag_icon.setIcon(R.drawable.ic_flag_turquoise);\n-                        break;\n-                    case 7:\n-                        flag_icon.setIcon(R.drawable.ic_flag_purple);\n-                        break;\n-                    default:\n-                        flag_icon.setIcon(R.drawable.ic_flag_transparent);\n-                        break;\n-                }\n-            }\n-            flag_icon.getIcon().mutate().setAlpha(alpha);\n-        }\n-\n-        // Undo button\n-        @DrawableRes int undoIconId;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n-            undoIconId = R.drawable.eraser;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n-        } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n-            undoIconId = R.drawable.ic_undo_white;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n-        }\n-        int alpha_undo = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem undoIcon = menu.findItem(R.id.action_undo);\n-        undoIcon.setIcon(undoIconId);\n-        undoIcon.setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n-        undoIcon.getActionView().setEnabled(undoEnabled);\n-        if (colIsOpen()) { // Required mostly because there are tests where `col` is null\n-            undoIcon.setTitle(getResources().getString(R.string.studyoptions_congrats_undo, getCol().undoName(getResources())));\n-        }\n-\n-        if (undoEnabled) {\n-            mOnboarding.onUndoButtonEnabled();\n-        }\n-\n-        MenuItem toggle_whiteboard_icon = menu.findItem(R.id.action_toggle_whiteboard);\n-        MenuItem hide_whiteboard_icon = menu.findItem(R.id.action_hide_whiteboard);\n-        MenuItem change_pen_color_icon = menu.findItem(R.id.action_change_whiteboard_pen_color);\n-        // White board button\n-        if (mPrefWhiteboard) {\n-            // Configure the whiteboard related items in the action bar\n-            toggle_whiteboard_icon.setTitle(R.string.disable_whiteboard);\n-            // Always allow \"Disable Whiteboard\", even if \"Enable Whiteboard\" is disabled\n-            toggle_whiteboard_icon.setVisible(true);\n-\n-            if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n-                hide_whiteboard_icon.setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().saveWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().whiteboardPenColorIsDisabled()) {\n-                change_pen_color_icon.setVisible(true);\n-            }\n-\n-            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white).mutate();\n-            Drawable whiteboardColorPaletteIcon = VectorDrawableCompat.create(getResources(), R.drawable.ic_color_lens_white_24dp, null).mutate();\n-\n-            if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-            } else {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                change_pen_color_icon.setEnabled(false);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else {\n-            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n-        }\n-        if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n-            menu.findItem(R.id.action_open_deck_options).setVisible(false);\n-        }\n-        if (mSpeakText && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n-            menu.findItem(R.id.action_select_tts).setVisible(true);\n-        }\n-        // Setup bury / suspend providers\n-        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n-        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n-\n-        setupSubMenu(menu, R.id.action_suspend, new SuspendProvider(this));\n-        setupSubMenu(menu, R.id.action_bury, new BuryProvider(this));\n-        if (suspendNoteAvailable()) {\n-            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n-            suspend_icon.setTitle(R.string.menu_suspend);\n-        } else {\n-            suspend_icon.setIcon(R.drawable.ic_pause_circle_outline);\n-            suspend_icon.setTitle(R.string.menu_suspend_card);\n-        }\n-        if (buryNoteAvailable()) {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_dropdown);\n-            bury_icon.setTitle(R.string.menu_bury);\n-        } else {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_white);\n-            bury_icon.setTitle(R.string.menu_bury_card);\n-        }\n-        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        bury_icon.getIcon().mutate().setAlpha(alpha);\n-        suspend_icon.getIcon().mutate().setAlpha(alpha);\n-\n-        setupSubMenu(menu, R.id.action_schedule, new ScheduleProvider(this));\n-        mOnboarding.onCreate();\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\")\n-    private void displayIcons(Menu menu) {\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-        }catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons in Over flow menu\");\n-        }\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\") // setOptionalIconsVisible\n-    private void displayIconsOnTv(Menu menu) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return;\n-        }\n-\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-\n-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-                for (int i = 0; i < menu.size(); i++) {\n-                    MenuItem m = menu.getItem(i);\n-\n-                    if (m == null || isFlagResource(m.getItemId())) {\n-                        continue;\n-                    }\n-\n-                    int color = Themes.getColorFromAttr(this, R.attr.navDrawerItemColor);\n-                    MenuItemCompat.setIconTintList(m, ColorStateList.valueOf(color));\n-                }\n-            }\n-\n-        } catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons\");\n-        }\n-    }\n-\n-\n-    private boolean isFlagResource(int itemId) {\n-        return itemId == R.id.action_flag_seven\n-                || itemId == R.id.action_flag_six\n-                || itemId == R.id.action_flag_five\n-                || itemId == R.id.action_flag_four\n-                || itemId == R.id.action_flag_three\n-                || itemId == R.id.action_flag_two\n-                || itemId == R.id.action_flag_one;\n-    }\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyDown(keyCode, event);\n-        }\n-\n-        if (mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event)) {\n-            return true;\n-        }\n-\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return false;\n-        }\n-\n-        // Process DPAD Up/Down to focus the TV Controls\n-        if (keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_DPAD_UP) {\n-            return false;\n-        }\n-\n-        // HACK: This shouldn't be required, as the navigation should handle this.\n-        if (isDrawerOpen()) {\n-            return false;\n-        }\n-\n-\n-        View view = keyCode == KeyEvent.KEYCODE_DPAD_UP ? findViewById(R.id.tv_nav_view) : findViewById(R.id.answer_options_layout);\n-        // HACK: We should be performing this in the base class, or allowing the view to be focused by the keyboard.\n-        // I couldn't get either to work\n-        if (view == null) {\n-            return false;\n-        }\n-\n-        view.requestFocus();\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (mProcessor.onKeyUp(keyCode, event)) {\n-            return true;\n-        }\n-        return super.onKeyUp(keyCode, event);\n-    }\n-\n-\n-    private <T extends ActionProvider & SubMenuProvider> void setupSubMenu(Menu menu, @IdRes int parentMenu, T subMenuProvider) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            MenuItemCompat.setActionProvider(menu.findItem(parentMenu), subMenuProvider);\n-            return;\n-        }\n-\n-        // Don't do anything if the menu is hidden (bury for example)\n-        if (!subMenuProvider.hasSubMenu()) {\n-            return;\n-        }\n-\n-        // 7227 - If we're running on a TV, then we can't show submenus until AOSP is fixed\n-        menu.removeItem(parentMenu);\n-        int count = menu.size();\n-        // move the menu to the bottom of the page\n-        getMenuInflater().inflate(subMenuProvider.getSubMenu(), menu);\n-        for (int i = 0; i < menu.size() - count; i++) {\n-            MenuItem item = menu.getItem(count + i);\n-            item.setOnMenuItemClickListener(subMenuProvider);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected boolean canAccessScheduler() {\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void performReload() {\n-        getCol().getSched().deferReset();\n-        new SchedulerService.GetCard().runWithHandler(answerCardHandler(false));\n-    }\n-\n-\n-    @Override\n-    protected void displayAnswerBottomBar() {\n-        super.displayAnswerBottomBar();\n-        mOnboarding.onAnswerShown();\n-        int buttonCount;\n-        try {\n-            buttonCount = getButtonCount();\n-        } catch (RuntimeException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"AbstractReviewer-showEaseButtons\");\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, true);\n-            return;\n-        }\n-\n-        // Set correct label and background resource for each button\n-        // Note that it's necessary to set the resource dynamically as the ease2 / ease3 buttons\n-        // (which libanki expects ease to be 2 and 3) can either be hard, good, or easy - depending on num buttons shown\n-        final int[] background = AnswerButtons.getBackgroundColors(this);\n-        final int[] textColor = AnswerButtons.getTextColors(this);\n-        mEase1Layout.setVisibility(View.VISIBLE);\n-        mEase1Layout.setBackgroundResource(background[0]);\n-        mEase4Layout.setBackgroundResource(background[3]);\n-        switch (buttonCount) {\n-            case 2:\n-                // Ease 2 is \"good\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            case 3:\n-                // Ease 2 is good\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                // Ease 3 is easy\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[3]);\n-                mEase3.setText(R.string.ease_button_easy);\n-                mEase3.setTextColor(textColor[3]);\n-                mNext3.setTextColor(textColor[3]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            default:\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                // Ease 2 is \"hard\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[1]);\n-                mEase2.setText(R.string.ease_button_hard);\n-                mEase2.setTextColor(textColor[1]);\n-                mNext2.setTextColor(textColor[1]);\n-                mEase2Layout.requestFocus();\n-                // Ease 3 is good\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[2]);\n-                mEase3.setText(R.string.ease_button_good);\n-                mEase3.setTextColor(textColor[2]);\n-                mNext3.setTextColor(textColor[2]);\n-                mEase4Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.requestFocus();\n-                break;\n-        }\n-\n-        // Show next review time\n-        if (shouldShowNextReviewTime()) {\n-            mNext1.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_ONE));\n-            mNext2.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_TWO));\n-            if (buttonCount > 2) {\n-                mNext3.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_THREE));\n-            }\n-            if (buttonCount > 3) {\n-                mNext4.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_FOUR));\n-            }\n-        }\n-    }\n-\n-    public int getButtonCount() {\n-        return mSched.answerButtons(mCurrentCard);\n-    }\n-\n-\n-    @Override\n-    public void automaticShowQuestion(@NonNull AutomaticAnswerAction action) {\n-        // explicitly do not call super\n-        if (mEase1Layout.isEnabled() && mEase1Layout.getVisibility() == View.VISIBLE) {\n-            action.execute(this);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected SharedPreferences restorePreferences() {\n-        SharedPreferences preferences = super.restorePreferences();\n-        mPrefHideDueCount = preferences.getBoolean(\"hideDueCount\", false);\n-        mPrefShowETA = preferences.getBoolean(\"showETA\", true);\n-        this.mProcessor.setup();\n-        mPrefFullscreenReview = FullScreenMode.isFullScreenReview(preferences);\n-        mActionButtons.setup(preferences);\n-        return preferences;\n-    }\n-\n-    @Override\n-    protected void updateActionBar() {\n-        super.updateActionBar();\n-        updateScreenCounts();\n-    }\n-\n-    protected void updateScreenCounts() {\n-        if (mCurrentCard == null) return;\n-        super.updateActionBar();\n-        ActionBar actionBar = getSupportActionBar();\n-        Counts counts = mSched.counts(mCurrentCard);\n-\n-        if (actionBar != null) {\n-            if (mPrefShowETA) {\n-                mEta = mSched.eta(counts, false);\n-                actionBar.setSubtitle(Utils.remainingTime(AnkiDroidApp.getInstance(), mEta * 60));\n-            }\n-        }\n-\n-\n-        mNewCount = new SpannableString(String.valueOf(counts.getNew()));\n-        mLrnCount = new SpannableString(String.valueOf(counts.getLrn()));\n-        mRevCount = new SpannableString(String.valueOf(counts.getRev()));\n-        if (mPrefHideDueCount) {\n-            mRevCount = new SpannableString(\"???\");\n-        }\n-\n-        switch (mSched.countIdx(mCurrentCard)) {\n-            case NEW:\n-                mNewCount.setSpan(new UnderlineSpan(), 0, mNewCount.length(), 0);\n-                break;\n-            case LRN:\n-                mLrnCount.setSpan(new UnderlineSpan(), 0, mLrnCount.length(), 0);\n-                break;\n-            case REV:\n-                mRevCount.setSpan(new UnderlineSpan(), 0, mRevCount.length(), 0);\n-                break;\n-            default:\n-                Timber.w(\"Unknown card type %s\", mSched.countIdx(mCurrentCard));\n-                break;\n-        }\n-\n-        mTextBarNew.setText(mNewCount);\n-        mTextBarLearn.setText(mLrnCount);\n-        mTextBarReview.setText(mRevCount);\n-    }\n-\n-    @Override\n-    public void fillFlashcard() {\n-        super.fillFlashcard();\n-        if (!sDisplayAnswer && mShowWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.clear();\n-        }\n-    }\n-\n-\n-    @Override\n-    public void displayCardQuestion() {\n-        // show timer, if activated in the deck's preferences\n-        initTimer();\n-        delayedHide(100);\n-        super.displayCardQuestion();\n-    }\n-\n-    @Override\n-    protected void displayCardAnswer() {\n-        delayedHide(100);\n-        super.displayCardAnswer();\n-    }\n-\n-    @Override\n-    protected void initLayout() {\n-        mTextBarNew = findViewById(R.id.new_number);\n-        mTextBarLearn = findViewById(R.id.learn_number);\n-        mTextBarReview = findViewById(R.id.review_number);\n-\n-        super.initLayout();\n-\n-        if (!mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.GONE);\n-            mTextBarLearn.setVisibility(View.GONE);\n-            mTextBarReview.setVisibility(View.GONE);\n-        }\n-    }\n-\n-    @Override\n-    protected void switchTopBarVisibility(int visible) {\n-        super.switchTopBarVisibility(visible);\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(visible);\n-            mTextBarLearn.setVisibility(visible);\n-            mTextBarReview.setVisibility(visible);\n-        }\n-    }\n-\n-    @Override\n-    protected void onStop() {\n-        super.onStop();\n-\n-        if (!isFinishing() && colIsOpen() && mSched != null) {\n-            WidgetStatus.update(this);\n-        }\n-        UIUtils.saveCollectionInBackground();\n-    }\n-\n-\n-    @Override\n-    protected void initControls() {\n-        super.initControls();\n-        if (mPrefWhiteboard) {\n-            setWhiteboardVisibility(mShowWhiteboard);\n-        }\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.VISIBLE);\n-            mTextBarLearn.setVisibility(View.VISIBLE);\n-            mTextBarReview.setVisibility(View.VISIBLE);\n-        }\n-    }\n-\n-    protected void restoreCollectionPreferences(Collection col) {\n-        super.restoreCollectionPreferences(col);\n-        mShowRemainingCardCount = col.get_config_boolean(\"dueCounts\");\n-    }\n-\n-    @Override\n-    protected boolean onSingleTap() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    protected void onFling() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    protected final Handler mFullScreenHandler = new Handler() {\n-        @Override\n-        public void handleMessage(Message msg) {\n-            if (mPrefFullscreenReview) {\n-                setFullScreen(Reviewer.this);\n-            }\n-        }\n-    };\n-\n-    /** Hide the navigation if in full-screen mode after a given period of time */\n-    protected void delayedHide(int delayMillis) {\n-        Timber.d(\"Fullscreen delayed hide in %dms\", delayMillis);\n-        mFullScreenHandler.removeMessages(0);\n-        mFullScreenHandler.sendEmptyMessageDelayed(0, delayMillis);\n-    }\n-\n-\n-    private void setWhiteboardEnabledState(boolean state) {\n-        mPrefWhiteboard = state;\n-        MetaDB.storeWhiteboardState(this, getParentDid(), state);\n-        if (state && mWhiteboard == null) {\n-            createWhiteboard();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private void setFullScreen(final AbstractFlashcardViewer a) {\n-        // Set appropriate flags to enable Sticky Immersive mode.\n-        a.getWindow().getDecorView().setSystemUiVisibility(\n-                View.SYSTEM_UI_FLAG_LAYOUT_STABLE\n-                        //| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION // temporarily disabled due to #5245\n-                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\n-                        | View.SYSTEM_UI_FLAG_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_LOW_PROFILE\n-                        | View.SYSTEM_UI_FLAG_IMMERSIVE\n-        );\n-        // Show / hide the Action bar together with the status bar\n-        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(a);\n-        FullScreenMode fullscreenMode = FullScreenMode.fromPreference(prefs);\n-        a.getWindow().setStatusBarColor(Themes.getColorFromAttr(a, R.attr.colorPrimaryDark));\n-        View decorView = a.getWindow().getDecorView();\n-        decorView.setOnSystemUiVisibilityChangeListener\n-                (flags -> {\n-                    final View toolbar = a.findViewById(R.id.toolbar);\n-                    final View answerButtons = a.findViewById(R.id.answer_options_layout);\n-                    final View topbar = a.findViewById(R.id.top_bar);\n-                    if (toolbar == null || topbar == null || answerButtons == null) {\n-                        return;\n-                    }\n-                    // Note that system bars will only be \"visible\" if none of the\n-                    // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set.\n-                    boolean visible = (flags & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-                    Timber.d(\"System UI visibility change. Visible: %b\", visible);\n-                    if (visible) {\n-                        showViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            showViewWithAnimation(topbar);\n-                            showViewWithAnimation(answerButtons);\n-                        }\n-                    } else {\n-                        hideViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            hideViewWithAnimation(topbar);\n-                            hideViewWithAnimation(answerButtons);\n-                        }\n-                    }\n-                });\n-    }\n-\n-    private static final int ANIMATION_DURATION = 200;\n-    private static final float TRANSPARENCY = 0.90f;\n-\n-\n-    private void showViewWithAnimation(final View view) {\n-        view.setAlpha(0.0f);\n-        view.setVisibility(View.VISIBLE);\n-        view.animate().alpha(TRANSPARENCY).setDuration(ANIMATION_DURATION).setListener(null);\n-    }\n-\n-    private void hideViewWithAnimation(final View view) {\n-        view.animate()\n-                .alpha(0f)\n-                .setDuration(ANIMATION_DURATION)\n-                .setListener(new AnimatorListenerAdapter() {\n-                    @Override\n-                    public void onAnimationEnd(Animator animation) {\n-                        view.setVisibility(View.GONE);\n-                    }\n-                });\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private boolean isImmersiveSystemUiVisible(AnkiActivity activity) {\n-        return (activity.getWindow().getDecorView().getSystemUiVisibility() & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-    }\n-\n-    private void createWhiteboard() {\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(this);\n-        mWhiteboard = Whiteboard.createInstance(this, true, this);\n-\n-        // We use the pen color of the selected deck at the time the whiteboard is enabled.\n-        // This is how all other whiteboard settings are\n-        Integer whiteboardPenColor = MetaDB.getWhiteboardPenColor(this, getParentDid()).fromPreferences(sharedPrefs);\n-        if (whiteboardPenColor != null) {\n-            mWhiteboard.setPenColor(whiteboardPenColor);\n-        }\n-\n-        mWhiteboard.setOnPaintColorChangeListener(color -> MetaDB.storeWhiteboardPenColor(this, getParentDid(), !CardAppearance.isInNightMode(sharedPrefs), color));\n-\n-        mWhiteboard.setOnTouchListener((v, event) -> {\n-            //If the whiteboard is currently drawing, and triggers the system UI to show, we want to continue drawing.\n-            if (!mWhiteboard.isCurrentlyDrawing() && (!mShowWhiteboard || (mPrefFullscreenReview\n-                    && isImmersiveSystemUiVisible(Reviewer.this)))) {\n-                // Bypass whiteboard listener when it's hidden or fullscreen immersive mode is temporarily suspended\n-                v.performClick();\n-                return getGestureDetector().onTouchEvent(event);\n-            }\n-            return mWhiteboard.handleTouchEvent(event);\n-        });\n-    }\n-\n-    // Show or hide the whiteboard\n-    private void setWhiteboardVisibility(boolean state) {\n-        mShowWhiteboard = state;\n-        MetaDB.storeWhiteboardVisibility(this, getParentDid(), state);\n-        if (state) {\n-            mWhiteboard.setVisibility(View.VISIBLE);\n-            disableDrawerSwipe();\n-        } else {\n-            mWhiteboard.setVisibility(View.GONE);\n-            if (!mHasDrawerSwipeConflicts) {\n-                enableDrawerSwipe();\n-            }\n-        }\n-    }\n-\n-\n-    private void disableDrawerSwipeOnConflicts() {\n-        if (mGestureProcessor.isBound(Gesture.SWIPE_UP, Gesture.SWIPE_DOWN, Gesture.SWIPE_RIGHT)) {\n-            mHasDrawerSwipeConflicts = true;\n-            super.disableDrawerSwipe();\n-        }\n-    }\n-\n-\n-    @Override\n-    protected Long getCurrentCardId() {\n-        return mCurrentCard.getId();\n-    }\n-\n-\n-    @Override\n-    public void onWindowFocusChanged(boolean hasFocus) {\n-        super.onWindowFocusChanged(hasFocus);\n-        // Restore full screen once we regain focus\n-        if (hasFocus) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        } else {\n-            mFullScreenHandler.removeMessages(0);\n-        }\n-    }\n-\n-\n-    /**\n-     * Whether or not dismiss note is available for current card and specified DismissType\n-     * @return true if there is another card of same note that could be dismissed\n-     */\n-    private boolean suspendNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // whether there exists a sibling not buried.\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue != \" + Consts.QUEUE_TYPE_SUSPENDED + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-    private boolean buryNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // Whether there exists a sibling which is neither susbended nor buried\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue >=  \" + Consts.QUEUE_TYPE_NEW + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    @CheckResult\n-    Whiteboard getWhiteboard() {\n-        return mWhiteboard;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public AudioView getAudioView() {\n-        return mMicToolBar;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public boolean hasDrawerSwipeConflicts() {\n-        return mHasDrawerSwipeConflicts;\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Suspend button\n-     */\n-    class SuspendProvider extends ActionProvider implements SubMenuProvider {\n-        public SuspendProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;  // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_suspend;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return suspendNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_suspend_card) {\n-                return suspendCard();\n-            } else if (itemId == R.id.action_suspend_note) {\n-                return suspendNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Bury button\n-     */\n-    class BuryProvider extends ActionProvider implements SubMenuProvider {\n-        public BuryProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_bury;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return buryNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_bury_card) {\n-                return buryCard();\n-            } else if (itemId == R.id.action_bury_note) {\n-                return buryNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-\n-    /**\n-     * Inner class which implements the submenu for the Schedule button\n-     */\n-    class ScheduleProvider extends ActionProvider implements SubMenuProvider {\n-        public ScheduleProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_reschedule_card) {\n-                showRescheduleCardDialog();\n-                return true;\n-            } else if (itemId == R.id.action_reset_card_progress) {\n-                showResetCardDialog();\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_schedule;\n-        }\n-    }\n-\n-    private interface SubMenuProvider extends MenuItem.OnMenuItemClickListener {\n-        @MenuRes int getSubMenu();\n-        boolean hasSubMenu();\n-    }\n-\n-    public ReviewerJavaScriptFunction javaScriptFunction() {\n-        return new ReviewerJavaScriptFunction();\n-    }\n-\n-    public class ReviewerJavaScriptFunction extends JavaScriptFunction {\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetNewCardCount() {\n-            return mNewCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetLrnCardCount() {\n-            return mLrnCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetRevCardCount() {\n-            return mRevCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public int ankiGetETA() {\n-            return mEta;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4MjE3Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445382176", "body": "```suggestion\r\n    private LinearLayout mColorPalette;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private LinearLayout colorPalette;\n          \n          \n            \n                private LinearLayout mColorPalette;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">private</span> <span class=\"pl-smi\">LinearLayout</span> <span class=\"x x-first x-last\">colorPalette</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> <span class=\"pl-smi\">LinearLayout</span> <span class=\"x x-first x-last\">mColorPalette</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "david-allison-1", "createdAt": "2020-06-25T08:09:31Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -66,6 +68,7 @@\n     private boolean mMonochrome;\n     private boolean mUndoModeActive = false;\n \n+    private LinearLayout colorPalette;", "originalCommit": "77d6abfbb12a4898098d59bb06670aa9aaec63f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex e1b2054af..1c4a154f2 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -67,8 +73,8 @@ public class Whiteboard extends View implements View.OnClickListener {\n     private boolean mInvertedColors;\n     private boolean mMonochrome;\n     private boolean mUndoModeActive = false;\n-\n-    private LinearLayout colorPalette;\n+    private final int foregroundColor;\n+    private SystemTime mTime = new SystemTime();\n \n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 1c4a154f2..0f4fcd932 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -74,6 +76,7 @@ public class Whiteboard extends View {\n     private boolean mMonochrome;\n     private boolean mUndoModeActive = false;\n     private final int foregroundColor;\n+    private final LinearLayout mColorPalette;\n     private SystemTime mTime = new SystemTime();\n \n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n", "next_change": {"commit": "2a1b50a210789e9a20064de3cb5ece59ca0be456", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 0f4fcd932..6b57dfd73 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -77,7 +78,6 @@ public class Whiteboard extends View {\n     private boolean mUndoModeActive = false;\n     private final int foregroundColor;\n     private final LinearLayout mColorPalette;\n-    private SystemTime mTime = new SystemTime();\n \n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n", "next_change": {"commit": "bd2fb549a2e827068ae3d3bd03623d4a549fe16d", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 6b57dfd73..4603418f4 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -73,7 +75,6 @@ public class Whiteboard extends View {\n \n     private boolean mSecondFingerWithinTapTolerance;\n     private boolean mCurrentlyDrawing = false;\n-    private boolean mInvertedColors;\n     private boolean mMonochrome;\n     private boolean mUndoModeActive = false;\n     private final int foregroundColor;\n", "next_change": {"commit": "bf209dc67aa56c94d84a173d10aa415fb4470aaf", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 4603418f4..2d6381590 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -75,7 +75,6 @@ public class Whiteboard extends View {\n \n     private boolean mSecondFingerWithinTapTolerance;\n     private boolean mCurrentlyDrawing = false;\n-    private boolean mMonochrome;\n     private boolean mUndoModeActive = false;\n     private final int foregroundColor;\n     private final LinearLayout mColorPalette;\n", "next_change": {"commit": "27f10d57c86fe2e8ad3e66c969b48b92b5e594f1", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 2d6381590..09c5cb62e 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -79,6 +82,9 @@ public class Whiteboard extends View {\n     private final int foregroundColor;\n     private final LinearLayout mColorPalette;\n \n+    @Nullable\n+    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n+\n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n", "next_change": {"commit": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 09c5cb62e..872c1de5f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -85,23 +86,21 @@ public class Whiteboard extends View {\n     @Nullable\n     private OnPaintColorChangeListener mOnPaintColorChangeListener;\n \n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n+    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n \n+        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n+        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n \n         if (!inverted) {\n-            if (monochrome) {\n+                whitePenColorButton.setVisibility(View.GONE);\n+                blackPenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.BLACK;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color);\n-            }\n         } else {\n-            if (monochrome) {\n+                blackPenColorButton.setVisibility(View.GONE);\n+                whitePenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.WHITE;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color_inv);\n-            }\n         }\n \n         mPaint = new Paint();\n", "next_change": {"commit": "164200255997ac4750493118c24cec649191b630", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 872c1de5f..9839e2295 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -96,17 +101,17 @@ public class Whiteboard extends View {\n         if (!inverted) {\n                 whitePenColorButton.setVisibility(View.GONE);\n                 blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n+                mForegroundColor = Color.BLACK;\n         } else {\n                 blackPenColorButton.setVisibility(View.GONE);\n                 whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n+                mForegroundColor = Color.WHITE;\n         }\n \n         mPaint = new Paint();\n         mPaint.setAntiAlias(true);\n         mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n+        mPaint.setColor(mForegroundColor);\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n", "next_change": {"commit": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 9839e2295..bb9f12e33 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -115,21 +117,24 @@ public class Whiteboard extends View {\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n+        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n \n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n     }\n \n+    public int getCurrentStrokeWidth() {\n+        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n+    }\n \n     @Override\n     protected void onDraw(Canvas canvas) {\n", "next_change": {"commit": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex bb9f12e33..9953065c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -136,6 +138,24 @@ public class Whiteboard extends View {\n         return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n     }\n \n+\n+    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n+\n+        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n+        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n+\n+        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n+                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n+\n+        whiteboard.setLayoutParams(lp2);\n+        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n+        fl.addView(whiteboard);\n+\n+        whiteboard.setEnabled(true);\n+\n+        return whiteboard;\n+    }\n+\n     @Override\n     protected void onDraw(Canvas canvas) {\n         super.onDraw(canvas);\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 9953065c7..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,634 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.net.Uri;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.isInNightMode;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-\n-    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n-\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n-        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n-\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-\n-        whiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n-        fl.addView(whiteboard);\n-\n-        whiteboard.setEnabled(true);\n-\n-        return whiteboard;\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mCardViewer.get(), getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mCardViewer.get()).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected Uri saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 4603418f4..2d6381590 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -83,17 +82,16 @@ public class Whiteboard extends View {\n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n-        mMonochrome = monochrome;\n \n \n         if (!inverted) {\n-            if (mMonochrome) {\n+            if (monochrome) {\n                 foregroundColor = Color.BLACK;\n             } else {\n                 foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color);\n             }\n         } else {\n-            if (mMonochrome) {\n+            if (monochrome) {\n                 foregroundColor = Color.WHITE;\n             } else {\n                 foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color_inv);\n", "next_change": {"commit": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 2d6381590..872c1de5f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -79,23 +83,24 @@ public class Whiteboard extends View {\n     private final int foregroundColor;\n     private final LinearLayout mColorPalette;\n \n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n+    @Nullable\n+    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n+\n+    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n \n+        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n+        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n \n         if (!inverted) {\n-            if (monochrome) {\n+                whitePenColorButton.setVisibility(View.GONE);\n+                blackPenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.BLACK;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color);\n-            }\n         } else {\n-            if (monochrome) {\n+                blackPenColorButton.setVisibility(View.GONE);\n+                whitePenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.WHITE;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color_inv);\n-            }\n         }\n \n         mPaint = new Paint();\n", "next_change": {"commit": "164200255997ac4750493118c24cec649191b630", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 872c1de5f..9839e2295 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -96,17 +101,17 @@ public class Whiteboard extends View {\n         if (!inverted) {\n                 whitePenColorButton.setVisibility(View.GONE);\n                 blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n+                mForegroundColor = Color.BLACK;\n         } else {\n                 blackPenColorButton.setVisibility(View.GONE);\n                 whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n+                mForegroundColor = Color.WHITE;\n         }\n \n         mPaint = new Paint();\n         mPaint.setAntiAlias(true);\n         mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n+        mPaint.setColor(mForegroundColor);\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n", "next_change": {"commit": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 9839e2295..bb9f12e33 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -115,21 +117,24 @@ public class Whiteboard extends View {\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n+        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n \n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n     }\n \n+    public int getCurrentStrokeWidth() {\n+        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n+    }\n \n     @Override\n     protected void onDraw(Canvas canvas) {\n", "next_change": {"commit": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex bb9f12e33..9953065c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -136,6 +138,24 @@ public class Whiteboard extends View {\n         return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n     }\n \n+\n+    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n+\n+        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n+        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n+\n+        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n+                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n+\n+        whiteboard.setLayoutParams(lp2);\n+        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n+        fl.addView(whiteboard);\n+\n+        whiteboard.setEnabled(true);\n+\n+        return whiteboard;\n+    }\n+\n     @Override\n     protected void onDraw(Canvas canvas) {\n         super.onDraw(canvas);\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 9953065c7..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,634 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.net.Uri;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.isInNightMode;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-\n-    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n-\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n-        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n-\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-\n-        whiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n-        fl.addView(whiteboard);\n-\n-        whiteboard.setEnabled(true);\n-\n-        return whiteboard;\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mCardViewer.get(), getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mCardViewer.get()).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected Uri saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 6b57dfd73..4603418f4 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -82,11 +83,10 @@ public class Whiteboard extends View {\n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n-        mInvertedColors = inverted;\n         mMonochrome = monochrome;\n \n \n-        if (!mInvertedColors) {\n+        if (!inverted) {\n             if (mMonochrome) {\n                 foregroundColor = Color.BLACK;\n             } else {\n", "next_change": {"commit": "bf209dc67aa56c94d84a173d10aa415fb4470aaf", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 4603418f4..2d6381590 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -83,17 +82,16 @@ public class Whiteboard extends View {\n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n-        mMonochrome = monochrome;\n \n \n         if (!inverted) {\n-            if (mMonochrome) {\n+            if (monochrome) {\n                 foregroundColor = Color.BLACK;\n             } else {\n                 foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color);\n             }\n         } else {\n-            if (mMonochrome) {\n+            if (monochrome) {\n                 foregroundColor = Color.WHITE;\n             } else {\n                 foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color_inv);\n", "next_change": {"commit": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 2d6381590..872c1de5f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -79,23 +83,24 @@ public class Whiteboard extends View {\n     private final int foregroundColor;\n     private final LinearLayout mColorPalette;\n \n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n+    @Nullable\n+    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n+\n+    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n \n+        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n+        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n \n         if (!inverted) {\n-            if (monochrome) {\n+                whitePenColorButton.setVisibility(View.GONE);\n+                blackPenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.BLACK;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color);\n-            }\n         } else {\n-            if (monochrome) {\n+                blackPenColorButton.setVisibility(View.GONE);\n+                whitePenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.WHITE;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color_inv);\n-            }\n         }\n \n         mPaint = new Paint();\n", "next_change": {"commit": "164200255997ac4750493118c24cec649191b630", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 872c1de5f..9839e2295 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -96,17 +101,17 @@ public class Whiteboard extends View {\n         if (!inverted) {\n                 whitePenColorButton.setVisibility(View.GONE);\n                 blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n+                mForegroundColor = Color.BLACK;\n         } else {\n                 blackPenColorButton.setVisibility(View.GONE);\n                 whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n+                mForegroundColor = Color.WHITE;\n         }\n \n         mPaint = new Paint();\n         mPaint.setAntiAlias(true);\n         mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n+        mPaint.setColor(mForegroundColor);\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n", "next_change": {"commit": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 9839e2295..bb9f12e33 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -115,21 +117,24 @@ public class Whiteboard extends View {\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n+        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n \n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n     }\n \n+    public int getCurrentStrokeWidth() {\n+        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n+    }\n \n     @Override\n     protected void onDraw(Canvas canvas) {\n", "next_change": {"commit": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex bb9f12e33..9953065c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -136,6 +138,24 @@ public class Whiteboard extends View {\n         return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n     }\n \n+\n+    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n+\n+        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n+        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n+\n+        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n+                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n+\n+        whiteboard.setLayoutParams(lp2);\n+        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n+        fl.addView(whiteboard);\n+\n+        whiteboard.setEnabled(true);\n+\n+        return whiteboard;\n+    }\n+\n     @Override\n     protected void onDraw(Canvas canvas) {\n         super.onDraw(canvas);\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 9953065c7..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,634 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.net.Uri;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.isInNightMode;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-\n-    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n-\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n-        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n-\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-\n-        whiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n-        fl.addView(whiteboard);\n-\n-        whiteboard.setEnabled(true);\n-\n-        return whiteboard;\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mCardViewer.get(), getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mCardViewer.get()).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected Uri saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4MjU0MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445382540", "body": "Why was this commented out?", "bodyText": "Why was this commented out?", "bodyHTML": "<p dir=\"auto\">Why was this commented out?</p>", "author": "david-allison-1", "createdAt": "2020-06-25T08:10:10Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -241,11 +260,13 @@ private void createBitmap() {\n         // To fix issue #1336, just make the whiteboard big and square.\n         final Point p = getDisplayDimenions();\n         int bitmapSize = Math.max(p.x, p.y);\n+        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_8888);\n+        /*\n         if (mMonochrome && !mInvertedColors) {", "originalCommit": "77d6abfbb12a4898098d59bb06670aa9aaec63f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5MDU2MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445490560", "bodyText": "When not commented out then pen color change but after drawing complete. The drawn figure change to black color.", "author": "infinyte7", "createdAt": "2020-06-25T11:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4MjU0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwOTc4Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445609783", "bodyText": "Wouldn't that the be mPaint line?\nDoes this feature still work in night mode?", "author": "david-allison-1", "createdAt": "2020-06-25T14:39:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4MjU0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYyOTE3OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445629178", "bodyText": "Yes, this work in night mode.  But in normal mode drawn figure color change to black.", "author": "infinyte7", "createdAt": "2020-06-25T15:05:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4MjU0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0NjY1Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445746656", "bodyText": "Could you try 4444, so we conserve memory.", "author": "david-allison-1", "createdAt": "2020-06-25T18:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4MjU0MA=="}], "type": "inlineReview", "revised_code": {"commit": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex e1b2054af..1c4a154f2 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -260,13 +250,11 @@ public class Whiteboard extends View implements View.OnClickListener {\n         // To fix issue #1336, just make the whiteboard big and square.\n         final Point p = getDisplayDimenions();\n         int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_8888);\n-        /*\n         if (mMonochrome && !mInvertedColors) {\n             createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ALPHA_8);\n         } else {\n             createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_4444);\n-        }*/\n+        }\n     }\n \n     private void drawStart(float x, float y) {\n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 1c4a154f2..0f4fcd932 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -250,11 +263,7 @@ public class Whiteboard extends View {\n         // To fix issue #1336, just make the whiteboard big and square.\n         final Point p = getDisplayDimenions();\n         int bitmapSize = Math.max(p.x, p.y);\n-        if (mMonochrome && !mInvertedColors) {\n-            createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ALPHA_8);\n-        } else {\n-            createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_4444);\n-        }\n+        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_4444);\n     }\n \n     private void drawStart(float x, float y) {\n", "next_change": {"commit": "69dba64459dc466daad2d81012c55b9d66b721bb", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 0f4fcd932..d2616c7c0 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -263,7 +260,7 @@ public class Whiteboard extends View {\n         // To fix issue #1336, just make the whiteboard big and square.\n         final Point p = getDisplayDimenions();\n         int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_4444);\n+        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_8888);\n     }\n \n     private void drawStart(float x, float y) {\n", "next_change": {"commit": "24a01ecfe55797fdb2011f49fb2c903b1528f075", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex d2616c7c0..94395fe77 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -260,7 +256,7 @@ public class Whiteboard extends View {\n         // To fix issue #1336, just make the whiteboard big and square.\n         final Point p = getDisplayDimenions();\n         int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_8888);\n+        createBitmap(bitmapSize, bitmapSize);\n     }\n \n     private void drawStart(float x, float y) {\n", "next_change": {"commit": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 94395fe77..872c1de5f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -254,7 +256,7 @@ public class Whiteboard extends View {\n \n     private void createBitmap() {\n         // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimenions();\n+        final Point p = getDisplayDimensions();\n         int bitmapSize = Math.max(p.x, p.y);\n         createBitmap(bitmapSize, bitmapSize);\n     }\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 872c1de5f..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,534 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import android.os.Environment;\n-import android.view.Display;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.WindowManager;\n-import android.widget.Button;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.lang.ref.WeakReference;\n-import java.util.Stack;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoStack mUndo = new UndoStack();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int foregroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-    }\n-\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        Display display = ((WindowManager) AnkiDroidApp.getInstance().getApplicationContext().\n-                getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\n-        Point point = new Point();\n-        display.getSize(point);\n-        return point;\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        }\n-    }\n-\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a stack of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the stack, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoStack {\n-        private final Stack<WhiteboardAction> mStack = new Stack<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mStack.add(action);\n-        }\n-\n-        public void clear() {\n-            mStack.clear();\n-        }\n-\n-        public int size() {\n-            return mStack.size();\n-        }\n-\n-        public void pop() {\n-            mStack.pop();\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mStack) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean empty() {\n-            return mStack.empty();\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    @SuppressWarnings( {\"deprecation\", \"RedundantSuppression\"}) // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n-    protected String saveWhiteboard(Time time) throws FileNotFoundException {\n-\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-\n-        File pictures = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);\n-        File ankiDroidFolder = new File(pictures, \"AnkiDroid\");\n-\n-        if (!ankiDroidFolder.exists()) {\n-            //noinspection ResultOfMethodCallIgnored\n-            ankiDroidFolder.mkdirs();\n-        }\n-\n-        String baseFileName = \"Whiteboard\";\n-        String timeStamp = TimeUtils.getTimestamp(time);\n-        String finalFileName = baseFileName + timeStamp + \".png\";\n-\n-        File saveWhiteboardImageFile = new File(ankiDroidFolder, finalFileName);\n-\n-        if (foregroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-\n-        this.draw(canvas);\n-        bitmap.compress(Bitmap.CompressFormat.JPEG, 95, new FileOutputStream(saveWhiteboardImageFile));\n-        return saveWhiteboardImageFile.getAbsolutePath();\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return foregroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4MjkyMQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445382921", "body": "Move all of these into the case statements (surround the cases with `{}` if they're declaring variables)", "bodyText": "Move all of these into the case statements (surround the cases with {} if they're declaring variables)", "bodyHTML": "<p dir=\"auto\">Move all of these into the case statements (surround the cases with <code>{}</code> if they're declaring variables)</p>", "author": "david-allison-1", "createdAt": "2020-06-25T08:10:47Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -356,6 +377,44 @@ private static Point getDisplayDimenions() {\n         return point;\n     }\n \n+    @Override\n+    public void onClick(View view) {\n+\n+        int redPenColor = Color.parseColor(\"#f44336\");", "originalCommit": "77d6abfbb12a4898098d59bb06670aa9aaec63f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5NTE0Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445495142", "bodyText": "The default colours seem sensible. At some point we might want to move to a colour picker.\nCould you rebase this to remove references to the .png images and use a vector instead?\n\nSome thing like this can be done. Google Keep\n\nI have used .png for color palette icon in Action Bar as Undo icon used. Undo icon have four png iconhdpi, mdpi, xdpi, xxdpi. So I have created four png icon for color palette icon.", "author": "infinyte7", "createdAt": "2020-06-25T11:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4MjkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5Njc1OQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445596759", "bodyText": "We plan to (eventually) remove the four pngs: #5134", "author": "david-allison-1", "createdAt": "2020-06-25T14:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4MjkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYyOTk0NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445629945", "bodyText": "To be updated.", "author": "infinyte7", "createdAt": "2020-06-25T15:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4MjkyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex e1b2054af..1c4a154f2 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -377,44 +365,6 @@ public class Whiteboard extends View implements View.OnClickListener {\n         return point;\n     }\n \n-    @Override\n-    public void onClick(View view) {\n-\n-        int redPenColor = Color.parseColor(\"#f44336\");\n-        int greenPenColor = Color.parseColor(\"#4caf50\");\n-        int bluePenColor = Color.parseColor(\"#2196f3\");\n-        int yellowPenColor = Color.parseColor(\"#ffeb3b\");\n-\n-        switch (view.getId()) {\n-            case R.id.pen_color_white:\n-                mPaint.setColor(Color.WHITE);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_black:\n-                mPaint.setColor(Color.BLACK);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_red:\n-                mPaint.setColor(redPenColor);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_green:\n-                mPaint.setColor(greenPenColor);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_blue:\n-                mPaint.setColor(bluePenColor);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_yellow:\n-                mPaint.setColor(yellowPenColor);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            default:\n-                break;\n-        }\n-    }\n-\n     /**\n      * Keep a stack of all points and paths so that the last stroke can be undone\n      * pop() removes the last stroke from the stack, and apply() redraws it to whiteboard.\n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 1c4a154f2..0f4fcd932 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -365,60 +371,117 @@ public class Whiteboard extends View {\n         return point;\n     }\n \n+\n+    public void onClick(View view) {\n+\n+        switch (view.getId()) {\n+            case R.id.pen_color_white:\n+                mPaint.setColor(Color.WHITE);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_black:\n+                mPaint.setColor(Color.BLACK);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_red:\n+                int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n+                mPaint.setColor(redPenColor);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_green:\n+                int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n+                mPaint.setColor(greenPenColor);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_blue:\n+                int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n+                mPaint.setColor(bluePenColor);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_yellow:\n+                int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n+                mPaint.setColor(yellowPenColor);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n     /**\n      * Keep a stack of all points and paths so that the last stroke can be undone\n      * pop() removes the last stroke from the stack, and apply() redraws it to whiteboard.\n      */\n     private class UndoStack {\n-        private final Stack<Path> mPathStack = new Stack<>();\n-        private final Stack<PointF> mPointStack = new Stack<>();\n-        private final Stack<Integer> mWhichStack = new Stack<>();\n+        private final Stack<WhiteboardAction> mStack = new Stack<>();\n \n-        public void add(Path path) {\n-            mPathStack.add(new Path(path));\n-            mWhichStack.add(0);\n-        }\n-        public void add(float x, float y) {\n-            mPointStack.add(new PointF(x, y));\n-            mWhichStack.add(1);\n+        public void add(WhiteboardAction action) {\n+            mStack.add(action);\n         }\n \n         public void clear() {\n-            mPathStack.clear();\n-            mPointStack.clear();\n-            mWhichStack.clear();\n+            mStack.clear();\n         }\n \n         public int size() {\n-            return mWhichStack.size();\n+            return mStack.size();\n         }\n \n         public void pop() {\n-            if (mWhichStack.size() == 0) return;\n-            switch (mWhichStack.peek()) {\n-                case 0:\n-                    mPathStack.pop();\n-                    break;\n-                case 1:\n-                    mPointStack.pop();\n-                    break;\n-            }\n-            mWhichStack.pop();\n+            mStack.pop();\n         }\n \n         public void apply() {\n             mBitmap.eraseColor(0);\n-            for (Path path : mPathStack) {\n-                mCanvas.drawPath(path, mPaint);\n-            }\n-            for (PointF point : mPointStack) {\n-                mCanvas.drawPoint(point.x, point.y, mPaint);\n+\n+            for (WhiteboardAction action : mStack) {\n+                action.apply(mCanvas);\n             }\n             invalidate();\n         }\n \n         public boolean empty() {\n-            return mWhichStack.empty();\n+            return mStack.empty();\n+        }\n+    }\n+\n+    private interface WhiteboardAction {\n+        void apply(@NonNull Canvas canvas);\n+    }\n+\n+    private static class DrawPoint implements WhiteboardAction {\n+\n+        private final float mX;\n+        private final float mY;\n+        private final Paint mPaint;\n+\n+\n+        public DrawPoint(float x, float y, Paint paint) {\n+            mX = x;\n+            mY = y;\n+            mPaint = paint;\n+        }\n+\n+\n+        @Override\n+        public void apply(@NonNull Canvas canvas) {\n+            canvas.drawPoint(mX, mY, mPaint);\n+        }\n+    }\n+\n+    private static class DrawPath implements WhiteboardAction {\n+        private final Path mPath;\n+        private final Paint mPaint;\n+\n+        public DrawPath(Path path, Paint paint) {\n+            mPath = path;\n+            mPaint = paint;\n+        }\n+\n+\n+        @Override\n+        public void apply(@NonNull Canvas canvas) {\n+            canvas.drawPath(mPath, mPaint);\n         }\n     }\n \n", "next_change": {"commit": "2a1b50a210789e9a20064de3cb5ece59ca0be456", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 0f4fcd932..6b57dfd73 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -489,7 +489,7 @@ public class Whiteboard extends View {\n         return mCurrentlyDrawing;\n     }\n \n-    protected String saveWhiteboard() throws FileNotFoundException {\n+    protected String saveWhiteboard(Time time) throws FileNotFoundException {\n \n         Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n         Canvas canvas = new Canvas(bitmap);\n", "next_change": {"commit": "69dba64459dc466daad2d81012c55b9d66b721bb", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 6b57dfd73..d2616c7c0 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -489,6 +486,7 @@ public class Whiteboard extends View {\n         return mCurrentlyDrawing;\n     }\n \n+    @SuppressWarnings(\"deprecation\") // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n     protected String saveWhiteboard(Time time) throws FileNotFoundException {\n \n         Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n", "next_change": {"commit": "24a01ecfe55797fdb2011f49fb2c903b1528f075", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex d2616c7c0..94395fe77 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -486,7 +474,7 @@ public class Whiteboard extends View {\n         return mCurrentlyDrawing;\n     }\n \n-    @SuppressWarnings(\"deprecation\") // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n+    @SuppressWarnings( {\"deprecation\", \"RedundantSuppression\"}) // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n     protected String saveWhiteboard(Time time) throws FileNotFoundException {\n \n         Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n", "next_change": {"commit": "9bdf38906bd7954fd443bf92de4199f42a00c1d6", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 94395fe77..549c721de 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -468,46 +569,43 @@ public class Whiteboard extends View {\n         public void apply(@NonNull Canvas canvas) {\n             canvas.drawPath(mPath, mPaint);\n         }\n+\n+        @Override\n+        public Path getPath() {\n+            return mPath;\n+        }\n+\n+        @Override\n+        public Point getPoint() {\n+            return null;\n+        }\n     }\n \n     public boolean isCurrentlyDrawing() {\n         return mCurrentlyDrawing;\n     }\n \n-    @SuppressWarnings( {\"deprecation\", \"RedundantSuppression\"}) // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n     protected String saveWhiteboard(Time time) throws FileNotFoundException {\n-\n         Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n         Canvas canvas = new Canvas(bitmap);\n-\n-        File pictures = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);\n-        File ankiDroidFolder = new File(pictures, \"AnkiDroid\");\n-\n-        if (!ankiDroidFolder.exists()) {\n-            //noinspection ResultOfMethodCallIgnored\n-            ankiDroidFolder.mkdirs();\n-        }\n-\n-        String baseFileName = \"Whiteboard\";\n-        String timeStamp = TimeUtils.getTimestamp(time);\n-        String finalFileName = baseFileName + timeStamp + \".png\";\n-\n-        File saveWhiteboardImageFile = new File(ankiDroidFolder, finalFileName);\n-\n-        if (foregroundColor != Color.BLACK) {\n+        if (mForegroundColor != Color.BLACK) {\n             canvas.drawColor(Color.BLACK);\n         } else {\n             canvas.drawColor(Color.WHITE);\n         }\n-\n         this.draw(canvas);\n-        bitmap.compress(Bitmap.CompressFormat.JPEG, 95, new FileOutputStream(saveWhiteboardImageFile));\n-        return saveWhiteboardImageFile.getAbsolutePath();\n+        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n+        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n+        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n     }\n \n     @VisibleForTesting\n     @CheckResult\n     protected int getForegroundColor() {\n-        return foregroundColor;\n+        return mForegroundColor;\n+    }\n+\n+    public interface OnPaintColorChangeListener {\n+        void onPaintColorChange(@Nullable Integer color);\n     }\n }\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 549c721de..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,611 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.widget.Button;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mCardViewer.get(), getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mCardViewer.get()).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected String saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM4ODE4MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445388181", "body": "might as well remove rather than commenting out", "bodyText": "might as well remove rather than commenting out", "bodyHTML": "<p dir=\"auto\">might as well remove rather than commenting out</p>", "author": "david-allison-1", "createdAt": "2020-06-25T08:19:45Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -91,7 +94,7 @@ public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean\n         mPaint = new Paint();\n         mPaint.setAntiAlias(true);\n         mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n+        //mPaint.setColor(foregroundColor);", "originalCommit": "77d6abfbb12a4898098d59bb06670aa9aaec63f6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex e1b2054af..1c4a154f2 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -94,7 +100,7 @@ public class Whiteboard extends View implements View.OnClickListener {\n         mPaint = new Paint();\n         mPaint.setAntiAlias(true);\n         mPaint.setDither(true);\n-        //mPaint.setColor(foregroundColor);\n+        mPaint.setColor(foregroundColor);\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 1c4a154f2..0f4fcd932 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -109,6 +112,16 @@ public class Whiteboard extends View {\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n+\n+        // selecting pen color to draw\n+        mColorPalette = (LinearLayout) cardViewer.findViewById(R.id.whiteboard_pen_color);\n+\n+        ((Button) cardViewer.findViewById(R.id.pen_color_white)).setOnClickListener(this::onClick);\n+        ((Button) cardViewer.findViewById(R.id.pen_color_black)).setOnClickListener(this::onClick);\n+        ((Button) cardViewer.findViewById(R.id.pen_color_red)).setOnClickListener(this::onClick);\n+        ((Button) cardViewer.findViewById(R.id.pen_color_green)).setOnClickListener(this::onClick);\n+        ((Button) cardViewer.findViewById(R.id.pen_color_blue)).setOnClickListener(this::onClick);\n+        ((Button) cardViewer.findViewById(R.id.pen_color_yellow)).setOnClickListener(this::onClick);\n     }\n \n \n", "next_change": {"commit": "42b92180120040299e590634f5b03d6f352c0a4f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 0f4fcd932..307bf13e0 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -114,14 +111,14 @@ public class Whiteboard extends View {\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = (LinearLayout) cardViewer.findViewById(R.id.whiteboard_pen_color);\n-\n-        ((Button) cardViewer.findViewById(R.id.pen_color_white)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_black)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_red)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_green)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_blue)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_yellow)).setOnClickListener(this::onClick);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+\n+        cardViewer.findViewById(R.id.pen_color_white).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_black).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n     }\n \n \n", "next_change": {"commit": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 307bf13e0..872c1de5f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -113,8 +119,6 @@ public class Whiteboard extends View {\n         // selecting pen color to draw\n         mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n \n-        cardViewer.findViewById(R.id.pen_color_white).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_black).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n", "next_change": {"commit": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 872c1de5f..bb9f12e33 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -96,35 +103,38 @@ public class Whiteboard extends View {\n         if (!inverted) {\n                 whitePenColorButton.setVisibility(View.GONE);\n                 blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n+                mForegroundColor = Color.BLACK;\n         } else {\n                 blackPenColorButton.setVisibility(View.GONE);\n                 whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n+                mForegroundColor = Color.WHITE;\n         }\n \n         mPaint = new Paint();\n         mPaint.setAntiAlias(true);\n         mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n+        mPaint.setColor(mForegroundColor);\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n+        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n \n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n     }\n \n+    public int getCurrentStrokeWidth() {\n+        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n+    }\n \n     @Override\n     protected void onDraw(Canvas canvas) {\n", "next_change": {"commit": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex bb9f12e33..9953065c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -136,6 +138,24 @@ public class Whiteboard extends View {\n         return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n     }\n \n+\n+    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n+\n+        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n+        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n+\n+        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n+                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n+\n+        whiteboard.setLayoutParams(lp2);\n+        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n+        fl.addView(whiteboard);\n+\n+        whiteboard.setEnabled(true);\n+\n+        return whiteboard;\n+    }\n+\n     @Override\n     protected void onDraw(Canvas canvas) {\n         super.onDraw(canvas);\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 9953065c7..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,634 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.net.Uri;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.isInNightMode;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-\n-    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n-\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n-        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n-\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-\n-        whiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n-        fl.addView(whiteboard);\n-\n-        whiteboard.setEnabled(true);\n-\n-        return whiteboard;\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mCardViewer.get(), getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mCardViewer.get()).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected Uri saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM5OTA2NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445399065", "body": "You'll need to update the UndoStack class to allow for colours.\r\n\r\nLikely moving it to a class-based model at this stage, so you'd have one undo stack rather than 3 (potentially 4 with adding in the colour).", "bodyText": "You'll need to update the UndoStack class to allow for colours.\nLikely moving it to a class-based model at this stage, so you'd have one undo stack rather than 3 (potentially 4 with adding in the colour).", "bodyHTML": "<p dir=\"auto\">You'll need to update the UndoStack class to allow for colours.</p>\n<p dir=\"auto\">Likely moving it to a class-based model at this stage, so you'd have one undo stack rather than 3 (potentially 4 with adding in the colour).</p>", "author": "david-allison-1", "createdAt": "2020-06-25T08:38:36Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -356,6 +377,44 @@ private static Point getDisplayDimenions() {\n         return point;\n     }\n \n+    @Override\n+    public void onClick(View view) {\n+\n+        int redPenColor = Color.parseColor(\"#f44336\");\n+        int greenPenColor = Color.parseColor(\"#4caf50\");\n+        int bluePenColor = Color.parseColor(\"#2196f3\");\n+        int yellowPenColor = Color.parseColor(\"#ffeb3b\");\n+\n+        switch (view.getId()) {\n+            case R.id.pen_color_white:\n+                mPaint.setColor(Color.WHITE);\n+                colorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_black:\n+                mPaint.setColor(Color.BLACK);\n+                colorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_red:\n+                mPaint.setColor(redPenColor);\n+                colorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_green:\n+                mPaint.setColor(greenPenColor);\n+                colorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_blue:\n+                mPaint.setColor(bluePenColor);\n+                colorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_yellow:\n+                mPaint.setColor(yellowPenColor);\n+                colorPalette.setVisibility(View.GONE);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n     /**\n      * Keep a stack of all points and paths so that the last stroke can be undone\n      * pop() removes the last stroke from the stack, and apply() redraws it to whiteboard.", "originalCommit": "77d6abfbb12a4898098d59bb06670aa9aaec63f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTQ5Mzg2Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445493862", "bodyText": "Please explain it more.", "author": "infinyte7", "createdAt": "2020-06-25T11:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM5OTA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMzM4Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445603382", "bodyText": "Currently, UndoStack uses 3 stacks to handle undo/redo.\nWhen an undo is performed, two stacks are popped, the canvas is reset, and the stacks are iterated to redraw the canvas.\nTo add colour to this feature, you'll need to add more data to these stacks. This can either be done by using a Pair class (or making a new object), or adding a new stack containing the Paint which was used at the time to draw the lines.\nBoth of the above options aren't great and add complexity.\n\nIt'd be much better to simplify the class to have one stack, and having the object in the stack being an interface which has an `apply(Canvas)`` operation.\nImplement the interface/object with two subclasses: Point and Line\nOnce this is done, you can supply a Paint object to the classes and use it in apply(Canvas) so they can handle different colours.\nThis has the added benefit of simplifying the UndoStack class", "author": "david-allison-1", "createdAt": "2020-06-25T14:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM5OTA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYzNjkzNA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445636934", "bodyText": "I understand it. But implementing this is difficult for me.", "author": "infinyte7", "createdAt": "2020-06-25T15:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM5OTA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY2Njg1Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445666856", "bodyText": "I'll send over some code... give me 5 mins\nEDIT: Just testing... can't be sending over broken code ;)", "author": "david-allison-1", "createdAt": "2020-06-25T16:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM5OTA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY4MTUzNA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445681534", "bodyText": "GitHub's file processing seems broken. Copy to a text file, rename to .patch and apply it (VCS - Apply Patch)\nwhiteboard.patch\nIndex: AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\t(revision 8236599b1db98f774a45c4f84de308e16affd0c3)\n+++ AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\t(date 1593101965792)\n@@ -26,7 +26,7 @@\n import android.graphics.Path;\n import android.graphics.PathMeasure;\n import android.graphics.Point;\n-import android.graphics.PointF;\n+import androidx.annotation.NonNull;\n import androidx.core.content.ContextCompat;\n import android.view.Display;\n import android.view.MotionEvent;\n@@ -272,13 +272,10 @@\n         mCurrentlyDrawing = false;\n         PathMeasure pm = new PathMeasure(mPath, false);\n         mPath.lineTo(mX, mY);\n-        if (pm.getLength() > 0) {\n-            mCanvas.drawPath(mPath, mPaint);\n-            mUndo.add(mPath);\n-        } else {\n-            mCanvas.drawPoint(mX, mY, mPaint);\n-            mUndo.add(mX, mY);\n-        }\n+        Paint paint = new Paint(mPaint);\n+        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n+        action.apply(mCanvas);\n+        mUndo.add(action);\n         mUndoModeActive = true;\n         // kill the path so we don't double draw\n         mPath.reset();\n@@ -361,55 +358,75 @@\n      * pop() removes the last stroke from the stack, and apply() redraws it to whiteboard.\n      */\n     private class UndoStack {\n-        private final Stack<Path> mPathStack = new Stack<>();\n-        private final Stack<PointF> mPointStack = new Stack<>();\n-        private final Stack<Integer> mWhichStack = new Stack<>();\n+        private final Stack<WhiteboardAction> mStack = new Stack<>();\n \n-        public void add(Path path) {\n-            mPathStack.add(new Path(path));\n-            mWhichStack.add(0);\n-        }\n-        public void add(float x, float y) {\n-            mPointStack.add(new PointF(x, y));\n-            mWhichStack.add(1);\n+        public void add(WhiteboardAction action) {\n+            mStack.add(action);\n         }\n \n         public void clear() {\n-            mPathStack.clear();\n-            mPointStack.clear();\n-            mWhichStack.clear();\n+            mStack.clear();\n         }\n \n         public int size() {\n-            return mWhichStack.size();\n+            return mStack.size();\n         }\n \n         public void pop() {\n-            if (mWhichStack.size() == 0) return;\n-            switch (mWhichStack.peek()) {\n-                case 0:\n-                    mPathStack.pop();\n-                    break;\n-                case 1:\n-                    mPointStack.pop();\n-                    break;\n-            }\n-            mWhichStack.pop();\n+            mStack.pop();\n         }\n \n         public void apply() {\n             mBitmap.eraseColor(0);\n-            for (Path path : mPathStack) {\n-                mCanvas.drawPath(path, mPaint);\n-            }\n-            for (PointF point : mPointStack) {\n-                mCanvas.drawPoint(point.x, point.y, mPaint);\n+\n+            for (WhiteboardAction action : mStack) {\n+                action.apply(mCanvas);\n             }\n             invalidate();\n         }\n \n         public boolean empty() {\n-            return mWhichStack.empty();\n+            return mStack.empty();\n+        }\n+    }\n+\n+    private interface WhiteboardAction {\n+        void apply(@NonNull Canvas canvas);\n+    }\n+\n+    private static class DrawPoint implements WhiteboardAction {\n+\n+        private final float mX;\n+        private final float mY;\n+        private final Paint mPaint;\n+\n+\n+        public DrawPoint(float x, float y, Paint paint) {\n+            mX = x;\n+            mY = y;\n+            mPaint = paint;\n+        }\n+\n+\n+        @Override\n+        public void apply(@NonNull Canvas canvas) {\n+            canvas.drawPoint(mX, mY, mPaint);\n+        }\n+    }\n+\n+    private static class DrawPath implements WhiteboardAction {\n+        private final Path mPath;\n+        private final Paint mPaint;\n+\n+        public DrawPath(Path path, Paint paint) {\n+            mPath = path;\n+            mPaint = paint;\n+        }\n+\n+\n+        @Override\n+        public void apply(@NonNull Canvas canvas) {\n+            canvas.drawPath(mPath, mPaint);\n         }\n     }", "author": "david-allison-1", "createdAt": "2020-06-25T16:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM5OTA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY5MzI1Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445693252", "bodyText": "Thank you,\nI have added the patch.\nIt is working as expected.", "author": "infinyte7", "createdAt": "2020-06-25T16:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM5OTA2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex e1b2054af..1c4a154f2 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -377,44 +365,6 @@ public class Whiteboard extends View implements View.OnClickListener {\n         return point;\n     }\n \n-    @Override\n-    public void onClick(View view) {\n-\n-        int redPenColor = Color.parseColor(\"#f44336\");\n-        int greenPenColor = Color.parseColor(\"#4caf50\");\n-        int bluePenColor = Color.parseColor(\"#2196f3\");\n-        int yellowPenColor = Color.parseColor(\"#ffeb3b\");\n-\n-        switch (view.getId()) {\n-            case R.id.pen_color_white:\n-                mPaint.setColor(Color.WHITE);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_black:\n-                mPaint.setColor(Color.BLACK);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_red:\n-                mPaint.setColor(redPenColor);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_green:\n-                mPaint.setColor(greenPenColor);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_blue:\n-                mPaint.setColor(bluePenColor);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_yellow:\n-                mPaint.setColor(yellowPenColor);\n-                colorPalette.setVisibility(View.GONE);\n-                break;\n-            default:\n-                break;\n-        }\n-    }\n-\n     /**\n      * Keep a stack of all points and paths so that the last stroke can be undone\n      * pop() removes the last stroke from the stack, and apply() redraws it to whiteboard.\n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 1c4a154f2..0f4fcd932 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -365,60 +371,117 @@ public class Whiteboard extends View {\n         return point;\n     }\n \n+\n+    public void onClick(View view) {\n+\n+        switch (view.getId()) {\n+            case R.id.pen_color_white:\n+                mPaint.setColor(Color.WHITE);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_black:\n+                mPaint.setColor(Color.BLACK);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_red:\n+                int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n+                mPaint.setColor(redPenColor);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_green:\n+                int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n+                mPaint.setColor(greenPenColor);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_blue:\n+                int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n+                mPaint.setColor(bluePenColor);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_yellow:\n+                int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n+                mPaint.setColor(yellowPenColor);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n     /**\n      * Keep a stack of all points and paths so that the last stroke can be undone\n      * pop() removes the last stroke from the stack, and apply() redraws it to whiteboard.\n      */\n     private class UndoStack {\n-        private final Stack<Path> mPathStack = new Stack<>();\n-        private final Stack<PointF> mPointStack = new Stack<>();\n-        private final Stack<Integer> mWhichStack = new Stack<>();\n+        private final Stack<WhiteboardAction> mStack = new Stack<>();\n \n-        public void add(Path path) {\n-            mPathStack.add(new Path(path));\n-            mWhichStack.add(0);\n-        }\n-        public void add(float x, float y) {\n-            mPointStack.add(new PointF(x, y));\n-            mWhichStack.add(1);\n+        public void add(WhiteboardAction action) {\n+            mStack.add(action);\n         }\n \n         public void clear() {\n-            mPathStack.clear();\n-            mPointStack.clear();\n-            mWhichStack.clear();\n+            mStack.clear();\n         }\n \n         public int size() {\n-            return mWhichStack.size();\n+            return mStack.size();\n         }\n \n         public void pop() {\n-            if (mWhichStack.size() == 0) return;\n-            switch (mWhichStack.peek()) {\n-                case 0:\n-                    mPathStack.pop();\n-                    break;\n-                case 1:\n-                    mPointStack.pop();\n-                    break;\n-            }\n-            mWhichStack.pop();\n+            mStack.pop();\n         }\n \n         public void apply() {\n             mBitmap.eraseColor(0);\n-            for (Path path : mPathStack) {\n-                mCanvas.drawPath(path, mPaint);\n-            }\n-            for (PointF point : mPointStack) {\n-                mCanvas.drawPoint(point.x, point.y, mPaint);\n+\n+            for (WhiteboardAction action : mStack) {\n+                action.apply(mCanvas);\n             }\n             invalidate();\n         }\n \n         public boolean empty() {\n-            return mWhichStack.empty();\n+            return mStack.empty();\n+        }\n+    }\n+\n+    private interface WhiteboardAction {\n+        void apply(@NonNull Canvas canvas);\n+    }\n+\n+    private static class DrawPoint implements WhiteboardAction {\n+\n+        private final float mX;\n+        private final float mY;\n+        private final Paint mPaint;\n+\n+\n+        public DrawPoint(float x, float y, Paint paint) {\n+            mX = x;\n+            mY = y;\n+            mPaint = paint;\n+        }\n+\n+\n+        @Override\n+        public void apply(@NonNull Canvas canvas) {\n+            canvas.drawPoint(mX, mY, mPaint);\n+        }\n+    }\n+\n+    private static class DrawPath implements WhiteboardAction {\n+        private final Path mPath;\n+        private final Paint mPaint;\n+\n+        public DrawPath(Path path, Paint paint) {\n+            mPath = path;\n+            mPaint = paint;\n+        }\n+\n+\n+        @Override\n+        public void apply(@NonNull Canvas canvas) {\n+            canvas.drawPath(mPath, mPaint);\n         }\n     }\n \n", "next_change": {"commit": "2a1b50a210789e9a20064de3cb5ece59ca0be456", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 0f4fcd932..6b57dfd73 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -489,7 +489,7 @@ public class Whiteboard extends View {\n         return mCurrentlyDrawing;\n     }\n \n-    protected String saveWhiteboard() throws FileNotFoundException {\n+    protected String saveWhiteboard(Time time) throws FileNotFoundException {\n \n         Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n         Canvas canvas = new Canvas(bitmap);\n", "next_change": {"commit": "69dba64459dc466daad2d81012c55b9d66b721bb", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 6b57dfd73..d2616c7c0 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -489,6 +486,7 @@ public class Whiteboard extends View {\n         return mCurrentlyDrawing;\n     }\n \n+    @SuppressWarnings(\"deprecation\") // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n     protected String saveWhiteboard(Time time) throws FileNotFoundException {\n \n         Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n", "next_change": {"commit": "24a01ecfe55797fdb2011f49fb2c903b1528f075", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex d2616c7c0..94395fe77 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -486,7 +474,7 @@ public class Whiteboard extends View {\n         return mCurrentlyDrawing;\n     }\n \n-    @SuppressWarnings(\"deprecation\") // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n+    @SuppressWarnings( {\"deprecation\", \"RedundantSuppression\"}) // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n     protected String saveWhiteboard(Time time) throws FileNotFoundException {\n \n         Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n", "next_change": {"commit": "9bdf38906bd7954fd443bf92de4199f42a00c1d6", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 94395fe77..549c721de 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -468,46 +569,43 @@ public class Whiteboard extends View {\n         public void apply(@NonNull Canvas canvas) {\n             canvas.drawPath(mPath, mPaint);\n         }\n+\n+        @Override\n+        public Path getPath() {\n+            return mPath;\n+        }\n+\n+        @Override\n+        public Point getPoint() {\n+            return null;\n+        }\n     }\n \n     public boolean isCurrentlyDrawing() {\n         return mCurrentlyDrawing;\n     }\n \n-    @SuppressWarnings( {\"deprecation\", \"RedundantSuppression\"}) // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n     protected String saveWhiteboard(Time time) throws FileNotFoundException {\n-\n         Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n         Canvas canvas = new Canvas(bitmap);\n-\n-        File pictures = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);\n-        File ankiDroidFolder = new File(pictures, \"AnkiDroid\");\n-\n-        if (!ankiDroidFolder.exists()) {\n-            //noinspection ResultOfMethodCallIgnored\n-            ankiDroidFolder.mkdirs();\n-        }\n-\n-        String baseFileName = \"Whiteboard\";\n-        String timeStamp = TimeUtils.getTimestamp(time);\n-        String finalFileName = baseFileName + timeStamp + \".png\";\n-\n-        File saveWhiteboardImageFile = new File(ankiDroidFolder, finalFileName);\n-\n-        if (foregroundColor != Color.BLACK) {\n+        if (mForegroundColor != Color.BLACK) {\n             canvas.drawColor(Color.BLACK);\n         } else {\n             canvas.drawColor(Color.WHITE);\n         }\n-\n         this.draw(canvas);\n-        bitmap.compress(Bitmap.CompressFormat.JPEG, 95, new FileOutputStream(saveWhiteboardImageFile));\n-        return saveWhiteboardImageFile.getAbsolutePath();\n+        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n+        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n+        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n     }\n \n     @VisibleForTesting\n     @CheckResult\n     protected int getForegroundColor() {\n-        return foregroundColor;\n+        return mForegroundColor;\n+    }\n+\n+    public interface OnPaintColorChangeListener {\n+        void onPaintColorChange(@Nullable Integer color);\n     }\n }\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 549c721de..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,611 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.widget.Button;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mCardViewer.get(), getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mCardViewer.get()).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected String saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"oid": "cd46f7c4ca8eb6a2380b7f4b7f2ba73164f10e3f", "url": "https://github.com/ankidroid/Anki-Android/commit/cd46f7c4ca8eb6a2380b7f4b7f2ba73164f10e3f", "message": "\tUpdated Reviewer.java, Whiteboard.java", "committedDate": "2020-06-25T11:36:08Z", "type": "commit"}, {"oid": "526c0db92ac8c7010007a7649e4da14ecc2f7362", "url": "https://github.com/ankidroid/Anki-Android/commit/526c0db92ac8c7010007a7649e4da14ecc2f7362", "message": "    Added vector icon for select pen color icon", "committedDate": "2020-06-25T16:08:47Z", "type": "commit"}, {"oid": "7f2dcf75fe1f523cb2333b364f84ac2e6fd335e7", "url": "https://github.com/ankidroid/Anki-Android/commit/7f2dcf75fe1f523cb2333b364f84ac2e6fd335e7", "message": "    Added patch to Whiteboard.java", "committedDate": "2020-06-25T16:41:26Z", "type": "commit"}, {"oid": "ddf40a5eb5fcaef10fe07f9a7cd638bf54f59243", "url": "https://github.com/ankidroid/Anki-Android/commit/ddf40a5eb5fcaef10fe07f9a7cd638bf54f59243", "message": "\tAdded button to ActionButtonStatus.java", "committedDate": "2020-06-25T16:57:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcwNTIxMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445705213", "body": "There's also some logic in Reviewer about enabling whitebaord buttons status depending on whether the whiteboard is available or not.", "bodyText": "There's also some logic in Reviewer about enabling whitebaord buttons status depending on whether the whiteboard is available or not.", "bodyHTML": "<p dir=\"auto\">There's also some logic in Reviewer about enabling whitebaord buttons status depending on whether the whiteboard is available or not.</p>", "author": "david-allison-1", "createdAt": "2020-06-25T16:59:48Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java", "diffHunk": "@@ -61,6 +61,7 @@ public void setup(SharedPreferences preferences) {\n         setupButton(preferences, R.id.action_mark_card, \"customButtonMarkCard\", SHOW_AS_ACTION_IF_ROOM);\n         setupButton(preferences, R.id.action_delete, \"customButtonDelete\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_toggle_mic_tool_bar, \"customButtonToggleMicToolBar\", SHOW_AS_ACTION_NEVER);\n+        setupButton(preferences, R.id.action_change_whiteboard_pen_color, \"customButtonWhiteboardPenColor\", SHOW_AS_ACTION_ALWAYS);", "originalCommit": "ddf40a5eb5fcaef10fe07f9a7cd638bf54f59243", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d413c3d24c40f1e267229a474759548dfdaf7c3", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\nindex 23dc10747..c84ada798 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n", "chunk": "@@ -61,7 +61,6 @@ public class ActionButtonStatus {\n         setupButton(preferences, R.id.action_mark_card, \"customButtonMarkCard\", SHOW_AS_ACTION_IF_ROOM);\n         setupButton(preferences, R.id.action_delete, \"customButtonDelete\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_toggle_mic_tool_bar, \"customButtonToggleMicToolBar\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_change_whiteboard_pen_color, \"customButtonWhiteboardPenColor\", SHOW_AS_ACTION_ALWAYS);\n     }\n \n \n", "next_change": {"commit": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\nindex c84ada798..723fc45df 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n", "chunk": "@@ -61,6 +61,7 @@ public class ActionButtonStatus {\n         setupButton(preferences, R.id.action_mark_card, \"customButtonMarkCard\", SHOW_AS_ACTION_IF_ROOM);\n         setupButton(preferences, R.id.action_delete, \"customButtonDelete\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_toggle_mic_tool_bar, \"customButtonToggleMicToolBar\", SHOW_AS_ACTION_NEVER);\n+        setupButton(preferences, R.id.action_save_whiteboard, \"customButtonSaveWhiteboard\", SHOW_AS_ACTION_NEVER);\n     }\n \n \n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\nindex 723fc45df..f40c7271c 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n", "chunk": "@@ -62,6 +62,7 @@ public class ActionButtonStatus {\n         setupButton(preferences, R.id.action_delete, \"customButtonDelete\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_toggle_mic_tool_bar, \"customButtonToggleMicToolBar\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_save_whiteboard, \"customButtonSaveWhiteboard\", SHOW_AS_ACTION_NEVER);\n+        setupButton(preferences, R.id.action_change_whiteboard_pen_color, \"customButtonWhiteboardPenColor\", SHOW_AS_ACTION_ALWAYS);\n     }\n \n \n", "next_change": {"commit": "9b1cf82c7d140cd185f9b57f7dc3000f69982621", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\nindex f40c7271c..a570dcf25 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n", "chunk": "@@ -62,7 +62,7 @@ public class ActionButtonStatus {\n         setupButton(preferences, R.id.action_delete, \"customButtonDelete\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_toggle_mic_tool_bar, \"customButtonToggleMicToolBar\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_save_whiteboard, \"customButtonSaveWhiteboard\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_change_whiteboard_pen_color, \"customButtonWhiteboardPenColor\", SHOW_AS_ACTION_ALWAYS);\n+        setupButton(preferences, R.id.action_change_whiteboard_pen_color, \"customButtonWhiteboardPenColor\", SHOW_AS_ACTION_IF_ROOM);\n     }\n \n \n", "next_change": {"commit": "5dfaf9012e6c38f4c601ccfc61131176a1fe11ee", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\nindex a570dcf25..7cdd69240 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n", "chunk": "@@ -61,6 +61,7 @@ public class ActionButtonStatus {\n         setupButton(preferences, R.id.action_mark_card, \"customButtonMarkCard\", SHOW_AS_ACTION_IF_ROOM);\n         setupButton(preferences, R.id.action_delete, \"customButtonDelete\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_toggle_mic_tool_bar, \"customButtonToggleMicToolBar\", SHOW_AS_ACTION_NEVER);\n+        setupButton(preferences, R.id.action_enable_whiteboard, \"customButtonEnableWhiteboard\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_save_whiteboard, \"customButtonSaveWhiteboard\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_change_whiteboard_pen_color, \"customButtonWhiteboardPenColor\", SHOW_AS_ACTION_IF_ROOM);\n     }\n", "next_change": {"commit": "937d3027a35f3af8c478b2066c8f35d1627710ee", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\nindex 7cdd69240..936ec1198 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n", "chunk": "@@ -61,7 +61,7 @@ public class ActionButtonStatus {\n         setupButton(preferences, R.id.action_mark_card, \"customButtonMarkCard\", SHOW_AS_ACTION_IF_ROOM);\n         setupButton(preferences, R.id.action_delete, \"customButtonDelete\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_toggle_mic_tool_bar, \"customButtonToggleMicToolBar\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_enable_whiteboard, \"customButtonEnableWhiteboard\", SHOW_AS_ACTION_NEVER);\n+        setupButton(preferences, R.id.action_toggle_whiteboard, \"customButtonEnableWhiteboard\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_save_whiteboard, \"customButtonSaveWhiteboard\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_change_whiteboard_pen_color, \"customButtonWhiteboardPenColor\", SHOW_AS_ACTION_IF_ROOM);\n     }\n", "next_change": {"commit": "d0890de143d98609e91c6d6d55c00b0bca4be30a", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\nindex 936ec1198..b8830372b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n", "chunk": "@@ -64,6 +66,11 @@ public class ActionButtonStatus {\n         setupButton(preferences, R.id.action_toggle_whiteboard, \"customButtonEnableWhiteboard\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_save_whiteboard, \"customButtonSaveWhiteboard\", SHOW_AS_ACTION_NEVER);\n         setupButton(preferences, R.id.action_change_whiteboard_pen_color, \"customButtonWhiteboardPenColor\", SHOW_AS_ACTION_IF_ROOM);\n+        if (!Lookup.isAvailable()) {\n+            mCustomButtons.put(R.id.action_search_dictionary, MENU_DISABLED);\n+        } else {\n+            setupButton(preferences, R.id.action_search_dictionary, \"customButtonLookup\", SHOW_AS_ACTION_NEVER);\n+        }\n     }\n \n \n", "next_change": {"commit": "70f87ac148ce1763bdae9d8712f3191d3ae5f993", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java b/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\ndeleted file mode 100644\nindex b8830372b..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/reviewer/ActionButtonStatus.java\n+++ /dev/null\n", "chunk": "@@ -1,140 +0,0 @@\n-package com.ichi2.anki.reviewer;\n-\n-import android.content.SharedPreferences;\n-import android.graphics.drawable.Drawable;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-\n-import com.ichi2.anki.Lookup;\n-import com.ichi2.anki.R;\n-import com.ichi2.themes.Themes;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import androidx.annotation.IdRes;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import timber.log.Timber;\n-\n-@SuppressWarnings(\"ConstantConditions\") //loads of unboxing issues, which are safe\n-public class ActionButtonStatus {\n-    /**\n-     * Custom button allocation\n-     */\n-    @NonNull\n-    protected final Map<Integer, Integer> mCustomButtons = new HashMap<>(25); // setup's size\n-    private final ReviewerUi mReviewerUi;\n-\n-    public static final int SHOW_AS_ACTION_NEVER = MenuItem.SHOW_AS_ACTION_NEVER;\n-    public static final int SHOW_AS_ACTION_IF_ROOM = MenuItem.SHOW_AS_ACTION_IF_ROOM;\n-    public static final int SHOW_AS_ACTION_ALWAYS = MenuItem.SHOW_AS_ACTION_ALWAYS;\n-    public static final int MENU_DISABLED = 3;\n-\n-    public @Nullable Integer getByMenuResourceId(int resourceId) {\n-        if (!mCustomButtons.containsKey(resourceId)) {\n-            Timber.w(\"Invalid resource lookup: %d\", resourceId);\n-            return SHOW_AS_ACTION_NEVER;\n-        }\n-        return mCustomButtons.get(resourceId);\n-    }\n-\n-\n-    public ActionButtonStatus(ReviewerUi reviewerUi) {\n-        this.mReviewerUi = reviewerUi;\n-    }\n-\n-    public void setup(SharedPreferences preferences) {\n-        // NOTE: the default values below should be in sync with preferences_custom_buttons.xml and reviewer.xml\n-        setupButton(preferences, R.id.action_undo, \"customButtonUndo\", SHOW_AS_ACTION_ALWAYS);\n-        setupButton(preferences, R.id.action_schedule, \"customButtonScheduleCard\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_flag, \"customButtonFlag\", SHOW_AS_ACTION_ALWAYS);\n-        setupButton(preferences, R.id.action_tag, \"customButtonTags\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_edit, \"customButtonEditCard\", SHOW_AS_ACTION_IF_ROOM);\n-        setupButton(preferences, R.id.action_add_note_reviewer, \"customButtonAddCard\", MENU_DISABLED);\n-        setupButton(preferences, R.id.action_replay, \"customButtonReplay\", SHOW_AS_ACTION_IF_ROOM);\n-        setupButton(preferences, R.id.action_card_info, \"customButtonCardInfo\", MENU_DISABLED);\n-        setupButton(preferences, R.id.action_clear_whiteboard, \"customButtonClearWhiteboard\", SHOW_AS_ACTION_IF_ROOM);\n-        setupButton(preferences, R.id.action_hide_whiteboard, \"customButtonShowHideWhiteboard\", SHOW_AS_ACTION_ALWAYS);\n-        setupButton(preferences, R.id.action_select_tts, \"customButtonSelectTts\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_open_deck_options, \"customButtonDeckOptions\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_bury, \"customButtonBury\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_suspend, \"customButtonSuspend\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_mark_card, \"customButtonMarkCard\", SHOW_AS_ACTION_IF_ROOM);\n-        setupButton(preferences, R.id.action_delete, \"customButtonDelete\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_toggle_mic_tool_bar, \"customButtonToggleMicToolBar\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_toggle_whiteboard, \"customButtonEnableWhiteboard\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_save_whiteboard, \"customButtonSaveWhiteboard\", SHOW_AS_ACTION_NEVER);\n-        setupButton(preferences, R.id.action_change_whiteboard_pen_color, \"customButtonWhiteboardPenColor\", SHOW_AS_ACTION_IF_ROOM);\n-        if (!Lookup.isAvailable()) {\n-            mCustomButtons.put(R.id.action_search_dictionary, MENU_DISABLED);\n-        } else {\n-            setupButton(preferences, R.id.action_search_dictionary, \"customButtonLookup\", SHOW_AS_ACTION_NEVER);\n-        }\n-    }\n-\n-\n-    private void setupButton(SharedPreferences preferences, @IdRes int resourceId, String preferenceName, int showAsActionType) {\n-        mCustomButtons.put(resourceId, Integer.parseInt(preferences.getString(preferenceName, Integer.toString(showAsActionType))));\n-    }\n-\n-\n-    public void setCustomButtons(Menu menu) {\n-        for(Map.Entry<Integer, Integer> entry : mCustomButtons.entrySet()) {\n-            int itemId = entry.getKey();\n-            if (entry.getValue() != MENU_DISABLED) {\n-                MenuItem item = menu.findItem(itemId);\n-                if (item == null) {\n-                    // Happens with TV - removing flag icon\n-                    Timber.w(\"Could not find Menu Item %d\", itemId);\n-                    continue;\n-                }\n-\n-                item.setShowAsAction(entry.getValue());\n-                Drawable icon = item.getIcon();\n-                item.setEnabled(!mReviewerUi.isControlBlocked());\n-                if (icon != null) {\n-                    /* Ideally, we want to give feedback to users that\n-                    buttons are disabled.  However, some actions are\n-                    expected to be so quick that the visual feedback\n-                    is useless and is only seen as a flickering.\n-\n-                    We use a heuristic to decide whether the next card\n-                    will appear quickly or slowly.  We change the\n-                    color only if the buttons are blocked and we\n-                    expect the next card to take time to arrive.\n-                    */\n-                    Drawable mutableIcon = icon.mutate();\n-                    if (mReviewerUi.getControlBlocked() == ReviewerUi.ControlBlock.SLOW) {\n-                        mutableIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                    } else {\n-                        mutableIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                    }\n-                }\n-            } else {\n-                menu.findItem(itemId).setVisible(false);\n-            }\n-        }\n-    }\n-\n-\n-    public boolean hideWhiteboardIsDisabled() {\n-        return mCustomButtons.get(R.id.action_hide_whiteboard) == MENU_DISABLED;\n-    }\n-\n-    public boolean clearWhiteboardIsDisabled() {\n-        return mCustomButtons.get(R.id.action_clear_whiteboard) == MENU_DISABLED;\n-    }\n-\n-    public boolean selectTtsIsDisabled() {\n-        return mCustomButtons.get(R.id.action_select_tts) == MENU_DISABLED;\n-    }\n-\n-    public boolean saveWhiteboardIsDisabled() {\n-        return mCustomButtons.get(R.id.action_save_whiteboard) == MENU_DISABLED;\n-    }\n-\n-    public boolean whiteboardPenColorIsDisabled() {\n-        return mCustomButtons.get(R.id.action_change_whiteboard_pen_color) == MENU_DISABLED;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "82c7d650943603dcedadb7e1a9d13bfb00050fcd", "url": "https://github.com/ankidroid/Anki-Android/commit/82c7d650943603dcedadb7e1a9d13bfb00050fcd", "message": "   Updated Reviewer.java", "committedDate": "2020-06-25T17:36:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDQyOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445730429", "body": "```suggestion\r\n            Drawable whiteboardColorPaletteIcon = ContextCompat.getDrawable(this, R.drawable.ic_color_lens_white_24dp).mutate();\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Drawable whiteboardColorPaletteIcon = ContextCompat.getDrawable(this, R.drawable.ic_color_lens_white_24dp);\n          \n          \n            \n                        Drawable whiteboardColorPaletteIcon = ContextCompat.getDrawable(this, R.drawable.ic_color_lens_white_24dp).mutate();", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-smi\">Drawable</span> whiteboardColorPaletteIcon <span class=\"pl-k\">=</span> <span class=\"pl-smi\">ContextCompat</span><span class=\"pl-k\">.</span>getDrawable(<span class=\"pl-c1\">this</span>, <span class=\"pl-smi\">R</span><span class=\"pl-k\">.</span>drawable<span class=\"pl-k\">.</span>ic_color_lens_white_24dp);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            <span class=\"pl-smi\">Drawable</span> whiteboardColorPaletteIcon <span class=\"pl-k\">=</span> <span class=\"pl-smi\">ContextCompat</span><span class=\"pl-k\">.</span>getDrawable(<span class=\"pl-c1\">this</span>, <span class=\"pl-smi\">R</span><span class=\"pl-k\">.</span>drawable<span class=\"pl-k\">.</span>ic_color_lens_white_24dp)<span class=\"pl-k x x-first\">.</span><span class=\"x x-last\">mutate()</span>;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "david-allison-1", "createdAt": "2020-06-25T17:44:10Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java", "diffHunk": "@@ -544,14 +545,24 @@ public boolean onCreateOptionsMenu(Menu menu) {\n             menu.findItem(R.id.action_change_whiteboard_pen_color).setVisible(true);\n \n             Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp);\n+            Drawable whiteboardColorPaletteIcon = ContextCompat.getDrawable(this, R.drawable.ic_color_lens_white_24dp);", "originalCommit": "82c7d650943603dcedadb7e1a9d13bfb00050fcd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e541b3ede91ca0bf8b1995deb32bd1a8f28ac1fb", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 3ddfc9ce8..237cc98f6 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -542,27 +525,15 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n             }\n \n-            menu.findItem(R.id.action_change_whiteboard_pen_color).setVisible(true);\n-\n             Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp);\n-            Drawable whiteboardColorPaletteIcon = ContextCompat.getDrawable(this, R.drawable.ic_color_lens_white_24dp);\n-\n             if (mShowWhiteboard) {\n                 whiteboardIcon.setAlpha(255);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(255);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n             } else {\n                 whiteboardIcon.setAlpha(77);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.show_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(77);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setEnabled(false);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n-                colorPalette.setVisibility(View.GONE);\n             }\n         } else {\n             menu.findItem(R.id.action_enable_whiteboard).setTitle(R.string.enable_whiteboard);\n", "next_change": {"commit": "7574ad576813e609baf204561d5495bf5b30e2f8", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 237cc98f6..d4ed8559b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -525,13 +525,13 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n             }\n \n-            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp);\n+            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp).mutate();\n             if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(255);\n+                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);\n             } else {\n-                whiteboardIcon.setAlpha(77);\n+                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.show_whiteboard);\n             }\n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex d4ed8559b..fe439beef 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -525,15 +544,28 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n             }\n \n+            menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n+            menu.findItem(R.id.action_change_whiteboard_pen_color).setVisible(true);\n+\n             Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp).mutate();\n+            Drawable whiteboardColorPaletteIcon = ContextCompat.getDrawable(this, R.drawable.ic_color_lens_white_24dp).mutate();\n+\n             if (mShowWhiteboard) {\n                 whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);\n+\n+                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n             } else {\n                 whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.show_whiteboard);\n+\n+                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+                menu.findItem(R.id.action_change_whiteboard_pen_color).setEnabled(false);\n+                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n+                colorPalette.setVisibility(View.GONE);\n             }\n         } else {\n             menu.findItem(R.id.action_enable_whiteboard).setTitle(R.string.enable_whiteboard);\n", "next_change": {"commit": "937d3027a35f3af8c478b2066c8f35d1627710ee", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex fe439beef..bb9623c9f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -568,7 +588,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 colorPalette.setVisibility(View.GONE);\n             }\n         } else {\n-            menu.findItem(R.id.action_enable_whiteboard).setTitle(R.string.enable_whiteboard);\n+            menu.findItem(R.id.action_toggle_whiteboard).setTitle(R.string.enable_whiteboard);\n         }\n         if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n             menu.findItem(R.id.action_open_deck_options).setVisible(false);\n", "next_change": {"commit": "5408ceaef7eef4db61b4064e5997099700913ed8", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex bb9623c9f..ceddfae16 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -572,23 +582,23 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n             if (mShowWhiteboard) {\n                 whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n-                menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);\n+                hide_whiteboard_icon.setIcon(whiteboardIcon);\n+                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n \n                 whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n+                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n             } else {\n                 whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n-                menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.show_whiteboard);\n+                hide_whiteboard_icon.setIcon(whiteboardIcon);\n+                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n \n                 whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setEnabled(false);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n+                change_pen_color_icon.setEnabled(false);\n+                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n                 colorPalette.setVisibility(View.GONE);\n             }\n         } else {\n-            menu.findItem(R.id.action_toggle_whiteboard).setTitle(R.string.enable_whiteboard);\n+            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n         }\n         if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n             menu.findItem(R.id.action_open_deck_options).setVisible(false);\n", "next_change": {"commit": "164200255997ac4750493118c24cec649191b630", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex ceddfae16..4e4d9ed2d 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -595,7 +661,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n                 change_pen_color_icon.setEnabled(false);\n                 change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                colorPalette.setVisibility(View.GONE);\n+                mColorPalette.setVisibility(View.GONE);\n             }\n         } else {\n             toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n", "next_change": {"commit": "a8f17f64771b79e8b83c8b1630f689594150d3e0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 4e4d9ed2d..26b70bfec 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -669,7 +718,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n         if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n             menu.findItem(R.id.action_open_deck_options).setVisible(false);\n         }\n-        if (mSpeakText && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n+        if (mTTS.isEnabled() && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n             menu.findItem(R.id.action_select_tts).setVisible(true);\n         }\n         // Setup bury / suspend providers\n", "next_change": {"commit": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\ndeleted file mode 100644\nindex 26b70bfec..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ /dev/null\n", "chunk": "@@ -1,1510 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\n-\n-package com.ichi2.anki;\n-\n-import android.Manifest;\n-import android.animation.Animator;\n-import android.animation.AnimatorListenerAdapter;\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.SharedPreferences;\n-import android.content.pm.PackageManager;\n-import android.content.res.ColorStateList;\n-import android.graphics.drawable.Drawable;\n-import android.os.Build;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.Message;\n-import android.text.SpannableString;\n-import android.text.style.UnderlineSpan;\n-import android.view.KeyEvent;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.SubMenu;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.webkit.WebView;\n-import android.webkit.JavascriptInterface;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-import android.widget.TextView;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.DrawableRes;\n-import androidx.annotation.IdRes;\n-import androidx.annotation.MenuRes;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.PluralsRes;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.appcompat.view.menu.MenuBuilder;\n-import androidx.appcompat.app.ActionBar;\n-import androidx.core.app.ActivityCompat;\n-import androidx.core.content.ContextCompat;\n-import androidx.core.content.res.ResourcesCompat;\n-import androidx.core.view.ActionProvider;\n-import androidx.core.view.MenuItemCompat;\n-import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;\n-\n-import com.ichi2.anki.cardviewer.CardAppearance;\n-import com.ichi2.anki.cardviewer.Gesture;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.multimediacard.AudioView;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.reviewer.AnswerButtons;\n-import com.ichi2.anki.reviewer.AutomaticAnswerAction;\n-import com.ichi2.anki.reviewer.FullScreenMode;\n-import com.ichi2.anki.reviewer.PeripheralKeymap;\n-import com.ichi2.anki.reviewer.ReviewerUi;\n-import com.ichi2.anki.servicelayer.SchedulerService;\n-import com.ichi2.anki.servicelayer.SchedulerService.NextCard;\n-import com.ichi2.anki.servicelayer.TaskListenerBuilder;\n-import com.ichi2.anki.workarounds.FirefoxSnackbarWorkaround;\n-import com.ichi2.anki.reviewer.ActionButtons;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.sched.Counts;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.utils.AndroidUiUtils;\n-import com.ichi2.utils.Computation;\n-import com.ichi2.utils.FunctionalInterfaces.Consumer;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.utils.ViewGroupUtils;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import kotlin.Unit;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.reviewer.CardMarker.*;\n-import static com.ichi2.anim.ActivityTransitionAnimation.Direction.*;\n-\n-\n-public class Reviewer extends AbstractFlashcardViewer {\n-    private boolean mHasDrawerSwipeConflicts = false;\n-    private boolean mShowWhiteboard = true;\n-    private boolean mPrefFullscreenReview = false;\n-    private static final int ADD_NOTE = 12;\n-    private static final int REQUEST_AUDIO_PERMISSION = 0;\n-    private LinearLayout mColorPalette;\n-\n-    // TODO: Consider extracting to ViewModel\n-    // Card counts\n-    private SpannableString mNewCount;\n-    private SpannableString mLrnCount;\n-    private SpannableString mRevCount;\n-\n-    private TextView mTextBarNew;\n-    private TextView mTextBarLearn;\n-    private TextView mTextBarReview;\n-\n-    private boolean mPrefHideDueCount;\n-\n-    // ETA\n-    private int mEta;\n-    private boolean mPrefShowETA;\n-\n-\n-    // Preferences from the collection\n-    private boolean mShowRemainingCardCount;\n-\n-    private final ActionButtons mActionButtons = new ActionButtons(this);\n-\n-\n-    @VisibleForTesting\n-    protected final PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n-    \n-    private final Onboarding.Reviewer mOnboarding = new Onboarding.Reviewer(this);\n-\n-    protected <T extends Computation<? extends NextCard<? extends Card[]>>> TaskListenerBuilder<Unit, T>\n-    scheduleCollectionTaskHandler(@PluralsRes int toastResourceId) {\n-        return nextCardHandler().alsoExecuteAfter(result -> {\n-            // BUG: If the method crashes, this will crash\n-            invalidateOptionsMenu();\n-            int cardCount = result.getValue().getResult().length;\n-            UIUtils.showThemedToast(this,\n-                    getResources().getQuantityString(toastResourceId, cardCount, cardCount), true);\n-        });\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        if (showedActivityFailedScreen(savedInstanceState)) {\n-            return;\n-        }\n-        Timber.d(\"onCreate()\");\n-        super.onCreate(savedInstanceState);\n-\n-        if (FirefoxSnackbarWorkaround.handledLaunchFromWebBrowser(getIntent(), this)) {\n-            this.setResult(RESULT_CANCELED);\n-            finishWithAnimation(END);\n-            return;\n-        }\n-\n-        if (Intent.ACTION_VIEW.equals(getIntent().getAction())) {\n-            Timber.d(\"onCreate() :: received Intent with action = %s\", getIntent().getAction());\n-            selectDeckFromExtra();\n-        }\n-\n-        mColorPalette = findViewById(R.id.whiteboard_editor);\n-\n-        startLoadingCollection();\n-    }\n-\n-\n-    @Override\n-    protected int getFlagToDisplay() {\n-        int actualValue = super.getFlagToDisplay();\n-        if (actualValue == FLAG_NONE) {\n-            return FLAG_NONE;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_FLAG);\n-        if (isShownInActionBar != null && isShownInActionBar) {\n-            return FLAG_NONE;\n-        }\n-        return actualValue;\n-    }\n-\n-\n-    @Override\n-    protected WebView createWebView() {\n-        WebView ret = super.createWebView();\n-        if (AndroidUiUtils.isRunningOnTv(this)) {\n-            ret.setFocusable(false);\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    protected void recreateWebView() {\n-        super.recreateWebView();\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-    @Override\n-    protected boolean shouldDisplayMark() {\n-        boolean markValue = super.shouldDisplayMark();\n-        if (!markValue) {\n-            return false;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_MARK);\n-        //If we don't know, show it.\n-        //Otherwise, if it's in the action bar, don't show it again.\n-        return isShownInActionBar == null || !isShownInActionBar;\n-    }\n-\n-    private void selectDeckFromExtra() {\n-        Bundle extras = getIntent().getExtras();\n-        if (extras == null || !extras.containsKey(\"deckId\")) {\n-            // deckId is not set, load default\n-            return;\n-        }\n-        long did = extras.getLong(\"deckId\", Long.MIN_VALUE);\n-\n-        Timber.d(\"selectDeckFromExtra() with deckId = %d\", did);\n-\n-        // Clear the undo history when selecting a new deck\n-        if (getCol().getDecks().selected() != did) {\n-            getCol().clearUndo();\n-        }\n-        // Select the deck\n-        getCol().getDecks().select(did);\n-        // Reset the schedule so that we get the counts for the currently selected deck\n-        getCol().getSched().deferReset();\n-    }\n-\n-    @Override\n-    protected void setTitle() {\n-        String title;\n-        if (colIsOpen()) {\n-            title = Decks.basename(getCol().getDecks().current().getString(\"name\"));\n-        } else {\n-            Timber.e(\"Could not set title in reviewer because collection closed\");\n-            title = \"\";\n-        }\n-        getSupportActionBar().setTitle(title);\n-        super.setTitle(title);\n-        getSupportActionBar().setSubtitle(\"\");\n-    }\n-\n-    @Override\n-    protected int getContentViewAttr(FullScreenMode fullscreenMode) {\n-        switch (fullscreenMode) {\n-            case BUTTONS_ONLY:\n-                return R.layout.reviewer_fullscreen;\n-            case FULLSCREEN_ALL_GONE:\n-                return R.layout.reviewer_fullscreen_noanswers;\n-            default:\n-                return R.layout.reviewer;\n-        }\n-    }\n-\n-    @Override\n-    protected boolean fitsSystemWindows() {\n-        return !getFullscreenMode().isFullScreenReview();\n-    }\n-\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        // Load the first card and start reviewing. Uses the answer card\n-        // task to load a card, but since we send null\n-        // as the card to answer, no card will be answered.\n-\n-        mPrefWhiteboard = MetaDB.getWhiteboardState(this, getParentDid());\n-        if (mPrefWhiteboard) {\n-            //DEFECT: Slight inefficiency here, as we set the database using these methods\n-            boolean whiteboardVisibility = MetaDB.getWhiteboardVisibility(this, getParentDid());\n-            setWhiteboardEnabledState(true);\n-            setWhiteboardVisibility(whiteboardVisibility);\n-        }\n-\n-        col.getSched().deferReset();     // Reset schedule in case card was previously loaded\n-        getCol().startTimebox();\n-        new SchedulerService.GetCard().runWithHandler(answerCardHandler(false));\n-\n-        disableDrawerSwipeOnConflicts();\n-        // Add a weak reference to current activity so that scheduler can talk to to Activity\n-        mSched.setContext(new WeakReference<>(this));\n-\n-        // Set full screen/immersive mode if needed\n-        if (mPrefFullscreenReview) {\n-            setFullScreen(this);\n-        }\n-\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        // 100ms was not enough on my device (Honor 9 Lite -  Android Pie)\n-        delayedHide(1000);\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-        int itemId = item.getItemId();\n-        if (itemId == android.R.id.home) {\n-            Timber.i(\"Reviewer:: Home button pressed\");\n-            closeReviewer(RESULT_OK, true);\n-        } else if (itemId == R.id.action_undo) {\n-            Timber.i(\"Reviewer:: Undo button pressed\");\n-            if (mShowWhiteboard && mWhiteboard != null && !mWhiteboard.undoEmpty()) {\n-                mWhiteboard.undo();\n-            } else {\n-                undo();\n-            }\n-        } else if (itemId == R.id.action_reset_card_progress) {\n-            Timber.i(\"Reviewer:: Reset progress button pressed\");\n-            showResetCardDialog();\n-        } else if (itemId == R.id.action_mark_card) {\n-            Timber.i(\"Reviewer:: Mark button pressed\");\n-            onMark(mCurrentCard);\n-        } else if (itemId == R.id.action_replay) {\n-            Timber.i(\"Reviewer:: Replay audio button pressed (from menu)\");\n-            playSounds(true);\n-        } else if (itemId == R.id.action_toggle_mic_tool_bar) {\n-            Timber.i(\"Reviewer:: Record mic\");\n-            // Check permission to record and request if not granted\n-            openOrToggleMicToolbar();\n-        } else if (itemId == R.id.action_tag) {\n-            Timber.i(\"Reviewer:: Tag button pressed\");\n-            showTagsDialog();\n-        } else if (itemId == R.id.action_edit) {\n-            Timber.i(\"Reviewer:: Edit note button pressed\");\n-            editCard();\n-            return true;\n-        } else if (itemId == R.id.action_bury) {\n-            Timber.i(\"Reviewer:: Bury button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Bury card due to no submenu\");\n-                buryCard();\n-            }\n-        } else if (itemId == R.id.action_suspend) {\n-            Timber.i(\"Reviewer:: Suspend button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Suspend card due to no submenu\");\n-                suspendCard();\n-            }\n-        } else if (itemId == R.id.action_delete) {\n-            Timber.i(\"Reviewer:: Delete note button pressed\");\n-            showDeleteNoteDialog();\n-        } else if (itemId == R.id.action_change_whiteboard_pen_color) {\n-            Timber.i(\"Reviewer:: Pen Color button pressed\");\n-            if (mColorPalette.getVisibility() == View.GONE) {\n-                mColorPalette.setVisibility(View.VISIBLE);\n-            } else {\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else if (itemId == R.id.action_save_whiteboard) {\n-            Timber.i(\"Reviewer:: Save whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                try {\n-                    String savedWhiteboardFileName = mWhiteboard.saveWhiteboard(getCol().getTime()).getPath();\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_saved, savedWhiteboardFileName), true);\n-                } catch (Exception e) {\n-                    Timber.w(e);\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_save_failed, e.getLocalizedMessage()), true);\n-                }\n-            }\n-        } else if (itemId == R.id.action_clear_whiteboard) {\n-            Timber.i(\"Reviewer:: Clear whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                mWhiteboard.clear();\n-            }\n-        } else if (itemId == R.id.action_hide_whiteboard) {// toggle whiteboard visibility\n-            Timber.i(\"Reviewer:: Whiteboard visibility set to %b\", !mShowWhiteboard);\n-            setWhiteboardVisibility(!mShowWhiteboard);\n-            refreshActionBar();\n-        } else if (itemId == R.id.action_toggle_whiteboard) {\n-            toggleWhiteboard();\n-        } else if (itemId == R.id.action_search_dictionary) {\n-            Timber.i(\"Reviewer:: Search dictionary button pressed\");\n-            lookUpOrSelectText();\n-        } else if (itemId == R.id.action_open_deck_options) {\n-            Intent i = new Intent(this, DeckOptions.class);\n-            startActivityForResultWithAnimation(i, DECK_OPTIONS, FADE);\n-        } else if (itemId == R.id.action_select_tts) {\n-            Timber.i(\"Reviewer:: Select TTS button pressed\");\n-            showSelectTtsDialogue();\n-        } else if (itemId == R.id.action_add_note_reviewer) {\n-            Timber.i(\"Reviewer:: Add note button pressed\");\n-            addNote();\n-        } else if (itemId == R.id.action_flag_zero) {\n-            Timber.i(\"Reviewer:: No flag\");\n-            onFlag(mCurrentCard, FLAG_NONE);\n-        } else if (itemId == R.id.action_flag_one) {\n-            Timber.i(\"Reviewer:: Flag one\");\n-            onFlag(mCurrentCard, FLAG_RED);\n-        } else if (itemId == R.id.action_flag_two) {\n-            Timber.i(\"Reviewer:: Flag two\");\n-            onFlag(mCurrentCard, FLAG_ORANGE);\n-        } else if (itemId == R.id.action_flag_three) {\n-            Timber.i(\"Reviewer:: Flag three\");\n-            onFlag(mCurrentCard, FLAG_GREEN);\n-        } else if (itemId == R.id.action_flag_four) {\n-            Timber.i(\"Reviewer:: Flag four\");\n-            onFlag(mCurrentCard, FLAG_BLUE);\n-        } else if (itemId == R.id.action_flag_five) {\n-            Timber.i(\"Reviewer:: Flag five\");\n-            onFlag(mCurrentCard, FLAG_PINK);\n-        } else if (itemId == R.id.action_flag_six) {\n-            Timber.i(\"Reviewer:: Flag six\");\n-            onFlag(mCurrentCard, FLAG_TURQUOISE);\n-        } else if (itemId == R.id.action_flag_seven) {\n-            Timber.i(\"Reviewer:: Flag seven\");\n-            onFlag(mCurrentCard, FLAG_PURPLE);\n-        } else if (itemId == R.id.action_card_info) {\n-            Timber.i(\"Card Viewer:: Card Info\");\n-            openCardInfo();\n-        } else {\n-            return super.onOptionsItemSelected(item);\n-        }\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void toggleWhiteboard() {\n-        mPrefWhiteboard = ! mPrefWhiteboard;\n-        Timber.i(\"Reviewer:: Whiteboard enabled state set to %b\", mPrefWhiteboard);\n-        //Even though the visibility is now stored in its own setting, we want it to be dependent\n-        //on the enabled status\n-        setWhiteboardEnabledState(mPrefWhiteboard);\n-        setWhiteboardVisibility(mPrefWhiteboard);\n-        if (!mPrefWhiteboard) {\n-            mColorPalette.setVisibility(View.GONE);\n-        }\n-        refreshActionBar();\n-    }\n-\n-\n-    @Override\n-    protected void replayVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        // COULD_BE_BETTER: this shows \"Failed\" if nothing was recorded\n-\n-        mMicToolBar.togglePlay();\n-    }\n-\n-\n-    @Override\n-    protected void recordVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        mMicToolBar.toggleRecord();\n-    }\n-\n-\n-    /**\n-     *\n-     * @return Whether the mic toolbar is usable\n-     */\n-    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n-    @VisibleForTesting\n-    public boolean openMicToolbar() {\n-        if (mMicToolBar == null || mMicToolBar.getVisibility() != View.VISIBLE) {\n-            openOrToggleMicToolbar();\n-        }\n-        return mMicToolBar != null;\n-    }\n-\n-\n-    protected void openOrToggleMicToolbar() {\n-        if (!Permissions.canRecordAudio(this)) {\n-            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.RECORD_AUDIO},\n-                    REQUEST_AUDIO_PERMISSION);\n-        } else {\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-\n-    private void toggleMicToolBar() {\n-        if (mMicToolBar != null) {\n-            // It exists swap visibility status\n-            if (mMicToolBar.getVisibility() != View.VISIBLE) {\n-                mMicToolBar.setVisibility(View.VISIBLE);\n-            } else {\n-                mMicToolBar.setVisibility(View.GONE);\n-            }\n-        } else {\n-            // Record mic tool bar does not exist yet\n-            mTempAudioPath = AudioView.generateTempAudioFile(this);\n-            if (mTempAudioPath == null) {\n-                return;\n-            }\n-            mMicToolBar = AudioView.createRecorderInstance(this, R.drawable.ic_play_arrow_white_24dp, R.drawable.ic_pause_white_24dp,\n-                        R.drawable.ic_stop_white_24dp, R.drawable.ic_rec, R.drawable.ic_rec_stop, mTempAudioPath);\n-            if (mMicToolBar == null) {\n-                mTempAudioPath = null;\n-                return;\n-            }\n-            FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-            mMicToolBar.setLayoutParams(lp2);\n-            LinearLayout micToolBarLayer = findViewById(R.id.mic_tool_bar_layer);\n-            micToolBarLayer.addView(mMicToolBar);\n-        }\n-    }\n-\n-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n-        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n-        if ((requestCode == REQUEST_AUDIO_PERMISSION) &&\n-                (permissions.length >= 1) && (grantResults[0] == PackageManager.PERMISSION_GRANTED)) {\n-            // Get get audio record permission, so we can create the record tool bar\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-    private void showRescheduleCardDialog() {\n-        Consumer<Integer> runnable = days -> {\n-            List<Long> cardIds = Collections.singletonList(mCurrentCard.getId());\n-            new SchedulerService.RescheduleCards(cardIds, days).runWithHandler(scheduleCollectionTaskHandler(R.plurals.reschedule_cards_dialog_acknowledge));\n-        };\n-        RescheduleDialog dialog = RescheduleDialog.rescheduleSingleCard(getResources(), mCurrentCard, runnable);\n-\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void showResetCardDialog() {\n-        // Show confirmation dialog before resetting card progress\n-        Timber.i(\"showResetCardDialog() Reset progress button pressed\");\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getResources().getString(R.string.reset_card_dialog_title);\n-        String message = getResources().getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"NoteEditor:: ResetProgress button pressed\");\n-            List<Long> cardIds = Collections.singletonList(mCurrentCard.getId());\n-            new SchedulerService.ResetCards(cardIds).runWithHandler(scheduleCollectionTaskHandler(R.plurals.reset_cards_dialog_acknowledge));\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void addNote() {\n-        Intent intent = new Intent(this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD);\n-        startActivityForResultWithAnimation(intent, ADD_NOTE, START);\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public boolean onMenuOpened(int featureId, Menu menu) {\n-        new Handler().post(() -> {\n-            for (int i = 0; i < menu.size(); i++) {\n-                MenuItem menuItem = menu.getItem(i);\n-                shouldUseDefaultColor(menuItem);\n-            }\n-        });\n-        return super.onMenuOpened(featureId, menu);\n-    }\n-\n-    /**\n-     * This Method changes the color of icon if user taps in overflow button.\n-     */\n-    private void shouldUseDefaultColor(MenuItem menuItem) {\n-        Drawable drawable = menuItem.getIcon();\n-\n-        if (drawable != null && !menuItem.hasSubMenu() && !isFlagResource(menuItem.getItemId())) {\n-            drawable.mutate();\n-            drawable.setTint(ResourcesCompat.getColor(getResources(), R.color.material_blue_600, null));\n-        }\n-    }\n-\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public void onPanelClosed(int featureId, @NonNull Menu menu) {\n-        new Handler().postDelayed(this::refreshActionBar, 100);\n-    }\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(Menu menu) {\n-        // NOTE: This is called every time a new question is shown via invalidate options menu\n-        getMenuInflater().inflate(R.menu.reviewer, menu);\n-\n-        displayIconsOnTv(menu);\n-        displayIcons(menu);\n-\n-        mActionButtons.setCustomButtonsStatus(menu);\n-        int alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem markCardIcon = menu.findItem(R.id.action_mark_card);\n-        if (mCurrentCard != null && mCurrentCard.note().hasTag(\"marked\")) {\n-            markCardIcon.setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white);\n-        } else {\n-            markCardIcon.setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_border_white);\n-        }\n-        markCardIcon.getIcon().mutate().setAlpha(alpha);\n-\n-        // 1643 - currently null on a TV\n-        @Nullable MenuItem flag_icon = menu.findItem(R.id.action_flag);\n-        if (flag_icon != null) {\n-            if (mCurrentCard != null) {\n-                switch (mCurrentCard.userFlag()) {\n-                    case 1:\n-                        flag_icon.setIcon(R.drawable.ic_flag_red);\n-                        break;\n-                    case 2:\n-                        flag_icon.setIcon(R.drawable.ic_flag_orange);\n-                        break;\n-                    case 3:\n-                        flag_icon.setIcon(R.drawable.ic_flag_green);\n-                        break;\n-                    case 4:\n-                        flag_icon.setIcon(R.drawable.ic_flag_blue);\n-                        break;\n-                    case 5:\n-                        flag_icon.setIcon(R.drawable.ic_flag_pink);\n-                        break;\n-                    case 6:\n-                        flag_icon.setIcon(R.drawable.ic_flag_turquoise);\n-                        break;\n-                    case 7:\n-                        flag_icon.setIcon(R.drawable.ic_flag_purple);\n-                        break;\n-                    default:\n-                        flag_icon.setIcon(R.drawable.ic_flag_transparent);\n-                        break;\n-                }\n-            }\n-            flag_icon.getIcon().mutate().setAlpha(alpha);\n-        }\n-\n-        // Undo button\n-        @DrawableRes int undoIconId;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n-            undoIconId = R.drawable.eraser;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n-        } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n-            undoIconId = R.drawable.ic_undo_white;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n-        }\n-        int alpha_undo = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem undoIcon = menu.findItem(R.id.action_undo);\n-        undoIcon.setIcon(undoIconId);\n-        undoIcon.setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n-        undoIcon.getActionView().setEnabled(undoEnabled);\n-        if (colIsOpen()) { // Required mostly because there are tests where `col` is null\n-            undoIcon.setTitle(getResources().getString(R.string.studyoptions_congrats_undo, getCol().undoName(getResources())));\n-        }\n-\n-        if (undoEnabled) {\n-            mOnboarding.onUndoButtonEnabled();\n-        }\n-\n-        MenuItem toggle_whiteboard_icon = menu.findItem(R.id.action_toggle_whiteboard);\n-        MenuItem hide_whiteboard_icon = menu.findItem(R.id.action_hide_whiteboard);\n-        MenuItem change_pen_color_icon = menu.findItem(R.id.action_change_whiteboard_pen_color);\n-        // White board button\n-        if (mPrefWhiteboard) {\n-            // Configure the whiteboard related items in the action bar\n-            toggle_whiteboard_icon.setTitle(R.string.disable_whiteboard);\n-            // Always allow \"Disable Whiteboard\", even if \"Enable Whiteboard\" is disabled\n-            toggle_whiteboard_icon.setVisible(true);\n-\n-            if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n-                hide_whiteboard_icon.setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().saveWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().whiteboardPenColorIsDisabled()) {\n-                change_pen_color_icon.setVisible(true);\n-            }\n-\n-            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white).mutate();\n-            Drawable whiteboardColorPaletteIcon = VectorDrawableCompat.create(getResources(), R.drawable.ic_color_lens_white_24dp, null).mutate();\n-\n-            if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-            } else {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                change_pen_color_icon.setEnabled(false);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else {\n-            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n-        }\n-        if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n-            menu.findItem(R.id.action_open_deck_options).setVisible(false);\n-        }\n-        if (mTTS.isEnabled() && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n-            menu.findItem(R.id.action_select_tts).setVisible(true);\n-        }\n-        // Setup bury / suspend providers\n-        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n-        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n-\n-        setupSubMenu(menu, R.id.action_suspend, new SuspendProvider(this));\n-        setupSubMenu(menu, R.id.action_bury, new BuryProvider(this));\n-        if (suspendNoteAvailable()) {\n-            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n-            suspend_icon.setTitle(R.string.menu_suspend);\n-        } else {\n-            suspend_icon.setIcon(R.drawable.ic_pause_circle_outline);\n-            suspend_icon.setTitle(R.string.menu_suspend_card);\n-        }\n-        if (buryNoteAvailable()) {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_dropdown);\n-            bury_icon.setTitle(R.string.menu_bury);\n-        } else {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_white);\n-            bury_icon.setTitle(R.string.menu_bury_card);\n-        }\n-        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        bury_icon.getIcon().mutate().setAlpha(alpha);\n-        suspend_icon.getIcon().mutate().setAlpha(alpha);\n-\n-        setupSubMenu(menu, R.id.action_schedule, new ScheduleProvider(this));\n-        mOnboarding.onCreate();\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\")\n-    private void displayIcons(Menu menu) {\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-        }catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons in Over flow menu\");\n-        }\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\") // setOptionalIconsVisible\n-    private void displayIconsOnTv(Menu menu) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return;\n-        }\n-\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-\n-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-                for (int i = 0; i < menu.size(); i++) {\n-                    MenuItem m = menu.getItem(i);\n-\n-                    if (m == null || isFlagResource(m.getItemId())) {\n-                        continue;\n-                    }\n-\n-                    int color = Themes.getColorFromAttr(this, R.attr.navDrawerItemColor);\n-                    MenuItemCompat.setIconTintList(m, ColorStateList.valueOf(color));\n-                }\n-            }\n-\n-        } catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons\");\n-        }\n-    }\n-\n-\n-    private boolean isFlagResource(int itemId) {\n-        return itemId == R.id.action_flag_seven\n-                || itemId == R.id.action_flag_six\n-                || itemId == R.id.action_flag_five\n-                || itemId == R.id.action_flag_four\n-                || itemId == R.id.action_flag_three\n-                || itemId == R.id.action_flag_two\n-                || itemId == R.id.action_flag_one;\n-    }\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyDown(keyCode, event);\n-        }\n-\n-        if (mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event)) {\n-            return true;\n-        }\n-\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return false;\n-        }\n-\n-        // Process DPAD Up/Down to focus the TV Controls\n-        if (keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_DPAD_UP) {\n-            return false;\n-        }\n-\n-        // HACK: This shouldn't be required, as the navigation should handle this.\n-        if (isDrawerOpen()) {\n-            return false;\n-        }\n-\n-\n-        View view = keyCode == KeyEvent.KEYCODE_DPAD_UP ? findViewById(R.id.tv_nav_view) : findViewById(R.id.answer_options_layout);\n-        // HACK: We should be performing this in the base class, or allowing the view to be focused by the keyboard.\n-        // I couldn't get either to work\n-        if (view == null) {\n-            return false;\n-        }\n-\n-        view.requestFocus();\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (mProcessor.onKeyUp(keyCode, event)) {\n-            return true;\n-        }\n-        return super.onKeyUp(keyCode, event);\n-    }\n-\n-\n-    private <T extends ActionProvider & SubMenuProvider> void setupSubMenu(Menu menu, @IdRes int parentMenu, T subMenuProvider) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            MenuItemCompat.setActionProvider(menu.findItem(parentMenu), subMenuProvider);\n-            return;\n-        }\n-\n-        // Don't do anything if the menu is hidden (bury for example)\n-        if (!subMenuProvider.hasSubMenu()) {\n-            return;\n-        }\n-\n-        // 7227 - If we're running on a TV, then we can't show submenus until AOSP is fixed\n-        menu.removeItem(parentMenu);\n-        int count = menu.size();\n-        // move the menu to the bottom of the page\n-        getMenuInflater().inflate(subMenuProvider.getSubMenu(), menu);\n-        for (int i = 0; i < menu.size() - count; i++) {\n-            MenuItem item = menu.getItem(count + i);\n-            item.setOnMenuItemClickListener(subMenuProvider);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected boolean canAccessScheduler() {\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void performReload() {\n-        getCol().getSched().deferReset();\n-        new SchedulerService.GetCard().runWithHandler(answerCardHandler(false));\n-    }\n-\n-\n-    @Override\n-    protected void displayAnswerBottomBar() {\n-        super.displayAnswerBottomBar();\n-        mOnboarding.onAnswerShown();\n-        int buttonCount;\n-        try {\n-            buttonCount = getButtonCount();\n-        } catch (RuntimeException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"AbstractReviewer-showEaseButtons\");\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, true);\n-            return;\n-        }\n-\n-        // Set correct label and background resource for each button\n-        // Note that it's necessary to set the resource dynamically as the ease2 / ease3 buttons\n-        // (which libanki expects ease to be 2 and 3) can either be hard, good, or easy - depending on num buttons shown\n-        final int[] background = AnswerButtons.getBackgroundColors(this);\n-        final int[] textColor = AnswerButtons.getTextColors(this);\n-        mEase1Layout.setVisibility(View.VISIBLE);\n-        mEase1Layout.setBackgroundResource(background[0]);\n-        mEase4Layout.setBackgroundResource(background[3]);\n-        switch (buttonCount) {\n-            case 2:\n-                // Ease 2 is \"good\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            case 3:\n-                // Ease 2 is good\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                // Ease 3 is easy\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[3]);\n-                mEase3.setText(R.string.ease_button_easy);\n-                mEase3.setTextColor(textColor[3]);\n-                mNext3.setTextColor(textColor[3]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            default:\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                // Ease 2 is \"hard\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[1]);\n-                mEase2.setText(R.string.ease_button_hard);\n-                mEase2.setTextColor(textColor[1]);\n-                mNext2.setTextColor(textColor[1]);\n-                mEase2Layout.requestFocus();\n-                // Ease 3 is good\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[2]);\n-                mEase3.setText(R.string.ease_button_good);\n-                mEase3.setTextColor(textColor[2]);\n-                mNext3.setTextColor(textColor[2]);\n-                mEase4Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.requestFocus();\n-                break;\n-        }\n-\n-        // Show next review time\n-        if (shouldShowNextReviewTime()) {\n-            mNext1.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_ONE));\n-            mNext2.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_TWO));\n-            if (buttonCount > 2) {\n-                mNext3.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_THREE));\n-            }\n-            if (buttonCount > 3) {\n-                mNext4.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_FOUR));\n-            }\n-        }\n-    }\n-\n-    public int getButtonCount() {\n-        return mSched.answerButtons(mCurrentCard);\n-    }\n-\n-\n-    @Override\n-    public void automaticShowQuestion(@NonNull AutomaticAnswerAction action) {\n-        // explicitly do not call super\n-        if (mEase1Layout.isEnabled() && mEase1Layout.getVisibility() == View.VISIBLE) {\n-            action.execute(this);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected SharedPreferences restorePreferences() {\n-        SharedPreferences preferences = super.restorePreferences();\n-        mPrefHideDueCount = preferences.getBoolean(\"hideDueCount\", false);\n-        mPrefShowETA = preferences.getBoolean(\"showETA\", true);\n-        this.mProcessor.setup();\n-        mPrefFullscreenReview = FullScreenMode.isFullScreenReview(preferences);\n-        mActionButtons.setup(preferences);\n-        return preferences;\n-    }\n-\n-    @Override\n-    protected void updateActionBar() {\n-        super.updateActionBar();\n-        updateScreenCounts();\n-    }\n-\n-    protected void updateScreenCounts() {\n-        if (mCurrentCard == null) return;\n-        super.updateActionBar();\n-        ActionBar actionBar = getSupportActionBar();\n-        Counts counts = mSched.counts(mCurrentCard);\n-\n-        if (actionBar != null) {\n-            if (mPrefShowETA) {\n-                mEta = mSched.eta(counts, false);\n-                actionBar.setSubtitle(Utils.remainingTime(AnkiDroidApp.getInstance(), mEta * 60));\n-            }\n-        }\n-\n-\n-        mNewCount = new SpannableString(String.valueOf(counts.getNew()));\n-        mLrnCount = new SpannableString(String.valueOf(counts.getLrn()));\n-        mRevCount = new SpannableString(String.valueOf(counts.getRev()));\n-        if (mPrefHideDueCount) {\n-            mRevCount = new SpannableString(\"???\");\n-        }\n-\n-        switch (mSched.countIdx(mCurrentCard)) {\n-            case NEW:\n-                mNewCount.setSpan(new UnderlineSpan(), 0, mNewCount.length(), 0);\n-                break;\n-            case LRN:\n-                mLrnCount.setSpan(new UnderlineSpan(), 0, mLrnCount.length(), 0);\n-                break;\n-            case REV:\n-                mRevCount.setSpan(new UnderlineSpan(), 0, mRevCount.length(), 0);\n-                break;\n-            default:\n-                Timber.w(\"Unknown card type %s\", mSched.countIdx(mCurrentCard));\n-                break;\n-        }\n-\n-        mTextBarNew.setText(mNewCount);\n-        mTextBarLearn.setText(mLrnCount);\n-        mTextBarReview.setText(mRevCount);\n-    }\n-\n-    @Override\n-    public void fillFlashcard() {\n-        super.fillFlashcard();\n-        if (!sDisplayAnswer && mShowWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.clear();\n-        }\n-    }\n-\n-\n-    @Override\n-    public void displayCardQuestion() {\n-        // show timer, if activated in the deck's preferences\n-        initTimer();\n-        delayedHide(100);\n-        super.displayCardQuestion();\n-    }\n-\n-    @Override\n-    protected void displayCardAnswer() {\n-        delayedHide(100);\n-        super.displayCardAnswer();\n-    }\n-\n-    @Override\n-    protected void initLayout() {\n-        mTextBarNew = findViewById(R.id.new_number);\n-        mTextBarLearn = findViewById(R.id.learn_number);\n-        mTextBarReview = findViewById(R.id.review_number);\n-\n-        super.initLayout();\n-\n-        if (!mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.GONE);\n-            mTextBarLearn.setVisibility(View.GONE);\n-            mTextBarReview.setVisibility(View.GONE);\n-        }\n-    }\n-\n-    @Override\n-    protected void switchTopBarVisibility(int visible) {\n-        super.switchTopBarVisibility(visible);\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(visible);\n-            mTextBarLearn.setVisibility(visible);\n-            mTextBarReview.setVisibility(visible);\n-        }\n-    }\n-\n-    @Override\n-    protected void onStop() {\n-        super.onStop();\n-\n-        if (!isFinishing() && colIsOpen() && mSched != null) {\n-            WidgetStatus.update(this);\n-        }\n-        UIUtils.saveCollectionInBackground();\n-    }\n-\n-\n-    @Override\n-    protected void initControls() {\n-        super.initControls();\n-        if (mPrefWhiteboard) {\n-            setWhiteboardVisibility(mShowWhiteboard);\n-        }\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.VISIBLE);\n-            mTextBarLearn.setVisibility(View.VISIBLE);\n-            mTextBarReview.setVisibility(View.VISIBLE);\n-        }\n-    }\n-\n-    protected void restoreCollectionPreferences(Collection col) {\n-        super.restoreCollectionPreferences(col);\n-        mShowRemainingCardCount = col.get_config_boolean(\"dueCounts\");\n-    }\n-\n-    @Override\n-    protected boolean onSingleTap() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    protected void onFling() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    protected final Handler mFullScreenHandler = new Handler() {\n-        @Override\n-        public void handleMessage(Message msg) {\n-            if (mPrefFullscreenReview) {\n-                setFullScreen(Reviewer.this);\n-            }\n-        }\n-    };\n-\n-    /** Hide the navigation if in full-screen mode after a given period of time */\n-    protected void delayedHide(int delayMillis) {\n-        Timber.d(\"Fullscreen delayed hide in %dms\", delayMillis);\n-        mFullScreenHandler.removeMessages(0);\n-        mFullScreenHandler.sendEmptyMessageDelayed(0, delayMillis);\n-    }\n-\n-\n-    private void setWhiteboardEnabledState(boolean state) {\n-        mPrefWhiteboard = state;\n-        MetaDB.storeWhiteboardState(this, getParentDid(), state);\n-        if (state && mWhiteboard == null) {\n-            createWhiteboard();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private void setFullScreen(final AbstractFlashcardViewer a) {\n-        // Set appropriate flags to enable Sticky Immersive mode.\n-        a.getWindow().getDecorView().setSystemUiVisibility(\n-                View.SYSTEM_UI_FLAG_LAYOUT_STABLE\n-                        //| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION // temporarily disabled due to #5245\n-                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\n-                        | View.SYSTEM_UI_FLAG_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_LOW_PROFILE\n-                        | View.SYSTEM_UI_FLAG_IMMERSIVE\n-        );\n-        // Show / hide the Action bar together with the status bar\n-        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(a);\n-        FullScreenMode fullscreenMode = FullScreenMode.fromPreference(prefs);\n-        a.getWindow().setStatusBarColor(Themes.getColorFromAttr(a, R.attr.colorPrimaryDark));\n-        View decorView = a.getWindow().getDecorView();\n-        decorView.setOnSystemUiVisibilityChangeListener\n-                (flags -> {\n-                    final View toolbar = a.findViewById(R.id.toolbar);\n-                    final View answerButtons = a.findViewById(R.id.answer_options_layout);\n-                    final View topbar = a.findViewById(R.id.top_bar);\n-                    if (toolbar == null || topbar == null || answerButtons == null) {\n-                        return;\n-                    }\n-                    // Note that system bars will only be \"visible\" if none of the\n-                    // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set.\n-                    boolean visible = (flags & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-                    Timber.d(\"System UI visibility change. Visible: %b\", visible);\n-                    if (visible) {\n-                        showViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            showViewWithAnimation(topbar);\n-                            showViewWithAnimation(answerButtons);\n-                        }\n-                    } else {\n-                        hideViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            hideViewWithAnimation(topbar);\n-                            hideViewWithAnimation(answerButtons);\n-                        }\n-                    }\n-                });\n-    }\n-\n-    private static final int ANIMATION_DURATION = 200;\n-    private static final float TRANSPARENCY = 0.90f;\n-\n-\n-    private void showViewWithAnimation(final View view) {\n-        view.setAlpha(0.0f);\n-        view.setVisibility(View.VISIBLE);\n-        view.animate().alpha(TRANSPARENCY).setDuration(ANIMATION_DURATION).setListener(null);\n-    }\n-\n-    private void hideViewWithAnimation(final View view) {\n-        view.animate()\n-                .alpha(0f)\n-                .setDuration(ANIMATION_DURATION)\n-                .setListener(new AnimatorListenerAdapter() {\n-                    @Override\n-                    public void onAnimationEnd(Animator animation) {\n-                        view.setVisibility(View.GONE);\n-                    }\n-                });\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private boolean isImmersiveSystemUiVisible(AnkiActivity activity) {\n-        return (activity.getWindow().getDecorView().getSystemUiVisibility() & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-    }\n-\n-    private void createWhiteboard() {\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(this);\n-        mWhiteboard = Whiteboard.createInstance(this, true, this);\n-\n-        // We use the pen color of the selected deck at the time the whiteboard is enabled.\n-        // This is how all other whiteboard settings are\n-        Integer whiteboardPenColor = MetaDB.getWhiteboardPenColor(this, getParentDid()).fromPreferences(sharedPrefs);\n-        if (whiteboardPenColor != null) {\n-            mWhiteboard.setPenColor(whiteboardPenColor);\n-        }\n-\n-        mWhiteboard.setOnPaintColorChangeListener(color -> MetaDB.storeWhiteboardPenColor(this, getParentDid(), !CardAppearance.isInNightMode(sharedPrefs), color));\n-\n-        mWhiteboard.setOnTouchListener((v, event) -> {\n-            //If the whiteboard is currently drawing, and triggers the system UI to show, we want to continue drawing.\n-            if (!mWhiteboard.isCurrentlyDrawing() && (!mShowWhiteboard || (mPrefFullscreenReview\n-                    && isImmersiveSystemUiVisible(Reviewer.this)))) {\n-                // Bypass whiteboard listener when it's hidden or fullscreen immersive mode is temporarily suspended\n-                v.performClick();\n-                return getGestureDetector().onTouchEvent(event);\n-            }\n-            return mWhiteboard.handleTouchEvent(event);\n-        });\n-    }\n-\n-    // Show or hide the whiteboard\n-    private void setWhiteboardVisibility(boolean state) {\n-        mShowWhiteboard = state;\n-        MetaDB.storeWhiteboardVisibility(this, getParentDid(), state);\n-        if (state) {\n-            mWhiteboard.setVisibility(View.VISIBLE);\n-            disableDrawerSwipe();\n-        } else {\n-            mWhiteboard.setVisibility(View.GONE);\n-            if (!mHasDrawerSwipeConflicts) {\n-                enableDrawerSwipe();\n-            }\n-        }\n-    }\n-\n-\n-    private void disableDrawerSwipeOnConflicts() {\n-        if (mGestureProcessor.isBound(Gesture.SWIPE_UP, Gesture.SWIPE_DOWN, Gesture.SWIPE_RIGHT)) {\n-            mHasDrawerSwipeConflicts = true;\n-            super.disableDrawerSwipe();\n-        }\n-    }\n-\n-\n-    @Override\n-    protected Long getCurrentCardId() {\n-        return mCurrentCard.getId();\n-    }\n-\n-\n-    @Override\n-    public void onWindowFocusChanged(boolean hasFocus) {\n-        super.onWindowFocusChanged(hasFocus);\n-        // Restore full screen once we regain focus\n-        if (hasFocus) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        } else {\n-            mFullScreenHandler.removeMessages(0);\n-        }\n-    }\n-\n-\n-    /**\n-     * Whether or not dismiss note is available for current card and specified DismissType\n-     * @return true if there is another card of same note that could be dismissed\n-     */\n-    private boolean suspendNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // whether there exists a sibling not buried.\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue != \" + Consts.QUEUE_TYPE_SUSPENDED + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-    private boolean buryNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // Whether there exists a sibling which is neither susbended nor buried\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue >=  \" + Consts.QUEUE_TYPE_NEW + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    @CheckResult\n-    Whiteboard getWhiteboard() {\n-        return mWhiteboard;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public AudioView getAudioView() {\n-        return mMicToolBar;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public boolean hasDrawerSwipeConflicts() {\n-        return mHasDrawerSwipeConflicts;\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Suspend button\n-     */\n-    class SuspendProvider extends ActionProvider implements SubMenuProvider {\n-        public SuspendProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;  // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_suspend;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return suspendNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_suspend_card) {\n-                return suspendCard();\n-            } else if (itemId == R.id.action_suspend_note) {\n-                return suspendNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Bury button\n-     */\n-    class BuryProvider extends ActionProvider implements SubMenuProvider {\n-        public BuryProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_bury;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return buryNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_bury_card) {\n-                return buryCard();\n-            } else if (itemId == R.id.action_bury_note) {\n-                return buryNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-\n-    /**\n-     * Inner class which implements the submenu for the Schedule button\n-     */\n-    class ScheduleProvider extends ActionProvider implements SubMenuProvider {\n-        public ScheduleProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_reschedule_card) {\n-                showRescheduleCardDialog();\n-                return true;\n-            } else if (itemId == R.id.action_reset_card_progress) {\n-                showResetCardDialog();\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_schedule;\n-        }\n-    }\n-\n-    private interface SubMenuProvider extends MenuItem.OnMenuItemClickListener {\n-        @MenuRes int getSubMenu();\n-        boolean hasSubMenu();\n-    }\n-\n-    public ReviewerJavaScriptFunction javaScriptFunction() {\n-        return new ReviewerJavaScriptFunction();\n-    }\n-\n-    public class ReviewerJavaScriptFunction extends JavaScriptFunction {\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetNewCardCount() {\n-            return mNewCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetLrnCardCount() {\n-            return mLrnCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetRevCardCount() {\n-            return mRevCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public int ankiGetETA() {\n-            return mEta;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex bb9623c9f..ceddfae16 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -597,22 +607,28 @@ public class Reviewer extends AbstractFlashcardViewer {\n             menu.findItem(R.id.action_select_tts).setVisible(true);\n         }\n         // Setup bury / suspend providers\n-        MenuItemCompat.setActionProvider(menu.findItem(R.id.action_suspend), new SuspendProvider(this));\n-        MenuItemCompat.setActionProvider(menu.findItem(R.id.action_bury), new BuryProvider(this));\n+        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n+        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n+        MenuItemCompat.setActionProvider(suspend_icon, new SuspendProvider(this));\n+        MenuItemCompat.setActionProvider(bury_icon, new BuryProvider(this));\n         if (suspendNoteAvailable()) {\n-            menu.findItem(R.id.action_suspend).setIcon(R.drawable.ic_action_suspend_dropdown);\n-            menu.findItem(R.id.action_suspend).setTitle(R.string.menu_suspend);\n+            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n+            suspend_icon.setTitle(R.string.menu_suspend);\n         } else {\n-            menu.findItem(R.id.action_suspend).setIcon(R.drawable.ic_action_suspend);\n-            menu.findItem(R.id.action_suspend).setTitle(R.string.menu_suspend_card);\n+            suspend_icon.setIcon(R.drawable.ic_action_suspend);\n+            suspend_icon.setTitle(R.string.menu_suspend_card);\n         }\n         if (buryNoteAvailable()) {\n-            menu.findItem(R.id.action_bury).setIcon(R.drawable.ic_flip_to_back_white_24px_dropdown);\n-            menu.findItem(R.id.action_bury).setTitle(R.string.menu_bury);\n+            bury_icon.setIcon(R.drawable.ic_flip_to_back_white_24px_dropdown);\n+            bury_icon.setTitle(R.string.menu_bury);\n         } else {\n-            menu.findItem(R.id.action_bury).setIcon(R.drawable.ic_flip_to_back_white_24dp);\n-            menu.findItem(R.id.action_bury).setTitle(R.string.menu_bury_card);\n+            bury_icon.setIcon(R.drawable.ic_flip_to_back_white_24dp);\n+            bury_icon.setTitle(R.string.menu_bury_card);\n         }\n+        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n+        bury_icon.getIcon().mutate().setAlpha(alpha);\n+        suspend_icon.getIcon().mutate().setAlpha(alpha);\n+\n         MenuItemCompat.setActionProvider(menu.findItem(R.id.action_schedule), new ScheduleProvider(this));\n         return super.onCreateOptionsMenu(menu);\n     }\n", "next_change": {"commit": "3763d6d0bc27900a9aa808f4b7fc3b3e68053d74", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex ceddfae16..7aa368970 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -636,7 +677,34 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n     @Override\n     public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        return mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event);\n+        if (mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event)) {\n+            return true;\n+        }\n+\n+        if (!AndroidUiUtils.isRunningOnTv(this)) {\n+            return false;\n+        }\n+\n+        // Process DPAD Up/Down to focus the TV Controls\n+        if (keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_DPAD_UP) {\n+            return false;\n+        }\n+\n+        // HACK: This shouldn't be required, as the navigation should handle this.\n+        if (isDrawerOpen()) {\n+            return false;\n+        }\n+\n+\n+        View view = keyCode == KeyEvent.KEYCODE_DPAD_UP ? findViewById(R.id.tv_nav_view) : findViewById(R.id.answer_options_layout);\n+        // HACK: We should be performing this in the base class, or allowing the view to be focused by the keyboard.\n+        // I couldn't get either to work\n+        if (view == null) {\n+            return false;\n+        }\n+\n+        view.requestFocus();\n+        return true;\n     }\n \n     @Override\n", "next_change": {"commit": "65ce8b1286f936f3d1d106b68463dfa384918a3e", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 7aa368970..0bf053673 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -709,9 +845,6 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n     @Override\n     public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyUp(keyCode, event);\n-        }\n         if (mProcessor.onKeyUp(keyCode, event)) {\n             return true;\n         }\n", "next_change": {"commit": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\ndeleted file mode 100644\nindex 0bf053673..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ /dev/null\n", "chunk": "@@ -1,1517 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\n-\n-package com.ichi2.anki;\n-\n-import android.Manifest;\n-import android.animation.Animator;\n-import android.animation.AnimatorListenerAdapter;\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.SharedPreferences;\n-import android.content.pm.PackageManager;\n-import android.content.res.ColorStateList;\n-import android.graphics.drawable.Drawable;\n-import android.os.Build;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.Message;\n-import android.text.SpannableString;\n-import android.text.style.UnderlineSpan;\n-import android.view.KeyEvent;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.SubMenu;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.webkit.WebView;\n-import android.webkit.JavascriptInterface;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-import android.widget.TextView;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.DrawableRes;\n-import androidx.annotation.IdRes;\n-import androidx.annotation.MenuRes;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.PluralsRes;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.appcompat.view.menu.MenuBuilder;\n-import androidx.appcompat.app.ActionBar;\n-import androidx.core.app.ActivityCompat;\n-import androidx.core.content.ContextCompat;\n-import androidx.core.content.res.ResourcesCompat;\n-import androidx.core.view.ActionProvider;\n-import androidx.core.view.MenuItemCompat;\n-import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;\n-\n-import com.ichi2.anki.cardviewer.CardAppearance;\n-import com.ichi2.anki.cardviewer.Gesture;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.multimediacard.AudioView;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.reviewer.FullScreenMode;\n-import com.ichi2.anki.reviewer.PeripheralKeymap;\n-import com.ichi2.anki.reviewer.ReviewerUi;\n-import com.ichi2.anki.workarounds.FirefoxSnackbarWorkaround;\n-import com.ichi2.anki.reviewer.ActionButtons;\n-import com.ichi2.async.CollectionTask;\n-import com.ichi2.async.TaskManager;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.sched.Counts;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.utils.AndroidUiUtils;\n-import com.ichi2.utils.FunctionalInterfaces.Consumer;\n-import com.ichi2.utils.Computation;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.utils.ViewGroupUtils;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Collections;\n-\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.reviewer.CardMarker.*;\n-import static com.ichi2.anim.ActivityTransitionAnimation.Direction.*;\n-\n-\n-public class Reviewer extends AbstractFlashcardViewer {\n-    private boolean mHasDrawerSwipeConflicts = false;\n-    private boolean mShowWhiteboard = true;\n-    private boolean mPrefFullscreenReview = false;\n-    private static final int ADD_NOTE = 12;\n-    private static final int REQUEST_AUDIO_PERMISSION = 0;\n-    private LinearLayout mColorPalette;\n-\n-    // TODO: Consider extracting to ViewModel\n-    // Card counts\n-    private SpannableString mNewCount;\n-    private SpannableString mLrnCount;\n-    private SpannableString mRevCount;\n-\n-    private TextView mTextBarNew;\n-    private TextView mTextBarLearn;\n-    private TextView mTextBarReview;\n-\n-    private boolean mPrefHideDueCount;\n-\n-    // ETA\n-    private int mEta;\n-    private boolean mPrefShowETA;\n-\n-\n-    // Preferences from the collection\n-    private boolean mShowRemainingCardCount;\n-\n-    private final ActionButtons mActionButtons = new ActionButtons(this);\n-\n-\n-    @VisibleForTesting\n-    protected final PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n-    \n-    private final Onboarding.Reviewer mOnboarding = new Onboarding.Reviewer(this);\n-\n-    /** We need to listen for and handle reschedules / resets very similarly */\n-    class ScheduleCollectionTaskListener extends NextCardHandler<Computation<Card[]>> {\n-\n-        private final @PluralsRes int mToastResourceId;\n-\n-\n-        protected ScheduleCollectionTaskListener(@PluralsRes int toastResourceId) {\n-            mToastResourceId = toastResourceId;\n-        }\n-\n-\n-        @Override\n-        public void onPostExecute(Computation<Card[]> result) {\n-            super.onPostExecute(result);\n-            invalidateOptionsMenu();\n-            int cardCount = result.getValue().length;\n-            UIUtils.showThemedToast(Reviewer.this,\n-                    getResources().getQuantityString(mToastResourceId, cardCount, cardCount), true);\n-        }\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        if (showedActivityFailedScreen(savedInstanceState)) {\n-            return;\n-        }\n-        Timber.d(\"onCreate()\");\n-        super.onCreate(savedInstanceState);\n-\n-        if (FirefoxSnackbarWorkaround.handledLaunchFromWebBrowser(getIntent(), this)) {\n-            this.setResult(RESULT_CANCELED);\n-            finishWithAnimation(END);\n-            return;\n-        }\n-\n-        if (Intent.ACTION_VIEW.equals(getIntent().getAction())) {\n-            Timber.d(\"onCreate() :: received Intent with action = %s\", getIntent().getAction());\n-            selectDeckFromExtra();\n-        }\n-\n-        mColorPalette = findViewById(R.id.whiteboard_editor);\n-\n-        startLoadingCollection();\n-    }\n-\n-\n-    @Override\n-    protected int getFlagToDisplay() {\n-        int actualValue = super.getFlagToDisplay();\n-        if (actualValue == FLAG_NONE) {\n-            return FLAG_NONE;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_FLAG);\n-        if (isShownInActionBar != null && isShownInActionBar) {\n-            return FLAG_NONE;\n-        }\n-        return actualValue;\n-    }\n-\n-\n-    @Override\n-    protected WebView createWebView() {\n-        WebView ret = super.createWebView();\n-        if (AndroidUiUtils.isRunningOnTv(this)) {\n-            ret.setFocusable(false);\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    protected void recreateWebView() {\n-        super.recreateWebView();\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-    @Override\n-    protected boolean shouldDisplayMark() {\n-        boolean markValue = super.shouldDisplayMark();\n-        if (!markValue) {\n-            return false;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_MARK);\n-        //If we don't know, show it.\n-        //Otherwise, if it's in the action bar, don't show it again.\n-        return isShownInActionBar == null || !isShownInActionBar;\n-    }\n-\n-    private void selectDeckFromExtra() {\n-        Bundle extras = getIntent().getExtras();\n-        if (extras == null || !extras.containsKey(\"deckId\")) {\n-            // deckId is not set, load default\n-            return;\n-        }\n-        long did = extras.getLong(\"deckId\", Long.MIN_VALUE);\n-\n-        Timber.d(\"selectDeckFromExtra() with deckId = %d\", did);\n-\n-        // Clear the undo history when selecting a new deck\n-        if (getCol().getDecks().selected() != did) {\n-            getCol().clearUndo();\n-        }\n-        // Select the deck\n-        getCol().getDecks().select(did);\n-        // Reset the schedule so that we get the counts for the currently selected deck\n-        getCol().getSched().deferReset();\n-    }\n-\n-    @Override\n-    protected void setTitle() {\n-        String title;\n-        if (colIsOpen()) {\n-            title = Decks.basename(getCol().getDecks().current().getString(\"name\"));\n-        } else {\n-            Timber.e(\"Could not set title in reviewer because collection closed\");\n-            title = \"\";\n-        }\n-        getSupportActionBar().setTitle(title);\n-        super.setTitle(title);\n-        getSupportActionBar().setSubtitle(\"\");\n-    }\n-\n-    @Override\n-    protected int getContentViewAttr(FullScreenMode fullscreenMode) {\n-        switch (fullscreenMode) {\n-            case BUTTONS_ONLY:\n-                return R.layout.reviewer_fullscreen;\n-            case FULLSCREEN_ALL_GONE:\n-                return R.layout.reviewer_fullscreen_noanswers;\n-            default:\n-                return R.layout.reviewer;\n-        }\n-    }\n-\n-    @Override\n-    protected boolean fitsSystemWindows() {\n-        return !getFullscreenMode().isFullScreenReview();\n-    }\n-\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        // Load the first card and start reviewing. Uses the answer card\n-        // task to load a card, but since we send null\n-        // as the card to answer, no card will be answered.\n-\n-        mPrefWhiteboard = MetaDB.getWhiteboardState(this, getParentDid());\n-        if (mPrefWhiteboard) {\n-            //DEFECT: Slight inefficiency here, as we set the database using these methods\n-            boolean whiteboardVisibility = MetaDB.getWhiteboardVisibility(this, getParentDid());\n-            setWhiteboardEnabledState(true);\n-            setWhiteboardVisibility(whiteboardVisibility);\n-        }\n-\n-        col.getSched().deferReset();     // Reset schedule in case card was previously loaded\n-        getCol().startTimebox();\n-        TaskManager.launchCollectionTask(new CollectionTask.GetCard(), new AnswerCardHandler(false));\n-\n-        disableDrawerSwipeOnConflicts();\n-        // Add a weak reference to current activity so that scheduler can talk to to Activity\n-        mSched.setContext(new WeakReference<>(this));\n-\n-        // Set full screen/immersive mode if needed\n-        if (mPrefFullscreenReview) {\n-            setFullScreen(this);\n-        }\n-\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        // 100ms was not enough on my device (Honor 9 Lite -  Android Pie)\n-        delayedHide(1000);\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-        int itemId = item.getItemId();\n-        if (itemId == android.R.id.home) {\n-            Timber.i(\"Reviewer:: Home button pressed\");\n-            closeReviewer(RESULT_OK, true);\n-        } else if (itemId == R.id.action_undo) {\n-            Timber.i(\"Reviewer:: Undo button pressed\");\n-            if (mShowWhiteboard && mWhiteboard != null && !mWhiteboard.undoEmpty()) {\n-                mWhiteboard.undo();\n-            } else {\n-                undo();\n-            }\n-        } else if (itemId == R.id.action_reset_card_progress) {\n-            Timber.i(\"Reviewer:: Reset progress button pressed\");\n-            showResetCardDialog();\n-        } else if (itemId == R.id.action_mark_card) {\n-            Timber.i(\"Reviewer:: Mark button pressed\");\n-            onMark(mCurrentCard);\n-        } else if (itemId == R.id.action_replay) {\n-            Timber.i(\"Reviewer:: Replay audio button pressed (from menu)\");\n-            playSounds(true);\n-        } else if (itemId == R.id.action_toggle_mic_tool_bar) {\n-            Timber.i(\"Reviewer:: Record mic\");\n-            // Check permission to record and request if not granted\n-            openOrToggleMicToolbar();\n-        } else if (itemId == R.id.action_tag) {\n-            Timber.i(\"Reviewer:: Tag button pressed\");\n-            showTagsDialog();\n-        } else if (itemId == R.id.action_edit) {\n-            Timber.i(\"Reviewer:: Edit note button pressed\");\n-            editCard();\n-            return true;\n-        } else if (itemId == R.id.action_bury) {\n-            Timber.i(\"Reviewer:: Bury button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Bury card due to no submenu\");\n-                buryCard();\n-            }\n-        } else if (itemId == R.id.action_suspend) {\n-            Timber.i(\"Reviewer:: Suspend button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Suspend card due to no submenu\");\n-                suspendCard();\n-            }\n-        } else if (itemId == R.id.action_delete) {\n-            Timber.i(\"Reviewer:: Delete note button pressed\");\n-            showDeleteNoteDialog();\n-        } else if (itemId == R.id.action_change_whiteboard_pen_color) {\n-            Timber.i(\"Reviewer:: Pen Color button pressed\");\n-            if (mColorPalette.getVisibility() == View.GONE) {\n-                mColorPalette.setVisibility(View.VISIBLE);\n-            } else {\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else if (itemId == R.id.action_save_whiteboard) {\n-            Timber.i(\"Reviewer:: Save whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                try {\n-                    String savedWhiteboardFileName = mWhiteboard.saveWhiteboard(getCol().getTime()).getPath();\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_saved, savedWhiteboardFileName), true);\n-                } catch (Exception e) {\n-                    Timber.w(e);\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_save_failed, e.getLocalizedMessage()), true);\n-                }\n-            }\n-        } else if (itemId == R.id.action_clear_whiteboard) {\n-            Timber.i(\"Reviewer:: Clear whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                mWhiteboard.clear();\n-            }\n-        } else if (itemId == R.id.action_hide_whiteboard) {// toggle whiteboard visibility\n-            Timber.i(\"Reviewer:: Whiteboard visibility set to %b\", !mShowWhiteboard);\n-            setWhiteboardVisibility(!mShowWhiteboard);\n-            refreshActionBar();\n-        } else if (itemId == R.id.action_toggle_whiteboard) {\n-            toggleWhiteboard();\n-        } else if (itemId == R.id.action_search_dictionary) {\n-            Timber.i(\"Reviewer:: Search dictionary button pressed\");\n-            lookUpOrSelectText();\n-        } else if (itemId == R.id.action_open_deck_options) {\n-            Intent i = new Intent(this, DeckOptions.class);\n-            startActivityForResultWithAnimation(i, DECK_OPTIONS, FADE);\n-        } else if (itemId == R.id.action_select_tts) {\n-            Timber.i(\"Reviewer:: Select TTS button pressed\");\n-            showSelectTtsDialogue();\n-        } else if (itemId == R.id.action_add_note_reviewer) {\n-            Timber.i(\"Reviewer:: Add note button pressed\");\n-            addNote();\n-        } else if (itemId == R.id.action_flag_zero) {\n-            Timber.i(\"Reviewer:: No flag\");\n-            onFlag(mCurrentCard, FLAG_NONE);\n-        } else if (itemId == R.id.action_flag_one) {\n-            Timber.i(\"Reviewer:: Flag one\");\n-            onFlag(mCurrentCard, FLAG_RED);\n-        } else if (itemId == R.id.action_flag_two) {\n-            Timber.i(\"Reviewer:: Flag two\");\n-            onFlag(mCurrentCard, FLAG_ORANGE);\n-        } else if (itemId == R.id.action_flag_three) {\n-            Timber.i(\"Reviewer:: Flag three\");\n-            onFlag(mCurrentCard, FLAG_GREEN);\n-        } else if (itemId == R.id.action_flag_four) {\n-            Timber.i(\"Reviewer:: Flag four\");\n-            onFlag(mCurrentCard, FLAG_BLUE);\n-        } else if (itemId == R.id.action_flag_five) {\n-            Timber.i(\"Reviewer:: Flag five\");\n-            onFlag(mCurrentCard, FLAG_PINK);\n-        } else if (itemId == R.id.action_flag_six) {\n-            Timber.i(\"Reviewer:: Flag six\");\n-            onFlag(mCurrentCard, FLAG_TURQUOISE);\n-        } else if (itemId == R.id.action_flag_seven) {\n-            Timber.i(\"Reviewer:: Flag seven\");\n-            onFlag(mCurrentCard, FLAG_PURPLE);\n-        } else if (itemId == R.id.action_card_info) {\n-            Timber.i(\"Card Viewer:: Card Info\");\n-            openCardInfo();\n-        } else {\n-            return super.onOptionsItemSelected(item);\n-        }\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void toggleWhiteboard() {\n-        mPrefWhiteboard = ! mPrefWhiteboard;\n-        Timber.i(\"Reviewer:: Whiteboard enabled state set to %b\", mPrefWhiteboard);\n-        //Even though the visibility is now stored in its own setting, we want it to be dependent\n-        //on the enabled status\n-        setWhiteboardEnabledState(mPrefWhiteboard);\n-        setWhiteboardVisibility(mPrefWhiteboard);\n-        if (!mPrefWhiteboard) {\n-            mColorPalette.setVisibility(View.GONE);\n-        }\n-        refreshActionBar();\n-    }\n-\n-\n-    @Override\n-    protected void replayVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        // COULD_BE_BETTER: this shows \"Failed\" if nothing was recorded\n-\n-        mMicToolBar.togglePlay();\n-    }\n-\n-\n-    @Override\n-    protected void recordVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        mMicToolBar.toggleRecord();\n-    }\n-\n-\n-    /**\n-     *\n-     * @return Whether the mic toolbar is usable\n-     */\n-    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n-    @VisibleForTesting\n-    public boolean openMicToolbar() {\n-        if (mMicToolBar == null || mMicToolBar.getVisibility() != View.VISIBLE) {\n-            openOrToggleMicToolbar();\n-        }\n-        return mMicToolBar != null;\n-    }\n-\n-\n-    protected void openOrToggleMicToolbar() {\n-        if (!Permissions.canRecordAudio(this)) {\n-            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.RECORD_AUDIO},\n-                    REQUEST_AUDIO_PERMISSION);\n-        } else {\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-\n-    private void toggleMicToolBar() {\n-        if (mMicToolBar != null) {\n-            // It exists swap visibility status\n-            if (mMicToolBar.getVisibility() != View.VISIBLE) {\n-                mMicToolBar.setVisibility(View.VISIBLE);\n-            } else {\n-                mMicToolBar.setVisibility(View.GONE);\n-            }\n-        } else {\n-            // Record mic tool bar does not exist yet\n-            mTempAudioPath = AudioView.generateTempAudioFile(this);\n-            if (mTempAudioPath == null) {\n-                return;\n-            }\n-            mMicToolBar = AudioView.createRecorderInstance(this, R.drawable.ic_play_arrow_white_24dp, R.drawable.ic_pause_white_24dp,\n-                        R.drawable.ic_stop_white_24dp, R.drawable.ic_rec, R.drawable.ic_rec_stop, mTempAudioPath);\n-            if (mMicToolBar == null) {\n-                mTempAudioPath = null;\n-                return;\n-            }\n-            FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-            mMicToolBar.setLayoutParams(lp2);\n-            LinearLayout micToolBarLayer = findViewById(R.id.mic_tool_bar_layer);\n-            micToolBarLayer.addView(mMicToolBar);\n-        }\n-    }\n-\n-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n-        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n-        if ((requestCode == REQUEST_AUDIO_PERMISSION) &&\n-                (permissions.length >= 1) && (grantResults[0] == PackageManager.PERMISSION_GRANTED)) {\n-            // Get get audio record permission, so we can create the record tool bar\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-    private void showRescheduleCardDialog() {\n-        Consumer<Integer> runnable = days ->\n-            TaskManager.launchCollectionTask(new CollectionTask.RescheduleCards(Collections.singletonList(mCurrentCard.getId()), days), new ScheduleCollectionTaskListener(R.plurals.reschedule_cards_dialog_acknowledge));\n-        RescheduleDialog dialog = RescheduleDialog.rescheduleSingleCard(getResources(), mCurrentCard, runnable);\n-\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void showResetCardDialog() {\n-        // Show confirmation dialog before resetting card progress\n-        Timber.i(\"showResetCardDialog() Reset progress button pressed\");\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getResources().getString(R.string.reset_card_dialog_title);\n-        String message = getResources().getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"NoteEditor:: ResetProgress button pressed\");\n-            TaskManager.launchCollectionTask(new CollectionTask.ResetCards(Collections.singletonList(mCurrentCard.getId())),\n-                    new ScheduleCollectionTaskListener(R.plurals.reset_cards_dialog_acknowledge));\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void addNote() {\n-        Intent intent = new Intent(this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD);\n-        startActivityForResultWithAnimation(intent, ADD_NOTE, START);\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public boolean onMenuOpened(int featureId, Menu menu) {\n-        new Handler().post(() -> {\n-            for (int i = 0; i < menu.size(); i++) {\n-                MenuItem menuItem = menu.getItem(i);\n-                shouldUseDefaultColor(menuItem);\n-            }\n-        });\n-        return super.onMenuOpened(featureId, menu);\n-    }\n-\n-    /**\n-     * This Method changes the color of icon if user taps in overflow button.\n-     */\n-    private void shouldUseDefaultColor(MenuItem menuItem) {\n-        Drawable drawable = menuItem.getIcon();\n-\n-        if (drawable != null && !menuItem.hasSubMenu() && !isFlagResource(menuItem.getItemId())) {\n-            drawable.mutate();\n-            drawable.setTint(ResourcesCompat.getColor(getResources(), R.color.material_blue_600, null));\n-        }\n-    }\n-\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public void onPanelClosed(int featureId, @NonNull Menu menu) {\n-        new Handler().postDelayed(this::refreshActionBar, 100);\n-    }\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(Menu menu) {\n-        // NOTE: This is called every time a new question is shown via invalidate options menu\n-        getMenuInflater().inflate(R.menu.reviewer, menu);\n-\n-        displayIconsOnTv(menu);\n-        displayIcons(menu);\n-\n-        mActionButtons.setCustomButtonsStatus(menu);\n-        int alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem markCardIcon = menu.findItem(R.id.action_mark_card);\n-        if (mCurrentCard != null && mCurrentCard.note().hasTag(\"marked\")) {\n-            markCardIcon.setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white);\n-        } else {\n-            markCardIcon.setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_border_white);\n-        }\n-        markCardIcon.getIcon().mutate().setAlpha(alpha);\n-\n-        // 1643 - currently null on a TV\n-        @Nullable MenuItem flag_icon = menu.findItem(R.id.action_flag);\n-        if (flag_icon != null) {\n-            if (mCurrentCard != null) {\n-                switch (mCurrentCard.userFlag()) {\n-                    case 1:\n-                        flag_icon.setIcon(R.drawable.ic_flag_red);\n-                        break;\n-                    case 2:\n-                        flag_icon.setIcon(R.drawable.ic_flag_orange);\n-                        break;\n-                    case 3:\n-                        flag_icon.setIcon(R.drawable.ic_flag_green);\n-                        break;\n-                    case 4:\n-                        flag_icon.setIcon(R.drawable.ic_flag_blue);\n-                        break;\n-                    case 5:\n-                        flag_icon.setIcon(R.drawable.ic_flag_pink);\n-                        break;\n-                    case 6:\n-                        flag_icon.setIcon(R.drawable.ic_flag_turquoise);\n-                        break;\n-                    case 7:\n-                        flag_icon.setIcon(R.drawable.ic_flag_purple);\n-                        break;\n-                    default:\n-                        flag_icon.setIcon(R.drawable.ic_flag_transparent);\n-                        break;\n-                }\n-            }\n-            flag_icon.getIcon().mutate().setAlpha(alpha);\n-        }\n-\n-        // Undo button\n-        @DrawableRes int undoIconId;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n-            undoIconId = R.drawable.eraser;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n-        } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n-            undoIconId = R.drawable.ic_undo_white;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n-        }\n-        int alpha_undo = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem undoIcon = menu.findItem(R.id.action_undo);\n-        undoIcon.setIcon(undoIconId);\n-        undoIcon.setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n-        undoIcon.getActionView().setEnabled(undoEnabled);\n-        if (colIsOpen()) { // Required mostly because there are tests where `col` is null\n-            undoIcon.setTitle(getResources().getString(R.string.studyoptions_congrats_undo, getCol().undoName(getResources())));\n-        }\n-\n-        if (undoEnabled) {\n-            mOnboarding.onUndoButtonEnabled();\n-        }\n-\n-        MenuItem toggle_whiteboard_icon = menu.findItem(R.id.action_toggle_whiteboard);\n-        MenuItem hide_whiteboard_icon = menu.findItem(R.id.action_hide_whiteboard);\n-        MenuItem change_pen_color_icon = menu.findItem(R.id.action_change_whiteboard_pen_color);\n-        // White board button\n-        if (mPrefWhiteboard) {\n-            // Configure the whiteboard related items in the action bar\n-            toggle_whiteboard_icon.setTitle(R.string.disable_whiteboard);\n-            // Always allow \"Disable Whiteboard\", even if \"Enable Whiteboard\" is disabled\n-            toggle_whiteboard_icon.setVisible(true);\n-\n-            if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n-                hide_whiteboard_icon.setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().saveWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().whiteboardPenColorIsDisabled()) {\n-                change_pen_color_icon.setVisible(true);\n-            }\n-\n-            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white).mutate();\n-            Drawable whiteboardColorPaletteIcon = VectorDrawableCompat.create(getResources(), R.drawable.ic_color_lens_white_24dp, null).mutate();\n-\n-            if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-            } else {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                change_pen_color_icon.setEnabled(false);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else {\n-            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n-        }\n-        if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n-            menu.findItem(R.id.action_open_deck_options).setVisible(false);\n-        }\n-        if (mSpeakText && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n-            menu.findItem(R.id.action_select_tts).setVisible(true);\n-        }\n-        // Setup bury / suspend providers\n-        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n-        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n-\n-        setupSubMenu(menu, R.id.action_suspend, new SuspendProvider(this));\n-        setupSubMenu(menu, R.id.action_bury, new BuryProvider(this));\n-        if (suspendNoteAvailable()) {\n-            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n-            suspend_icon.setTitle(R.string.menu_suspend);\n-        } else {\n-            suspend_icon.setIcon(R.drawable.ic_pause_circle_outline);\n-            suspend_icon.setTitle(R.string.menu_suspend_card);\n-        }\n-        if (buryNoteAvailable()) {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_dropdown);\n-            bury_icon.setTitle(R.string.menu_bury);\n-        } else {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_white);\n-            bury_icon.setTitle(R.string.menu_bury_card);\n-        }\n-        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        bury_icon.getIcon().mutate().setAlpha(alpha);\n-        suspend_icon.getIcon().mutate().setAlpha(alpha);\n-\n-        setupSubMenu(menu, R.id.action_schedule, new ScheduleProvider(this));\n-        mOnboarding.onCreate();\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\")\n-    private void displayIcons(Menu menu) {\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-        }catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons in Over flow menu\");\n-        }\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\") // setOptionalIconsVisible\n-    private void displayIconsOnTv(Menu menu) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return;\n-        }\n-\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-\n-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-                for (int i = 0; i < menu.size(); i++) {\n-                    MenuItem m = menu.getItem(i);\n-\n-                    if (m == null || isFlagResource(m.getItemId())) {\n-                        continue;\n-                    }\n-\n-                    int color = Themes.getColorFromAttr(this, R.attr.navDrawerItemColor);\n-                    MenuItemCompat.setIconTintList(m, ColorStateList.valueOf(color));\n-                }\n-            }\n-\n-        } catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons\");\n-        }\n-    }\n-\n-\n-    private boolean isFlagResource(int itemId) {\n-        return itemId == R.id.action_flag_seven\n-                || itemId == R.id.action_flag_six\n-                || itemId == R.id.action_flag_five\n-                || itemId == R.id.action_flag_four\n-                || itemId == R.id.action_flag_three\n-                || itemId == R.id.action_flag_two\n-                || itemId == R.id.action_flag_one;\n-    }\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyDown(keyCode, event);\n-        }\n-\n-        if (mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event)) {\n-            return true;\n-        }\n-\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return false;\n-        }\n-\n-        // Process DPAD Up/Down to focus the TV Controls\n-        if (keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_DPAD_UP) {\n-            return false;\n-        }\n-\n-        // HACK: This shouldn't be required, as the navigation should handle this.\n-        if (isDrawerOpen()) {\n-            return false;\n-        }\n-\n-\n-        View view = keyCode == KeyEvent.KEYCODE_DPAD_UP ? findViewById(R.id.tv_nav_view) : findViewById(R.id.answer_options_layout);\n-        // HACK: We should be performing this in the base class, or allowing the view to be focused by the keyboard.\n-        // I couldn't get either to work\n-        if (view == null) {\n-            return false;\n-        }\n-\n-        view.requestFocus();\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (mProcessor.onKeyUp(keyCode, event)) {\n-            return true;\n-        }\n-        return super.onKeyUp(keyCode, event);\n-    }\n-\n-\n-    private <T extends ActionProvider & SubMenuProvider> void setupSubMenu(Menu menu, @IdRes int parentMenu, T subMenuProvider) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            MenuItemCompat.setActionProvider(menu.findItem(parentMenu), subMenuProvider);\n-            return;\n-        }\n-\n-        // Don't do anything if the menu is hidden (bury for example)\n-        if (!subMenuProvider.hasSubMenu()) {\n-            return;\n-        }\n-\n-        // 7227 - If we're running on a TV, then we can't show submenus until AOSP is fixed\n-        menu.removeItem(parentMenu);\n-        int count = menu.size();\n-        // move the menu to the bottom of the page\n-        getMenuInflater().inflate(subMenuProvider.getSubMenu(), menu);\n-        for (int i = 0; i < menu.size() - count; i++) {\n-            MenuItem item = menu.getItem(count + i);\n-            item.setOnMenuItemClickListener(subMenuProvider);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected boolean canAccessScheduler() {\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void performReload() {\n-        getCol().getSched().deferReset();\n-        TaskManager.launchCollectionTask(new CollectionTask.GetCard(), new AnswerCardHandler(false));\n-    }\n-\n-\n-    @Override\n-    protected void displayAnswerBottomBar() {\n-        super.displayAnswerBottomBar();\n-        mOnboarding.onAnswerShown();\n-        int buttonCount;\n-        try {\n-            buttonCount = mSched.answerButtons(mCurrentCard);\n-        } catch (RuntimeException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"AbstractReviewer-showEaseButtons\");\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, true);\n-            return;\n-        }\n-\n-        // Set correct label and background resource for each button\n-        // Note that it's necessary to set the resource dynamically as the ease2 / ease3 buttons\n-        // (which libanki expects ease to be 2 and 3) can either be hard, good, or easy - depending on num buttons shown\n-        int[] backgroundIds;\n-        if (animationEnabled()) {\n-            backgroundIds = new int [] {\n-                    R.attr.againButtonRippleRef,\n-                    R.attr.hardButtonRippleRef,\n-                    R.attr.goodButtonRippleRef,\n-                    R.attr.easyButtonRippleRef};\n-        } else {\n-            backgroundIds = new int [] {\n-                    R.attr.againButtonRef,\n-                    R.attr.hardButtonRef,\n-                    R.attr.goodButtonRef,\n-                    R.attr.easyButtonRef};\n-        }\n-        final int[] background = Themes.getResFromAttr(this, backgroundIds);\n-        final int[] textColor = Themes.getColorFromAttr(this, new int [] {\n-                R.attr.againButtonTextColor,\n-                R.attr.hardButtonTextColor,\n-                R.attr.goodButtonTextColor,\n-                R.attr.easyButtonTextColor});\n-        mEase1Layout.setVisibility(View.VISIBLE);\n-        mEase1Layout.setBackgroundResource(background[0]);\n-        mEase4Layout.setBackgroundResource(background[3]);\n-        switch (buttonCount) {\n-            case 2:\n-                // Ease 2 is \"good\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            case 3:\n-                // Ease 2 is good\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                // Ease 3 is easy\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[3]);\n-                mEase3.setText(R.string.ease_button_easy);\n-                mEase3.setTextColor(textColor[3]);\n-                mNext3.setTextColor(textColor[3]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            default:\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                // Ease 2 is \"hard\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[1]);\n-                mEase2.setText(R.string.ease_button_hard);\n-                mEase2.setTextColor(textColor[1]);\n-                mNext2.setTextColor(textColor[1]);\n-                mEase2Layout.requestFocus();\n-                // Ease 3 is good\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[2]);\n-                mEase3.setText(R.string.ease_button_good);\n-                mEase3.setTextColor(textColor[2]);\n-                mNext3.setTextColor(textColor[2]);\n-                mEase4Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.requestFocus();\n-                break;\n-        }\n-\n-        // Show next review time\n-        if (shouldShowNextReviewTime()) {\n-            mNext1.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_ONE));\n-            mNext2.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_TWO));\n-            if (buttonCount > 2) {\n-                mNext3.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_THREE));\n-            }\n-            if (buttonCount > 3) {\n-                mNext4.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_FOUR));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected SharedPreferences restorePreferences() {\n-        SharedPreferences preferences = super.restorePreferences();\n-        mPrefHideDueCount = preferences.getBoolean(\"hideDueCount\", false);\n-        mPrefShowETA = preferences.getBoolean(\"showETA\", true);\n-        this.mProcessor.setup();\n-        mPrefFullscreenReview = FullScreenMode.isFullScreenReview(preferences);\n-        mActionButtons.setup(preferences);\n-        return preferences;\n-    }\n-\n-    @Override\n-    protected void updateActionBar() {\n-        super.updateActionBar();\n-        updateScreenCounts();\n-    }\n-\n-    protected void updateScreenCounts() {\n-        if (mCurrentCard == null) return;\n-        super.updateActionBar();\n-        ActionBar actionBar = getSupportActionBar();\n-        Counts counts = mSched.counts(mCurrentCard);\n-\n-        if (actionBar != null) {\n-            if (mPrefShowETA) {\n-                mEta = mSched.eta(counts, false);\n-                actionBar.setSubtitle(Utils.remainingTime(AnkiDroidApp.getInstance(), mEta * 60));\n-            }\n-        }\n-\n-\n-        mNewCount = new SpannableString(String.valueOf(counts.getNew()));\n-        mLrnCount = new SpannableString(String.valueOf(counts.getLrn()));\n-        mRevCount = new SpannableString(String.valueOf(counts.getRev()));\n-        if (mPrefHideDueCount) {\n-            mRevCount = new SpannableString(\"???\");\n-        }\n-\n-        switch (mSched.countIdx(mCurrentCard)) {\n-            case NEW:\n-                mNewCount.setSpan(new UnderlineSpan(), 0, mNewCount.length(), 0);\n-                break;\n-            case LRN:\n-                mLrnCount.setSpan(new UnderlineSpan(), 0, mLrnCount.length(), 0);\n-                break;\n-            case REV:\n-                mRevCount.setSpan(new UnderlineSpan(), 0, mRevCount.length(), 0);\n-                break;\n-            default:\n-                Timber.w(\"Unknown card type %s\", mSched.countIdx(mCurrentCard));\n-                break;\n-        }\n-\n-        mTextBarNew.setText(mNewCount);\n-        mTextBarLearn.setText(mLrnCount);\n-        mTextBarReview.setText(mRevCount);\n-    }\n-\n-    @Override\n-    public void fillFlashcard() {\n-        super.fillFlashcard();\n-        if (!sDisplayAnswer && mShowWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.clear();\n-        }\n-    }\n-\n-\n-    @Override\n-    public void displayCardQuestion() {\n-        // show timer, if activated in the deck's preferences\n-        initTimer();\n-        delayedHide(100);\n-        super.displayCardQuestion();\n-    }\n-\n-    @Override\n-    protected void displayCardAnswer() {\n-        delayedHide(100);\n-        super.displayCardAnswer();\n-    }\n-\n-    @Override\n-    protected void initLayout() {\n-        mTextBarNew = findViewById(R.id.new_number);\n-        mTextBarLearn = findViewById(R.id.learn_number);\n-        mTextBarReview = findViewById(R.id.review_number);\n-\n-        super.initLayout();\n-\n-        if (!mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.GONE);\n-            mTextBarLearn.setVisibility(View.GONE);\n-            mTextBarReview.setVisibility(View.GONE);\n-        }\n-    }\n-\n-    @Override\n-    protected void switchTopBarVisibility(int visible) {\n-        super.switchTopBarVisibility(visible);\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(visible);\n-            mTextBarLearn.setVisibility(visible);\n-            mTextBarReview.setVisibility(visible);\n-        }\n-    }\n-\n-    @Override\n-    protected void onStop() {\n-        super.onStop();\n-\n-        if (!isFinishing() && colIsOpen() && mSched != null) {\n-            WidgetStatus.update(this);\n-        }\n-        UIUtils.saveCollectionInBackground();\n-    }\n-\n-\n-    @Override\n-    protected void initControls() {\n-        super.initControls();\n-        if (mPrefWhiteboard) {\n-            setWhiteboardVisibility(mShowWhiteboard);\n-        }\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.VISIBLE);\n-            mTextBarLearn.setVisibility(View.VISIBLE);\n-            mTextBarReview.setVisibility(View.VISIBLE);\n-        }\n-    }\n-\n-    protected void restoreCollectionPreferences() {\n-        super.restoreCollectionPreferences();\n-        mShowRemainingCardCount = getCol().get_config_boolean(\"dueCounts\");\n-    }\n-\n-    @Override\n-    protected boolean onSingleTap() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    protected void onFling() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    protected final Handler mFullScreenHandler = new Handler() {\n-        @Override\n-        public void handleMessage(Message msg) {\n-            if (mPrefFullscreenReview) {\n-                setFullScreen(Reviewer.this);\n-            }\n-        }\n-    };\n-\n-    /** Hide the navigation if in full-screen mode after a given period of time */\n-    protected void delayedHide(int delayMillis) {\n-        Timber.d(\"Fullscreen delayed hide in %dms\", delayMillis);\n-        mFullScreenHandler.removeMessages(0);\n-        mFullScreenHandler.sendEmptyMessageDelayed(0, delayMillis);\n-    }\n-\n-\n-    private void setWhiteboardEnabledState(boolean state) {\n-        mPrefWhiteboard = state;\n-        MetaDB.storeWhiteboardState(this, getParentDid(), state);\n-        if (state && mWhiteboard == null) {\n-            createWhiteboard();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private void setFullScreen(final AbstractFlashcardViewer a) {\n-        // Set appropriate flags to enable Sticky Immersive mode.\n-        a.getWindow().getDecorView().setSystemUiVisibility(\n-                View.SYSTEM_UI_FLAG_LAYOUT_STABLE\n-                        //| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION // temporarily disabled due to #5245\n-                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\n-                        | View.SYSTEM_UI_FLAG_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_LOW_PROFILE\n-                        | View.SYSTEM_UI_FLAG_IMMERSIVE\n-        );\n-        // Show / hide the Action bar together with the status bar\n-        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(a);\n-        FullScreenMode fullscreenMode = FullScreenMode.fromPreference(prefs);\n-        a.getWindow().setStatusBarColor(Themes.getColorFromAttr(a, R.attr.colorPrimaryDark));\n-        View decorView = a.getWindow().getDecorView();\n-        decorView.setOnSystemUiVisibilityChangeListener\n-                (flags -> {\n-                    final View toolbar = a.findViewById(R.id.toolbar);\n-                    final View answerButtons = a.findViewById(R.id.answer_options_layout);\n-                    final View topbar = a.findViewById(R.id.top_bar);\n-                    if (toolbar == null || topbar == null || answerButtons == null) {\n-                        return;\n-                    }\n-                    // Note that system bars will only be \"visible\" if none of the\n-                    // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set.\n-                    boolean visible = (flags & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-                    Timber.d(\"System UI visibility change. Visible: %b\", visible);\n-                    if (visible) {\n-                        showViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            showViewWithAnimation(topbar);\n-                            showViewWithAnimation(answerButtons);\n-                        }\n-                    } else {\n-                        hideViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            hideViewWithAnimation(topbar);\n-                            hideViewWithAnimation(answerButtons);\n-                        }\n-                    }\n-                });\n-    }\n-\n-    private static final int ANIMATION_DURATION = 200;\n-    private static final float TRANSPARENCY = 0.90f;\n-\n-\n-    private void showViewWithAnimation(final View view) {\n-        view.setAlpha(0.0f);\n-        view.setVisibility(View.VISIBLE);\n-        view.animate().alpha(TRANSPARENCY).setDuration(ANIMATION_DURATION).setListener(null);\n-    }\n-\n-    private void hideViewWithAnimation(final View view) {\n-        view.animate()\n-                .alpha(0f)\n-                .setDuration(ANIMATION_DURATION)\n-                .setListener(new AnimatorListenerAdapter() {\n-                    @Override\n-                    public void onAnimationEnd(Animator animation) {\n-                        view.setVisibility(View.GONE);\n-                    }\n-                });\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private boolean isImmersiveSystemUiVisible(AnkiActivity activity) {\n-        return (activity.getWindow().getDecorView().getSystemUiVisibility() & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-    }\n-\n-    private void createWhiteboard() {\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(this);\n-        mWhiteboard = Whiteboard.createInstance(this, true, this);\n-\n-        // We use the pen color of the selected deck at the time the whiteboard is enabled.\n-        // This is how all other whiteboard settings are\n-        Integer whiteboardPenColor = MetaDB.getWhiteboardPenColor(this, getParentDid()).fromPreferences(sharedPrefs);\n-        if (whiteboardPenColor != null) {\n-            mWhiteboard.setPenColor(whiteboardPenColor);\n-        }\n-\n-        mWhiteboard.setOnPaintColorChangeListener(color -> MetaDB.storeWhiteboardPenColor(this, getParentDid(), !CardAppearance.isInNightMode(sharedPrefs), color));\n-\n-        mWhiteboard.setOnTouchListener((v, event) -> {\n-            //If the whiteboard is currently drawing, and triggers the system UI to show, we want to continue drawing.\n-            if (!mWhiteboard.isCurrentlyDrawing() && (!mShowWhiteboard || (mPrefFullscreenReview\n-                    && isImmersiveSystemUiVisible(Reviewer.this)))) {\n-                // Bypass whiteboard listener when it's hidden or fullscreen immersive mode is temporarily suspended\n-                v.performClick();\n-                return getGestureDetector().onTouchEvent(event);\n-            }\n-            return mWhiteboard.handleTouchEvent(event);\n-        });\n-    }\n-\n-    // Show or hide the whiteboard\n-    private void setWhiteboardVisibility(boolean state) {\n-        mShowWhiteboard = state;\n-        MetaDB.storeWhiteboardVisibility(this, getParentDid(), state);\n-        if (state) {\n-            mWhiteboard.setVisibility(View.VISIBLE);\n-            disableDrawerSwipe();\n-        } else {\n-            mWhiteboard.setVisibility(View.GONE);\n-            if (!mHasDrawerSwipeConflicts) {\n-                enableDrawerSwipe();\n-            }\n-        }\n-    }\n-\n-\n-    private void disableDrawerSwipeOnConflicts() {\n-        if (mGestureProcessor.isBound(Gesture.SWIPE_UP, Gesture.SWIPE_DOWN, Gesture.SWIPE_RIGHT)) {\n-            mHasDrawerSwipeConflicts = true;\n-            super.disableDrawerSwipe();\n-        }\n-    }\n-\n-\n-    @Override\n-    protected Long getCurrentCardId() {\n-        return mCurrentCard.getId();\n-    }\n-\n-\n-    @Override\n-    public void onWindowFocusChanged(boolean hasFocus) {\n-        super.onWindowFocusChanged(hasFocus);\n-        // Restore full screen once we regain focus\n-        if (hasFocus) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        } else {\n-            mFullScreenHandler.removeMessages(0);\n-        }\n-    }\n-\n-\n-    /**\n-     * Whether or not dismiss note is available for current card and specified DismissType\n-     * @return true if there is another card of same note that could be dismissed\n-     */\n-    private boolean suspendNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // whether there exists a sibling not buried.\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue != \" + Consts.QUEUE_TYPE_SUSPENDED + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-    private boolean buryNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // Whether there exists a sibling which is neither susbended nor buried\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue >=  \" + Consts.QUEUE_TYPE_NEW + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    @CheckResult\n-    Whiteboard getWhiteboard() {\n-        return mWhiteboard;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public AudioView getAudioView() {\n-        return mMicToolBar;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public boolean hasDrawerSwipeConflicts() {\n-        return mHasDrawerSwipeConflicts;\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Suspend button\n-     */\n-    class SuspendProvider extends ActionProvider implements SubMenuProvider {\n-        public SuspendProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;  // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_suspend;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return suspendNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_suspend_card) {\n-                return suspendCard();\n-            } else if (itemId == R.id.action_suspend_note) {\n-                return suspendNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Bury button\n-     */\n-    class BuryProvider extends ActionProvider implements SubMenuProvider {\n-        public BuryProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_bury;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return buryNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_bury_card) {\n-                return buryCard();\n-            } else if (itemId == R.id.action_bury_note) {\n-                return buryNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-\n-    /**\n-     * Inner class which implements the submenu for the Schedule button\n-     */\n-    class ScheduleProvider extends ActionProvider implements SubMenuProvider {\n-        public ScheduleProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_reschedule_card) {\n-                showRescheduleCardDialog();\n-                return true;\n-            } else if (itemId == R.id.action_reset_card_progress) {\n-                showResetCardDialog();\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_schedule;\n-        }\n-    }\n-\n-    private interface SubMenuProvider extends MenuItem.OnMenuItemClickListener {\n-        @MenuRes int getSubMenu();\n-        boolean hasSubMenu();\n-    }\n-\n-    public ReviewerJavaScriptFunction javaScriptFunction() {\n-        return new ReviewerJavaScriptFunction();\n-    }\n-\n-    public class ReviewerJavaScriptFunction extends JavaScriptFunction {\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetNewCardCount() {\n-            return mNewCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetLrnCardCount() {\n-            return mLrnCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetRevCardCount() {\n-            return mRevCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public int ankiGetETA() {\n-            return mEta;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "174065d896cbfdf5d420f3cacda9a82b476b917f", "url": "https://github.com/ankidroid/Anki-Android/commit/174065d896cbfdf5d420f3cacda9a82b476b917f", "message": "\tUpdated Reviewer.java", "committedDate": "2020-06-25T17:50:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0Mzc0MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445743740", "body": "if you're just implementing the interface to allow `setOnClickListener(this)`, then you can would be better define it as a lambda inside the method and remove the interface impementation\r\n\r\nI believe the syntax would be `btn.setOnClickListener(this::onClick)`. Then you can rename the method to something more readable.", "bodyText": "if you're just implementing the interface to allow setOnClickListener(this), then you can would be better define it as a lambda inside the method and remove the interface impementation\nI believe the syntax would be btn.setOnClickListener(this::onClick). Then you can rename the method to something more readable.", "bodyHTML": "<p dir=\"auto\">if you're just implementing the interface to allow <code>setOnClickListener(this)</code>, then you can would be better define it as a lambda inside the method and remove the interface impementation</p>\n<p dir=\"auto\">I believe the syntax would be <code>btn.setOnClickListener(this::onClick)</code>. Then you can rename the method to something more readable.</p>", "author": "david-allison-1", "createdAt": "2020-06-25T18:07:44Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -26,20 +26,22 @@\n import android.graphics.Path;\n import android.graphics.PathMeasure;\n import android.graphics.Point;\n-import android.graphics.PointF;\n+import androidx.annotation.NonNull;\n import androidx.core.content.ContextCompat;\n import android.view.Display;\n import android.view.MotionEvent;\n import android.view.View;\n import android.view.WindowManager;\n+import android.widget.Button;\n+import android.widget.LinearLayout;\n \n import java.lang.ref.WeakReference;\n import java.util.Stack;\n \n /**\n  * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n  */\n-public class Whiteboard extends View {\n+public class Whiteboard extends View implements View.OnClickListener {", "originalCommit": "174065d896cbfdf5d420f3cacda9a82b476b917f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex e3c8a1e12..1c4a154f2 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -26,22 +26,28 @@ import android.graphics.Paint;\n import android.graphics.Path;\n import android.graphics.PathMeasure;\n import android.graphics.Point;\n-import androidx.annotation.NonNull;\n+import android.graphics.PointF;\n import androidx.core.content.ContextCompat;\n+\n+import android.os.Environment;\n import android.view.Display;\n import android.view.MotionEvent;\n import android.view.View;\n import android.view.WindowManager;\n-import android.widget.Button;\n-import android.widget.LinearLayout;\n \n+import com.ichi2.libanki.utils.SystemTime;\n+import com.ichi2.libanki.utils.TimeUtils;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n import java.lang.ref.WeakReference;\n import java.util.Stack;\n \n /**\n  * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n  */\n-public class Whiteboard extends View implements View.OnClickListener {\n+public class Whiteboard extends View {\n \n     private static final float TOUCH_TOLERANCE = 4;\n \n", "next_change": {"commit": "3e8148c2deb5cea4afb1e7de2b7523d8f6244a91", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 1c4a154f2..66037e42a 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -47,6 +51,7 @@ import java.util.Stack;\n /**\n  * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n  */\n+@SuppressLint(\"ViewConstructor\")\n public class Whiteboard extends View {\n \n     private static final float TOUCH_TOLERANCE = 4;\n", "next_change": {"commit": "1f785c1b8c324266fdf652e84c9d9309d7278392", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 66037e42a..b78164994 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -56,13 +56,13 @@ public class Whiteboard extends View {\n \n     private static final float TOUCH_TOLERANCE = 4;\n \n-    private Paint mPaint;\n-    private UndoStack mUndo = new UndoStack();\n+    private final Paint mPaint;\n+    private final UndoStack mUndo = new UndoStack();\n     private Bitmap mBitmap;\n     private Canvas mCanvas;\n-    private Path mPath;\n-    private Paint mBitmapPaint;\n-    private WeakReference<AbstractFlashcardViewer> mCardViewer;\n+    private final Path mPath;\n+    private final Paint mBitmapPaint;\n+    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n \n     private float mX;\n     private float mY;\n", "next_change": {"commit": "840dbe4dca484b8ef7baa5d5d4800f519f2c07f9", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex b78164994..6b14ccbfe 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -55,14 +66,16 @@ import java.util.Stack;\n public class Whiteboard extends View {\n \n     private static final float TOUCH_TOLERANCE = 4;\n+    @Nullable\n+    private static WhiteboardMultiTouchMethods mWhiteboardMultiTouchMethods;\n \n     private final Paint mPaint;\n-    private final UndoStack mUndo = new UndoStack();\n+    private final UndoList mUndo = new UndoList();\n     private Bitmap mBitmap;\n     private Canvas mCanvas;\n     private final Path mPath;\n     private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n+    private final AnkiActivity mAnkiActivity;\n \n     private float mX;\n     private float mY;\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 6b14ccbfe..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,637 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.net.Uri;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.isInNightMode;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-    @Nullable\n-    private static WhiteboardMultiTouchMethods mWhiteboardMultiTouchMethods;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final AnkiActivity mAnkiActivity;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    private final Boolean mHandleMultiTouch;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AnkiActivity activity, Boolean handleMultiTouch, boolean inverted) {\n-        super(activity, null);\n-\n-        mAnkiActivity = activity;\n-        mHandleMultiTouch = handleMultiTouch;\n-\n-        Button whitePenColorButton = activity.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = activity.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-            whitePenColorButton.setVisibility(View.GONE);\n-            blackPenColorButton.setOnClickListener(this::onClick);\n-            mForegroundColor = Color.BLACK;\n-        } else {\n-            blackPenColorButton.setVisibility(View.GONE);\n-            whitePenColorButton.setOnClickListener(this::onClick);\n-            mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = activity.findViewById(R.id.whiteboard_editor);\n-\n-        activity.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        activity.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        activity.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        activity.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        activity.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mAnkiActivity).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-\n-    public static Whiteboard createInstance(AnkiActivity context, boolean handleMultiTouch, @Nullable WhiteboardMultiTouchMethods whiteboardMultiTouchMethods) {\n-\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(context);\n-        Whiteboard whiteboard = new Whiteboard(context, handleMultiTouch, isInNightMode(sharedPrefs));\n-\n-        mWhiteboardMultiTouchMethods = whiteboardMultiTouchMethods;\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-\n-        whiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = context.findViewById(R.id.whiteboard);\n-        fl.addView(whiteboard);\n-\n-        whiteboard.setEnabled(true);\n-\n-        return whiteboard;\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mAnkiActivity != null) {\n-                            mAnkiActivity.supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (mHandleMultiTouch && event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mAnkiActivity != null) {\n-            mAnkiActivity.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mAnkiActivity != null) {\n-            mAnkiActivity.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mAnkiActivity != null) {\n-            mAnkiActivity.supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            if (mSecondFingerWithinTapTolerance && mWhiteboardMultiTouchMethods != null) {\n-                mWhiteboardMultiTouchMethods.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            if (dy != 0 && mWhiteboardMultiTouchMethods != null) {\n-                mWhiteboardMultiTouchMethods.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mAnkiActivity, getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mAnkiActivity).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected Uri saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0NDQ3OQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445744479", "body": "```suggestion\r\n    private final LinearLayout mColorPalette;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private LinearLayout mColorPalette;\n          \n          \n            \n                private final LinearLayout mColorPalette;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">private</span> <span class=\"pl-smi\">LinearLayout</span> mColorPalette;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> <span class=\"pl-k x x-first\">final</span><span class=\"x x-last\"> </span><span class=\"pl-smi\">LinearLayout</span> mColorPalette;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "david-allison-1", "createdAt": "2020-06-25T18:09:02Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -66,6 +68,7 @@\n     private boolean mMonochrome;\n     private boolean mUndoModeActive = false;\n \n+    private LinearLayout mColorPalette;", "originalCommit": "174065d896cbfdf5d420f3cacda9a82b476b917f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex e3c8a1e12..1c4a154f2 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -67,8 +73,8 @@ public class Whiteboard extends View implements View.OnClickListener {\n     private boolean mInvertedColors;\n     private boolean mMonochrome;\n     private boolean mUndoModeActive = false;\n-\n-    private LinearLayout mColorPalette;\n+    private final int foregroundColor;\n+    private SystemTime mTime = new SystemTime();\n \n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 1c4a154f2..0f4fcd932 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -74,6 +76,7 @@ public class Whiteboard extends View {\n     private boolean mMonochrome;\n     private boolean mUndoModeActive = false;\n     private final int foregroundColor;\n+    private final LinearLayout mColorPalette;\n     private SystemTime mTime = new SystemTime();\n \n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n", "next_change": {"commit": "2a1b50a210789e9a20064de3cb5ece59ca0be456", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 0f4fcd932..6b57dfd73 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -77,7 +78,6 @@ public class Whiteboard extends View {\n     private boolean mUndoModeActive = false;\n     private final int foregroundColor;\n     private final LinearLayout mColorPalette;\n-    private SystemTime mTime = new SystemTime();\n \n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n", "next_change": {"commit": "bd2fb549a2e827068ae3d3bd03623d4a549fe16d", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 6b57dfd73..4603418f4 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -73,7 +75,6 @@ public class Whiteboard extends View {\n \n     private boolean mSecondFingerWithinTapTolerance;\n     private boolean mCurrentlyDrawing = false;\n-    private boolean mInvertedColors;\n     private boolean mMonochrome;\n     private boolean mUndoModeActive = false;\n     private final int foregroundColor;\n", "next_change": {"commit": "bf209dc67aa56c94d84a173d10aa415fb4470aaf", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 4603418f4..2d6381590 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -75,7 +75,6 @@ public class Whiteboard extends View {\n \n     private boolean mSecondFingerWithinTapTolerance;\n     private boolean mCurrentlyDrawing = false;\n-    private boolean mMonochrome;\n     private boolean mUndoModeActive = false;\n     private final int foregroundColor;\n     private final LinearLayout mColorPalette;\n", "next_change": {"commit": "27f10d57c86fe2e8ad3e66c969b48b92b5e594f1", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 2d6381590..09c5cb62e 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -79,6 +82,9 @@ public class Whiteboard extends View {\n     private final int foregroundColor;\n     private final LinearLayout mColorPalette;\n \n+    @Nullable\n+    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n+\n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n", "next_change": {"commit": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 09c5cb62e..872c1de5f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -85,23 +86,21 @@ public class Whiteboard extends View {\n     @Nullable\n     private OnPaintColorChangeListener mOnPaintColorChangeListener;\n \n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n+    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n \n+        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n+        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n \n         if (!inverted) {\n-            if (monochrome) {\n+                whitePenColorButton.setVisibility(View.GONE);\n+                blackPenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.BLACK;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color);\n-            }\n         } else {\n-            if (monochrome) {\n+                blackPenColorButton.setVisibility(View.GONE);\n+                whitePenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.WHITE;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color_inv);\n-            }\n         }\n \n         mPaint = new Paint();\n", "next_change": {"commit": "164200255997ac4750493118c24cec649191b630", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 872c1de5f..9839e2295 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -96,17 +101,17 @@ public class Whiteboard extends View {\n         if (!inverted) {\n                 whitePenColorButton.setVisibility(View.GONE);\n                 blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n+                mForegroundColor = Color.BLACK;\n         } else {\n                 blackPenColorButton.setVisibility(View.GONE);\n                 whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n+                mForegroundColor = Color.WHITE;\n         }\n \n         mPaint = new Paint();\n         mPaint.setAntiAlias(true);\n         mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n+        mPaint.setColor(mForegroundColor);\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n", "next_change": {"commit": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 9839e2295..bb9f12e33 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -115,21 +117,24 @@ public class Whiteboard extends View {\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n+        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n \n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n     }\n \n+    public int getCurrentStrokeWidth() {\n+        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n+    }\n \n     @Override\n     protected void onDraw(Canvas canvas) {\n", "next_change": {"commit": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex bb9f12e33..9953065c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -136,6 +138,24 @@ public class Whiteboard extends View {\n         return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n     }\n \n+\n+    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n+\n+        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n+        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n+\n+        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n+                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n+\n+        whiteboard.setLayoutParams(lp2);\n+        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n+        fl.addView(whiteboard);\n+\n+        whiteboard.setEnabled(true);\n+\n+        return whiteboard;\n+    }\n+\n     @Override\n     protected void onDraw(Canvas canvas) {\n         super.onDraw(canvas);\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 9953065c7..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,634 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.net.Uri;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.isInNightMode;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-\n-    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n-\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n-        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n-\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-\n-        whiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n-        fl.addView(whiteboard);\n-\n-        whiteboard.setEnabled(true);\n-\n-        return whiteboard;\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mCardViewer.get(), getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mCardViewer.get()).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected Uri saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 4603418f4..2d6381590 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -83,17 +82,16 @@ public class Whiteboard extends View {\n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n-        mMonochrome = monochrome;\n \n \n         if (!inverted) {\n-            if (mMonochrome) {\n+            if (monochrome) {\n                 foregroundColor = Color.BLACK;\n             } else {\n                 foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color);\n             }\n         } else {\n-            if (mMonochrome) {\n+            if (monochrome) {\n                 foregroundColor = Color.WHITE;\n             } else {\n                 foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color_inv);\n", "next_change": {"commit": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 2d6381590..872c1de5f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -79,23 +83,24 @@ public class Whiteboard extends View {\n     private final int foregroundColor;\n     private final LinearLayout mColorPalette;\n \n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n+    @Nullable\n+    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n+\n+    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n \n+        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n+        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n \n         if (!inverted) {\n-            if (monochrome) {\n+                whitePenColorButton.setVisibility(View.GONE);\n+                blackPenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.BLACK;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color);\n-            }\n         } else {\n-            if (monochrome) {\n+                blackPenColorButton.setVisibility(View.GONE);\n+                whitePenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.WHITE;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color_inv);\n-            }\n         }\n \n         mPaint = new Paint();\n", "next_change": {"commit": "164200255997ac4750493118c24cec649191b630", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 872c1de5f..9839e2295 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -96,17 +101,17 @@ public class Whiteboard extends View {\n         if (!inverted) {\n                 whitePenColorButton.setVisibility(View.GONE);\n                 blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n+                mForegroundColor = Color.BLACK;\n         } else {\n                 blackPenColorButton.setVisibility(View.GONE);\n                 whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n+                mForegroundColor = Color.WHITE;\n         }\n \n         mPaint = new Paint();\n         mPaint.setAntiAlias(true);\n         mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n+        mPaint.setColor(mForegroundColor);\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n", "next_change": {"commit": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 9839e2295..bb9f12e33 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -115,21 +117,24 @@ public class Whiteboard extends View {\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n+        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n \n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n     }\n \n+    public int getCurrentStrokeWidth() {\n+        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n+    }\n \n     @Override\n     protected void onDraw(Canvas canvas) {\n", "next_change": {"commit": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex bb9f12e33..9953065c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -136,6 +138,24 @@ public class Whiteboard extends View {\n         return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n     }\n \n+\n+    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n+\n+        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n+        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n+\n+        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n+                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n+\n+        whiteboard.setLayoutParams(lp2);\n+        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n+        fl.addView(whiteboard);\n+\n+        whiteboard.setEnabled(true);\n+\n+        return whiteboard;\n+    }\n+\n     @Override\n     protected void onDraw(Canvas canvas) {\n         super.onDraw(canvas);\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 9953065c7..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,634 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.net.Uri;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.isInNightMode;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-\n-    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n-\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n-        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n-\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-\n-        whiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n-        fl.addView(whiteboard);\n-\n-        whiteboard.setEnabled(true);\n-\n-        return whiteboard;\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mCardViewer.get(), getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mCardViewer.get()).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected Uri saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 6b57dfd73..4603418f4 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -82,11 +83,10 @@ public class Whiteboard extends View {\n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n-        mInvertedColors = inverted;\n         mMonochrome = monochrome;\n \n \n-        if (!mInvertedColors) {\n+        if (!inverted) {\n             if (mMonochrome) {\n                 foregroundColor = Color.BLACK;\n             } else {\n", "next_change": {"commit": "bf209dc67aa56c94d84a173d10aa415fb4470aaf", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 4603418f4..2d6381590 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -83,17 +82,16 @@ public class Whiteboard extends View {\n     public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n-        mMonochrome = monochrome;\n \n \n         if (!inverted) {\n-            if (mMonochrome) {\n+            if (monochrome) {\n                 foregroundColor = Color.BLACK;\n             } else {\n                 foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color);\n             }\n         } else {\n-            if (mMonochrome) {\n+            if (monochrome) {\n                 foregroundColor = Color.WHITE;\n             } else {\n                 foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color_inv);\n", "next_change": {"commit": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 2d6381590..872c1de5f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -79,23 +83,24 @@ public class Whiteboard extends View {\n     private final int foregroundColor;\n     private final LinearLayout mColorPalette;\n \n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean monochrome) {\n+    @Nullable\n+    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n+\n+    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n         super(cardViewer, null);\n         mCardViewer = new WeakReference<>(cardViewer);\n \n+        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n+        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n \n         if (!inverted) {\n-            if (monochrome) {\n+                whitePenColorButton.setVisibility(View.GONE);\n+                blackPenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.BLACK;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color);\n-            }\n         } else {\n-            if (monochrome) {\n+                blackPenColorButton.setVisibility(View.GONE);\n+                whitePenColorButton.setOnClickListener(this::onClick);\n                 foregroundColor = Color.WHITE;\n-            } else {\n-                foregroundColor = ContextCompat.getColor(cardViewer, R.color.wb_fg_color_inv);\n-            }\n         }\n \n         mPaint = new Paint();\n", "next_change": {"commit": "164200255997ac4750493118c24cec649191b630", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 872c1de5f..9839e2295 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -96,17 +101,17 @@ public class Whiteboard extends View {\n         if (!inverted) {\n                 whitePenColorButton.setVisibility(View.GONE);\n                 blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n+                mForegroundColor = Color.BLACK;\n         } else {\n                 blackPenColorButton.setVisibility(View.GONE);\n                 whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n+                mForegroundColor = Color.WHITE;\n         }\n \n         mPaint = new Paint();\n         mPaint.setAntiAlias(true);\n         mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n+        mPaint.setColor(mForegroundColor);\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n", "next_change": {"commit": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 9839e2295..bb9f12e33 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -115,21 +117,24 @@ public class Whiteboard extends View {\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n+        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n \n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n     }\n \n+    public int getCurrentStrokeWidth() {\n+        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n+    }\n \n     @Override\n     protected void onDraw(Canvas canvas) {\n", "next_change": {"commit": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex bb9f12e33..9953065c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -136,6 +138,24 @@ public class Whiteboard extends View {\n         return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n     }\n \n+\n+    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n+\n+        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n+        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n+\n+        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n+                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n+\n+        whiteboard.setLayoutParams(lp2);\n+        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n+        fl.addView(whiteboard);\n+\n+        whiteboard.setEnabled(true);\n+\n+        return whiteboard;\n+    }\n+\n     @Override\n     protected void onDraw(Canvas canvas) {\n         super.onDraw(canvas);\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 9953065c7..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,634 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.net.Uri;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.isInNightMode;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-\n-    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n-\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n-        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n-\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-\n-        whiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n-        fl.addView(whiteboard);\n-\n-        whiteboard.setEnabled(true);\n-\n-        return whiteboard;\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mCardViewer.get(), getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mCardViewer.get()).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected Uri saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "46727015c90598ed8ae7fa7d91b67d024a718537", "url": "https://github.com/ankidroid/Anki-Android/commit/46727015c90598ed8ae7fa7d91b67d024a718537", "message": "\tUpdated reviewer_fullscreen.xml, reviewer_fullscreen_noanswers.xml", "committedDate": "2020-06-25T18:09:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0Njg1MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445746851", "body": "Might as well remove the code rather than commenting it out", "bodyText": "Might as well remove the code rather than commenting it out", "bodyHTML": "<p dir=\"auto\">Might as well remove the code rather than commenting it out</p>", "author": "david-allison-1", "createdAt": "2020-06-25T18:13:14Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -241,11 +260,13 @@ private void createBitmap() {\n         // To fix issue #1336, just make the whiteboard big and square.\n         final Point p = getDisplayDimenions();\n         int bitmapSize = Math.max(p.x, p.y);\n+        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_8888);\n+        /*\n         if (mMonochrome && !mInvertedColors) {\n             createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ALPHA_8);\n         } else {\n             createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_4444);", "originalCommit": "174065d896cbfdf5d420f3cacda9a82b476b917f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex e3c8a1e12..1c4a154f2 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -260,13 +250,11 @@ public class Whiteboard extends View implements View.OnClickListener {\n         // To fix issue #1336, just make the whiteboard big and square.\n         final Point p = getDisplayDimenions();\n         int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_8888);\n-        /*\n         if (mMonochrome && !mInvertedColors) {\n             createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ALPHA_8);\n         } else {\n             createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_4444);\n-        }*/\n+        }\n     }\n \n     private void drawStart(float x, float y) {\n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 1c4a154f2..0f4fcd932 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -250,11 +263,7 @@ public class Whiteboard extends View {\n         // To fix issue #1336, just make the whiteboard big and square.\n         final Point p = getDisplayDimenions();\n         int bitmapSize = Math.max(p.x, p.y);\n-        if (mMonochrome && !mInvertedColors) {\n-            createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ALPHA_8);\n-        } else {\n-            createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_4444);\n-        }\n+        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_4444);\n     }\n \n     private void drawStart(float x, float y) {\n", "next_change": {"commit": "69dba64459dc466daad2d81012c55b9d66b721bb", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 0f4fcd932..d2616c7c0 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -263,7 +260,7 @@ public class Whiteboard extends View {\n         // To fix issue #1336, just make the whiteboard big and square.\n         final Point p = getDisplayDimenions();\n         int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_4444);\n+        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_8888);\n     }\n \n     private void drawStart(float x, float y) {\n", "next_change": {"commit": "24a01ecfe55797fdb2011f49fb2c903b1528f075", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex d2616c7c0..94395fe77 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -260,7 +256,7 @@ public class Whiteboard extends View {\n         // To fix issue #1336, just make the whiteboard big and square.\n         final Point p = getDisplayDimenions();\n         int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize, Bitmap.Config.ARGB_8888);\n+        createBitmap(bitmapSize, bitmapSize);\n     }\n \n     private void drawStart(float x, float y) {\n", "next_change": {"commit": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 94395fe77..872c1de5f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -254,7 +256,7 @@ public class Whiteboard extends View {\n \n     private void createBitmap() {\n         // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimenions();\n+        final Point p = getDisplayDimensions();\n         int bitmapSize = Math.max(p.x, p.y);\n         createBitmap(bitmapSize, bitmapSize);\n     }\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 872c1de5f..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,534 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import android.os.Environment;\n-import android.view.Display;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.WindowManager;\n-import android.widget.Button;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.lang.ref.WeakReference;\n-import java.util.Stack;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoStack mUndo = new UndoStack();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int foregroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-    }\n-\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        Display display = ((WindowManager) AnkiDroidApp.getInstance().getApplicationContext().\n-                getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\n-        Point point = new Point();\n-        display.getSize(point);\n-        return point;\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        }\n-    }\n-\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a stack of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the stack, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoStack {\n-        private final Stack<WhiteboardAction> mStack = new Stack<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mStack.add(action);\n-        }\n-\n-        public void clear() {\n-            mStack.clear();\n-        }\n-\n-        public int size() {\n-            return mStack.size();\n-        }\n-\n-        public void pop() {\n-            mStack.pop();\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mStack) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean empty() {\n-            return mStack.empty();\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    @SuppressWarnings( {\"deprecation\", \"RedundantSuppression\"}) // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n-    protected String saveWhiteboard(Time time) throws FileNotFoundException {\n-\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-\n-        File pictures = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);\n-        File ankiDroidFolder = new File(pictures, \"AnkiDroid\");\n-\n-        if (!ankiDroidFolder.exists()) {\n-            //noinspection ResultOfMethodCallIgnored\n-            ankiDroidFolder.mkdirs();\n-        }\n-\n-        String baseFileName = \"Whiteboard\";\n-        String timeStamp = TimeUtils.getTimestamp(time);\n-        String finalFileName = baseFileName + timeStamp + \".png\";\n-\n-        File saveWhiteboardImageFile = new File(ankiDroidFolder, finalFileName);\n-\n-        if (foregroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-\n-        this.draw(canvas);\n-        bitmap.compress(Bitmap.CompressFormat.JPEG, 95, new FileOutputStream(saveWhiteboardImageFile));\n-        return saveWhiteboardImageFile.getAbsolutePath();\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return foregroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "c8574991523c26f02fe367f6b0849a6458d2423d", "url": "https://github.com/ankidroid/Anki-Android/commit/c8574991523c26f02fe367f6b0849a6458d2423d", "message": "\tUpdated Whiteboard.java", "committedDate": "2020-06-25T18:17:34Z", "type": "commit"}, {"oid": "c8574991523c26f02fe367f6b0849a6458d2423d", "url": "https://github.com/ankidroid/Anki-Android/commit/c8574991523c26f02fe367f6b0849a6458d2423d", "message": "\tUpdated Whiteboard.java", "committedDate": "2020-06-25T18:17:34Z", "type": "forcePushed"}, {"oid": "c8574991523c26f02fe367f6b0849a6458d2423d", "url": "https://github.com/ankidroid/Anki-Android/commit/c8574991523c26f02fe367f6b0849a6458d2423d", "message": "\tUpdated Whiteboard.java", "committedDate": "2020-06-25T18:17:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc5Njc4Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445796783", "body": "There are constants in the `Themes` class, can you use these?", "bodyText": "There are constants in the Themes class, can you use these?", "bodyHTML": "<p dir=\"auto\">There are constants in the <code>Themes</code> class, can you use these?</p>", "author": "david-allison-1", "createdAt": "2020-06-25T19:43:34Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java", "diffHunk": "@@ -534,15 +542,27 @@ public boolean onCreateOptionsMenu(Menu menu) {\n                 menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n             }\n \n+            menu.findItem(R.id.action_change_whiteboard_pen_color).setVisible(true);\n+\n             Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp);\n+            Drawable whiteboardColorPaletteIcon = ContextCompat.getDrawable(this, R.drawable.ic_color_lens_white_24dp).mutate();\n+\n             if (mShowWhiteboard) {\n                 whiteboardIcon.setAlpha(255);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);\n+\n+                whiteboardColorPaletteIcon.setAlpha(255);", "originalCommit": "c8574991523c26f02fe367f6b0849a6458d2423d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e541b3ede91ca0bf8b1995deb32bd1a8f28ac1fb", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex b25ae1168..237cc98f6 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -542,27 +525,15 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n             }\n \n-            menu.findItem(R.id.action_change_whiteboard_pen_color).setVisible(true);\n-\n             Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp);\n-            Drawable whiteboardColorPaletteIcon = ContextCompat.getDrawable(this, R.drawable.ic_color_lens_white_24dp).mutate();\n-\n             if (mShowWhiteboard) {\n                 whiteboardIcon.setAlpha(255);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(255);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n             } else {\n                 whiteboardIcon.setAlpha(77);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.show_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(77);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setEnabled(false);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n-                colorPalette.setVisibility(View.GONE);\n             }\n         } else {\n             menu.findItem(R.id.action_enable_whiteboard).setTitle(R.string.enable_whiteboard);\n", "next_change": {"commit": "7574ad576813e609baf204561d5495bf5b30e2f8", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 237cc98f6..d4ed8559b 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -525,13 +525,13 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n             }\n \n-            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp);\n+            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp).mutate();\n             if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(255);\n+                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);\n             } else {\n-                whiteboardIcon.setAlpha(77);\n+                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.show_whiteboard);\n             }\n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex d4ed8559b..fe439beef 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -525,15 +544,28 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n             }\n \n+            menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n+            menu.findItem(R.id.action_change_whiteboard_pen_color).setVisible(true);\n+\n             Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white_24dp).mutate();\n+            Drawable whiteboardColorPaletteIcon = ContextCompat.getDrawable(this, R.drawable.ic_color_lens_white_24dp).mutate();\n+\n             if (mShowWhiteboard) {\n                 whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);\n+\n+                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n+                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n             } else {\n                 whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n                 menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n                 menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.show_whiteboard);\n+\n+                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n+                menu.findItem(R.id.action_change_whiteboard_pen_color).setEnabled(false);\n+                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n+                colorPalette.setVisibility(View.GONE);\n             }\n         } else {\n             menu.findItem(R.id.action_enable_whiteboard).setTitle(R.string.enable_whiteboard);\n", "next_change": {"commit": "937d3027a35f3af8c478b2066c8f35d1627710ee", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex fe439beef..bb9623c9f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -568,7 +588,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 colorPalette.setVisibility(View.GONE);\n             }\n         } else {\n-            menu.findItem(R.id.action_enable_whiteboard).setTitle(R.string.enable_whiteboard);\n+            menu.findItem(R.id.action_toggle_whiteboard).setTitle(R.string.enable_whiteboard);\n         }\n         if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n             menu.findItem(R.id.action_open_deck_options).setVisible(false);\n", "next_change": {"commit": "5408ceaef7eef4db61b4064e5997099700913ed8", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex bb9623c9f..ceddfae16 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -572,23 +582,23 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n             if (mShowWhiteboard) {\n                 whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n-                menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.hide_whiteboard);\n+                hide_whiteboard_icon.setIcon(whiteboardIcon);\n+                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n \n                 whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n+                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n             } else {\n                 whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                menu.findItem(R.id.action_hide_whiteboard).setIcon(whiteboardIcon);\n-                menu.findItem(R.id.action_hide_whiteboard).setTitle(R.string.show_whiteboard);\n+                hide_whiteboard_icon.setIcon(whiteboardIcon);\n+                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n \n                 whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setEnabled(false);\n-                menu.findItem(R.id.action_change_whiteboard_pen_color).setIcon(whiteboardColorPaletteIcon);\n+                change_pen_color_icon.setEnabled(false);\n+                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n                 colorPalette.setVisibility(View.GONE);\n             }\n         } else {\n-            menu.findItem(R.id.action_toggle_whiteboard).setTitle(R.string.enable_whiteboard);\n+            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n         }\n         if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n             menu.findItem(R.id.action_open_deck_options).setVisible(false);\n", "next_change": {"commit": "164200255997ac4750493118c24cec649191b630", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex ceddfae16..4e4d9ed2d 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -595,7 +661,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n                 whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n                 change_pen_color_icon.setEnabled(false);\n                 change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                colorPalette.setVisibility(View.GONE);\n+                mColorPalette.setVisibility(View.GONE);\n             }\n         } else {\n             toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n", "next_change": {"commit": "a8f17f64771b79e8b83c8b1630f689594150d3e0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 4e4d9ed2d..26b70bfec 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -669,7 +718,7 @@ public class Reviewer extends AbstractFlashcardViewer {\n         if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n             menu.findItem(R.id.action_open_deck_options).setVisible(false);\n         }\n-        if (mSpeakText && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n+        if (mTTS.isEnabled() && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n             menu.findItem(R.id.action_select_tts).setVisible(true);\n         }\n         // Setup bury / suspend providers\n", "next_change": {"commit": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\ndeleted file mode 100644\nindex 26b70bfec..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ /dev/null\n", "chunk": "@@ -1,1510 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\n-\n-package com.ichi2.anki;\n-\n-import android.Manifest;\n-import android.animation.Animator;\n-import android.animation.AnimatorListenerAdapter;\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.SharedPreferences;\n-import android.content.pm.PackageManager;\n-import android.content.res.ColorStateList;\n-import android.graphics.drawable.Drawable;\n-import android.os.Build;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.Message;\n-import android.text.SpannableString;\n-import android.text.style.UnderlineSpan;\n-import android.view.KeyEvent;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.SubMenu;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.webkit.WebView;\n-import android.webkit.JavascriptInterface;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-import android.widget.TextView;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.DrawableRes;\n-import androidx.annotation.IdRes;\n-import androidx.annotation.MenuRes;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.PluralsRes;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.appcompat.view.menu.MenuBuilder;\n-import androidx.appcompat.app.ActionBar;\n-import androidx.core.app.ActivityCompat;\n-import androidx.core.content.ContextCompat;\n-import androidx.core.content.res.ResourcesCompat;\n-import androidx.core.view.ActionProvider;\n-import androidx.core.view.MenuItemCompat;\n-import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;\n-\n-import com.ichi2.anki.cardviewer.CardAppearance;\n-import com.ichi2.anki.cardviewer.Gesture;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.multimediacard.AudioView;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.reviewer.AnswerButtons;\n-import com.ichi2.anki.reviewer.AutomaticAnswerAction;\n-import com.ichi2.anki.reviewer.FullScreenMode;\n-import com.ichi2.anki.reviewer.PeripheralKeymap;\n-import com.ichi2.anki.reviewer.ReviewerUi;\n-import com.ichi2.anki.servicelayer.SchedulerService;\n-import com.ichi2.anki.servicelayer.SchedulerService.NextCard;\n-import com.ichi2.anki.servicelayer.TaskListenerBuilder;\n-import com.ichi2.anki.workarounds.FirefoxSnackbarWorkaround;\n-import com.ichi2.anki.reviewer.ActionButtons;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.sched.Counts;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.utils.AndroidUiUtils;\n-import com.ichi2.utils.Computation;\n-import com.ichi2.utils.FunctionalInterfaces.Consumer;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.utils.ViewGroupUtils;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import kotlin.Unit;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.reviewer.CardMarker.*;\n-import static com.ichi2.anim.ActivityTransitionAnimation.Direction.*;\n-\n-\n-public class Reviewer extends AbstractFlashcardViewer {\n-    private boolean mHasDrawerSwipeConflicts = false;\n-    private boolean mShowWhiteboard = true;\n-    private boolean mPrefFullscreenReview = false;\n-    private static final int ADD_NOTE = 12;\n-    private static final int REQUEST_AUDIO_PERMISSION = 0;\n-    private LinearLayout mColorPalette;\n-\n-    // TODO: Consider extracting to ViewModel\n-    // Card counts\n-    private SpannableString mNewCount;\n-    private SpannableString mLrnCount;\n-    private SpannableString mRevCount;\n-\n-    private TextView mTextBarNew;\n-    private TextView mTextBarLearn;\n-    private TextView mTextBarReview;\n-\n-    private boolean mPrefHideDueCount;\n-\n-    // ETA\n-    private int mEta;\n-    private boolean mPrefShowETA;\n-\n-\n-    // Preferences from the collection\n-    private boolean mShowRemainingCardCount;\n-\n-    private final ActionButtons mActionButtons = new ActionButtons(this);\n-\n-\n-    @VisibleForTesting\n-    protected final PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n-    \n-    private final Onboarding.Reviewer mOnboarding = new Onboarding.Reviewer(this);\n-\n-    protected <T extends Computation<? extends NextCard<? extends Card[]>>> TaskListenerBuilder<Unit, T>\n-    scheduleCollectionTaskHandler(@PluralsRes int toastResourceId) {\n-        return nextCardHandler().alsoExecuteAfter(result -> {\n-            // BUG: If the method crashes, this will crash\n-            invalidateOptionsMenu();\n-            int cardCount = result.getValue().getResult().length;\n-            UIUtils.showThemedToast(this,\n-                    getResources().getQuantityString(toastResourceId, cardCount, cardCount), true);\n-        });\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        if (showedActivityFailedScreen(savedInstanceState)) {\n-            return;\n-        }\n-        Timber.d(\"onCreate()\");\n-        super.onCreate(savedInstanceState);\n-\n-        if (FirefoxSnackbarWorkaround.handledLaunchFromWebBrowser(getIntent(), this)) {\n-            this.setResult(RESULT_CANCELED);\n-            finishWithAnimation(END);\n-            return;\n-        }\n-\n-        if (Intent.ACTION_VIEW.equals(getIntent().getAction())) {\n-            Timber.d(\"onCreate() :: received Intent with action = %s\", getIntent().getAction());\n-            selectDeckFromExtra();\n-        }\n-\n-        mColorPalette = findViewById(R.id.whiteboard_editor);\n-\n-        startLoadingCollection();\n-    }\n-\n-\n-    @Override\n-    protected int getFlagToDisplay() {\n-        int actualValue = super.getFlagToDisplay();\n-        if (actualValue == FLAG_NONE) {\n-            return FLAG_NONE;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_FLAG);\n-        if (isShownInActionBar != null && isShownInActionBar) {\n-            return FLAG_NONE;\n-        }\n-        return actualValue;\n-    }\n-\n-\n-    @Override\n-    protected WebView createWebView() {\n-        WebView ret = super.createWebView();\n-        if (AndroidUiUtils.isRunningOnTv(this)) {\n-            ret.setFocusable(false);\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    protected void recreateWebView() {\n-        super.recreateWebView();\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-    @Override\n-    protected boolean shouldDisplayMark() {\n-        boolean markValue = super.shouldDisplayMark();\n-        if (!markValue) {\n-            return false;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_MARK);\n-        //If we don't know, show it.\n-        //Otherwise, if it's in the action bar, don't show it again.\n-        return isShownInActionBar == null || !isShownInActionBar;\n-    }\n-\n-    private void selectDeckFromExtra() {\n-        Bundle extras = getIntent().getExtras();\n-        if (extras == null || !extras.containsKey(\"deckId\")) {\n-            // deckId is not set, load default\n-            return;\n-        }\n-        long did = extras.getLong(\"deckId\", Long.MIN_VALUE);\n-\n-        Timber.d(\"selectDeckFromExtra() with deckId = %d\", did);\n-\n-        // Clear the undo history when selecting a new deck\n-        if (getCol().getDecks().selected() != did) {\n-            getCol().clearUndo();\n-        }\n-        // Select the deck\n-        getCol().getDecks().select(did);\n-        // Reset the schedule so that we get the counts for the currently selected deck\n-        getCol().getSched().deferReset();\n-    }\n-\n-    @Override\n-    protected void setTitle() {\n-        String title;\n-        if (colIsOpen()) {\n-            title = Decks.basename(getCol().getDecks().current().getString(\"name\"));\n-        } else {\n-            Timber.e(\"Could not set title in reviewer because collection closed\");\n-            title = \"\";\n-        }\n-        getSupportActionBar().setTitle(title);\n-        super.setTitle(title);\n-        getSupportActionBar().setSubtitle(\"\");\n-    }\n-\n-    @Override\n-    protected int getContentViewAttr(FullScreenMode fullscreenMode) {\n-        switch (fullscreenMode) {\n-            case BUTTONS_ONLY:\n-                return R.layout.reviewer_fullscreen;\n-            case FULLSCREEN_ALL_GONE:\n-                return R.layout.reviewer_fullscreen_noanswers;\n-            default:\n-                return R.layout.reviewer;\n-        }\n-    }\n-\n-    @Override\n-    protected boolean fitsSystemWindows() {\n-        return !getFullscreenMode().isFullScreenReview();\n-    }\n-\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        // Load the first card and start reviewing. Uses the answer card\n-        // task to load a card, but since we send null\n-        // as the card to answer, no card will be answered.\n-\n-        mPrefWhiteboard = MetaDB.getWhiteboardState(this, getParentDid());\n-        if (mPrefWhiteboard) {\n-            //DEFECT: Slight inefficiency here, as we set the database using these methods\n-            boolean whiteboardVisibility = MetaDB.getWhiteboardVisibility(this, getParentDid());\n-            setWhiteboardEnabledState(true);\n-            setWhiteboardVisibility(whiteboardVisibility);\n-        }\n-\n-        col.getSched().deferReset();     // Reset schedule in case card was previously loaded\n-        getCol().startTimebox();\n-        new SchedulerService.GetCard().runWithHandler(answerCardHandler(false));\n-\n-        disableDrawerSwipeOnConflicts();\n-        // Add a weak reference to current activity so that scheduler can talk to to Activity\n-        mSched.setContext(new WeakReference<>(this));\n-\n-        // Set full screen/immersive mode if needed\n-        if (mPrefFullscreenReview) {\n-            setFullScreen(this);\n-        }\n-\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        // 100ms was not enough on my device (Honor 9 Lite -  Android Pie)\n-        delayedHide(1000);\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-        int itemId = item.getItemId();\n-        if (itemId == android.R.id.home) {\n-            Timber.i(\"Reviewer:: Home button pressed\");\n-            closeReviewer(RESULT_OK, true);\n-        } else if (itemId == R.id.action_undo) {\n-            Timber.i(\"Reviewer:: Undo button pressed\");\n-            if (mShowWhiteboard && mWhiteboard != null && !mWhiteboard.undoEmpty()) {\n-                mWhiteboard.undo();\n-            } else {\n-                undo();\n-            }\n-        } else if (itemId == R.id.action_reset_card_progress) {\n-            Timber.i(\"Reviewer:: Reset progress button pressed\");\n-            showResetCardDialog();\n-        } else if (itemId == R.id.action_mark_card) {\n-            Timber.i(\"Reviewer:: Mark button pressed\");\n-            onMark(mCurrentCard);\n-        } else if (itemId == R.id.action_replay) {\n-            Timber.i(\"Reviewer:: Replay audio button pressed (from menu)\");\n-            playSounds(true);\n-        } else if (itemId == R.id.action_toggle_mic_tool_bar) {\n-            Timber.i(\"Reviewer:: Record mic\");\n-            // Check permission to record and request if not granted\n-            openOrToggleMicToolbar();\n-        } else if (itemId == R.id.action_tag) {\n-            Timber.i(\"Reviewer:: Tag button pressed\");\n-            showTagsDialog();\n-        } else if (itemId == R.id.action_edit) {\n-            Timber.i(\"Reviewer:: Edit note button pressed\");\n-            editCard();\n-            return true;\n-        } else if (itemId == R.id.action_bury) {\n-            Timber.i(\"Reviewer:: Bury button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Bury card due to no submenu\");\n-                buryCard();\n-            }\n-        } else if (itemId == R.id.action_suspend) {\n-            Timber.i(\"Reviewer:: Suspend button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Suspend card due to no submenu\");\n-                suspendCard();\n-            }\n-        } else if (itemId == R.id.action_delete) {\n-            Timber.i(\"Reviewer:: Delete note button pressed\");\n-            showDeleteNoteDialog();\n-        } else if (itemId == R.id.action_change_whiteboard_pen_color) {\n-            Timber.i(\"Reviewer:: Pen Color button pressed\");\n-            if (mColorPalette.getVisibility() == View.GONE) {\n-                mColorPalette.setVisibility(View.VISIBLE);\n-            } else {\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else if (itemId == R.id.action_save_whiteboard) {\n-            Timber.i(\"Reviewer:: Save whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                try {\n-                    String savedWhiteboardFileName = mWhiteboard.saveWhiteboard(getCol().getTime()).getPath();\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_saved, savedWhiteboardFileName), true);\n-                } catch (Exception e) {\n-                    Timber.w(e);\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_save_failed, e.getLocalizedMessage()), true);\n-                }\n-            }\n-        } else if (itemId == R.id.action_clear_whiteboard) {\n-            Timber.i(\"Reviewer:: Clear whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                mWhiteboard.clear();\n-            }\n-        } else if (itemId == R.id.action_hide_whiteboard) {// toggle whiteboard visibility\n-            Timber.i(\"Reviewer:: Whiteboard visibility set to %b\", !mShowWhiteboard);\n-            setWhiteboardVisibility(!mShowWhiteboard);\n-            refreshActionBar();\n-        } else if (itemId == R.id.action_toggle_whiteboard) {\n-            toggleWhiteboard();\n-        } else if (itemId == R.id.action_search_dictionary) {\n-            Timber.i(\"Reviewer:: Search dictionary button pressed\");\n-            lookUpOrSelectText();\n-        } else if (itemId == R.id.action_open_deck_options) {\n-            Intent i = new Intent(this, DeckOptions.class);\n-            startActivityForResultWithAnimation(i, DECK_OPTIONS, FADE);\n-        } else if (itemId == R.id.action_select_tts) {\n-            Timber.i(\"Reviewer:: Select TTS button pressed\");\n-            showSelectTtsDialogue();\n-        } else if (itemId == R.id.action_add_note_reviewer) {\n-            Timber.i(\"Reviewer:: Add note button pressed\");\n-            addNote();\n-        } else if (itemId == R.id.action_flag_zero) {\n-            Timber.i(\"Reviewer:: No flag\");\n-            onFlag(mCurrentCard, FLAG_NONE);\n-        } else if (itemId == R.id.action_flag_one) {\n-            Timber.i(\"Reviewer:: Flag one\");\n-            onFlag(mCurrentCard, FLAG_RED);\n-        } else if (itemId == R.id.action_flag_two) {\n-            Timber.i(\"Reviewer:: Flag two\");\n-            onFlag(mCurrentCard, FLAG_ORANGE);\n-        } else if (itemId == R.id.action_flag_three) {\n-            Timber.i(\"Reviewer:: Flag three\");\n-            onFlag(mCurrentCard, FLAG_GREEN);\n-        } else if (itemId == R.id.action_flag_four) {\n-            Timber.i(\"Reviewer:: Flag four\");\n-            onFlag(mCurrentCard, FLAG_BLUE);\n-        } else if (itemId == R.id.action_flag_five) {\n-            Timber.i(\"Reviewer:: Flag five\");\n-            onFlag(mCurrentCard, FLAG_PINK);\n-        } else if (itemId == R.id.action_flag_six) {\n-            Timber.i(\"Reviewer:: Flag six\");\n-            onFlag(mCurrentCard, FLAG_TURQUOISE);\n-        } else if (itemId == R.id.action_flag_seven) {\n-            Timber.i(\"Reviewer:: Flag seven\");\n-            onFlag(mCurrentCard, FLAG_PURPLE);\n-        } else if (itemId == R.id.action_card_info) {\n-            Timber.i(\"Card Viewer:: Card Info\");\n-            openCardInfo();\n-        } else {\n-            return super.onOptionsItemSelected(item);\n-        }\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void toggleWhiteboard() {\n-        mPrefWhiteboard = ! mPrefWhiteboard;\n-        Timber.i(\"Reviewer:: Whiteboard enabled state set to %b\", mPrefWhiteboard);\n-        //Even though the visibility is now stored in its own setting, we want it to be dependent\n-        //on the enabled status\n-        setWhiteboardEnabledState(mPrefWhiteboard);\n-        setWhiteboardVisibility(mPrefWhiteboard);\n-        if (!mPrefWhiteboard) {\n-            mColorPalette.setVisibility(View.GONE);\n-        }\n-        refreshActionBar();\n-    }\n-\n-\n-    @Override\n-    protected void replayVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        // COULD_BE_BETTER: this shows \"Failed\" if nothing was recorded\n-\n-        mMicToolBar.togglePlay();\n-    }\n-\n-\n-    @Override\n-    protected void recordVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        mMicToolBar.toggleRecord();\n-    }\n-\n-\n-    /**\n-     *\n-     * @return Whether the mic toolbar is usable\n-     */\n-    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n-    @VisibleForTesting\n-    public boolean openMicToolbar() {\n-        if (mMicToolBar == null || mMicToolBar.getVisibility() != View.VISIBLE) {\n-            openOrToggleMicToolbar();\n-        }\n-        return mMicToolBar != null;\n-    }\n-\n-\n-    protected void openOrToggleMicToolbar() {\n-        if (!Permissions.canRecordAudio(this)) {\n-            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.RECORD_AUDIO},\n-                    REQUEST_AUDIO_PERMISSION);\n-        } else {\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-\n-    private void toggleMicToolBar() {\n-        if (mMicToolBar != null) {\n-            // It exists swap visibility status\n-            if (mMicToolBar.getVisibility() != View.VISIBLE) {\n-                mMicToolBar.setVisibility(View.VISIBLE);\n-            } else {\n-                mMicToolBar.setVisibility(View.GONE);\n-            }\n-        } else {\n-            // Record mic tool bar does not exist yet\n-            mTempAudioPath = AudioView.generateTempAudioFile(this);\n-            if (mTempAudioPath == null) {\n-                return;\n-            }\n-            mMicToolBar = AudioView.createRecorderInstance(this, R.drawable.ic_play_arrow_white_24dp, R.drawable.ic_pause_white_24dp,\n-                        R.drawable.ic_stop_white_24dp, R.drawable.ic_rec, R.drawable.ic_rec_stop, mTempAudioPath);\n-            if (mMicToolBar == null) {\n-                mTempAudioPath = null;\n-                return;\n-            }\n-            FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-            mMicToolBar.setLayoutParams(lp2);\n-            LinearLayout micToolBarLayer = findViewById(R.id.mic_tool_bar_layer);\n-            micToolBarLayer.addView(mMicToolBar);\n-        }\n-    }\n-\n-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n-        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n-        if ((requestCode == REQUEST_AUDIO_PERMISSION) &&\n-                (permissions.length >= 1) && (grantResults[0] == PackageManager.PERMISSION_GRANTED)) {\n-            // Get get audio record permission, so we can create the record tool bar\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-    private void showRescheduleCardDialog() {\n-        Consumer<Integer> runnable = days -> {\n-            List<Long> cardIds = Collections.singletonList(mCurrentCard.getId());\n-            new SchedulerService.RescheduleCards(cardIds, days).runWithHandler(scheduleCollectionTaskHandler(R.plurals.reschedule_cards_dialog_acknowledge));\n-        };\n-        RescheduleDialog dialog = RescheduleDialog.rescheduleSingleCard(getResources(), mCurrentCard, runnable);\n-\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void showResetCardDialog() {\n-        // Show confirmation dialog before resetting card progress\n-        Timber.i(\"showResetCardDialog() Reset progress button pressed\");\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getResources().getString(R.string.reset_card_dialog_title);\n-        String message = getResources().getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"NoteEditor:: ResetProgress button pressed\");\n-            List<Long> cardIds = Collections.singletonList(mCurrentCard.getId());\n-            new SchedulerService.ResetCards(cardIds).runWithHandler(scheduleCollectionTaskHandler(R.plurals.reset_cards_dialog_acknowledge));\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void addNote() {\n-        Intent intent = new Intent(this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD);\n-        startActivityForResultWithAnimation(intent, ADD_NOTE, START);\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public boolean onMenuOpened(int featureId, Menu menu) {\n-        new Handler().post(() -> {\n-            for (int i = 0; i < menu.size(); i++) {\n-                MenuItem menuItem = menu.getItem(i);\n-                shouldUseDefaultColor(menuItem);\n-            }\n-        });\n-        return super.onMenuOpened(featureId, menu);\n-    }\n-\n-    /**\n-     * This Method changes the color of icon if user taps in overflow button.\n-     */\n-    private void shouldUseDefaultColor(MenuItem menuItem) {\n-        Drawable drawable = menuItem.getIcon();\n-\n-        if (drawable != null && !menuItem.hasSubMenu() && !isFlagResource(menuItem.getItemId())) {\n-            drawable.mutate();\n-            drawable.setTint(ResourcesCompat.getColor(getResources(), R.color.material_blue_600, null));\n-        }\n-    }\n-\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public void onPanelClosed(int featureId, @NonNull Menu menu) {\n-        new Handler().postDelayed(this::refreshActionBar, 100);\n-    }\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(Menu menu) {\n-        // NOTE: This is called every time a new question is shown via invalidate options menu\n-        getMenuInflater().inflate(R.menu.reviewer, menu);\n-\n-        displayIconsOnTv(menu);\n-        displayIcons(menu);\n-\n-        mActionButtons.setCustomButtonsStatus(menu);\n-        int alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem markCardIcon = menu.findItem(R.id.action_mark_card);\n-        if (mCurrentCard != null && mCurrentCard.note().hasTag(\"marked\")) {\n-            markCardIcon.setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white);\n-        } else {\n-            markCardIcon.setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_border_white);\n-        }\n-        markCardIcon.getIcon().mutate().setAlpha(alpha);\n-\n-        // 1643 - currently null on a TV\n-        @Nullable MenuItem flag_icon = menu.findItem(R.id.action_flag);\n-        if (flag_icon != null) {\n-            if (mCurrentCard != null) {\n-                switch (mCurrentCard.userFlag()) {\n-                    case 1:\n-                        flag_icon.setIcon(R.drawable.ic_flag_red);\n-                        break;\n-                    case 2:\n-                        flag_icon.setIcon(R.drawable.ic_flag_orange);\n-                        break;\n-                    case 3:\n-                        flag_icon.setIcon(R.drawable.ic_flag_green);\n-                        break;\n-                    case 4:\n-                        flag_icon.setIcon(R.drawable.ic_flag_blue);\n-                        break;\n-                    case 5:\n-                        flag_icon.setIcon(R.drawable.ic_flag_pink);\n-                        break;\n-                    case 6:\n-                        flag_icon.setIcon(R.drawable.ic_flag_turquoise);\n-                        break;\n-                    case 7:\n-                        flag_icon.setIcon(R.drawable.ic_flag_purple);\n-                        break;\n-                    default:\n-                        flag_icon.setIcon(R.drawable.ic_flag_transparent);\n-                        break;\n-                }\n-            }\n-            flag_icon.getIcon().mutate().setAlpha(alpha);\n-        }\n-\n-        // Undo button\n-        @DrawableRes int undoIconId;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n-            undoIconId = R.drawable.eraser;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n-        } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n-            undoIconId = R.drawable.ic_undo_white;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n-        }\n-        int alpha_undo = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem undoIcon = menu.findItem(R.id.action_undo);\n-        undoIcon.setIcon(undoIconId);\n-        undoIcon.setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n-        undoIcon.getActionView().setEnabled(undoEnabled);\n-        if (colIsOpen()) { // Required mostly because there are tests where `col` is null\n-            undoIcon.setTitle(getResources().getString(R.string.studyoptions_congrats_undo, getCol().undoName(getResources())));\n-        }\n-\n-        if (undoEnabled) {\n-            mOnboarding.onUndoButtonEnabled();\n-        }\n-\n-        MenuItem toggle_whiteboard_icon = menu.findItem(R.id.action_toggle_whiteboard);\n-        MenuItem hide_whiteboard_icon = menu.findItem(R.id.action_hide_whiteboard);\n-        MenuItem change_pen_color_icon = menu.findItem(R.id.action_change_whiteboard_pen_color);\n-        // White board button\n-        if (mPrefWhiteboard) {\n-            // Configure the whiteboard related items in the action bar\n-            toggle_whiteboard_icon.setTitle(R.string.disable_whiteboard);\n-            // Always allow \"Disable Whiteboard\", even if \"Enable Whiteboard\" is disabled\n-            toggle_whiteboard_icon.setVisible(true);\n-\n-            if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n-                hide_whiteboard_icon.setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().saveWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().whiteboardPenColorIsDisabled()) {\n-                change_pen_color_icon.setVisible(true);\n-            }\n-\n-            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white).mutate();\n-            Drawable whiteboardColorPaletteIcon = VectorDrawableCompat.create(getResources(), R.drawable.ic_color_lens_white_24dp, null).mutate();\n-\n-            if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-            } else {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                change_pen_color_icon.setEnabled(false);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else {\n-            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n-        }\n-        if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n-            menu.findItem(R.id.action_open_deck_options).setVisible(false);\n-        }\n-        if (mTTS.isEnabled() && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n-            menu.findItem(R.id.action_select_tts).setVisible(true);\n-        }\n-        // Setup bury / suspend providers\n-        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n-        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n-\n-        setupSubMenu(menu, R.id.action_suspend, new SuspendProvider(this));\n-        setupSubMenu(menu, R.id.action_bury, new BuryProvider(this));\n-        if (suspendNoteAvailable()) {\n-            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n-            suspend_icon.setTitle(R.string.menu_suspend);\n-        } else {\n-            suspend_icon.setIcon(R.drawable.ic_pause_circle_outline);\n-            suspend_icon.setTitle(R.string.menu_suspend_card);\n-        }\n-        if (buryNoteAvailable()) {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_dropdown);\n-            bury_icon.setTitle(R.string.menu_bury);\n-        } else {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_white);\n-            bury_icon.setTitle(R.string.menu_bury_card);\n-        }\n-        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        bury_icon.getIcon().mutate().setAlpha(alpha);\n-        suspend_icon.getIcon().mutate().setAlpha(alpha);\n-\n-        setupSubMenu(menu, R.id.action_schedule, new ScheduleProvider(this));\n-        mOnboarding.onCreate();\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\")\n-    private void displayIcons(Menu menu) {\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-        }catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons in Over flow menu\");\n-        }\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\") // setOptionalIconsVisible\n-    private void displayIconsOnTv(Menu menu) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return;\n-        }\n-\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-\n-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-                for (int i = 0; i < menu.size(); i++) {\n-                    MenuItem m = menu.getItem(i);\n-\n-                    if (m == null || isFlagResource(m.getItemId())) {\n-                        continue;\n-                    }\n-\n-                    int color = Themes.getColorFromAttr(this, R.attr.navDrawerItemColor);\n-                    MenuItemCompat.setIconTintList(m, ColorStateList.valueOf(color));\n-                }\n-            }\n-\n-        } catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons\");\n-        }\n-    }\n-\n-\n-    private boolean isFlagResource(int itemId) {\n-        return itemId == R.id.action_flag_seven\n-                || itemId == R.id.action_flag_six\n-                || itemId == R.id.action_flag_five\n-                || itemId == R.id.action_flag_four\n-                || itemId == R.id.action_flag_three\n-                || itemId == R.id.action_flag_two\n-                || itemId == R.id.action_flag_one;\n-    }\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyDown(keyCode, event);\n-        }\n-\n-        if (mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event)) {\n-            return true;\n-        }\n-\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return false;\n-        }\n-\n-        // Process DPAD Up/Down to focus the TV Controls\n-        if (keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_DPAD_UP) {\n-            return false;\n-        }\n-\n-        // HACK: This shouldn't be required, as the navigation should handle this.\n-        if (isDrawerOpen()) {\n-            return false;\n-        }\n-\n-\n-        View view = keyCode == KeyEvent.KEYCODE_DPAD_UP ? findViewById(R.id.tv_nav_view) : findViewById(R.id.answer_options_layout);\n-        // HACK: We should be performing this in the base class, or allowing the view to be focused by the keyboard.\n-        // I couldn't get either to work\n-        if (view == null) {\n-            return false;\n-        }\n-\n-        view.requestFocus();\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (mProcessor.onKeyUp(keyCode, event)) {\n-            return true;\n-        }\n-        return super.onKeyUp(keyCode, event);\n-    }\n-\n-\n-    private <T extends ActionProvider & SubMenuProvider> void setupSubMenu(Menu menu, @IdRes int parentMenu, T subMenuProvider) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            MenuItemCompat.setActionProvider(menu.findItem(parentMenu), subMenuProvider);\n-            return;\n-        }\n-\n-        // Don't do anything if the menu is hidden (bury for example)\n-        if (!subMenuProvider.hasSubMenu()) {\n-            return;\n-        }\n-\n-        // 7227 - If we're running on a TV, then we can't show submenus until AOSP is fixed\n-        menu.removeItem(parentMenu);\n-        int count = menu.size();\n-        // move the menu to the bottom of the page\n-        getMenuInflater().inflate(subMenuProvider.getSubMenu(), menu);\n-        for (int i = 0; i < menu.size() - count; i++) {\n-            MenuItem item = menu.getItem(count + i);\n-            item.setOnMenuItemClickListener(subMenuProvider);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected boolean canAccessScheduler() {\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void performReload() {\n-        getCol().getSched().deferReset();\n-        new SchedulerService.GetCard().runWithHandler(answerCardHandler(false));\n-    }\n-\n-\n-    @Override\n-    protected void displayAnswerBottomBar() {\n-        super.displayAnswerBottomBar();\n-        mOnboarding.onAnswerShown();\n-        int buttonCount;\n-        try {\n-            buttonCount = getButtonCount();\n-        } catch (RuntimeException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"AbstractReviewer-showEaseButtons\");\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, true);\n-            return;\n-        }\n-\n-        // Set correct label and background resource for each button\n-        // Note that it's necessary to set the resource dynamically as the ease2 / ease3 buttons\n-        // (which libanki expects ease to be 2 and 3) can either be hard, good, or easy - depending on num buttons shown\n-        final int[] background = AnswerButtons.getBackgroundColors(this);\n-        final int[] textColor = AnswerButtons.getTextColors(this);\n-        mEase1Layout.setVisibility(View.VISIBLE);\n-        mEase1Layout.setBackgroundResource(background[0]);\n-        mEase4Layout.setBackgroundResource(background[3]);\n-        switch (buttonCount) {\n-            case 2:\n-                // Ease 2 is \"good\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            case 3:\n-                // Ease 2 is good\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                // Ease 3 is easy\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[3]);\n-                mEase3.setText(R.string.ease_button_easy);\n-                mEase3.setTextColor(textColor[3]);\n-                mNext3.setTextColor(textColor[3]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            default:\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                // Ease 2 is \"hard\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[1]);\n-                mEase2.setText(R.string.ease_button_hard);\n-                mEase2.setTextColor(textColor[1]);\n-                mNext2.setTextColor(textColor[1]);\n-                mEase2Layout.requestFocus();\n-                // Ease 3 is good\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[2]);\n-                mEase3.setText(R.string.ease_button_good);\n-                mEase3.setTextColor(textColor[2]);\n-                mNext3.setTextColor(textColor[2]);\n-                mEase4Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.requestFocus();\n-                break;\n-        }\n-\n-        // Show next review time\n-        if (shouldShowNextReviewTime()) {\n-            mNext1.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_ONE));\n-            mNext2.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_TWO));\n-            if (buttonCount > 2) {\n-                mNext3.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_THREE));\n-            }\n-            if (buttonCount > 3) {\n-                mNext4.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_FOUR));\n-            }\n-        }\n-    }\n-\n-    public int getButtonCount() {\n-        return mSched.answerButtons(mCurrentCard);\n-    }\n-\n-\n-    @Override\n-    public void automaticShowQuestion(@NonNull AutomaticAnswerAction action) {\n-        // explicitly do not call super\n-        if (mEase1Layout.isEnabled() && mEase1Layout.getVisibility() == View.VISIBLE) {\n-            action.execute(this);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected SharedPreferences restorePreferences() {\n-        SharedPreferences preferences = super.restorePreferences();\n-        mPrefHideDueCount = preferences.getBoolean(\"hideDueCount\", false);\n-        mPrefShowETA = preferences.getBoolean(\"showETA\", true);\n-        this.mProcessor.setup();\n-        mPrefFullscreenReview = FullScreenMode.isFullScreenReview(preferences);\n-        mActionButtons.setup(preferences);\n-        return preferences;\n-    }\n-\n-    @Override\n-    protected void updateActionBar() {\n-        super.updateActionBar();\n-        updateScreenCounts();\n-    }\n-\n-    protected void updateScreenCounts() {\n-        if (mCurrentCard == null) return;\n-        super.updateActionBar();\n-        ActionBar actionBar = getSupportActionBar();\n-        Counts counts = mSched.counts(mCurrentCard);\n-\n-        if (actionBar != null) {\n-            if (mPrefShowETA) {\n-                mEta = mSched.eta(counts, false);\n-                actionBar.setSubtitle(Utils.remainingTime(AnkiDroidApp.getInstance(), mEta * 60));\n-            }\n-        }\n-\n-\n-        mNewCount = new SpannableString(String.valueOf(counts.getNew()));\n-        mLrnCount = new SpannableString(String.valueOf(counts.getLrn()));\n-        mRevCount = new SpannableString(String.valueOf(counts.getRev()));\n-        if (mPrefHideDueCount) {\n-            mRevCount = new SpannableString(\"???\");\n-        }\n-\n-        switch (mSched.countIdx(mCurrentCard)) {\n-            case NEW:\n-                mNewCount.setSpan(new UnderlineSpan(), 0, mNewCount.length(), 0);\n-                break;\n-            case LRN:\n-                mLrnCount.setSpan(new UnderlineSpan(), 0, mLrnCount.length(), 0);\n-                break;\n-            case REV:\n-                mRevCount.setSpan(new UnderlineSpan(), 0, mRevCount.length(), 0);\n-                break;\n-            default:\n-                Timber.w(\"Unknown card type %s\", mSched.countIdx(mCurrentCard));\n-                break;\n-        }\n-\n-        mTextBarNew.setText(mNewCount);\n-        mTextBarLearn.setText(mLrnCount);\n-        mTextBarReview.setText(mRevCount);\n-    }\n-\n-    @Override\n-    public void fillFlashcard() {\n-        super.fillFlashcard();\n-        if (!sDisplayAnswer && mShowWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.clear();\n-        }\n-    }\n-\n-\n-    @Override\n-    public void displayCardQuestion() {\n-        // show timer, if activated in the deck's preferences\n-        initTimer();\n-        delayedHide(100);\n-        super.displayCardQuestion();\n-    }\n-\n-    @Override\n-    protected void displayCardAnswer() {\n-        delayedHide(100);\n-        super.displayCardAnswer();\n-    }\n-\n-    @Override\n-    protected void initLayout() {\n-        mTextBarNew = findViewById(R.id.new_number);\n-        mTextBarLearn = findViewById(R.id.learn_number);\n-        mTextBarReview = findViewById(R.id.review_number);\n-\n-        super.initLayout();\n-\n-        if (!mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.GONE);\n-            mTextBarLearn.setVisibility(View.GONE);\n-            mTextBarReview.setVisibility(View.GONE);\n-        }\n-    }\n-\n-    @Override\n-    protected void switchTopBarVisibility(int visible) {\n-        super.switchTopBarVisibility(visible);\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(visible);\n-            mTextBarLearn.setVisibility(visible);\n-            mTextBarReview.setVisibility(visible);\n-        }\n-    }\n-\n-    @Override\n-    protected void onStop() {\n-        super.onStop();\n-\n-        if (!isFinishing() && colIsOpen() && mSched != null) {\n-            WidgetStatus.update(this);\n-        }\n-        UIUtils.saveCollectionInBackground();\n-    }\n-\n-\n-    @Override\n-    protected void initControls() {\n-        super.initControls();\n-        if (mPrefWhiteboard) {\n-            setWhiteboardVisibility(mShowWhiteboard);\n-        }\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.VISIBLE);\n-            mTextBarLearn.setVisibility(View.VISIBLE);\n-            mTextBarReview.setVisibility(View.VISIBLE);\n-        }\n-    }\n-\n-    protected void restoreCollectionPreferences(Collection col) {\n-        super.restoreCollectionPreferences(col);\n-        mShowRemainingCardCount = col.get_config_boolean(\"dueCounts\");\n-    }\n-\n-    @Override\n-    protected boolean onSingleTap() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    protected void onFling() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    protected final Handler mFullScreenHandler = new Handler() {\n-        @Override\n-        public void handleMessage(Message msg) {\n-            if (mPrefFullscreenReview) {\n-                setFullScreen(Reviewer.this);\n-            }\n-        }\n-    };\n-\n-    /** Hide the navigation if in full-screen mode after a given period of time */\n-    protected void delayedHide(int delayMillis) {\n-        Timber.d(\"Fullscreen delayed hide in %dms\", delayMillis);\n-        mFullScreenHandler.removeMessages(0);\n-        mFullScreenHandler.sendEmptyMessageDelayed(0, delayMillis);\n-    }\n-\n-\n-    private void setWhiteboardEnabledState(boolean state) {\n-        mPrefWhiteboard = state;\n-        MetaDB.storeWhiteboardState(this, getParentDid(), state);\n-        if (state && mWhiteboard == null) {\n-            createWhiteboard();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private void setFullScreen(final AbstractFlashcardViewer a) {\n-        // Set appropriate flags to enable Sticky Immersive mode.\n-        a.getWindow().getDecorView().setSystemUiVisibility(\n-                View.SYSTEM_UI_FLAG_LAYOUT_STABLE\n-                        //| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION // temporarily disabled due to #5245\n-                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\n-                        | View.SYSTEM_UI_FLAG_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_LOW_PROFILE\n-                        | View.SYSTEM_UI_FLAG_IMMERSIVE\n-        );\n-        // Show / hide the Action bar together with the status bar\n-        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(a);\n-        FullScreenMode fullscreenMode = FullScreenMode.fromPreference(prefs);\n-        a.getWindow().setStatusBarColor(Themes.getColorFromAttr(a, R.attr.colorPrimaryDark));\n-        View decorView = a.getWindow().getDecorView();\n-        decorView.setOnSystemUiVisibilityChangeListener\n-                (flags -> {\n-                    final View toolbar = a.findViewById(R.id.toolbar);\n-                    final View answerButtons = a.findViewById(R.id.answer_options_layout);\n-                    final View topbar = a.findViewById(R.id.top_bar);\n-                    if (toolbar == null || topbar == null || answerButtons == null) {\n-                        return;\n-                    }\n-                    // Note that system bars will only be \"visible\" if none of the\n-                    // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set.\n-                    boolean visible = (flags & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-                    Timber.d(\"System UI visibility change. Visible: %b\", visible);\n-                    if (visible) {\n-                        showViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            showViewWithAnimation(topbar);\n-                            showViewWithAnimation(answerButtons);\n-                        }\n-                    } else {\n-                        hideViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            hideViewWithAnimation(topbar);\n-                            hideViewWithAnimation(answerButtons);\n-                        }\n-                    }\n-                });\n-    }\n-\n-    private static final int ANIMATION_DURATION = 200;\n-    private static final float TRANSPARENCY = 0.90f;\n-\n-\n-    private void showViewWithAnimation(final View view) {\n-        view.setAlpha(0.0f);\n-        view.setVisibility(View.VISIBLE);\n-        view.animate().alpha(TRANSPARENCY).setDuration(ANIMATION_DURATION).setListener(null);\n-    }\n-\n-    private void hideViewWithAnimation(final View view) {\n-        view.animate()\n-                .alpha(0f)\n-                .setDuration(ANIMATION_DURATION)\n-                .setListener(new AnimatorListenerAdapter() {\n-                    @Override\n-                    public void onAnimationEnd(Animator animation) {\n-                        view.setVisibility(View.GONE);\n-                    }\n-                });\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private boolean isImmersiveSystemUiVisible(AnkiActivity activity) {\n-        return (activity.getWindow().getDecorView().getSystemUiVisibility() & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-    }\n-\n-    private void createWhiteboard() {\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(this);\n-        mWhiteboard = Whiteboard.createInstance(this, true, this);\n-\n-        // We use the pen color of the selected deck at the time the whiteboard is enabled.\n-        // This is how all other whiteboard settings are\n-        Integer whiteboardPenColor = MetaDB.getWhiteboardPenColor(this, getParentDid()).fromPreferences(sharedPrefs);\n-        if (whiteboardPenColor != null) {\n-            mWhiteboard.setPenColor(whiteboardPenColor);\n-        }\n-\n-        mWhiteboard.setOnPaintColorChangeListener(color -> MetaDB.storeWhiteboardPenColor(this, getParentDid(), !CardAppearance.isInNightMode(sharedPrefs), color));\n-\n-        mWhiteboard.setOnTouchListener((v, event) -> {\n-            //If the whiteboard is currently drawing, and triggers the system UI to show, we want to continue drawing.\n-            if (!mWhiteboard.isCurrentlyDrawing() && (!mShowWhiteboard || (mPrefFullscreenReview\n-                    && isImmersiveSystemUiVisible(Reviewer.this)))) {\n-                // Bypass whiteboard listener when it's hidden or fullscreen immersive mode is temporarily suspended\n-                v.performClick();\n-                return getGestureDetector().onTouchEvent(event);\n-            }\n-            return mWhiteboard.handleTouchEvent(event);\n-        });\n-    }\n-\n-    // Show or hide the whiteboard\n-    private void setWhiteboardVisibility(boolean state) {\n-        mShowWhiteboard = state;\n-        MetaDB.storeWhiteboardVisibility(this, getParentDid(), state);\n-        if (state) {\n-            mWhiteboard.setVisibility(View.VISIBLE);\n-            disableDrawerSwipe();\n-        } else {\n-            mWhiteboard.setVisibility(View.GONE);\n-            if (!mHasDrawerSwipeConflicts) {\n-                enableDrawerSwipe();\n-            }\n-        }\n-    }\n-\n-\n-    private void disableDrawerSwipeOnConflicts() {\n-        if (mGestureProcessor.isBound(Gesture.SWIPE_UP, Gesture.SWIPE_DOWN, Gesture.SWIPE_RIGHT)) {\n-            mHasDrawerSwipeConflicts = true;\n-            super.disableDrawerSwipe();\n-        }\n-    }\n-\n-\n-    @Override\n-    protected Long getCurrentCardId() {\n-        return mCurrentCard.getId();\n-    }\n-\n-\n-    @Override\n-    public void onWindowFocusChanged(boolean hasFocus) {\n-        super.onWindowFocusChanged(hasFocus);\n-        // Restore full screen once we regain focus\n-        if (hasFocus) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        } else {\n-            mFullScreenHandler.removeMessages(0);\n-        }\n-    }\n-\n-\n-    /**\n-     * Whether or not dismiss note is available for current card and specified DismissType\n-     * @return true if there is another card of same note that could be dismissed\n-     */\n-    private boolean suspendNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // whether there exists a sibling not buried.\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue != \" + Consts.QUEUE_TYPE_SUSPENDED + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-    private boolean buryNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // Whether there exists a sibling which is neither susbended nor buried\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue >=  \" + Consts.QUEUE_TYPE_NEW + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    @CheckResult\n-    Whiteboard getWhiteboard() {\n-        return mWhiteboard;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public AudioView getAudioView() {\n-        return mMicToolBar;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public boolean hasDrawerSwipeConflicts() {\n-        return mHasDrawerSwipeConflicts;\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Suspend button\n-     */\n-    class SuspendProvider extends ActionProvider implements SubMenuProvider {\n-        public SuspendProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;  // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_suspend;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return suspendNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_suspend_card) {\n-                return suspendCard();\n-            } else if (itemId == R.id.action_suspend_note) {\n-                return suspendNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Bury button\n-     */\n-    class BuryProvider extends ActionProvider implements SubMenuProvider {\n-        public BuryProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_bury;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return buryNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_bury_card) {\n-                return buryCard();\n-            } else if (itemId == R.id.action_bury_note) {\n-                return buryNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-\n-    /**\n-     * Inner class which implements the submenu for the Schedule button\n-     */\n-    class ScheduleProvider extends ActionProvider implements SubMenuProvider {\n-        public ScheduleProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_reschedule_card) {\n-                showRescheduleCardDialog();\n-                return true;\n-            } else if (itemId == R.id.action_reset_card_progress) {\n-                showResetCardDialog();\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_schedule;\n-        }\n-    }\n-\n-    private interface SubMenuProvider extends MenuItem.OnMenuItemClickListener {\n-        @MenuRes int getSubMenu();\n-        boolean hasSubMenu();\n-    }\n-\n-    public ReviewerJavaScriptFunction javaScriptFunction() {\n-        return new ReviewerJavaScriptFunction();\n-    }\n-\n-    public class ReviewerJavaScriptFunction extends JavaScriptFunction {\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetNewCardCount() {\n-            return mNewCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetLrnCardCount() {\n-            return mLrnCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetRevCardCount() {\n-            return mRevCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public int ankiGetETA() {\n-            return mEta;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex bb9623c9f..ceddfae16 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -597,22 +607,28 @@ public class Reviewer extends AbstractFlashcardViewer {\n             menu.findItem(R.id.action_select_tts).setVisible(true);\n         }\n         // Setup bury / suspend providers\n-        MenuItemCompat.setActionProvider(menu.findItem(R.id.action_suspend), new SuspendProvider(this));\n-        MenuItemCompat.setActionProvider(menu.findItem(R.id.action_bury), new BuryProvider(this));\n+        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n+        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n+        MenuItemCompat.setActionProvider(suspend_icon, new SuspendProvider(this));\n+        MenuItemCompat.setActionProvider(bury_icon, new BuryProvider(this));\n         if (suspendNoteAvailable()) {\n-            menu.findItem(R.id.action_suspend).setIcon(R.drawable.ic_action_suspend_dropdown);\n-            menu.findItem(R.id.action_suspend).setTitle(R.string.menu_suspend);\n+            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n+            suspend_icon.setTitle(R.string.menu_suspend);\n         } else {\n-            menu.findItem(R.id.action_suspend).setIcon(R.drawable.ic_action_suspend);\n-            menu.findItem(R.id.action_suspend).setTitle(R.string.menu_suspend_card);\n+            suspend_icon.setIcon(R.drawable.ic_action_suspend);\n+            suspend_icon.setTitle(R.string.menu_suspend_card);\n         }\n         if (buryNoteAvailable()) {\n-            menu.findItem(R.id.action_bury).setIcon(R.drawable.ic_flip_to_back_white_24px_dropdown);\n-            menu.findItem(R.id.action_bury).setTitle(R.string.menu_bury);\n+            bury_icon.setIcon(R.drawable.ic_flip_to_back_white_24px_dropdown);\n+            bury_icon.setTitle(R.string.menu_bury);\n         } else {\n-            menu.findItem(R.id.action_bury).setIcon(R.drawable.ic_flip_to_back_white_24dp);\n-            menu.findItem(R.id.action_bury).setTitle(R.string.menu_bury_card);\n+            bury_icon.setIcon(R.drawable.ic_flip_to_back_white_24dp);\n+            bury_icon.setTitle(R.string.menu_bury_card);\n         }\n+        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n+        bury_icon.getIcon().mutate().setAlpha(alpha);\n+        suspend_icon.getIcon().mutate().setAlpha(alpha);\n+\n         MenuItemCompat.setActionProvider(menu.findItem(R.id.action_schedule), new ScheduleProvider(this));\n         return super.onCreateOptionsMenu(menu);\n     }\n", "next_change": {"commit": "3763d6d0bc27900a9aa808f4b7fc3b3e68053d74", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex ceddfae16..7aa368970 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -636,7 +677,34 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n     @Override\n     public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        return mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event);\n+        if (mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event)) {\n+            return true;\n+        }\n+\n+        if (!AndroidUiUtils.isRunningOnTv(this)) {\n+            return false;\n+        }\n+\n+        // Process DPAD Up/Down to focus the TV Controls\n+        if (keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_DPAD_UP) {\n+            return false;\n+        }\n+\n+        // HACK: This shouldn't be required, as the navigation should handle this.\n+        if (isDrawerOpen()) {\n+            return false;\n+        }\n+\n+\n+        View view = keyCode == KeyEvent.KEYCODE_DPAD_UP ? findViewById(R.id.tv_nav_view) : findViewById(R.id.answer_options_layout);\n+        // HACK: We should be performing this in the base class, or allowing the view to be focused by the keyboard.\n+        // I couldn't get either to work\n+        if (view == null) {\n+            return false;\n+        }\n+\n+        view.requestFocus();\n+        return true;\n     }\n \n     @Override\n", "next_change": {"commit": "65ce8b1286f936f3d1d106b68463dfa384918a3e", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\nindex 7aa368970..0bf053673 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n", "chunk": "@@ -709,9 +845,6 @@ public class Reviewer extends AbstractFlashcardViewer {\n \n     @Override\n     public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyUp(keyCode, event);\n-        }\n         if (mProcessor.onKeyUp(keyCode, event)) {\n             return true;\n         }\n", "next_change": {"commit": "0eeb25b27ce65585ffbeb6f45cd507a1ae1b7a8c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java b/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\ndeleted file mode 100644\nindex 0bf053673..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Reviewer.java\n+++ /dev/null\n", "chunk": "@@ -1,1517 +0,0 @@\n-/****************************************************************************************\n- * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *\n- * Copyright (c) 2014 Bruno Romero de Azevedo <brunodea@inf.ufsm.br>                    *\n- *                                                                                      *\n- * This program is free software; you can redistribute it and/or modify it under        *\n- * the terms of the GNU General Public License as published by the Free Software        *\n- * Foundation; either version 3 of the License, or (at your option) any later           *\n- * version.                                                                             *\n- *                                                                                      *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *\n- *                                                                                      *\n- * You should have received a copy of the GNU General Public License along with         *\n- * this program.  If not, see <http://www.gnu.org/licenses/>.                           *\n- ****************************************************************************************/\n-// TODO: implement own menu? http://www.codeproject.com/Articles/173121/Android-Menus-My-Way\n-\n-package com.ichi2.anki;\n-\n-import android.Manifest;\n-import android.animation.Animator;\n-import android.animation.AnimatorListenerAdapter;\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.Intent;\n-import android.content.SharedPreferences;\n-import android.content.pm.PackageManager;\n-import android.content.res.ColorStateList;\n-import android.graphics.drawable.Drawable;\n-import android.os.Build;\n-import android.os.Bundle;\n-import android.os.Handler;\n-import android.os.Message;\n-import android.text.SpannableString;\n-import android.text.style.UnderlineSpan;\n-import android.view.KeyEvent;\n-import android.view.Menu;\n-import android.view.MenuItem;\n-import android.view.SubMenu;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.webkit.WebView;\n-import android.webkit.JavascriptInterface;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-import android.widget.TextView;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.DrawableRes;\n-import androidx.annotation.IdRes;\n-import androidx.annotation.MenuRes;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.PluralsRes;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.appcompat.view.menu.MenuBuilder;\n-import androidx.appcompat.app.ActionBar;\n-import androidx.core.app.ActivityCompat;\n-import androidx.core.content.ContextCompat;\n-import androidx.core.content.res.ResourcesCompat;\n-import androidx.core.view.ActionProvider;\n-import androidx.core.view.MenuItemCompat;\n-import androidx.vectordrawable.graphics.drawable.VectorDrawableCompat;\n-\n-import com.ichi2.anki.cardviewer.CardAppearance;\n-import com.ichi2.anki.cardviewer.Gesture;\n-import com.ichi2.anki.dialogs.ConfirmationDialog;\n-import com.ichi2.anki.multimediacard.AudioView;\n-import com.ichi2.anki.dialogs.RescheduleDialog;\n-import com.ichi2.anki.reviewer.FullScreenMode;\n-import com.ichi2.anki.reviewer.PeripheralKeymap;\n-import com.ichi2.anki.reviewer.ReviewerUi;\n-import com.ichi2.anki.workarounds.FirefoxSnackbarWorkaround;\n-import com.ichi2.anki.reviewer.ActionButtons;\n-import com.ichi2.async.CollectionTask;\n-import com.ichi2.async.TaskManager;\n-import com.ichi2.libanki.Card;\n-import com.ichi2.libanki.Collection;\n-import com.ichi2.libanki.Consts;\n-import com.ichi2.libanki.Decks;\n-import com.ichi2.libanki.Utils;\n-import com.ichi2.libanki.sched.Counts;\n-import com.ichi2.themes.Themes;\n-import com.ichi2.utils.AndroidUiUtils;\n-import com.ichi2.utils.FunctionalInterfaces.Consumer;\n-import com.ichi2.utils.Computation;\n-import com.ichi2.utils.Permissions;\n-import com.ichi2.utils.ViewGroupUtils;\n-import com.ichi2.widget.WidgetStatus;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Collections;\n-\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.reviewer.CardMarker.*;\n-import static com.ichi2.anim.ActivityTransitionAnimation.Direction.*;\n-\n-\n-public class Reviewer extends AbstractFlashcardViewer {\n-    private boolean mHasDrawerSwipeConflicts = false;\n-    private boolean mShowWhiteboard = true;\n-    private boolean mPrefFullscreenReview = false;\n-    private static final int ADD_NOTE = 12;\n-    private static final int REQUEST_AUDIO_PERMISSION = 0;\n-    private LinearLayout mColorPalette;\n-\n-    // TODO: Consider extracting to ViewModel\n-    // Card counts\n-    private SpannableString mNewCount;\n-    private SpannableString mLrnCount;\n-    private SpannableString mRevCount;\n-\n-    private TextView mTextBarNew;\n-    private TextView mTextBarLearn;\n-    private TextView mTextBarReview;\n-\n-    private boolean mPrefHideDueCount;\n-\n-    // ETA\n-    private int mEta;\n-    private boolean mPrefShowETA;\n-\n-\n-    // Preferences from the collection\n-    private boolean mShowRemainingCardCount;\n-\n-    private final ActionButtons mActionButtons = new ActionButtons(this);\n-\n-\n-    @VisibleForTesting\n-    protected final PeripheralKeymap mProcessor = new PeripheralKeymap(this, this);\n-    \n-    private final Onboarding.Reviewer mOnboarding = new Onboarding.Reviewer(this);\n-\n-    /** We need to listen for and handle reschedules / resets very similarly */\n-    class ScheduleCollectionTaskListener extends NextCardHandler<Computation<Card[]>> {\n-\n-        private final @PluralsRes int mToastResourceId;\n-\n-\n-        protected ScheduleCollectionTaskListener(@PluralsRes int toastResourceId) {\n-            mToastResourceId = toastResourceId;\n-        }\n-\n-\n-        @Override\n-        public void onPostExecute(Computation<Card[]> result) {\n-            super.onPostExecute(result);\n-            invalidateOptionsMenu();\n-            int cardCount = result.getValue().length;\n-            UIUtils.showThemedToast(Reviewer.this,\n-                    getResources().getQuantityString(mToastResourceId, cardCount, cardCount), true);\n-        }\n-    }\n-\n-    @Override\n-    protected void onCreate(Bundle savedInstanceState) {\n-        if (showedActivityFailedScreen(savedInstanceState)) {\n-            return;\n-        }\n-        Timber.d(\"onCreate()\");\n-        super.onCreate(savedInstanceState);\n-\n-        if (FirefoxSnackbarWorkaround.handledLaunchFromWebBrowser(getIntent(), this)) {\n-            this.setResult(RESULT_CANCELED);\n-            finishWithAnimation(END);\n-            return;\n-        }\n-\n-        if (Intent.ACTION_VIEW.equals(getIntent().getAction())) {\n-            Timber.d(\"onCreate() :: received Intent with action = %s\", getIntent().getAction());\n-            selectDeckFromExtra();\n-        }\n-\n-        mColorPalette = findViewById(R.id.whiteboard_editor);\n-\n-        startLoadingCollection();\n-    }\n-\n-\n-    @Override\n-    protected int getFlagToDisplay() {\n-        int actualValue = super.getFlagToDisplay();\n-        if (actualValue == FLAG_NONE) {\n-            return FLAG_NONE;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_FLAG);\n-        if (isShownInActionBar != null && isShownInActionBar) {\n-            return FLAG_NONE;\n-        }\n-        return actualValue;\n-    }\n-\n-\n-    @Override\n-    protected WebView createWebView() {\n-        WebView ret = super.createWebView();\n-        if (AndroidUiUtils.isRunningOnTv(this)) {\n-            ret.setFocusable(false);\n-        }\n-        return ret;\n-    }\n-\n-    @Override\n-    protected void recreateWebView() {\n-        super.recreateWebView();\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-    @Override\n-    protected boolean shouldDisplayMark() {\n-        boolean markValue = super.shouldDisplayMark();\n-        if (!markValue) {\n-            return false;\n-        }\n-        Boolean isShownInActionBar = mActionButtons.isShownInActionBar(ActionButtons.RES_MARK);\n-        //If we don't know, show it.\n-        //Otherwise, if it's in the action bar, don't show it again.\n-        return isShownInActionBar == null || !isShownInActionBar;\n-    }\n-\n-    private void selectDeckFromExtra() {\n-        Bundle extras = getIntent().getExtras();\n-        if (extras == null || !extras.containsKey(\"deckId\")) {\n-            // deckId is not set, load default\n-            return;\n-        }\n-        long did = extras.getLong(\"deckId\", Long.MIN_VALUE);\n-\n-        Timber.d(\"selectDeckFromExtra() with deckId = %d\", did);\n-\n-        // Clear the undo history when selecting a new deck\n-        if (getCol().getDecks().selected() != did) {\n-            getCol().clearUndo();\n-        }\n-        // Select the deck\n-        getCol().getDecks().select(did);\n-        // Reset the schedule so that we get the counts for the currently selected deck\n-        getCol().getSched().deferReset();\n-    }\n-\n-    @Override\n-    protected void setTitle() {\n-        String title;\n-        if (colIsOpen()) {\n-            title = Decks.basename(getCol().getDecks().current().getString(\"name\"));\n-        } else {\n-            Timber.e(\"Could not set title in reviewer because collection closed\");\n-            title = \"\";\n-        }\n-        getSupportActionBar().setTitle(title);\n-        super.setTitle(title);\n-        getSupportActionBar().setSubtitle(\"\");\n-    }\n-\n-    @Override\n-    protected int getContentViewAttr(FullScreenMode fullscreenMode) {\n-        switch (fullscreenMode) {\n-            case BUTTONS_ONLY:\n-                return R.layout.reviewer_fullscreen;\n-            case FULLSCREEN_ALL_GONE:\n-                return R.layout.reviewer_fullscreen_noanswers;\n-            default:\n-                return R.layout.reviewer;\n-        }\n-    }\n-\n-    @Override\n-    protected boolean fitsSystemWindows() {\n-        return !getFullscreenMode().isFullScreenReview();\n-    }\n-\n-    @Override\n-    protected void onCollectionLoaded(Collection col) {\n-        super.onCollectionLoaded(col);\n-        // Load the first card and start reviewing. Uses the answer card\n-        // task to load a card, but since we send null\n-        // as the card to answer, no card will be answered.\n-\n-        mPrefWhiteboard = MetaDB.getWhiteboardState(this, getParentDid());\n-        if (mPrefWhiteboard) {\n-            //DEFECT: Slight inefficiency here, as we set the database using these methods\n-            boolean whiteboardVisibility = MetaDB.getWhiteboardVisibility(this, getParentDid());\n-            setWhiteboardEnabledState(true);\n-            setWhiteboardVisibility(whiteboardVisibility);\n-        }\n-\n-        col.getSched().deferReset();     // Reset schedule in case card was previously loaded\n-        getCol().startTimebox();\n-        TaskManager.launchCollectionTask(new CollectionTask.GetCard(), new AnswerCardHandler(false));\n-\n-        disableDrawerSwipeOnConflicts();\n-        // Add a weak reference to current activity so that scheduler can talk to to Activity\n-        mSched.setContext(new WeakReference<>(this));\n-\n-        // Set full screen/immersive mode if needed\n-        if (mPrefFullscreenReview) {\n-            setFullScreen(this);\n-        }\n-\n-        ViewGroupUtils.setRenderWorkaround(this);\n-    }\n-\n-\n-    @Override\n-    public boolean onOptionsItemSelected(MenuItem item) {\n-        // 100ms was not enough on my device (Honor 9 Lite -  Android Pie)\n-        delayedHide(1000);\n-        if (getDrawerToggle().onOptionsItemSelected(item)) {\n-            return true;\n-        }\n-        int itemId = item.getItemId();\n-        if (itemId == android.R.id.home) {\n-            Timber.i(\"Reviewer:: Home button pressed\");\n-            closeReviewer(RESULT_OK, true);\n-        } else if (itemId == R.id.action_undo) {\n-            Timber.i(\"Reviewer:: Undo button pressed\");\n-            if (mShowWhiteboard && mWhiteboard != null && !mWhiteboard.undoEmpty()) {\n-                mWhiteboard.undo();\n-            } else {\n-                undo();\n-            }\n-        } else if (itemId == R.id.action_reset_card_progress) {\n-            Timber.i(\"Reviewer:: Reset progress button pressed\");\n-            showResetCardDialog();\n-        } else if (itemId == R.id.action_mark_card) {\n-            Timber.i(\"Reviewer:: Mark button pressed\");\n-            onMark(mCurrentCard);\n-        } else if (itemId == R.id.action_replay) {\n-            Timber.i(\"Reviewer:: Replay audio button pressed (from menu)\");\n-            playSounds(true);\n-        } else if (itemId == R.id.action_toggle_mic_tool_bar) {\n-            Timber.i(\"Reviewer:: Record mic\");\n-            // Check permission to record and request if not granted\n-            openOrToggleMicToolbar();\n-        } else if (itemId == R.id.action_tag) {\n-            Timber.i(\"Reviewer:: Tag button pressed\");\n-            showTagsDialog();\n-        } else if (itemId == R.id.action_edit) {\n-            Timber.i(\"Reviewer:: Edit note button pressed\");\n-            editCard();\n-            return true;\n-        } else if (itemId == R.id.action_bury) {\n-            Timber.i(\"Reviewer:: Bury button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Bury card due to no submenu\");\n-                buryCard();\n-            }\n-        } else if (itemId == R.id.action_suspend) {\n-            Timber.i(\"Reviewer:: Suspend button pressed\");\n-            if (!MenuItemCompat.getActionProvider(item).hasSubMenu()) {\n-                Timber.d(\"Suspend card due to no submenu\");\n-                suspendCard();\n-            }\n-        } else if (itemId == R.id.action_delete) {\n-            Timber.i(\"Reviewer:: Delete note button pressed\");\n-            showDeleteNoteDialog();\n-        } else if (itemId == R.id.action_change_whiteboard_pen_color) {\n-            Timber.i(\"Reviewer:: Pen Color button pressed\");\n-            if (mColorPalette.getVisibility() == View.GONE) {\n-                mColorPalette.setVisibility(View.VISIBLE);\n-            } else {\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else if (itemId == R.id.action_save_whiteboard) {\n-            Timber.i(\"Reviewer:: Save whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                try {\n-                    String savedWhiteboardFileName = mWhiteboard.saveWhiteboard(getCol().getTime()).getPath();\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_saved, savedWhiteboardFileName), true);\n-                } catch (Exception e) {\n-                    Timber.w(e);\n-                    UIUtils.showThemedToast(Reviewer.this, getString(R.string.white_board_image_save_failed, e.getLocalizedMessage()), true);\n-                }\n-            }\n-        } else if (itemId == R.id.action_clear_whiteboard) {\n-            Timber.i(\"Reviewer:: Clear whiteboard button pressed\");\n-            if (mWhiteboard != null) {\n-                mWhiteboard.clear();\n-            }\n-        } else if (itemId == R.id.action_hide_whiteboard) {// toggle whiteboard visibility\n-            Timber.i(\"Reviewer:: Whiteboard visibility set to %b\", !mShowWhiteboard);\n-            setWhiteboardVisibility(!mShowWhiteboard);\n-            refreshActionBar();\n-        } else if (itemId == R.id.action_toggle_whiteboard) {\n-            toggleWhiteboard();\n-        } else if (itemId == R.id.action_search_dictionary) {\n-            Timber.i(\"Reviewer:: Search dictionary button pressed\");\n-            lookUpOrSelectText();\n-        } else if (itemId == R.id.action_open_deck_options) {\n-            Intent i = new Intent(this, DeckOptions.class);\n-            startActivityForResultWithAnimation(i, DECK_OPTIONS, FADE);\n-        } else if (itemId == R.id.action_select_tts) {\n-            Timber.i(\"Reviewer:: Select TTS button pressed\");\n-            showSelectTtsDialogue();\n-        } else if (itemId == R.id.action_add_note_reviewer) {\n-            Timber.i(\"Reviewer:: Add note button pressed\");\n-            addNote();\n-        } else if (itemId == R.id.action_flag_zero) {\n-            Timber.i(\"Reviewer:: No flag\");\n-            onFlag(mCurrentCard, FLAG_NONE);\n-        } else if (itemId == R.id.action_flag_one) {\n-            Timber.i(\"Reviewer:: Flag one\");\n-            onFlag(mCurrentCard, FLAG_RED);\n-        } else if (itemId == R.id.action_flag_two) {\n-            Timber.i(\"Reviewer:: Flag two\");\n-            onFlag(mCurrentCard, FLAG_ORANGE);\n-        } else if (itemId == R.id.action_flag_three) {\n-            Timber.i(\"Reviewer:: Flag three\");\n-            onFlag(mCurrentCard, FLAG_GREEN);\n-        } else if (itemId == R.id.action_flag_four) {\n-            Timber.i(\"Reviewer:: Flag four\");\n-            onFlag(mCurrentCard, FLAG_BLUE);\n-        } else if (itemId == R.id.action_flag_five) {\n-            Timber.i(\"Reviewer:: Flag five\");\n-            onFlag(mCurrentCard, FLAG_PINK);\n-        } else if (itemId == R.id.action_flag_six) {\n-            Timber.i(\"Reviewer:: Flag six\");\n-            onFlag(mCurrentCard, FLAG_TURQUOISE);\n-        } else if (itemId == R.id.action_flag_seven) {\n-            Timber.i(\"Reviewer:: Flag seven\");\n-            onFlag(mCurrentCard, FLAG_PURPLE);\n-        } else if (itemId == R.id.action_card_info) {\n-            Timber.i(\"Card Viewer:: Card Info\");\n-            openCardInfo();\n-        } else {\n-            return super.onOptionsItemSelected(item);\n-        }\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void toggleWhiteboard() {\n-        mPrefWhiteboard = ! mPrefWhiteboard;\n-        Timber.i(\"Reviewer:: Whiteboard enabled state set to %b\", mPrefWhiteboard);\n-        //Even though the visibility is now stored in its own setting, we want it to be dependent\n-        //on the enabled status\n-        setWhiteboardEnabledState(mPrefWhiteboard);\n-        setWhiteboardVisibility(mPrefWhiteboard);\n-        if (!mPrefWhiteboard) {\n-            mColorPalette.setVisibility(View.GONE);\n-        }\n-        refreshActionBar();\n-    }\n-\n-\n-    @Override\n-    protected void replayVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        // COULD_BE_BETTER: this shows \"Failed\" if nothing was recorded\n-\n-        mMicToolBar.togglePlay();\n-    }\n-\n-\n-    @Override\n-    protected void recordVoice() {\n-        if (!openMicToolbar()) {\n-            return;\n-        }\n-\n-        mMicToolBar.toggleRecord();\n-    }\n-\n-\n-    /**\n-     *\n-     * @return Whether the mic toolbar is usable\n-     */\n-    @SuppressWarnings(\"BooleanMethodIsAlwaysInverted\")\n-    @VisibleForTesting\n-    public boolean openMicToolbar() {\n-        if (mMicToolBar == null || mMicToolBar.getVisibility() != View.VISIBLE) {\n-            openOrToggleMicToolbar();\n-        }\n-        return mMicToolBar != null;\n-    }\n-\n-\n-    protected void openOrToggleMicToolbar() {\n-        if (!Permissions.canRecordAudio(this)) {\n-            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.RECORD_AUDIO},\n-                    REQUEST_AUDIO_PERMISSION);\n-        } else {\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-\n-    private void toggleMicToolBar() {\n-        if (mMicToolBar != null) {\n-            // It exists swap visibility status\n-            if (mMicToolBar.getVisibility() != View.VISIBLE) {\n-                mMicToolBar.setVisibility(View.VISIBLE);\n-            } else {\n-                mMicToolBar.setVisibility(View.GONE);\n-            }\n-        } else {\n-            // Record mic tool bar does not exist yet\n-            mTempAudioPath = AudioView.generateTempAudioFile(this);\n-            if (mTempAudioPath == null) {\n-                return;\n-            }\n-            mMicToolBar = AudioView.createRecorderInstance(this, R.drawable.ic_play_arrow_white_24dp, R.drawable.ic_pause_white_24dp,\n-                        R.drawable.ic_stop_white_24dp, R.drawable.ic_rec, R.drawable.ic_rec_stop, mTempAudioPath);\n-            if (mMicToolBar == null) {\n-                mTempAudioPath = null;\n-                return;\n-            }\n-            FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                    ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-            mMicToolBar.setLayoutParams(lp2);\n-            LinearLayout micToolBarLayer = findViewById(R.id.mic_tool_bar_layer);\n-            micToolBarLayer.addView(mMicToolBar);\n-        }\n-    }\n-\n-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n-        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n-        if ((requestCode == REQUEST_AUDIO_PERMISSION) &&\n-                (permissions.length >= 1) && (grantResults[0] == PackageManager.PERMISSION_GRANTED)) {\n-            // Get get audio record permission, so we can create the record tool bar\n-            toggleMicToolBar();\n-        }\n-    }\n-\n-    private void showRescheduleCardDialog() {\n-        Consumer<Integer> runnable = days ->\n-            TaskManager.launchCollectionTask(new CollectionTask.RescheduleCards(Collections.singletonList(mCurrentCard.getId()), days), new ScheduleCollectionTaskListener(R.plurals.reschedule_cards_dialog_acknowledge));\n-        RescheduleDialog dialog = RescheduleDialog.rescheduleSingleCard(getResources(), mCurrentCard, runnable);\n-\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void showResetCardDialog() {\n-        // Show confirmation dialog before resetting card progress\n-        Timber.i(\"showResetCardDialog() Reset progress button pressed\");\n-        // Show confirmation dialog before resetting card progress\n-        ConfirmationDialog dialog = new ConfirmationDialog();\n-        String title = getResources().getString(R.string.reset_card_dialog_title);\n-        String message = getResources().getString(R.string.reset_card_dialog_message);\n-        dialog.setArgs(title, message);\n-        Runnable confirm = () -> {\n-            Timber.i(\"NoteEditor:: ResetProgress button pressed\");\n-            TaskManager.launchCollectionTask(new CollectionTask.ResetCards(Collections.singletonList(mCurrentCard.getId())),\n-                    new ScheduleCollectionTaskListener(R.plurals.reset_cards_dialog_acknowledge));\n-        };\n-        dialog.setConfirm(confirm);\n-        showDialogFragment(dialog);\n-    }\n-\n-\n-    private void addNote() {\n-        Intent intent = new Intent(this, NoteEditor.class);\n-        intent.putExtra(NoteEditor.EXTRA_CALLER, NoteEditor.CALLER_REVIEWER_ADD);\n-        startActivityForResultWithAnimation(intent, ADD_NOTE, START);\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public boolean onMenuOpened(int featureId, Menu menu) {\n-        new Handler().post(() -> {\n-            for (int i = 0; i < menu.size(); i++) {\n-                MenuItem menuItem = menu.getItem(i);\n-                shouldUseDefaultColor(menuItem);\n-            }\n-        });\n-        return super.onMenuOpened(featureId, menu);\n-    }\n-\n-    /**\n-     * This Method changes the color of icon if user taps in overflow button.\n-     */\n-    private void shouldUseDefaultColor(MenuItem menuItem) {\n-        Drawable drawable = menuItem.getIcon();\n-\n-        if (drawable != null && !menuItem.hasSubMenu() && !isFlagResource(menuItem.getItemId())) {\n-            drawable.mutate();\n-            drawable.setTint(ResourcesCompat.getColor(getResources(), R.color.material_blue_600, null));\n-        }\n-    }\n-\n-\n-    @Override\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    public void onPanelClosed(int featureId, @NonNull Menu menu) {\n-        new Handler().postDelayed(this::refreshActionBar, 100);\n-    }\n-\n-    @Override\n-    public boolean onCreateOptionsMenu(Menu menu) {\n-        // NOTE: This is called every time a new question is shown via invalidate options menu\n-        getMenuInflater().inflate(R.menu.reviewer, menu);\n-\n-        displayIconsOnTv(menu);\n-        displayIcons(menu);\n-\n-        mActionButtons.setCustomButtonsStatus(menu);\n-        int alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem markCardIcon = menu.findItem(R.id.action_mark_card);\n-        if (mCurrentCard != null && mCurrentCard.note().hasTag(\"marked\")) {\n-            markCardIcon.setTitle(R.string.menu_unmark_note).setIcon(R.drawable.ic_star_white);\n-        } else {\n-            markCardIcon.setTitle(R.string.menu_mark_note).setIcon(R.drawable.ic_star_border_white);\n-        }\n-        markCardIcon.getIcon().mutate().setAlpha(alpha);\n-\n-        // 1643 - currently null on a TV\n-        @Nullable MenuItem flag_icon = menu.findItem(R.id.action_flag);\n-        if (flag_icon != null) {\n-            if (mCurrentCard != null) {\n-                switch (mCurrentCard.userFlag()) {\n-                    case 1:\n-                        flag_icon.setIcon(R.drawable.ic_flag_red);\n-                        break;\n-                    case 2:\n-                        flag_icon.setIcon(R.drawable.ic_flag_orange);\n-                        break;\n-                    case 3:\n-                        flag_icon.setIcon(R.drawable.ic_flag_green);\n-                        break;\n-                    case 4:\n-                        flag_icon.setIcon(R.drawable.ic_flag_blue);\n-                        break;\n-                    case 5:\n-                        flag_icon.setIcon(R.drawable.ic_flag_pink);\n-                        break;\n-                    case 6:\n-                        flag_icon.setIcon(R.drawable.ic_flag_turquoise);\n-                        break;\n-                    case 7:\n-                        flag_icon.setIcon(R.drawable.ic_flag_purple);\n-                        break;\n-                    default:\n-                        flag_icon.setIcon(R.drawable.ic_flag_transparent);\n-                        break;\n-                }\n-            }\n-            flag_icon.getIcon().mutate().setAlpha(alpha);\n-        }\n-\n-        // Undo button\n-        @DrawableRes int undoIconId;\n-        boolean undoEnabled;\n-        if (mShowWhiteboard && mWhiteboard != null && mWhiteboard.isUndoModeActive()) {\n-            // Whiteboard is here and strokes have been added at some point\n-            undoIconId = R.drawable.eraser;\n-            undoEnabled = !mWhiteboard.undoEmpty();\n-        } else {\n-            // We can arrive here even if `mShowWhiteboard &&\n-            // mWhiteboard != null` if no stroke had ever been made\n-            undoIconId = R.drawable.ic_undo_white;\n-            undoEnabled = (colIsOpen() && getCol().undoAvailable());\n-        }\n-        int alpha_undo = (undoEnabled && getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        MenuItem undoIcon = menu.findItem(R.id.action_undo);\n-        undoIcon.setIcon(undoIconId);\n-        undoIcon.setEnabled(undoEnabled).getIcon().mutate().setAlpha(alpha_undo);\n-        undoIcon.getActionView().setEnabled(undoEnabled);\n-        if (colIsOpen()) { // Required mostly because there are tests where `col` is null\n-            undoIcon.setTitle(getResources().getString(R.string.studyoptions_congrats_undo, getCol().undoName(getResources())));\n-        }\n-\n-        if (undoEnabled) {\n-            mOnboarding.onUndoButtonEnabled();\n-        }\n-\n-        MenuItem toggle_whiteboard_icon = menu.findItem(R.id.action_toggle_whiteboard);\n-        MenuItem hide_whiteboard_icon = menu.findItem(R.id.action_hide_whiteboard);\n-        MenuItem change_pen_color_icon = menu.findItem(R.id.action_change_whiteboard_pen_color);\n-        // White board button\n-        if (mPrefWhiteboard) {\n-            // Configure the whiteboard related items in the action bar\n-            toggle_whiteboard_icon.setTitle(R.string.disable_whiteboard);\n-            // Always allow \"Disable Whiteboard\", even if \"Enable Whiteboard\" is disabled\n-            toggle_whiteboard_icon.setVisible(true);\n-\n-            if (!mActionButtons.getStatus().hideWhiteboardIsDisabled()) {\n-                hide_whiteboard_icon.setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().clearWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_clear_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().saveWhiteboardIsDisabled()) {\n-                menu.findItem(R.id.action_save_whiteboard).setVisible(true);\n-            }\n-            if (!mActionButtons.getStatus().whiteboardPenColorIsDisabled()) {\n-                change_pen_color_icon.setVisible(true);\n-            }\n-\n-            Drawable whiteboardIcon = ContextCompat.getDrawable(this, R.drawable.ic_gesture_white).mutate();\n-            Drawable whiteboardColorPaletteIcon = VectorDrawableCompat.create(getResources(), R.drawable.ic_color_lens_white_24dp, null).mutate();\n-\n-            if (mShowWhiteboard) {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.hide_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_ENABLED_LIGHT);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-            } else {\n-                whiteboardIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                hide_whiteboard_icon.setIcon(whiteboardIcon);\n-                hide_whiteboard_icon.setTitle(R.string.show_whiteboard);\n-\n-                whiteboardColorPaletteIcon.setAlpha(Themes.ALPHA_ICON_DISABLED_LIGHT);\n-                change_pen_color_icon.setEnabled(false);\n-                change_pen_color_icon.setIcon(whiteboardColorPaletteIcon);\n-                mColorPalette.setVisibility(View.GONE);\n-            }\n-        } else {\n-            toggle_whiteboard_icon.setTitle(R.string.enable_whiteboard);\n-        }\n-        if (colIsOpen() && getCol().getDecks().isDyn(getParentDid())) {\n-            menu.findItem(R.id.action_open_deck_options).setVisible(false);\n-        }\n-        if (mSpeakText && !mActionButtons.getStatus().selectTtsIsDisabled()) {\n-            menu.findItem(R.id.action_select_tts).setVisible(true);\n-        }\n-        // Setup bury / suspend providers\n-        MenuItem suspend_icon = menu.findItem(R.id.action_suspend);\n-        MenuItem bury_icon = menu.findItem(R.id.action_bury);\n-\n-        setupSubMenu(menu, R.id.action_suspend, new SuspendProvider(this));\n-        setupSubMenu(menu, R.id.action_bury, new BuryProvider(this));\n-        if (suspendNoteAvailable()) {\n-            suspend_icon.setIcon(R.drawable.ic_action_suspend_dropdown);\n-            suspend_icon.setTitle(R.string.menu_suspend);\n-        } else {\n-            suspend_icon.setIcon(R.drawable.ic_pause_circle_outline);\n-            suspend_icon.setTitle(R.string.menu_suspend_card);\n-        }\n-        if (buryNoteAvailable()) {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_dropdown);\n-            bury_icon.setTitle(R.string.menu_bury);\n-        } else {\n-            bury_icon.setIcon(R.drawable.ic_flip_to_back_white);\n-            bury_icon.setTitle(R.string.menu_bury_card);\n-        }\n-        alpha = (getControlBlocked() != ReviewerUi.ControlBlock.SLOW) ? Themes.ALPHA_ICON_ENABLED_LIGHT : Themes.ALPHA_ICON_DISABLED_LIGHT ;\n-        bury_icon.getIcon().mutate().setAlpha(alpha);\n-        suspend_icon.getIcon().mutate().setAlpha(alpha);\n-\n-        setupSubMenu(menu, R.id.action_schedule, new ScheduleProvider(this));\n-        mOnboarding.onCreate();\n-        return super.onCreateOptionsMenu(menu);\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\")\n-    private void displayIcons(Menu menu) {\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-        }catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons in Over flow menu\");\n-        }\n-    }\n-\n-\n-    @SuppressLint(\"RestrictedApi\") // setOptionalIconsVisible\n-    private void displayIconsOnTv(Menu menu) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return;\n-        }\n-\n-        try {\n-            if (menu instanceof MenuBuilder) {\n-                MenuBuilder m = (MenuBuilder) menu;\n-                m.setOptionalIconsVisible(true);\n-            }\n-\n-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n-                for (int i = 0; i < menu.size(); i++) {\n-                    MenuItem m = menu.getItem(i);\n-\n-                    if (m == null || isFlagResource(m.getItemId())) {\n-                        continue;\n-                    }\n-\n-                    int color = Themes.getColorFromAttr(this, R.attr.navDrawerItemColor);\n-                    MenuItemCompat.setIconTintList(m, ColorStateList.valueOf(color));\n-                }\n-            }\n-\n-        } catch (Exception | Error e) {\n-            Timber.w(e, \"Failed to display icons\");\n-        }\n-    }\n-\n-\n-    private boolean isFlagResource(int itemId) {\n-        return itemId == R.id.action_flag_seven\n-                || itemId == R.id.action_flag_six\n-                || itemId == R.id.action_flag_five\n-                || itemId == R.id.action_flag_four\n-                || itemId == R.id.action_flag_three\n-                || itemId == R.id.action_flag_two\n-                || itemId == R.id.action_flag_one;\n-    }\n-    @Override\n-    public boolean onKeyDown(int keyCode, KeyEvent event) {\n-        if (answerFieldIsFocused()) {\n-            return super.onKeyDown(keyCode, event);\n-        }\n-\n-        if (mProcessor.onKeyDown(keyCode, event) || super.onKeyDown(keyCode, event)) {\n-            return true;\n-        }\n-\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            return false;\n-        }\n-\n-        // Process DPAD Up/Down to focus the TV Controls\n-        if (keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_DPAD_UP) {\n-            return false;\n-        }\n-\n-        // HACK: This shouldn't be required, as the navigation should handle this.\n-        if (isDrawerOpen()) {\n-            return false;\n-        }\n-\n-\n-        View view = keyCode == KeyEvent.KEYCODE_DPAD_UP ? findViewById(R.id.tv_nav_view) : findViewById(R.id.answer_options_layout);\n-        // HACK: We should be performing this in the base class, or allowing the view to be focused by the keyboard.\n-        // I couldn't get either to work\n-        if (view == null) {\n-            return false;\n-        }\n-\n-        view.requestFocus();\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean onKeyUp(int keyCode, KeyEvent event) {\n-        if (mProcessor.onKeyUp(keyCode, event)) {\n-            return true;\n-        }\n-        return super.onKeyUp(keyCode, event);\n-    }\n-\n-\n-    private <T extends ActionProvider & SubMenuProvider> void setupSubMenu(Menu menu, @IdRes int parentMenu, T subMenuProvider) {\n-        if (!AndroidUiUtils.isRunningOnTv(this)) {\n-            MenuItemCompat.setActionProvider(menu.findItem(parentMenu), subMenuProvider);\n-            return;\n-        }\n-\n-        // Don't do anything if the menu is hidden (bury for example)\n-        if (!subMenuProvider.hasSubMenu()) {\n-            return;\n-        }\n-\n-        // 7227 - If we're running on a TV, then we can't show submenus until AOSP is fixed\n-        menu.removeItem(parentMenu);\n-        int count = menu.size();\n-        // move the menu to the bottom of the page\n-        getMenuInflater().inflate(subMenuProvider.getSubMenu(), menu);\n-        for (int i = 0; i < menu.size() - count; i++) {\n-            MenuItem item = menu.getItem(count + i);\n-            item.setOnMenuItemClickListener(subMenuProvider);\n-        }\n-    }\n-\n-\n-    @Override\n-    protected boolean canAccessScheduler() {\n-        return true;\n-    }\n-\n-\n-    @Override\n-    protected void performReload() {\n-        getCol().getSched().deferReset();\n-        TaskManager.launchCollectionTask(new CollectionTask.GetCard(), new AnswerCardHandler(false));\n-    }\n-\n-\n-    @Override\n-    protected void displayAnswerBottomBar() {\n-        super.displayAnswerBottomBar();\n-        mOnboarding.onAnswerShown();\n-        int buttonCount;\n-        try {\n-            buttonCount = mSched.answerButtons(mCurrentCard);\n-        } catch (RuntimeException e) {\n-            AnkiDroidApp.sendExceptionReport(e, \"AbstractReviewer-showEaseButtons\");\n-            closeReviewer(DeckPicker.RESULT_DB_ERROR, true);\n-            return;\n-        }\n-\n-        // Set correct label and background resource for each button\n-        // Note that it's necessary to set the resource dynamically as the ease2 / ease3 buttons\n-        // (which libanki expects ease to be 2 and 3) can either be hard, good, or easy - depending on num buttons shown\n-        int[] backgroundIds;\n-        if (animationEnabled()) {\n-            backgroundIds = new int [] {\n-                    R.attr.againButtonRippleRef,\n-                    R.attr.hardButtonRippleRef,\n-                    R.attr.goodButtonRippleRef,\n-                    R.attr.easyButtonRippleRef};\n-        } else {\n-            backgroundIds = new int [] {\n-                    R.attr.againButtonRef,\n-                    R.attr.hardButtonRef,\n-                    R.attr.goodButtonRef,\n-                    R.attr.easyButtonRef};\n-        }\n-        final int[] background = Themes.getResFromAttr(this, backgroundIds);\n-        final int[] textColor = Themes.getColorFromAttr(this, new int [] {\n-                R.attr.againButtonTextColor,\n-                R.attr.hardButtonTextColor,\n-                R.attr.goodButtonTextColor,\n-                R.attr.easyButtonTextColor});\n-        mEase1Layout.setVisibility(View.VISIBLE);\n-        mEase1Layout.setBackgroundResource(background[0]);\n-        mEase4Layout.setBackgroundResource(background[3]);\n-        switch (buttonCount) {\n-            case 2:\n-                // Ease 2 is \"good\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            case 3:\n-                // Ease 2 is good\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[2]);\n-                mEase2.setText(R.string.ease_button_good);\n-                mEase2.setTextColor(textColor[2]);\n-                mNext2.setTextColor(textColor[2]);\n-                // Ease 3 is easy\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[3]);\n-                mEase3.setText(R.string.ease_button_easy);\n-                mEase3.setTextColor(textColor[3]);\n-                mNext3.setTextColor(textColor[3]);\n-                mEase2Layout.requestFocus();\n-                break;\n-            default:\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                // Ease 2 is \"hard\"\n-                mEase2Layout.setVisibility(View.VISIBLE);\n-                mEase2Layout.setBackgroundResource(background[1]);\n-                mEase2.setText(R.string.ease_button_hard);\n-                mEase2.setTextColor(textColor[1]);\n-                mNext2.setTextColor(textColor[1]);\n-                mEase2Layout.requestFocus();\n-                // Ease 3 is good\n-                mEase3Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.setBackgroundResource(background[2]);\n-                mEase3.setText(R.string.ease_button_good);\n-                mEase3.setTextColor(textColor[2]);\n-                mNext3.setTextColor(textColor[2]);\n-                mEase4Layout.setVisibility(View.VISIBLE);\n-                mEase3Layout.requestFocus();\n-                break;\n-        }\n-\n-        // Show next review time\n-        if (shouldShowNextReviewTime()) {\n-            mNext1.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_ONE));\n-            mNext2.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_TWO));\n-            if (buttonCount > 2) {\n-                mNext3.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_THREE));\n-            }\n-            if (buttonCount > 3) {\n-                mNext4.setText(mSched.nextIvlStr(this, mCurrentCard, Consts.BUTTON_FOUR));\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected SharedPreferences restorePreferences() {\n-        SharedPreferences preferences = super.restorePreferences();\n-        mPrefHideDueCount = preferences.getBoolean(\"hideDueCount\", false);\n-        mPrefShowETA = preferences.getBoolean(\"showETA\", true);\n-        this.mProcessor.setup();\n-        mPrefFullscreenReview = FullScreenMode.isFullScreenReview(preferences);\n-        mActionButtons.setup(preferences);\n-        return preferences;\n-    }\n-\n-    @Override\n-    protected void updateActionBar() {\n-        super.updateActionBar();\n-        updateScreenCounts();\n-    }\n-\n-    protected void updateScreenCounts() {\n-        if (mCurrentCard == null) return;\n-        super.updateActionBar();\n-        ActionBar actionBar = getSupportActionBar();\n-        Counts counts = mSched.counts(mCurrentCard);\n-\n-        if (actionBar != null) {\n-            if (mPrefShowETA) {\n-                mEta = mSched.eta(counts, false);\n-                actionBar.setSubtitle(Utils.remainingTime(AnkiDroidApp.getInstance(), mEta * 60));\n-            }\n-        }\n-\n-\n-        mNewCount = new SpannableString(String.valueOf(counts.getNew()));\n-        mLrnCount = new SpannableString(String.valueOf(counts.getLrn()));\n-        mRevCount = new SpannableString(String.valueOf(counts.getRev()));\n-        if (mPrefHideDueCount) {\n-            mRevCount = new SpannableString(\"???\");\n-        }\n-\n-        switch (mSched.countIdx(mCurrentCard)) {\n-            case NEW:\n-                mNewCount.setSpan(new UnderlineSpan(), 0, mNewCount.length(), 0);\n-                break;\n-            case LRN:\n-                mLrnCount.setSpan(new UnderlineSpan(), 0, mLrnCount.length(), 0);\n-                break;\n-            case REV:\n-                mRevCount.setSpan(new UnderlineSpan(), 0, mRevCount.length(), 0);\n-                break;\n-            default:\n-                Timber.w(\"Unknown card type %s\", mSched.countIdx(mCurrentCard));\n-                break;\n-        }\n-\n-        mTextBarNew.setText(mNewCount);\n-        mTextBarLearn.setText(mLrnCount);\n-        mTextBarReview.setText(mRevCount);\n-    }\n-\n-    @Override\n-    public void fillFlashcard() {\n-        super.fillFlashcard();\n-        if (!sDisplayAnswer && mShowWhiteboard && mWhiteboard != null) {\n-            mWhiteboard.clear();\n-        }\n-    }\n-\n-\n-    @Override\n-    public void displayCardQuestion() {\n-        // show timer, if activated in the deck's preferences\n-        initTimer();\n-        delayedHide(100);\n-        super.displayCardQuestion();\n-    }\n-\n-    @Override\n-    protected void displayCardAnswer() {\n-        delayedHide(100);\n-        super.displayCardAnswer();\n-    }\n-\n-    @Override\n-    protected void initLayout() {\n-        mTextBarNew = findViewById(R.id.new_number);\n-        mTextBarLearn = findViewById(R.id.learn_number);\n-        mTextBarReview = findViewById(R.id.review_number);\n-\n-        super.initLayout();\n-\n-        if (!mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.GONE);\n-            mTextBarLearn.setVisibility(View.GONE);\n-            mTextBarReview.setVisibility(View.GONE);\n-        }\n-    }\n-\n-    @Override\n-    protected void switchTopBarVisibility(int visible) {\n-        super.switchTopBarVisibility(visible);\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(visible);\n-            mTextBarLearn.setVisibility(visible);\n-            mTextBarReview.setVisibility(visible);\n-        }\n-    }\n-\n-    @Override\n-    protected void onStop() {\n-        super.onStop();\n-\n-        if (!isFinishing() && colIsOpen() && mSched != null) {\n-            WidgetStatus.update(this);\n-        }\n-        UIUtils.saveCollectionInBackground();\n-    }\n-\n-\n-    @Override\n-    protected void initControls() {\n-        super.initControls();\n-        if (mPrefWhiteboard) {\n-            setWhiteboardVisibility(mShowWhiteboard);\n-        }\n-        if (mShowRemainingCardCount) {\n-            mTextBarNew.setVisibility(View.VISIBLE);\n-            mTextBarLearn.setVisibility(View.VISIBLE);\n-            mTextBarReview.setVisibility(View.VISIBLE);\n-        }\n-    }\n-\n-    protected void restoreCollectionPreferences() {\n-        super.restoreCollectionPreferences();\n-        mShowRemainingCardCount = getCol().get_config_boolean(\"dueCounts\");\n-    }\n-\n-    @Override\n-    protected boolean onSingleTap() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    protected void onFling() {\n-        if (mPrefFullscreenReview && isImmersiveSystemUiVisible(this)) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") //  #7111: new Handler()\n-    protected final Handler mFullScreenHandler = new Handler() {\n-        @Override\n-        public void handleMessage(Message msg) {\n-            if (mPrefFullscreenReview) {\n-                setFullScreen(Reviewer.this);\n-            }\n-        }\n-    };\n-\n-    /** Hide the navigation if in full-screen mode after a given period of time */\n-    protected void delayedHide(int delayMillis) {\n-        Timber.d(\"Fullscreen delayed hide in %dms\", delayMillis);\n-        mFullScreenHandler.removeMessages(0);\n-        mFullScreenHandler.sendEmptyMessageDelayed(0, delayMillis);\n-    }\n-\n-\n-    private void setWhiteboardEnabledState(boolean state) {\n-        mPrefWhiteboard = state;\n-        MetaDB.storeWhiteboardState(this, getParentDid(), state);\n-        if (state && mWhiteboard == null) {\n-            createWhiteboard();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private void setFullScreen(final AbstractFlashcardViewer a) {\n-        // Set appropriate flags to enable Sticky Immersive mode.\n-        a.getWindow().getDecorView().setSystemUiVisibility(\n-                View.SYSTEM_UI_FLAG_LAYOUT_STABLE\n-                        //| View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION // temporarily disabled due to #5245\n-                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\n-                        | View.SYSTEM_UI_FLAG_FULLSCREEN\n-                        | View.SYSTEM_UI_FLAG_LOW_PROFILE\n-                        | View.SYSTEM_UI_FLAG_IMMERSIVE\n-        );\n-        // Show / hide the Action bar together with the status bar\n-        SharedPreferences prefs = AnkiDroidApp.getSharedPrefs(a);\n-        FullScreenMode fullscreenMode = FullScreenMode.fromPreference(prefs);\n-        a.getWindow().setStatusBarColor(Themes.getColorFromAttr(a, R.attr.colorPrimaryDark));\n-        View decorView = a.getWindow().getDecorView();\n-        decorView.setOnSystemUiVisibilityChangeListener\n-                (flags -> {\n-                    final View toolbar = a.findViewById(R.id.toolbar);\n-                    final View answerButtons = a.findViewById(R.id.answer_options_layout);\n-                    final View topbar = a.findViewById(R.id.top_bar);\n-                    if (toolbar == null || topbar == null || answerButtons == null) {\n-                        return;\n-                    }\n-                    // Note that system bars will only be \"visible\" if none of the\n-                    // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set.\n-                    boolean visible = (flags & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-                    Timber.d(\"System UI visibility change. Visible: %b\", visible);\n-                    if (visible) {\n-                        showViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            showViewWithAnimation(topbar);\n-                            showViewWithAnimation(answerButtons);\n-                        }\n-                    } else {\n-                        hideViewWithAnimation(toolbar);\n-                        if (fullscreenMode.equals(FullScreenMode.FULLSCREEN_ALL_GONE)) {\n-                            hideViewWithAnimation(topbar);\n-                            hideViewWithAnimation(answerButtons);\n-                        }\n-                    }\n-                });\n-    }\n-\n-    private static final int ANIMATION_DURATION = 200;\n-    private static final float TRANSPARENCY = 0.90f;\n-\n-\n-    private void showViewWithAnimation(final View view) {\n-        view.setAlpha(0.0f);\n-        view.setVisibility(View.VISIBLE);\n-        view.animate().alpha(TRANSPARENCY).setDuration(ANIMATION_DURATION).setListener(null);\n-    }\n-\n-    private void hideViewWithAnimation(final View view) {\n-        view.animate()\n-                .alpha(0f)\n-                .setDuration(ANIMATION_DURATION)\n-                .setListener(new AnimatorListenerAdapter() {\n-                    @Override\n-                    public void onAnimationEnd(Animator animation) {\n-                        view.setVisibility(View.GONE);\n-                    }\n-                });\n-    }\n-\n-    @SuppressWarnings(\"deprecation\") // #9332: UI Visibility -> Insets\n-    private boolean isImmersiveSystemUiVisible(AnkiActivity activity) {\n-        return (activity.getWindow().getDecorView().getSystemUiVisibility() & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;\n-    }\n-\n-    private void createWhiteboard() {\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(this);\n-        mWhiteboard = Whiteboard.createInstance(this, true, this);\n-\n-        // We use the pen color of the selected deck at the time the whiteboard is enabled.\n-        // This is how all other whiteboard settings are\n-        Integer whiteboardPenColor = MetaDB.getWhiteboardPenColor(this, getParentDid()).fromPreferences(sharedPrefs);\n-        if (whiteboardPenColor != null) {\n-            mWhiteboard.setPenColor(whiteboardPenColor);\n-        }\n-\n-        mWhiteboard.setOnPaintColorChangeListener(color -> MetaDB.storeWhiteboardPenColor(this, getParentDid(), !CardAppearance.isInNightMode(sharedPrefs), color));\n-\n-        mWhiteboard.setOnTouchListener((v, event) -> {\n-            //If the whiteboard is currently drawing, and triggers the system UI to show, we want to continue drawing.\n-            if (!mWhiteboard.isCurrentlyDrawing() && (!mShowWhiteboard || (mPrefFullscreenReview\n-                    && isImmersiveSystemUiVisible(Reviewer.this)))) {\n-                // Bypass whiteboard listener when it's hidden or fullscreen immersive mode is temporarily suspended\n-                v.performClick();\n-                return getGestureDetector().onTouchEvent(event);\n-            }\n-            return mWhiteboard.handleTouchEvent(event);\n-        });\n-    }\n-\n-    // Show or hide the whiteboard\n-    private void setWhiteboardVisibility(boolean state) {\n-        mShowWhiteboard = state;\n-        MetaDB.storeWhiteboardVisibility(this, getParentDid(), state);\n-        if (state) {\n-            mWhiteboard.setVisibility(View.VISIBLE);\n-            disableDrawerSwipe();\n-        } else {\n-            mWhiteboard.setVisibility(View.GONE);\n-            if (!mHasDrawerSwipeConflicts) {\n-                enableDrawerSwipe();\n-            }\n-        }\n-    }\n-\n-\n-    private void disableDrawerSwipeOnConflicts() {\n-        if (mGestureProcessor.isBound(Gesture.SWIPE_UP, Gesture.SWIPE_DOWN, Gesture.SWIPE_RIGHT)) {\n-            mHasDrawerSwipeConflicts = true;\n-            super.disableDrawerSwipe();\n-        }\n-    }\n-\n-\n-    @Override\n-    protected Long getCurrentCardId() {\n-        return mCurrentCard.getId();\n-    }\n-\n-\n-    @Override\n-    public void onWindowFocusChanged(boolean hasFocus) {\n-        super.onWindowFocusChanged(hasFocus);\n-        // Restore full screen once we regain focus\n-        if (hasFocus) {\n-            delayedHide(INITIAL_HIDE_DELAY);\n-        } else {\n-            mFullScreenHandler.removeMessages(0);\n-        }\n-    }\n-\n-\n-    /**\n-     * Whether or not dismiss note is available for current card and specified DismissType\n-     * @return true if there is another card of same note that could be dismissed\n-     */\n-    private boolean suspendNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // whether there exists a sibling not buried.\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue != \" + Consts.QUEUE_TYPE_SUSPENDED + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-    private boolean buryNoteAvailable() {\n-        if (mCurrentCard == null || isControlBlocked()) {\n-            return false;\n-        }\n-        // Whether there exists a sibling which is neither susbended nor buried\n-        return getCol().getDb().queryScalar(\"select 1 from cards where nid = ? and id != ? and queue >=  \" + Consts.QUEUE_TYPE_NEW + \" limit 1\",\n-                mCurrentCard.getNid(), mCurrentCard.getId()) == 1;\n-    }\n-\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    @CheckResult\n-    Whiteboard getWhiteboard() {\n-        return mWhiteboard;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public AudioView getAudioView() {\n-        return mMicToolBar;\n-    }\n-\n-    @VisibleForTesting(otherwise = VisibleForTesting.NONE)\n-    public boolean hasDrawerSwipeConflicts() {\n-        return mHasDrawerSwipeConflicts;\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Suspend button\n-     */\n-    class SuspendProvider extends ActionProvider implements SubMenuProvider {\n-        public SuspendProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;  // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_suspend;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return suspendNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_suspend_card) {\n-                return suspendCard();\n-            } else if (itemId == R.id.action_suspend_note) {\n-                return suspendNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-    /**\n-     * Inner class which implements the submenu for the Bury button\n-     */\n-    class BuryProvider extends ActionProvider implements SubMenuProvider {\n-        public BuryProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_bury;\n-        }\n-\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return buryNoteAvailable();\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_bury_card) {\n-                return buryCard();\n-            } else if (itemId == R.id.action_bury_note) {\n-                return buryNote();\n-            }\n-            return false;\n-        }\n-    }\n-\n-\n-    /**\n-     * Inner class which implements the submenu for the Schedule button\n-     */\n-    class ScheduleProvider extends ActionProvider implements SubMenuProvider {\n-        public ScheduleProvider(Context context) {\n-            super(context);\n-        }\n-\n-        @Override\n-        public View onCreateActionView() {\n-            return null;    // Just return null for a simple dropdown menu\n-        }\n-\n-        @Override\n-        public boolean hasSubMenu() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void onPrepareSubMenu(SubMenu subMenu) {\n-            subMenu.clear();\n-            getMenuInflater().inflate(getSubMenu(), subMenu);\n-            for (int i = 0; i < subMenu.size(); i++) {\n-                subMenu.getItem(i).setOnMenuItemClickListener(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean onMenuItemClick(MenuItem item) {\n-            int itemId = item.getItemId();\n-            if (itemId == R.id.action_reschedule_card) {\n-                showRescheduleCardDialog();\n-                return true;\n-            } else if (itemId == R.id.action_reset_card_progress) {\n-                showResetCardDialog();\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-\n-        @Override\n-        public int getSubMenu() {\n-            return R.menu.reviewer_schedule;\n-        }\n-    }\n-\n-    private interface SubMenuProvider extends MenuItem.OnMenuItemClickListener {\n-        @MenuRes int getSubMenu();\n-        boolean hasSubMenu();\n-    }\n-\n-    public ReviewerJavaScriptFunction javaScriptFunction() {\n-        return new ReviewerJavaScriptFunction();\n-    }\n-\n-    public class ReviewerJavaScriptFunction extends JavaScriptFunction {\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetNewCardCount() {\n-            return mNewCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetLrnCardCount() {\n-            return mLrnCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public String ankiGetRevCardCount() {\n-            return mRevCount.toString();\n-        }\n-\n-        @JavascriptInterface\n-        @Override\n-        public int ankiGetETA() {\n-            return mEta;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc5OTA0MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r445799041", "body": "Implementer's choice: Can be shortened to: \r\n```suggestion\r\n        ((Button) cardViewer.findViewById(R.id.pen_color_white)).setOnClickListener(this::onClick);\r\n```", "bodyText": "Implementer's choice: Can be shortened to:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Button penColorWhite = (Button) cardViewer.findViewById(R.id.pen_color_white);\n          \n          \n            \n                    ((Button) cardViewer.findViewById(R.id.pen_color_white)).setOnClickListener(this::onClick);", "bodyHTML": "<p dir=\"auto\">Implementer's choice: Can be shortened to:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-smi x x-first\">Button</span><span class=\"x\"> penColorWhite </span><span class=\"pl-k x\">=</span><span class=\"x x-last\"> (</span><span class=\"pl-smi\">Button</span>) cardViewer<span class=\"pl-k\">.</span>findViewById(<span class=\"pl-smi\">R</span><span class=\"pl-k\">.</span>id<span class=\"pl-k\">.</span>pen_color_white);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"x x-first x-last\">((</span><span class=\"pl-smi\">Button</span>) cardViewer<span class=\"pl-k\">.</span>findViewById(<span class=\"pl-smi\">R</span><span class=\"pl-k\">.</span>id<span class=\"pl-k\">.</span>pen_color_white<span class=\"x x-first\">))</span><span class=\"pl-k x\">.</span><span class=\"x\">setOnClickListener(</span><span class=\"pl-c1 x\">this</span><span class=\"pl-k x\">::</span><span class=\"x x-last\">onClick</span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "david-allison-1", "createdAt": "2020-06-25T19:48:13Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -100,6 +103,22 @@ public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n+\n+        // selecting pen color to draw\n+        mColorPalette = (LinearLayout) cardViewer.findViewById(R.id.whiteboard_pen_color);\n+\n+        Button penColorWhite = (Button) cardViewer.findViewById(R.id.pen_color_white);", "originalCommit": "c8574991523c26f02fe367f6b0849a6458d2423d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "747d16ec6aaad628616dc017b33bd8e6ba8e0706", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 9aa2af251..1c4a154f2 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -103,22 +109,6 @@ public class Whiteboard extends View {\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = (LinearLayout) cardViewer.findViewById(R.id.whiteboard_pen_color);\n-\n-        Button penColorWhite = (Button) cardViewer.findViewById(R.id.pen_color_white);\n-        Button penColorBlack = (Button) cardViewer.findViewById(R.id.pen_color_black);\n-        Button penColorRed = (Button) cardViewer.findViewById(R.id.pen_color_red);\n-        Button penColorGreen = (Button) cardViewer.findViewById(R.id.pen_color_green);\n-        Button penColorBlue = (Button) cardViewer.findViewById(R.id.pen_color_blue);\n-        Button penColorYellow = (Button) cardViewer.findViewById(R.id.pen_color_yellow);\n-        penColorWhite.setOnClickListener(this::onClick);\n-        penColorBlack.setOnClickListener(this::onClick);\n-        penColorRed.setOnClickListener(this::onClick);\n-        penColorGreen.setOnClickListener(this::onClick);\n-        penColorBlue.setOnClickListener(this::onClick);\n-        penColorYellow.setOnClickListener(this::onClick);\n     }\n \n \n", "next_change": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 1c4a154f2..0f4fcd932 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -109,6 +112,16 @@ public class Whiteboard extends View {\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n+\n+        // selecting pen color to draw\n+        mColorPalette = (LinearLayout) cardViewer.findViewById(R.id.whiteboard_pen_color);\n+\n+        ((Button) cardViewer.findViewById(R.id.pen_color_white)).setOnClickListener(this::onClick);\n+        ((Button) cardViewer.findViewById(R.id.pen_color_black)).setOnClickListener(this::onClick);\n+        ((Button) cardViewer.findViewById(R.id.pen_color_red)).setOnClickListener(this::onClick);\n+        ((Button) cardViewer.findViewById(R.id.pen_color_green)).setOnClickListener(this::onClick);\n+        ((Button) cardViewer.findViewById(R.id.pen_color_blue)).setOnClickListener(this::onClick);\n+        ((Button) cardViewer.findViewById(R.id.pen_color_yellow)).setOnClickListener(this::onClick);\n     }\n \n \n", "next_change": {"commit": "42b92180120040299e590634f5b03d6f352c0a4f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 0f4fcd932..307bf13e0 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -114,14 +111,14 @@ public class Whiteboard extends View {\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = (LinearLayout) cardViewer.findViewById(R.id.whiteboard_pen_color);\n-\n-        ((Button) cardViewer.findViewById(R.id.pen_color_white)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_black)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_red)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_green)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_blue)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_yellow)).setOnClickListener(this::onClick);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+\n+        cardViewer.findViewById(R.id.pen_color_white).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_black).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n     }\n \n \n", "next_change": {"commit": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 307bf13e0..872c1de5f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -113,8 +119,6 @@ public class Whiteboard extends View {\n         // selecting pen color to draw\n         mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n \n-        cardViewer.findViewById(R.id.pen_color_white).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_black).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n", "next_change": {"commit": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 872c1de5f..bb9f12e33 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -96,35 +103,38 @@ public class Whiteboard extends View {\n         if (!inverted) {\n                 whitePenColorButton.setVisibility(View.GONE);\n                 blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n+                mForegroundColor = Color.BLACK;\n         } else {\n                 blackPenColorButton.setVisibility(View.GONE);\n                 whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n+                mForegroundColor = Color.WHITE;\n         }\n \n         mPaint = new Paint();\n         mPaint.setAntiAlias(true);\n         mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n+        mPaint.setColor(mForegroundColor);\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n+        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n \n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n     }\n \n+    public int getCurrentStrokeWidth() {\n+        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n+    }\n \n     @Override\n     protected void onDraw(Canvas canvas) {\n", "next_change": {"commit": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex bb9f12e33..9953065c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -136,6 +138,24 @@ public class Whiteboard extends View {\n         return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n     }\n \n+\n+    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n+\n+        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n+        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n+\n+        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n+                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n+\n+        whiteboard.setLayoutParams(lp2);\n+        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n+        fl.addView(whiteboard);\n+\n+        whiteboard.setEnabled(true);\n+\n+        return whiteboard;\n+    }\n+\n     @Override\n     protected void onDraw(Canvas canvas) {\n         super.onDraw(canvas);\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 9953065c7..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,634 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.net.Uri;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.isInNightMode;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-\n-    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n-\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n-        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n-\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-\n-        whiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n-        fl.addView(whiteboard);\n-\n-        whiteboard.setEnabled(true);\n-\n-        return whiteboard;\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mCardViewer.get(), getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mCardViewer.get()).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected Uri saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"oid": "bc30c1dab10e0e8a60623a76817589ad9961c113", "url": "https://github.com/ankidroid/Anki-Android/commit/bc30c1dab10e0e8a60623a76817589ad9961c113", "message": "Revert \"Fork Update\"", "committedDate": "2020-06-26T03:06:58Z", "type": "commit"}, {"oid": "6a3339cf2689a619dc96747fa51768c24f417c95", "url": "https://github.com/ankidroid/Anki-Android/commit/6a3339cf2689a619dc96747fa51768c24f417c95", "message": "\tUpdate fork", "committedDate": "2020-06-26T03:36:53Z", "type": "commit"}, {"oid": "e660d320dbe1da2d540725138ac3eab07d353f7f", "url": "https://github.com/ankidroid/Anki-Android/commit/e660d320dbe1da2d540725138ac3eab07d353f7f", "message": "Merge remote-tracking branch 'origin/master' into feature-pen-color", "committedDate": "2020-06-26T03:56:34Z", "type": "commit"}, {"oid": "a104048452cd6b64eccdea1081af0e215107e1a8", "url": "https://github.com/ankidroid/Anki-Android/commit/a104048452cd6b64eccdea1081af0e215107e1a8", "message": "\tUpdated", "committedDate": "2020-06-26T05:05:45Z", "type": "commit"}, {"oid": "a104048452cd6b64eccdea1081af0e215107e1a8", "url": "https://github.com/ankidroid/Anki-Android/commit/a104048452cd6b64eccdea1081af0e215107e1a8", "message": "\tUpdated", "committedDate": "2020-06-26T05:05:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyMTg0Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r446121842", "body": "Much nicer \ud83d\udc4d ", "bodyText": "Much nicer \ud83d\udc4d", "bodyHTML": "<p dir=\"auto\">Much nicer <g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png\">\ud83d\udc4d</g-emoji></p>", "author": "david-allison-1", "createdAt": "2020-06-26T11:15:36Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -109,6 +112,16 @@ public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted, boolean\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n+\n+        // selecting pen color to draw\n+        mColorPalette = (LinearLayout) cardViewer.findViewById(R.id.whiteboard_pen_color);\n+\n+        ((Button) cardViewer.findViewById(R.id.pen_color_white)).setOnClickListener(this::onClick);", "originalCommit": "a104048452cd6b64eccdea1081af0e215107e1a8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "42b92180120040299e590634f5b03d6f352c0a4f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 8a1f82ca0..307bf13e0 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -114,14 +111,14 @@ public class Whiteboard extends View {\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = (LinearLayout) cardViewer.findViewById(R.id.whiteboard_pen_color);\n-\n-        ((Button) cardViewer.findViewById(R.id.pen_color_white)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_black)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_red)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_green)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_blue)).setOnClickListener(this::onClick);\n-        ((Button) cardViewer.findViewById(R.id.pen_color_yellow)).setOnClickListener(this::onClick);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+\n+        cardViewer.findViewById(R.id.pen_color_white).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_black).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n     }\n \n \n", "next_change": {"commit": "8311d47fc2d4886fc62efef882fb2264e63fa4a5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 307bf13e0..872c1de5f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -113,8 +119,6 @@ public class Whiteboard extends View {\n         // selecting pen color to draw\n         mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n \n-        cardViewer.findViewById(R.id.pen_color_white).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_black).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n", "next_change": {"commit": "425701eb65d8f58267c2d289998fe33b5eeda3ba", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 872c1de5f..bb9f12e33 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -96,35 +103,38 @@ public class Whiteboard extends View {\n         if (!inverted) {\n                 whitePenColorButton.setVisibility(View.GONE);\n                 blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n+                mForegroundColor = Color.BLACK;\n         } else {\n                 blackPenColorButton.setVisibility(View.GONE);\n                 whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n+                mForegroundColor = Color.WHITE;\n         }\n \n         mPaint = new Paint();\n         mPaint.setAntiAlias(true);\n         mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n+        mPaint.setColor(mForegroundColor);\n         mPaint.setStyle(Paint.Style.STROKE);\n         mPaint.setStrokeJoin(Paint.Join.ROUND);\n         mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n+        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n         createBitmap();\n         mPath = new Path();\n         mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n \n         // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n+        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n \n         cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n         cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n+        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n     }\n \n+    public int getCurrentStrokeWidth() {\n+        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n+    }\n \n     @Override\n     protected void onDraw(Canvas canvas) {\n", "next_change": {"commit": "8d7a6813c88276d2c4d8d97d14e43996ebdf65fe", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex bb9f12e33..9953065c7 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -136,6 +138,24 @@ public class Whiteboard extends View {\n         return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n     }\n \n+\n+    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n+\n+        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n+        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n+\n+        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n+                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n+\n+        whiteboard.setLayoutParams(lp2);\n+        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n+        fl.addView(whiteboard);\n+\n+        whiteboard.setEnabled(true);\n+\n+        return whiteboard;\n+    }\n+\n     @Override\n     protected void onDraw(Canvas canvas) {\n         super.onDraw(canvas);\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 9953065c7..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,634 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.content.SharedPreferences;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.net.Uri;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.ViewGroup;\n-import android.widget.Button;\n-import android.widget.FrameLayout;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.anki.dialogs.WhiteBoardWidthDialog;\n-import com.ichi2.compat.CompatHelper;\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-import com.ichi2.utils.DisplayUtils;\n-\n-import java.io.FileNotFoundException;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-import static com.ichi2.anki.cardviewer.CardAppearance.isInNightMode;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int mForegroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                mForegroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(mForegroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        mPaint.setStrokeWidth((float) getCurrentStrokeWidth());\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_editor);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.stroke_width).setOnClickListener(this::onClick);\n-    }\n-\n-    public int getCurrentStrokeWidth() {\n-        return AnkiDroidApp.getSharedPrefs(mCardViewer.get()).getInt(\"whiteBoardStrokeWidth\", 6);\n-    }\n-\n-\n-    public static Whiteboard createInstance(AbstractFlashcardViewer cardViewer) {\n-\n-        SharedPreferences sharedPrefs = AnkiDroidApp.getSharedPrefs(cardViewer);\n-        Whiteboard whiteboard = new Whiteboard(cardViewer, isInNightMode(sharedPrefs));\n-\n-        FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(\n-                ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);\n-\n-        whiteboard.setLayoutParams(lp2);\n-        FrameLayout fl = cardViewer.findViewById(R.id.whiteboard);\n-        fl.addView(whiteboard);\n-\n-        whiteboard.setEnabled(true);\n-\n-        return whiteboard;\n-    }\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        return DisplayUtils.getDisplayDimensions(AnkiDroidApp.getInstance().getApplicationContext());\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        } else if (id == R.id.stroke_width) {\n-            handleWidthChangeDialog();\n-        }\n-    }\n-\n-\n-    private void handleWidthChangeDialog() {\n-        WhiteBoardWidthDialog whiteBoardWidthDialog = new WhiteBoardWidthDialog(mCardViewer.get(), getCurrentStrokeWidth());\n-        whiteBoardWidthDialog.onStrokeWidthChanged(this::saveStrokeWidth);\n-        whiteBoardWidthDialog.showStrokeWidthDialog();\n-    }\n-\n-    private void saveStrokeWidth(int wbStrokeWidth) {\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        SharedPreferences.Editor edit = AnkiDroidApp.getSharedPrefs(mCardViewer.get()).edit();\n-        edit.putInt(\"whiteBoardStrokeWidth\", wbStrokeWidth);\n-        edit.apply();\n-    }\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    protected Uri saveWhiteboard(Time time) throws FileNotFoundException {\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-        if (mForegroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-        this.draw(canvas);\n-        String baseFileName = \"Whiteboard\" + TimeUtils.getTimestamp(time);\n-        // TODO: Fix inconsistent CompressFormat 'JPEG' and file extension 'png'\n-        return CompatHelper.getCompat().saveImage(getContext(), bitmap, baseFileName, \"png\", Bitmap.CompressFormat.JPEG, 95);\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return mForegroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5NTYwMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r446395603", "body": "If we are using colors that do not have a universal definition, and we are using them both in Java and in XML I think we can define the RGB hex code in XML:\r\n\r\nhttps://developer.android.com/guide/topics/resources/more-resources#Color\r\n\r\nThen reference them by a single name to make sure the colors stay consistent - otherwise we repeat these constants instead of referring to a single definition", "bodyText": "If we are using colors that do not have a universal definition, and we are using them both in Java and in XML I think we can define the RGB hex code in XML:\nhttps://developer.android.com/guide/topics/resources/more-resources#Color\nThen reference them by a single name to make sure the colors stay consistent - otherwise we repeat these constants instead of referring to a single definition", "bodyHTML": "<p dir=\"auto\">If we are using colors that do not have a universal definition, and we are using them both in Java and in XML I think we can define the RGB hex code in XML:</p>\n<p dir=\"auto\"><a href=\"https://developer.android.com/guide/topics/resources/more-resources#Color\" rel=\"nofollow\">https://developer.android.com/guide/topics/resources/more-resources#Color</a></p>\n<p dir=\"auto\">Then reference them by a single name to make sure the colors stay consistent - otherwise we repeat these constants instead of referring to a single definition</p>", "author": "mikehardy", "createdAt": "2020-06-26T20:30:07Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java", "diffHunk": "@@ -365,60 +371,117 @@ private static Point getDisplayDimenions() {\n         return point;\n     }\n \n+\n+    public void onClick(View view) {\n+\n+        switch (view.getId()) {\n+            case R.id.pen_color_white:\n+                mPaint.setColor(Color.WHITE);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_black:\n+                mPaint.setColor(Color.BLACK);\n+                mColorPalette.setVisibility(View.GONE);\n+                break;\n+            case R.id.pen_color_red:\n+                int redPenColor = Color.parseColor(\"#f44336\");", "originalCommit": "a104048452cd6b64eccdea1081af0e215107e1a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4OTQ4Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6550#discussion_r446489487", "bodyText": "I used that one but deprecated. So I used ContextCompat.getColor();\nhttps://stackoverflow.com/questions/31590714/getcolorint-id-deprecated-on-android-6-0-marshmallow-api-23", "author": "infinyte7", "createdAt": "2020-06-27T05:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5NTYwMw=="}], "type": "inlineReview", "revised_code": {"commit": "b988f5ab6f28c73c4b77b227914ce199f1c0929c", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 8a1f82ca0..0f4fcd932 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -384,22 +384,22 @@ public class Whiteboard extends View {\n                 mColorPalette.setVisibility(View.GONE);\n                 break;\n             case R.id.pen_color_red:\n-                int redPenColor = Color.parseColor(\"#f44336\");\n+                int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n                 mPaint.setColor(redPenColor);\n                 mColorPalette.setVisibility(View.GONE);\n                 break;\n             case R.id.pen_color_green:\n-                int greenPenColor = Color.parseColor(\"#4caf50\");\n+                int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n                 mPaint.setColor(greenPenColor);\n                 mColorPalette.setVisibility(View.GONE);\n                 break;\n             case R.id.pen_color_blue:\n-                int bluePenColor = Color.parseColor(\"#2196f3\");\n+                int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n                 mPaint.setColor(bluePenColor);\n                 mColorPalette.setVisibility(View.GONE);\n                 break;\n             case R.id.pen_color_yellow:\n-                int yellowPenColor = Color.parseColor(\"#ffeb3b\");\n+                int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n                 mPaint.setColor(yellowPenColor);\n                 mColorPalette.setVisibility(View.GONE);\n                 break;\n", "next_change": {"commit": "ada67bc3d304193eab15d42badaafe9863d340cf", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 0f4fcd932..bf759bec9 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -374,37 +371,29 @@ public class Whiteboard extends View {\n \n     public void onClick(View view) {\n \n-        switch (view.getId()) {\n-            case R.id.pen_color_white:\n-                mPaint.setColor(Color.WHITE);\n-                mColorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_black:\n-                mPaint.setColor(Color.BLACK);\n-                mColorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_red:\n-                int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-                mPaint.setColor(redPenColor);\n-                mColorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_green:\n-                int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-                mPaint.setColor(greenPenColor);\n-                mColorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_blue:\n-                int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-                mPaint.setColor(bluePenColor);\n-                mColorPalette.setVisibility(View.GONE);\n-                break;\n-            case R.id.pen_color_yellow:\n-                int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-                mPaint.setColor(yellowPenColor);\n-                mColorPalette.setVisibility(View.GONE);\n-                break;\n-            default:\n-                break;\n+        int id = view.getId();\n+        if (id == R.id.pen_color_white) {\n+            mPaint.setColor(Color.WHITE);\n+            mColorPalette.setVisibility(View.GONE);\n+        } else if (id == R.id.pen_color_black) {\n+            mPaint.setColor(Color.BLACK);\n+            mColorPalette.setVisibility(View.GONE);\n+        } else if (id == R.id.pen_color_red) {\n+            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n+            mPaint.setColor(redPenColor);\n+            mColorPalette.setVisibility(View.GONE);\n+        } else if (id == R.id.pen_color_green) {\n+            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n+            mPaint.setColor(greenPenColor);\n+            mColorPalette.setVisibility(View.GONE);\n+        } else if (id == R.id.pen_color_blue) {\n+            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n+            mPaint.setColor(bluePenColor);\n+            mColorPalette.setVisibility(View.GONE);\n+        } else if (id == R.id.pen_color_yellow) {\n+            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n+            mPaint.setColor(yellowPenColor);\n+            mColorPalette.setVisibility(View.GONE);\n         }\n     }\n \n", "next_change": {"commit": "9597e35418e8923a12cfe5915dad2f71fa4d5aa5", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex bf759bec9..28688368f 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -373,30 +370,32 @@ public class Whiteboard extends View {\n \n         int id = view.getId();\n         if (id == R.id.pen_color_white) {\n-            mPaint.setColor(Color.WHITE);\n-            mColorPalette.setVisibility(View.GONE);\n+            setPenColor(Color.WHITE);\n         } else if (id == R.id.pen_color_black) {\n-            mPaint.setColor(Color.BLACK);\n-            mColorPalette.setVisibility(View.GONE);\n+            setPenColor(Color.BLACK);\n         } else if (id == R.id.pen_color_red) {\n             int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            mPaint.setColor(redPenColor);\n-            mColorPalette.setVisibility(View.GONE);\n+            setPenColor(redPenColor);\n         } else if (id == R.id.pen_color_green) {\n             int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            mPaint.setColor(greenPenColor);\n-            mColorPalette.setVisibility(View.GONE);\n+            setPenColor(greenPenColor);\n         } else if (id == R.id.pen_color_blue) {\n             int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            mPaint.setColor(bluePenColor);\n-            mColorPalette.setVisibility(View.GONE);\n+            setPenColor(bluePenColor);\n         } else if (id == R.id.pen_color_yellow) {\n             int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            mPaint.setColor(yellowPenColor);\n-            mColorPalette.setVisibility(View.GONE);\n+            setPenColor(yellowPenColor);\n         }\n     }\n \n+\n+    protected void setPenColor(int color) {\n+        Timber.d(\"Setting pen color to %d\", color);\n+        mPaint.setColor(color);\n+        mColorPalette.setVisibility(View.GONE);\n+    }\n+\n+\n     /**\n      * Keep a stack of all points and paths so that the last stroke can be undone\n      * pop() removes the last stroke from the stack, and apply() redraws it to whiteboard.\n", "next_change": {"commit": "27f10d57c86fe2e8ad3e66c969b48b92b5e594f1", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 28688368f..09c5cb62e 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -389,10 +393,23 @@ public class Whiteboard extends View {\n     }\n \n \n-    protected void setPenColor(int color) {\n+    public void setPenColor(int color) {\n         Timber.d(\"Setting pen color to %d\", color);\n         mPaint.setColor(color);\n         mColorPalette.setVisibility(View.GONE);\n+        if (mOnPaintColorChangeListener != null) {\n+            mOnPaintColorChangeListener.onPaintColorChange(color);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    public int getPenColor() {\n+        return mPaint.getColor();\n+    }\n+\n+\n+    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n+        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n     }\n \n \n", "next_change": {"commit": "591407338b226ecadd93f33446a807514d228d0f", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\nindex 09c5cb62e..25b8c171d 100644\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n", "chunk": "@@ -414,44 +429,87 @@ public class Whiteboard extends View {\n \n \n     /**\n-     * Keep a stack of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the stack, and apply() redraws it to whiteboard.\n+     * Keep a list of all points and paths so that the last stroke can be undone\n+     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n      */\n-    private class UndoStack {\n-        private final Stack<WhiteboardAction> mStack = new Stack<>();\n+    private class UndoList {\n+        private final List<WhiteboardAction> mList = new ArrayList<>();\n \n         public void add(WhiteboardAction action) {\n-            mStack.add(action);\n+            mList.add(action);\n         }\n \n         public void clear() {\n-            mStack.clear();\n+            mList.clear();\n         }\n \n         public int size() {\n-            return mStack.size();\n+            return mList.size();\n         }\n \n         public void pop() {\n-            mStack.pop();\n+            mList.remove(mList.size() - 1);\n         }\n \n         public void apply() {\n             mBitmap.eraseColor(0);\n \n-            for (WhiteboardAction action : mStack) {\n+            for (WhiteboardAction action : mList) {\n                 action.apply(mCanvas);\n             }\n             invalidate();\n         }\n \n+        public boolean erase(int x, int y) {\n+            boolean didErase = false;\n+            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n+            Path eraserPath = new Path();\n+            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n+            Region eraserRegion = new Region();\n+            eraserRegion.setPath(eraserPath, clip);\n+\n+            // used inside the loop \u2013 created here to make things a little more efficient\n+            RectF bounds = new RectF();\n+            Region lineRegion = new Region();\n+\n+            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n+            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n+                WhiteboardAction action = iterator.next();\n+\n+                Path mPath = action.getPath();\n+                if (mPath != null) { // \u2192 line\n+                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n+                    if (!lineRegionSuccess) {\n+                        // Small lines can be perfectly vertical/horizontal,\n+                        // thus giving us an empty region, which would make them undeletable.\n+                        // For this edge case, we create a Region ourselves.\n+                        mPath.computeBounds(bounds, true);\n+                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n+                    }\n+                } else { // \u2192 point\n+                    Point p = action.getPoint();\n+                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n+                }\n+\n+                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n+                    iterator.remove();\n+                    didErase = true;\n+                }\n+            }\n+            return didErase;\n+        }\n+\n         public boolean empty() {\n-            return mStack.empty();\n+            return mList.size() == 0;\n         }\n     }\n \n     private interface WhiteboardAction {\n         void apply(@NonNull Canvas canvas);\n+\n+        Path getPath();\n+\n+        Point getPoint();\n     }\n \n     private static class DrawPoint implements WhiteboardAction {\n", "next_change": {"commit": "3d141fd0a98d879640a4e3c4e60879040977e6c0", "changed_code": [{"header": "diff --git a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java b/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\ndeleted file mode 100644\nindex 25b8c171d..000000000\n--- a/AnkiDroid/src/main/java/com/ichi2/anki/Whiteboard.java\n+++ /dev/null\n", "chunk": "@@ -1,615 +0,0 @@\n-/*\n- * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>\n- * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>\n- * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>\n- * Copyright (c) 2021 Nicolai Weitkemper <kontakt@nicolaiweitkemper.de>\n- *\n- * This program is free software; you can redistribute it and/or modify it under\n- * the terms of the GNU General Public License as published by the Free Software\n- * Foundation; either version 3 of the License, or (at your option) any later\n- * version.\n- *\n- * This program is distributed in the hope that it will be useful, but WITHOUT ANY\n- * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n- * PARTICULAR PURPOSE. See the GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License along with\n- * this program.  If not, see <http://www.gnu.org/licenses/>.\n- */\n-\n-package com.ichi2.anki;\n-\n-import android.annotation.SuppressLint;\n-import android.content.Context;\n-import android.graphics.Bitmap;\n-import android.graphics.Canvas;\n-import android.graphics.Color;\n-import android.graphics.Paint;\n-import android.graphics.Path;\n-import android.graphics.PathMeasure;\n-import android.graphics.Point;\n-import android.graphics.Rect;\n-import android.graphics.RectF;\n-import android.graphics.Region;\n-import android.os.Environment;\n-import android.view.Display;\n-import android.view.MotionEvent;\n-import android.view.View;\n-import android.view.WindowManager;\n-import android.widget.Button;\n-import android.widget.LinearLayout;\n-\n-import com.ichi2.libanki.utils.Time;\n-import com.ichi2.libanki.utils.TimeUtils;\n-\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import androidx.annotation.CheckResult;\n-import androidx.annotation.NonNull;\n-import androidx.annotation.Nullable;\n-import androidx.annotation.VisibleForTesting;\n-import androidx.core.content.ContextCompat;\n-import timber.log.Timber;\n-\n-/**\n- * Whiteboard allowing the user to draw the card's answer on the touchscreen.\n- */\n-@SuppressLint(\"ViewConstructor\")\n-public class Whiteboard extends View {\n-\n-    private static final float TOUCH_TOLERANCE = 4;\n-\n-    private final Paint mPaint;\n-    private final UndoList mUndo = new UndoList();\n-    private Bitmap mBitmap;\n-    private Canvas mCanvas;\n-    private final Path mPath;\n-    private final Paint mBitmapPaint;\n-    private final WeakReference<AbstractFlashcardViewer> mCardViewer;\n-\n-    private float mX;\n-    private float mY;\n-    private float mSecondFingerX0;\n-    private float mSecondFingerY0;\n-    private float mSecondFingerX;\n-    private float mSecondFingerY;\n-\n-    private int mSecondFingerPointerId;\n-\n-    private boolean mSecondFingerWithinTapTolerance;\n-    private boolean mCurrentlyDrawing = false;\n-    private boolean mUndoModeActive = false;\n-    private final int foregroundColor;\n-    private final LinearLayout mColorPalette;\n-\n-    @Nullable\n-    private OnPaintColorChangeListener mOnPaintColorChangeListener;\n-\n-    public Whiteboard(AbstractFlashcardViewer cardViewer, boolean inverted) {\n-        super(cardViewer, null);\n-        mCardViewer = new WeakReference<>(cardViewer);\n-\n-        Button whitePenColorButton = cardViewer.findViewById(R.id.pen_color_white);\n-        Button blackPenColorButton = cardViewer.findViewById(R.id.pen_color_black);\n-\n-        if (!inverted) {\n-                whitePenColorButton.setVisibility(View.GONE);\n-                blackPenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.BLACK;\n-        } else {\n-                blackPenColorButton.setVisibility(View.GONE);\n-                whitePenColorButton.setOnClickListener(this::onClick);\n-                foregroundColor = Color.WHITE;\n-        }\n-\n-        mPaint = new Paint();\n-        mPaint.setAntiAlias(true);\n-        mPaint.setDither(true);\n-        mPaint.setColor(foregroundColor);\n-        mPaint.setStyle(Paint.Style.STROKE);\n-        mPaint.setStrokeJoin(Paint.Join.ROUND);\n-        mPaint.setStrokeCap(Paint.Cap.ROUND);\n-        int wbStrokeWidth = AnkiDroidApp.getSharedPrefs(cardViewer).getInt(\"whiteBoardStrokeWidth\", 6);\n-        mPaint.setStrokeWidth((float) wbStrokeWidth);\n-        createBitmap();\n-        mPath = new Path();\n-        mBitmapPaint = new Paint(Paint.DITHER_FLAG);\n-\n-        // selecting pen color to draw\n-        mColorPalette = cardViewer.findViewById(R.id.whiteboard_pen_color);\n-\n-        cardViewer.findViewById(R.id.pen_color_red).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_green).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_blue).setOnClickListener(this::onClick);\n-        cardViewer.findViewById(R.id.pen_color_yellow).setOnClickListener(this::onClick);\n-    }\n-\n-\n-    @Override\n-    protected void onDraw(Canvas canvas) {\n-        super.onDraw(canvas);\n-        canvas.drawColor(0);\n-        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);\n-        canvas.drawPath(mPath, mPaint);\n-    }\n-\n-\n-    /** Handle motion events to draw using the touch screen or to interact with the flashcard behind\n-     * the whiteboard by using a second finger.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise\n-     */\n-    public boolean handleTouchEvent(MotionEvent event) {\n-        return handleDrawEvent(event) || handleMultiTouchEvent(event);\n-    }\n-\n-\n-    /**\n-     * Handle motion events to draw using the touch screen. Only simple touch events are processed,\n-     * a multitouch event aborts to current stroke.\n-     *\n-     * @param event The motion event.\n-     * @return True if the event was handled, false otherwise or when drawing was aborted due to\n-     *              detection of a multitouch event.\n-     */\n-    private boolean handleDrawEvent(MotionEvent event) {\n-        float x = event.getX();\n-        float y = event.getY();\n-\n-        switch (event.getActionMasked()) {\n-            case MotionEvent.ACTION_DOWN:\n-                drawStart(x, y);\n-                invalidate();\n-                return true;\n-            case MotionEvent.ACTION_MOVE:\n-                if (mCurrentlyDrawing) {\n-                    for (int i = 0; i < event.getHistorySize(); i++) {\n-                        drawAlong(event.getHistoricalX(i), event.getHistoricalY(i));\n-                    }\n-                    drawAlong(x, y);\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_UP:\n-                if (mCurrentlyDrawing) {\n-                    drawFinish();\n-                    invalidate();\n-                    return true;\n-                }\n-                return false;\n-            case MotionEvent.ACTION_POINTER_DOWN:\n-                if (mCurrentlyDrawing) {\n-                    drawAbort();\n-                }\n-                return false;\n-            // not present in docs: https://developer.android.com/reference/android/view/MotionEvent\n-            case 211: // POINTER_DOWN with S-Pen-button\n-            case 213: // MOVE with S-Pen-button\n-                if (event.getButtonState() == MotionEvent.BUTTON_STYLUS_PRIMARY && !undoEmpty()) {\n-                    boolean didErase = mUndo.erase((int) event.getX(), (int) event.getY());\n-                    if (didErase) {\n-                        mUndo.apply();\n-                        if (undoEmpty() && mCardViewer.get() != null) {\n-                            mCardViewer.get().supportInvalidateOptionsMenu();\n-                        }\n-                    }\n-                }\n-                return true;\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    // Parse multitouch input to scroll the card behind the whiteboard or click on elements\n-    private boolean handleMultiTouchEvent(MotionEvent event) {\n-        if (event.getPointerCount() == 2) {\n-            switch (event.getActionMasked()) {\n-                case MotionEvent.ACTION_POINTER_DOWN:\n-                    reinitializeSecondFinger(event);\n-                    return true;\n-                case MotionEvent.ACTION_MOVE:\n-                    return trySecondFingerScroll(event);\n-                case MotionEvent.ACTION_POINTER_UP:\n-                    return trySecondFingerClick(event);\n-                default:\n-                    return false;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    /**\n-     * Clear the whiteboard.\n-     */\n-    public void clear() {\n-        mUndoModeActive = false;\n-        mBitmap.eraseColor(0);\n-        mUndo.clear();\n-        invalidate();\n-        if (mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /**\n-     * Undo the last stroke\n-     */\n-    public void undo() {\n-        mUndo.pop();\n-        mUndo.apply();\n-        if (undoEmpty() && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    /** @return Whether there are strokes to undo */\n-    public boolean undoEmpty() {\n-        return mUndo.empty();\n-    }\n-\n-    /**\n-     * @return true if the undo queue has had any strokes added to it since the last clear\n-     */\n-    public boolean isUndoModeActive() {\n-        return mUndoModeActive;\n-    }\n-\n-    private void createBitmap(int w, int h) {\n-        mBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\n-        mCanvas = new Canvas(mBitmap);\n-        clear();\n-    }\n-\n-\n-    private void createBitmap() {\n-        // To fix issue #1336, just make the whiteboard big and square.\n-        final Point p = getDisplayDimensions();\n-        int bitmapSize = Math.max(p.x, p.y);\n-        createBitmap(bitmapSize, bitmapSize);\n-    }\n-\n-    private void drawStart(float x, float y) {\n-        mCurrentlyDrawing = true;\n-        mPath.reset();\n-        mPath.moveTo(x, y);\n-        mX = x;\n-        mY = y;\n-    }\n-\n-\n-    private void drawAlong(float x, float y) {\n-        float dx = Math.abs(x - mX);\n-        float dy = Math.abs(y - mY);\n-        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n-            mX = x;\n-            mY = y;\n-        }\n-    }\n-\n-\n-    private void drawFinish() {\n-        mCurrentlyDrawing = false;\n-        PathMeasure pm = new PathMeasure(mPath, false);\n-        mPath.lineTo(mX, mY);\n-        Paint paint = new Paint(mPaint);\n-        WhiteboardAction action = pm.getLength() > 0 ? new DrawPath(new Path(mPath), paint) : new DrawPoint(mX, mY, paint);\n-        action.apply(mCanvas);\n-        mUndo.add(action);\n-        mUndoModeActive = true;\n-        // kill the path so we don't double draw\n-        mPath.reset();\n-        if (mUndo.size() == 1 && mCardViewer.get() != null) {\n-            mCardViewer.get().supportInvalidateOptionsMenu();\n-        }\n-    }\n-\n-\n-    private void drawAbort() {\n-        drawFinish();\n-        undo();\n-    }\n-\n-\n-    // call this with an ACTION_POINTER_DOWN event to start a new round of detecting drag or tap with\n-    // a second finger\n-    private void reinitializeSecondFinger(MotionEvent event) {\n-        mSecondFingerWithinTapTolerance = true;\n-        mSecondFingerPointerId = event.getPointerId(event.getActionIndex());\n-        mSecondFingerX0 = event.getX(event.findPointerIndex(mSecondFingerPointerId));\n-        mSecondFingerY0 = event.getY(event.findPointerIndex(mSecondFingerPointerId));\n-    }\n-\n-    private boolean updateSecondFinger(MotionEvent event) {\n-        int pointerIndex = event.findPointerIndex(mSecondFingerPointerId);\n-        if (pointerIndex > -1) {\n-            mSecondFingerX = event.getX(pointerIndex);\n-            mSecondFingerY = event.getY(pointerIndex);\n-            float dx = Math.abs(mSecondFingerX0 - mSecondFingerX);\n-            float dy = Math.abs(mSecondFingerY0 - mSecondFingerY);\n-            if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n-                mSecondFingerWithinTapTolerance = false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_POINTER_UP event to check whether it matches a tap of the second finger\n-    // if so, forward a click action and return true\n-    private boolean trySecondFingerClick(MotionEvent event) {\n-        if (mSecondFingerPointerId == event.getPointerId(event.getActionIndex())) {\n-            updateSecondFinger(event);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (mSecondFingerWithinTapTolerance && cardViewer != null) {\n-                cardViewer.tapOnCurrentCard((int) mSecondFingerX, (int) mSecondFingerY);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    // call this with an ACTION_MOVE event to check whether it is within the threshold for a tap of the second finger\n-    // in this case perform a scroll action\n-    private boolean trySecondFingerScroll(MotionEvent event) {\n-        if (updateSecondFinger(event) && !mSecondFingerWithinTapTolerance) {\n-            int dy = (int) (mSecondFingerY0 - mSecondFingerY);\n-            AbstractFlashcardViewer cardViewer = mCardViewer.get();\n-            if (dy != 0 && cardViewer != null) {\n-                cardViewer.scrollCurrentCardBy(dy);\n-                mSecondFingerX0 = mSecondFingerX;\n-                mSecondFingerY0 = mSecondFingerY;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static Point getDisplayDimensions() {\n-        Display display = ((WindowManager) AnkiDroidApp.getInstance().getApplicationContext().\n-                getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();\n-        Point point = new Point();\n-        display.getSize(point);\n-        return point;\n-    }\n-\n-\n-    public void onClick(View view) {\n-\n-        int id = view.getId();\n-        if (id == R.id.pen_color_white) {\n-            setPenColor(Color.WHITE);\n-        } else if (id == R.id.pen_color_black) {\n-            setPenColor(Color.BLACK);\n-        } else if (id == R.id.pen_color_red) {\n-            int redPenColor = ContextCompat.getColor(getContext(), R.color.material_red_500);\n-            setPenColor(redPenColor);\n-        } else if (id == R.id.pen_color_green) {\n-            int greenPenColor = ContextCompat.getColor(getContext(), R.color.material_green_500);\n-            setPenColor(greenPenColor);\n-        } else if (id == R.id.pen_color_blue) {\n-            int bluePenColor = ContextCompat.getColor(getContext(), R.color.material_blue_500);\n-            setPenColor(bluePenColor);\n-        } else if (id == R.id.pen_color_yellow) {\n-            int yellowPenColor = ContextCompat.getColor(getContext(), R.color.material_yellow_500);\n-            setPenColor(yellowPenColor);\n-        }\n-    }\n-\n-\n-    public void setPenColor(int color) {\n-        Timber.d(\"Setting pen color to %d\", color);\n-        mPaint.setColor(color);\n-        mColorPalette.setVisibility(View.GONE);\n-        if (mOnPaintColorChangeListener != null) {\n-            mOnPaintColorChangeListener.onPaintColorChange(color);\n-        }\n-    }\n-\n-    @VisibleForTesting\n-    public int getPenColor() {\n-        return mPaint.getColor();\n-    }\n-\n-\n-    public void setOnPaintColorChangeListener(@Nullable OnPaintColorChangeListener mOnPaintColorChangeListener) {\n-        this.mOnPaintColorChangeListener = mOnPaintColorChangeListener;\n-    }\n-\n-\n-    /**\n-     * Keep a list of all points and paths so that the last stroke can be undone\n-     * pop() removes the last stroke from the list, and apply() redraws it to whiteboard.\n-     */\n-    private class UndoList {\n-        private final List<WhiteboardAction> mList = new ArrayList<>();\n-\n-        public void add(WhiteboardAction action) {\n-            mList.add(action);\n-        }\n-\n-        public void clear() {\n-            mList.clear();\n-        }\n-\n-        public int size() {\n-            return mList.size();\n-        }\n-\n-        public void pop() {\n-            mList.remove(mList.size() - 1);\n-        }\n-\n-        public void apply() {\n-            mBitmap.eraseColor(0);\n-\n-            for (WhiteboardAction action : mList) {\n-                action.apply(mCanvas);\n-            }\n-            invalidate();\n-        }\n-\n-        public boolean erase(int x, int y) {\n-            boolean didErase = false;\n-            Region clip = new Region(0, 0, getDisplayDimensions().x, getDisplayDimensions().y);\n-            Path eraserPath = new Path();\n-            eraserPath.addRect(x - 10, y - 10, x + 10, y + 10, Path.Direction.CW);\n-            Region eraserRegion = new Region();\n-            eraserRegion.setPath(eraserPath, clip);\n-\n-            // used inside the loop \u2013 created here to make things a little more efficient\n-            RectF bounds = new RectF();\n-            Region lineRegion = new Region();\n-\n-            // we delete elements while iterating, so we need to use an iterator in order to avoid java.util.ConcurrentModificationException\n-            for (Iterator<WhiteboardAction> iterator = mList.iterator(); iterator.hasNext(); ) {\n-                WhiteboardAction action = iterator.next();\n-\n-                Path mPath = action.getPath();\n-                if (mPath != null) { // \u2192 line\n-                    boolean lineRegionSuccess = lineRegion.setPath(mPath, clip);\n-                    if (!lineRegionSuccess) {\n-                        // Small lines can be perfectly vertical/horizontal,\n-                        // thus giving us an empty region, which would make them undeletable.\n-                        // For this edge case, we create a Region ourselves.\n-                        mPath.computeBounds(bounds, true);\n-                        lineRegion = new Region(new Rect((int) bounds.left, (int) bounds.top, (int) bounds.right + 1, (int) bounds.bottom + 1));\n-                    }\n-                } else { // \u2192 point\n-                    Point p = action.getPoint();\n-                    lineRegion = new Region(p.x, p.y, p.x + 1, p.y + 1);\n-                }\n-\n-                if (!lineRegion.quickReject(eraserRegion) && lineRegion.op(eraserRegion, Region.Op.INTERSECT)) {\n-                    iterator.remove();\n-                    didErase = true;\n-                }\n-            }\n-            return didErase;\n-        }\n-\n-        public boolean empty() {\n-            return mList.size() == 0;\n-        }\n-    }\n-\n-    private interface WhiteboardAction {\n-        void apply(@NonNull Canvas canvas);\n-\n-        Path getPath();\n-\n-        Point getPoint();\n-    }\n-\n-    private static class DrawPoint implements WhiteboardAction {\n-\n-        private final float mX;\n-        private final float mY;\n-        private final Paint mPaint;\n-\n-\n-        public DrawPoint(float x, float y, Paint paint) {\n-            mX = x;\n-            mY = y;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPoint(mX, mY, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return null;\n-        }\n-\n-\n-        public Point getPoint() {\n-            return new Point((int) mX, (int) mY);\n-        }\n-    }\n-\n-    private static class DrawPath implements WhiteboardAction {\n-        private final Path mPath;\n-        private final Paint mPaint;\n-\n-        public DrawPath(Path path, Paint paint) {\n-            mPath = path;\n-            mPaint = paint;\n-        }\n-\n-\n-        @Override\n-        public void apply(@NonNull Canvas canvas) {\n-            canvas.drawPath(mPath, mPaint);\n-        }\n-\n-        @Override\n-        public Path getPath() {\n-            return mPath;\n-        }\n-\n-        @Override\n-        public Point getPoint() {\n-            return null;\n-        }\n-    }\n-\n-    public boolean isCurrentlyDrawing() {\n-        return mCurrentlyDrawing;\n-    }\n-\n-    @SuppressWarnings( {\"deprecation\", \"RedundantSuppression\"}) // TODO Tracked in https://github.com/ankidroid/Anki-Android/issues/5304\n-    protected String saveWhiteboard(Time time) throws FileNotFoundException {\n-\n-        Bitmap bitmap = Bitmap.createBitmap(this.getWidth(), this.getHeight(), Bitmap.Config.ARGB_8888);\n-        Canvas canvas = new Canvas(bitmap);\n-\n-        File pictures = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);\n-        File ankiDroidFolder = new File(pictures, \"AnkiDroid\");\n-\n-        if (!ankiDroidFolder.exists()) {\n-            //noinspection ResultOfMethodCallIgnored\n-            ankiDroidFolder.mkdirs();\n-        }\n-\n-        String baseFileName = \"Whiteboard\";\n-        String timeStamp = TimeUtils.getTimestamp(time);\n-        String finalFileName = baseFileName + timeStamp + \".png\";\n-\n-        File saveWhiteboardImageFile = new File(ankiDroidFolder, finalFileName);\n-\n-        if (foregroundColor != Color.BLACK) {\n-            canvas.drawColor(Color.BLACK);\n-        } else {\n-            canvas.drawColor(Color.WHITE);\n-        }\n-\n-        this.draw(canvas);\n-        bitmap.compress(Bitmap.CompressFormat.JPEG, 95, new FileOutputStream(saveWhiteboardImageFile));\n-        return saveWhiteboardImageFile.getAbsolutePath();\n-    }\n-\n-    @VisibleForTesting\n-    @CheckResult\n-    protected int getForegroundColor() {\n-        return foregroundColor;\n-    }\n-\n-    public interface OnPaintColorChangeListener {\n-        void onPaintColorChange(@Nullable Integer color);\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "1aa90865f94d98b9fb901dbe9751ca0564d3ef8e", "url": "https://github.com/ankidroid/Anki-Android/commit/1aa90865f94d98b9fb901dbe9751ca0564d3ef8e", "message": "\tUpdated Whiteboard.java, colors.xml", "committedDate": "2020-06-27T05:53:15Z", "type": "commit"}, {"oid": "2539fa3db1cc4af60937a9e41d1e1ff8419127ef", "url": "https://github.com/ankidroid/Anki-Android/commit/2539fa3db1cc4af60937a9e41d1e1ff8419127ef", "message": "\tUpdated reviewer_whiteboard_pen_color.xml", "committedDate": "2020-06-27T05:59:31Z", "type": "commit"}]}