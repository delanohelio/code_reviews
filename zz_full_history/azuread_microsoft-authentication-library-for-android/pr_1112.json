{"pr_number": 1112, "pr_title": "Device Code Flow Final PR on MSAL", "pr_author": "t-fadura", "pr_createdAt": "2020-07-29T16:34:50Z", "pr_url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112", "timeline": [{"oid": "29787921e414835b5a537660f13afcd79371fcd7", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/29787921e414835b5a537660f13afcd79371fcd7", "message": "side branch while PRs complete", "committedDate": "2020-07-25T16:41:06Z", "type": "commit"}, {"oid": "97fd721583643faa64a9da3292a7af67dbb27eec", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/97fd721583643faa64a9da3292a7af67dbb27eec", "message": "Added acquireDeviceCodeFlowToken", "committedDate": "2020-07-27T19:37:25Z", "type": "commit"}, {"oid": "690f693de473b88b0c7cd22b49635fba8abfe4fd", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/690f693de473b88b0c7cd22b49635fba8abfe4fd", "message": "Worked on deviceCodeFlowAuthRequest", "committedDate": "2020-07-27T19:57:58Z", "type": "commit"}, {"oid": "316f2b96bb64807c4f892ddad13e2600b84a402f", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/316f2b96bb64807c4f892ddad13e2600b84a402f", "message": "Before merge", "committedDate": "2020-07-28T14:05:04Z", "type": "commit"}, {"oid": "97d3e15cd050fce2462a9b43b3a36b296de32fec", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/97d3e15cd050fce2462a9b43b3a36b296de32fec", "message": "Fixed conflicts", "committedDate": "2020-07-28T14:06:31Z", "type": "commit"}, {"oid": "0b29f9d2179e7cb62e350b057c7a238546d97c71", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/0b29f9d2179e7cb62e350b057c7a238546d97c71", "message": "Merge branch 't-fadura/dcf-main' of https://github.com/AzureAD/microsoft-authentication-library-for-android into t-fadura/dcf-main", "committedDate": "2020-07-28T14:07:16Z", "type": "commit"}, {"oid": "440a8633bfc63572dfe756ad94abb6e40c1456d0", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/440a8633bfc63572dfe756ad94abb6e40c1456d0", "message": "Merge branch 'dev' of https://github.com/AzureAD/microsoft-authentication-library-for-android into t-fadura/dcf-main", "committedDate": "2020-07-28T15:01:30Z", "type": "commit"}, {"oid": "adaa450623bf701b7f929ea67e076795e3dd8f08", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/adaa450623bf701b7f929ea67e076795e3dd8f08", "message": "Added Exception handling", "committedDate": "2020-07-28T15:03:47Z", "type": "commit"}, {"oid": "9d30c589039258e4a4212cc833a37762835e3dbb", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/9d30c589039258e4a4212cc833a37762835e3dbb", "message": "removed typo", "committedDate": "2020-07-28T15:14:45Z", "type": "commit"}, {"oid": "24a92811f0ad5124edbf3ecd1f18d2b1b8f9d3b5", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/24a92811f0ad5124edbf3ecd1f18d2b1b8f9d3b5", "message": "End-to-end working", "committedDate": "2020-07-29T15:52:16Z", "type": "commit"}, {"oid": "dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "message": "Small tweaks", "committedDate": "2020-07-29T16:26:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MTA3Nw==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462581077", "body": "`authorization_pending` is declared too many times. It must go in a constant in the appropriate constants file.", "bodyText": "authorization_pending is declared too many times. It must go in a constant in the appropriate constants file.", "bodyHTML": "<p dir=\"auto\"><code>authorization_pending</code> is declared too many times. It must go in a constant in the appropriate constants file.</p>", "author": "shahzaibj", "createdAt": "2020-07-29T20:52:01Z", "path": "msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java", "diffHunk": "@@ -463,14 +468,224 @@ public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) t\n     }\n \n     @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n+        // Logging start of method\n+        final String methodName = \":deviceCodeFlowAuthRequest\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Authorizing user code...\"\n+        );\n+\n+        // Default scopes here\n+        final Set<String> mergedScopes = addDefaultScopes(parameters);\n+\n+        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n+                .toBuilder()\n+                .scopes(mergedScopes)\n+                .build();\n+\n+        logParameters(TAG, parametersWithScopes);\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putProperties(parametersWithScopes)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 1: Get user code\n+        // Populate global authorization request\n+        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n+\n+        // Call method defined in oAuth2Strategy to request authorization\n+        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n+\n+        validateServiceResult(authorizationResult);\n+\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow authorization step finished...\"\n+        );\n+        logResult(TAG, authorizationResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        return authorizationResult;\n     }\n \n     @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(final AuthorizationResult authorizationResult, DeviceCodeFlowCommandParameters commandParameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AcquireTokenResult acquireDeviceCodeFlowToken(\n+            final AuthorizationResult authorizationResult,\n+            final DeviceCodeFlowCommandParameters parameters)\n+            throws MsalException, ClientException, IOException, InterruptedException {\n+\n+        // Logging start of method\n+        final String methodName = \":acquireDeviceCodeFlowToken\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Polling for token...\"\n+        );\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        // Create empty AcquireTokenResult object\n+        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n+\n+        // Assign authorization result\n+        acquireTokenResult.setAuthorizationResult(authorizationResult);\n+\n+        // Fetch the Authorization Response\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parameters\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 2: Poll for token\n+        TokenResult tokenResult = null;\n+\n+        // Create token request outside of loop so it isn't re-created after every loop\n+        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n+                mAuthorizationRequest,\n+                authorizationResponse,\n+                parameters.getAuthenticationScheme()\n+        );\n+\n+        // Fetch wait interval\n+        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n+\n+        String errorCode = \"authorization_pending\";\n+\n+        // Loop to send multiple requests checking for token\n+        while (errorCode.equals(\"authorization_pending\")) {\n+            errorCode = \"\"; // Reset error code\n+\n+            // Execute Token Request\n+            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n+\n+            if (tokenResult.getErrorResponse() != null) {\n+                errorCode = tokenResult.getErrorResponse().getError();\n+            }\n+\n+            if (errorCode.equals(\"authorization_pending\")) {\n+                // interval is passed through params\n+                Thread.sleep(interval);\n+            }\n+        }", "originalCommit": "dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db4160a3861d0ee64f555150baba754033aba357", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java b/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\ndeleted file mode 100644\nindex 0bbf36bb..00000000\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\n+++ /dev/null\n", "chunk": "@@ -1,691 +0,0 @@\n-//  Copyright (c) Microsoft Corporation.\n-//  All rights reserved.\n-//\n-//  This code is licensed under the MIT License.\n-//\n-//  Permission is hereby granted, free of charge, to any person obtaining a copy\n-//  of this software and associated documentation files(the \"Software\"), to deal\n-//  in the Software without restriction, including without limitation the rights\n-//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n-//  copies of the Software, and to permit persons to whom the Software is\n-//  furnished to do so, subject to the following conditions :\n-//\n-//  The above copyright notice and this permission notice shall be included in\n-//  all copies or substantial portions of the Software.\n-//\n-//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-//  THE SOFTWARE.\n-package com.microsoft.identity.client.internal.controllers;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.text.TextUtils;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.WorkerThread;\n-\n-import com.microsoft.identity.client.exception.MsalException;\n-import com.microsoft.identity.client.exception.MsalServiceException;\n-import com.microsoft.identity.client.exception.MsalUiRequiredException;\n-import com.microsoft.identity.common.exception.ArgumentException;\n-import com.microsoft.identity.common.exception.ClientException;\n-import com.microsoft.identity.common.exception.ErrorStrings;\n-import com.microsoft.identity.common.exception.ServiceException;\n-import com.microsoft.identity.common.internal.authorities.Authority;\n-import com.microsoft.identity.common.internal.authscheme.AbstractAuthenticationScheme;\n-import com.microsoft.identity.common.internal.cache.ICacheRecord;\n-import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n-import com.microsoft.identity.common.internal.controllers.BaseController;\n-import com.microsoft.identity.common.internal.dto.AccountRecord;\n-import com.microsoft.identity.common.internal.logging.Logger;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStatus;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStrategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.IErrorResponse;\n-import com.microsoft.identity.common.internal.providers.oauth2.IResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2TokenCache;\n-import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n-import com.microsoft.identity.common.internal.request.SdkType;\n-import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n-import com.microsoft.identity.common.internal.result.LocalAuthenticationResult;\n-import com.microsoft.identity.common.internal.telemetry.Telemetry;\n-import com.microsoft.identity.common.internal.telemetry.TelemetryEventStrings;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiEndEvent;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiStartEvent;\n-import com.microsoft.identity.common.internal.ui.AuthorizationStrategyFactory;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import static com.microsoft.identity.common.adal.internal.net.HttpWebRequest.throwIfNetworkNotAvailable;\n-\n-public class LocalMSALController extends BaseController {\n-\n-    private static final String TAG = LocalMSALController.class.getSimpleName();\n-\n-    private AuthorizationStrategy mAuthorizationStrategy = null;\n-    private AuthorizationRequest mAuthorizationRequest = null;\n-\n-    @Override\n-    public AcquireTokenResult acquireToken(\n-            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException, IOException, ArgumentException {\n-        final String methodName = \":acquireToken\";\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        //00) Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final InteractiveTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        //0) Get known authority result\n-        throwIfNetworkNotAvailable(\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes.isPowerOptCheckEnabled()\n-        );\n-\n-        Authority.KnownAuthorityResult authorityResult = Authority.getKnownAuthorityResult(parametersWithScopes.getAuthority());\n-\n-        //0.1 If not known throw resulting exception\n-        if (!authorityResult.getKnown()) {\n-            Telemetry.emit(\n-                    new ApiEndEvent()\n-                            .putException(authorityResult.getClientException())\n-                            .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-            );\n-\n-            throw authorityResult.getClientException();\n-        }\n-\n-        // Build up params for Strategy construction\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        //1) Get oAuth2Strategy for Authority Type\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-\n-        //2) Request authorization interactively\n-        final AuthorizationResult result = performAuthorizationRequest(\n-                oAuth2Strategy,\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes\n-        );\n-        acquireTokenResult.setAuthorizationResult(result);\n-\n-        logResult(TAG, result);\n-\n-        if (result.getAuthorizationStatus().equals(AuthorizationStatus.SUCCESS)) {\n-            //3) Exchange authorization code for token\n-            final TokenResult tokenResult = performTokenRequest(\n-                    oAuth2Strategy,\n-                    mAuthorizationRequest,\n-                    result.getAuthorizationResponse(),\n-                    parametersWithScopes\n-            );\n-\n-            acquireTokenResult.setTokenResult(tokenResult);\n-\n-            if (tokenResult != null && tokenResult.getSuccess()) {\n-                //4) Save tokens in token cache\n-                final List<ICacheRecord> records = saveTokens(\n-                        oAuth2Strategy,\n-                        mAuthorizationRequest,\n-                        tokenResult.getTokenResponse(),\n-                        parametersWithScopes.getOAuth2TokenCache()\n-                );\n-\n-                // The first element in the returned list is the item we *just* saved, the rest of\n-                // the elements are necessary to construct the full IAccount + TenantProfile\n-                final ICacheRecord newestRecord = records.get(0);\n-\n-                acquireTokenResult.setLocalAuthenticationResult(\n-                        new LocalAuthenticationResult(\n-                                finalizeCacheRecordForResult(\n-                                        newestRecord,\n-                                        parametersWithScopes.getAuthenticationScheme()\n-                                ),\n-                                records,\n-                                SdkType.MSAL,\n-                                false\n-                        )\n-                );\n-            }\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    private AuthorizationResult performAuthorizationRequest(@NonNull final OAuth2Strategy strategy,\n-                                                            @NonNull final Context context,\n-                                                            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException {\n-\n-        throwIfNetworkNotAvailable(context, parameters.isPowerOptCheckEnabled());\n-\n-        mAuthorizationStrategy = AuthorizationStrategyFactory.getInstance()\n-                .getAuthorizationStrategy(\n-                        parameters\n-                );\n-        mAuthorizationRequest = getAuthorizationRequest(strategy, parameters);\n-\n-        final Future<AuthorizationResult> future = strategy.requestAuthorization(\n-                mAuthorizationRequest,\n-                mAuthorizationStrategy\n-        );\n-\n-        final AuthorizationResult result = future.get();\n-\n-        return result;\n-    }\n-\n-    @Override\n-    public void completeAcquireToken(final int requestCode,\n-                                     final int resultCode,\n-                                     final Intent data) {\n-        final String methodName = \":completeAcquireToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Completing acquire token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-                        .put(TelemetryEventStrings.Key.RESULT_CODE, String.valueOf(resultCode))\n-                        .put(TelemetryEventStrings.Key.REQUEST_CODE, String.valueOf(requestCode))\n-        );\n-\n-        mAuthorizationStrategy.completeAuthorization(requestCode, resultCode, data);\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireTokenSilent(\n-            @NonNull final SilentTokenCommandParameters parameters)\n-            throws IOException, ClientException, ArgumentException, ServiceException {\n-        final String methodName = \":acquireTokenSilent\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token silently...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        final AcquireTokenResult acquireTokenSilentResult = new AcquireTokenResult();\n-\n-        //Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final SilentTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        final OAuth2TokenCache tokenCache = parametersWithScopes.getOAuth2TokenCache();\n-\n-        final AccountRecord targetAccount = getCachedAccountRecord(parametersWithScopes);\n-\n-        // Build up params for Strategy construction\n-        final AbstractAuthenticationScheme authScheme = parametersWithScopes.getAuthenticationScheme();\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy strategy = parametersWithScopes.getAuthority().createOAuth2Strategy(strategyParameters);\n-\n-        final List<ICacheRecord> cacheRecords = tokenCache.loadWithAggregatedAccountData(\n-                parametersWithScopes.getClientId(),\n-                TextUtils.join(\" \", parametersWithScopes.getScopes()),\n-                targetAccount,\n-                authScheme\n-        );\n-\n-        // The first element is the 'fully-loaded' CacheRecord which may contain the AccountRecord,\n-        // AccessTokenRecord, RefreshTokenRecord, and IdTokenRecord... (if all of those artifacts exist)\n-        // subsequent CacheRecords represent other profiles (projections) of this principal in\n-        // other tenants. Those tokens will be 'sparse', meaning that their AT/RT will not be loaded\n-        final ICacheRecord fullCacheRecord = cacheRecords.get(0);\n-\n-        if (accessTokenIsNull(fullCacheRecord)\n-                || refreshTokenIsNull(fullCacheRecord)\n-                || parametersWithScopes.isForceRefresh()\n-                || !isRequestAuthorityRealmSameAsATRealm(parametersWithScopes.getAuthority(), fullCacheRecord.getAccessToken())\n-                || !strategy.validateCachedResult(authScheme, fullCacheRecord)) {\n-            if (!refreshTokenIsNull(fullCacheRecord)) {\n-                // No AT found, but the RT checks out, so we'll use it\n-                Logger.verbose(\n-                        TAG + methodName,\n-                        \"No access token found, but RT is available.\"\n-                );\n-\n-                renewAccessToken(\n-                        parametersWithScopes,\n-                        acquireTokenSilentResult,\n-                        tokenCache,\n-                        strategy,\n-                        fullCacheRecord\n-                );\n-            } else {\n-                //TODO need the refactor, should just throw the ui required exception, rather than\n-                // wrap the exception later in the exception wrapper.\n-                final ClientException exception = new ClientException(\n-                        MsalUiRequiredException.NO_TOKENS_FOUND,\n-                        \"No refresh token was found. \"\n-                );\n-\n-                Telemetry.emit(\n-                        new ApiEndEvent()\n-                                .putException(exception)\n-                                .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-                );\n-\n-                throw exception;\n-            }\n-        } else if (fullCacheRecord.getAccessToken().isExpired()) {\n-            Logger.warn(\n-                    TAG + methodName,\n-                    \"Access token is expired. Removing from cache...\"\n-            );\n-            // Remove the expired token\n-            tokenCache.removeCredential(fullCacheRecord.getAccessToken());\n-\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Renewing access token...\"\n-            );\n-            // Request a new AT\n-            renewAccessToken(\n-                    parametersWithScopes,\n-                    acquireTokenSilentResult,\n-                    tokenCache,\n-                    strategy,\n-                    fullCacheRecord\n-            );\n-        } else {\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Returning silent result\"\n-            );\n-            // the result checks out, return that....\n-            acquireTokenSilentResult.setLocalAuthenticationResult(\n-                    new LocalAuthenticationResult(\n-                            finalizeCacheRecordForResult(\n-                                    fullCacheRecord,\n-                                    parametersWithScopes.getAuthenticationScheme()\n-                            ),\n-                            cacheRecords,\n-                            SdkType.MSAL,\n-                            true\n-                    )\n-            );\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenSilentResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        return acquireTokenSilentResult;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public List<ICacheRecord> getAccounts(@NonNull final CommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-        );\n-\n-        final List<ICacheRecord> accountsInCache =\n-                parameters\n-                        .getOAuth2TokenCache()\n-                        .getAccountsWithAggregatedAccountData(\n-                                null, // * wildcard\n-                                parameters.getClientId()\n-                        );\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-                        .put(TelemetryEventStrings.Key.ACCOUNTS_NUMBER, Integer.toString(accountsInCache.size()))\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, TelemetryEventStrings.Value.TRUE)\n-        );\n-\n-        return accountsInCache;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public boolean removeAccount(\n-            @NonNull final RemoveAccountCommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        String realm = null;\n-\n-        if (parameters.getAccount() != null) {\n-            realm = parameters.getAccount().getRealm();\n-        }\n-\n-        final boolean localRemoveAccountSuccess = !parameters\n-                .getOAuth2TokenCache()\n-                .removeAccount(\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getEnvironment(),\n-                        parameters.getClientId(),\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getHomeAccountId(),\n-                        realm\n-                ).isEmpty();\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, String.valueOf(localRemoveAccountSuccess))\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        return localRemoveAccountSuccess;\n-    }\n-\n-    @Override\n-    public boolean getDeviceMode(CommandParameters parameters) throws Exception {\n-        final String methodName = \":getDeviceMode\";\n-\n-        final String errorMessage = \"LocalMSALController is not eligible to use the broker. Do not check sharedDevice mode and return false immediately.\";\n-        com.microsoft.identity.common.internal.logging.Logger.warn(TAG + methodName, errorMessage);\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public List<ICacheRecord> getCurrentAccount(CommandParameters parameters) throws Exception {\n-        return getAccounts(parameters);\n-    }\n-\n-    @Override\n-    public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) throws Exception {\n-        return removeAccount(parameters);\n-    }\n-\n-    @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n-        // Logging start of method\n-        final String methodName = \":deviceCodeFlowAuthRequest\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Authorizing user code...\"\n-        );\n-\n-        // Default scopes here\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parametersWithScopes)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 1: Get user code\n-        // Populate global authorization request\n-        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n-\n-        // Call method defined in oAuth2Strategy to request authorization\n-        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n-\n-        validateServiceResult(authorizationResult);\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow authorization step finished...\"\n-        );\n-        logResult(TAG, authorizationResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        return authorizationResult;\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(\n-            final AuthorizationResult authorizationResult,\n-            final DeviceCodeFlowCommandParameters parameters)\n-            throws MsalException, ClientException, IOException, InterruptedException {\n-\n-        // Logging start of method\n-        final String methodName = \":acquireDeviceCodeFlowToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Polling for token...\"\n-        );\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        // Create empty AcquireTokenResult object\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        // Assign authorization result\n-        acquireTokenResult.setAuthorizationResult(authorizationResult);\n-\n-        // Fetch the Authorization Response\n-        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parameters\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 2: Poll for token\n-        TokenResult tokenResult = null;\n-\n-        // Create token request outside of loop so it isn't re-created after every loop\n-        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n-                mAuthorizationRequest,\n-                authorizationResponse,\n-                parameters.getAuthenticationScheme()\n-        );\n-\n-        // Fetch wait interval\n-        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n-\n-        String errorCode = \"authorization_pending\";\n-\n-        // Loop to send multiple requests checking for token\n-        while (errorCode.equals(\"authorization_pending\")) {\n-            errorCode = \"\"; // Reset error code\n-\n-            // Execute Token Request\n-            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n-\n-            if (tokenResult.getErrorResponse() != null) {\n-                errorCode = tokenResult.getErrorResponse().getError();\n-            }\n-\n-            if (errorCode.equals(\"authorization_pending\")) {\n-                // interval is passed through params\n-                Thread.sleep(interval);\n-            }\n-        }\n-\n-        // Assign token result\n-        acquireTokenResult.setTokenResult(tokenResult);\n-\n-        // Validate request success, may throw MsalServiceException\n-        validateServiceResult(tokenResult);\n-\n-        // If the token is valid, save it into token cache\n-        final List<ICacheRecord> records = saveTokens(\n-                oAuth2Strategy,\n-                mAuthorizationRequest,\n-                acquireTokenResult.getTokenResult().getTokenResponse(),\n-                parameters.getOAuth2TokenCache()\n-        );\n-\n-        // Once the token is stored, fetch and assign the authentication result\n-        final ICacheRecord newestRecord = records.get(0);\n-        acquireTokenResult.setLocalAuthenticationResult(\n-                new LocalAuthenticationResult(\n-                        finalizeCacheRecordForResult(\n-                                newestRecord,\n-                                parameters.getAuthenticationScheme()\n-                        ),\n-                        records,\n-                        SdkType.MSAL,\n-                        false\n-                )\n-        );\n-\n-        logResult(TAG, tokenResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    /**\n-     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n-     * This method is called in both parts of the DCF protocol.\n-     * @param result result object to be checked\n-     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n-     */\n-    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n-        // If result was unsuccessful, create an exception\n-        if (!result.getSuccess()) {\n-            // Create ServiceException object\n-            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n-\n-            // Convert ServiceException to MsalServiceException, then throw\n-            throw new MsalServiceException(\n-                    serviceException.getErrorCode(),\n-                    serviceException.getMessage(),\n-                    serviceException.getHttpStatusCode(),\n-                    serviceException\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Given an error response object, create a serviceException object using the predefined error codes.\n-     * @param response error response object to be checked\n-     * @return an exception object\n-     */\n-    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {\n-        // Based on error code, fetch the error message\n-        String errorCode = response.getError();\n-        String errorMessage = null;\n-\n-        // Check response code against pre-defined error codes\n-        switch (errorCode) {\n-            case ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_MESSAGE;\n-                break;\n-            default:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_DEFAULT_ERROR_MESSAGE;\n-        }\n-\n-        // Create a ServiceException object and return it\n-        return new ServiceException(\n-                errorCode,\n-                errorMessage,\n-                ServiceException.DEFAULT_STATUS_CODE,\n-                null\n-        );\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MTQxMg==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462581412", "body": "Consider refactoring into a boolean method such as:\r\n\r\n```java\r\n   while (authorizationPending())\r\n```", "bodyText": "Consider refactoring into a boolean method such as:\n   while (authorizationPending())", "bodyHTML": "<p dir=\"auto\">Consider refactoring into a boolean method such as:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"   while (authorizationPending())\n\"><pre>   <span class=\"pl-k\">while</span> (authorizationPending())</pre></div>", "author": "shahzaibj", "createdAt": "2020-07-29T20:52:40Z", "path": "msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java", "diffHunk": "@@ -463,14 +468,224 @@ public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) t\n     }\n \n     @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n+        // Logging start of method\n+        final String methodName = \":deviceCodeFlowAuthRequest\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Authorizing user code...\"\n+        );\n+\n+        // Default scopes here\n+        final Set<String> mergedScopes = addDefaultScopes(parameters);\n+\n+        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n+                .toBuilder()\n+                .scopes(mergedScopes)\n+                .build();\n+\n+        logParameters(TAG, parametersWithScopes);\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putProperties(parametersWithScopes)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 1: Get user code\n+        // Populate global authorization request\n+        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n+\n+        // Call method defined in oAuth2Strategy to request authorization\n+        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n+\n+        validateServiceResult(authorizationResult);\n+\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow authorization step finished...\"\n+        );\n+        logResult(TAG, authorizationResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        return authorizationResult;\n     }\n \n     @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(final AuthorizationResult authorizationResult, DeviceCodeFlowCommandParameters commandParameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AcquireTokenResult acquireDeviceCodeFlowToken(\n+            final AuthorizationResult authorizationResult,\n+            final DeviceCodeFlowCommandParameters parameters)\n+            throws MsalException, ClientException, IOException, InterruptedException {\n+\n+        // Logging start of method\n+        final String methodName = \":acquireDeviceCodeFlowToken\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Polling for token...\"\n+        );\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        // Create empty AcquireTokenResult object\n+        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n+\n+        // Assign authorization result\n+        acquireTokenResult.setAuthorizationResult(authorizationResult);\n+\n+        // Fetch the Authorization Response\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parameters\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 2: Poll for token\n+        TokenResult tokenResult = null;\n+\n+        // Create token request outside of loop so it isn't re-created after every loop\n+        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n+                mAuthorizationRequest,\n+                authorizationResponse,\n+                parameters.getAuthenticationScheme()\n+        );\n+\n+        // Fetch wait interval\n+        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n+\n+        String errorCode = \"authorization_pending\";\n+\n+        // Loop to send multiple requests checking for token\n+        while (errorCode.equals(\"authorization_pending\")) {", "originalCommit": "dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db4160a3861d0ee64f555150baba754033aba357", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java b/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\ndeleted file mode 100644\nindex 0bbf36bb..00000000\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\n+++ /dev/null\n", "chunk": "@@ -1,691 +0,0 @@\n-//  Copyright (c) Microsoft Corporation.\n-//  All rights reserved.\n-//\n-//  This code is licensed under the MIT License.\n-//\n-//  Permission is hereby granted, free of charge, to any person obtaining a copy\n-//  of this software and associated documentation files(the \"Software\"), to deal\n-//  in the Software without restriction, including without limitation the rights\n-//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n-//  copies of the Software, and to permit persons to whom the Software is\n-//  furnished to do so, subject to the following conditions :\n-//\n-//  The above copyright notice and this permission notice shall be included in\n-//  all copies or substantial portions of the Software.\n-//\n-//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-//  THE SOFTWARE.\n-package com.microsoft.identity.client.internal.controllers;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.text.TextUtils;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.WorkerThread;\n-\n-import com.microsoft.identity.client.exception.MsalException;\n-import com.microsoft.identity.client.exception.MsalServiceException;\n-import com.microsoft.identity.client.exception.MsalUiRequiredException;\n-import com.microsoft.identity.common.exception.ArgumentException;\n-import com.microsoft.identity.common.exception.ClientException;\n-import com.microsoft.identity.common.exception.ErrorStrings;\n-import com.microsoft.identity.common.exception.ServiceException;\n-import com.microsoft.identity.common.internal.authorities.Authority;\n-import com.microsoft.identity.common.internal.authscheme.AbstractAuthenticationScheme;\n-import com.microsoft.identity.common.internal.cache.ICacheRecord;\n-import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n-import com.microsoft.identity.common.internal.controllers.BaseController;\n-import com.microsoft.identity.common.internal.dto.AccountRecord;\n-import com.microsoft.identity.common.internal.logging.Logger;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStatus;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStrategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.IErrorResponse;\n-import com.microsoft.identity.common.internal.providers.oauth2.IResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2TokenCache;\n-import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n-import com.microsoft.identity.common.internal.request.SdkType;\n-import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n-import com.microsoft.identity.common.internal.result.LocalAuthenticationResult;\n-import com.microsoft.identity.common.internal.telemetry.Telemetry;\n-import com.microsoft.identity.common.internal.telemetry.TelemetryEventStrings;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiEndEvent;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiStartEvent;\n-import com.microsoft.identity.common.internal.ui.AuthorizationStrategyFactory;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import static com.microsoft.identity.common.adal.internal.net.HttpWebRequest.throwIfNetworkNotAvailable;\n-\n-public class LocalMSALController extends BaseController {\n-\n-    private static final String TAG = LocalMSALController.class.getSimpleName();\n-\n-    private AuthorizationStrategy mAuthorizationStrategy = null;\n-    private AuthorizationRequest mAuthorizationRequest = null;\n-\n-    @Override\n-    public AcquireTokenResult acquireToken(\n-            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException, IOException, ArgumentException {\n-        final String methodName = \":acquireToken\";\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        //00) Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final InteractiveTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        //0) Get known authority result\n-        throwIfNetworkNotAvailable(\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes.isPowerOptCheckEnabled()\n-        );\n-\n-        Authority.KnownAuthorityResult authorityResult = Authority.getKnownAuthorityResult(parametersWithScopes.getAuthority());\n-\n-        //0.1 If not known throw resulting exception\n-        if (!authorityResult.getKnown()) {\n-            Telemetry.emit(\n-                    new ApiEndEvent()\n-                            .putException(authorityResult.getClientException())\n-                            .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-            );\n-\n-            throw authorityResult.getClientException();\n-        }\n-\n-        // Build up params for Strategy construction\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        //1) Get oAuth2Strategy for Authority Type\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-\n-        //2) Request authorization interactively\n-        final AuthorizationResult result = performAuthorizationRequest(\n-                oAuth2Strategy,\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes\n-        );\n-        acquireTokenResult.setAuthorizationResult(result);\n-\n-        logResult(TAG, result);\n-\n-        if (result.getAuthorizationStatus().equals(AuthorizationStatus.SUCCESS)) {\n-            //3) Exchange authorization code for token\n-            final TokenResult tokenResult = performTokenRequest(\n-                    oAuth2Strategy,\n-                    mAuthorizationRequest,\n-                    result.getAuthorizationResponse(),\n-                    parametersWithScopes\n-            );\n-\n-            acquireTokenResult.setTokenResult(tokenResult);\n-\n-            if (tokenResult != null && tokenResult.getSuccess()) {\n-                //4) Save tokens in token cache\n-                final List<ICacheRecord> records = saveTokens(\n-                        oAuth2Strategy,\n-                        mAuthorizationRequest,\n-                        tokenResult.getTokenResponse(),\n-                        parametersWithScopes.getOAuth2TokenCache()\n-                );\n-\n-                // The first element in the returned list is the item we *just* saved, the rest of\n-                // the elements are necessary to construct the full IAccount + TenantProfile\n-                final ICacheRecord newestRecord = records.get(0);\n-\n-                acquireTokenResult.setLocalAuthenticationResult(\n-                        new LocalAuthenticationResult(\n-                                finalizeCacheRecordForResult(\n-                                        newestRecord,\n-                                        parametersWithScopes.getAuthenticationScheme()\n-                                ),\n-                                records,\n-                                SdkType.MSAL,\n-                                false\n-                        )\n-                );\n-            }\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    private AuthorizationResult performAuthorizationRequest(@NonNull final OAuth2Strategy strategy,\n-                                                            @NonNull final Context context,\n-                                                            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException {\n-\n-        throwIfNetworkNotAvailable(context, parameters.isPowerOptCheckEnabled());\n-\n-        mAuthorizationStrategy = AuthorizationStrategyFactory.getInstance()\n-                .getAuthorizationStrategy(\n-                        parameters\n-                );\n-        mAuthorizationRequest = getAuthorizationRequest(strategy, parameters);\n-\n-        final Future<AuthorizationResult> future = strategy.requestAuthorization(\n-                mAuthorizationRequest,\n-                mAuthorizationStrategy\n-        );\n-\n-        final AuthorizationResult result = future.get();\n-\n-        return result;\n-    }\n-\n-    @Override\n-    public void completeAcquireToken(final int requestCode,\n-                                     final int resultCode,\n-                                     final Intent data) {\n-        final String methodName = \":completeAcquireToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Completing acquire token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-                        .put(TelemetryEventStrings.Key.RESULT_CODE, String.valueOf(resultCode))\n-                        .put(TelemetryEventStrings.Key.REQUEST_CODE, String.valueOf(requestCode))\n-        );\n-\n-        mAuthorizationStrategy.completeAuthorization(requestCode, resultCode, data);\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireTokenSilent(\n-            @NonNull final SilentTokenCommandParameters parameters)\n-            throws IOException, ClientException, ArgumentException, ServiceException {\n-        final String methodName = \":acquireTokenSilent\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token silently...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        final AcquireTokenResult acquireTokenSilentResult = new AcquireTokenResult();\n-\n-        //Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final SilentTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        final OAuth2TokenCache tokenCache = parametersWithScopes.getOAuth2TokenCache();\n-\n-        final AccountRecord targetAccount = getCachedAccountRecord(parametersWithScopes);\n-\n-        // Build up params for Strategy construction\n-        final AbstractAuthenticationScheme authScheme = parametersWithScopes.getAuthenticationScheme();\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy strategy = parametersWithScopes.getAuthority().createOAuth2Strategy(strategyParameters);\n-\n-        final List<ICacheRecord> cacheRecords = tokenCache.loadWithAggregatedAccountData(\n-                parametersWithScopes.getClientId(),\n-                TextUtils.join(\" \", parametersWithScopes.getScopes()),\n-                targetAccount,\n-                authScheme\n-        );\n-\n-        // The first element is the 'fully-loaded' CacheRecord which may contain the AccountRecord,\n-        // AccessTokenRecord, RefreshTokenRecord, and IdTokenRecord... (if all of those artifacts exist)\n-        // subsequent CacheRecords represent other profiles (projections) of this principal in\n-        // other tenants. Those tokens will be 'sparse', meaning that their AT/RT will not be loaded\n-        final ICacheRecord fullCacheRecord = cacheRecords.get(0);\n-\n-        if (accessTokenIsNull(fullCacheRecord)\n-                || refreshTokenIsNull(fullCacheRecord)\n-                || parametersWithScopes.isForceRefresh()\n-                || !isRequestAuthorityRealmSameAsATRealm(parametersWithScopes.getAuthority(), fullCacheRecord.getAccessToken())\n-                || !strategy.validateCachedResult(authScheme, fullCacheRecord)) {\n-            if (!refreshTokenIsNull(fullCacheRecord)) {\n-                // No AT found, but the RT checks out, so we'll use it\n-                Logger.verbose(\n-                        TAG + methodName,\n-                        \"No access token found, but RT is available.\"\n-                );\n-\n-                renewAccessToken(\n-                        parametersWithScopes,\n-                        acquireTokenSilentResult,\n-                        tokenCache,\n-                        strategy,\n-                        fullCacheRecord\n-                );\n-            } else {\n-                //TODO need the refactor, should just throw the ui required exception, rather than\n-                // wrap the exception later in the exception wrapper.\n-                final ClientException exception = new ClientException(\n-                        MsalUiRequiredException.NO_TOKENS_FOUND,\n-                        \"No refresh token was found. \"\n-                );\n-\n-                Telemetry.emit(\n-                        new ApiEndEvent()\n-                                .putException(exception)\n-                                .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-                );\n-\n-                throw exception;\n-            }\n-        } else if (fullCacheRecord.getAccessToken().isExpired()) {\n-            Logger.warn(\n-                    TAG + methodName,\n-                    \"Access token is expired. Removing from cache...\"\n-            );\n-            // Remove the expired token\n-            tokenCache.removeCredential(fullCacheRecord.getAccessToken());\n-\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Renewing access token...\"\n-            );\n-            // Request a new AT\n-            renewAccessToken(\n-                    parametersWithScopes,\n-                    acquireTokenSilentResult,\n-                    tokenCache,\n-                    strategy,\n-                    fullCacheRecord\n-            );\n-        } else {\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Returning silent result\"\n-            );\n-            // the result checks out, return that....\n-            acquireTokenSilentResult.setLocalAuthenticationResult(\n-                    new LocalAuthenticationResult(\n-                            finalizeCacheRecordForResult(\n-                                    fullCacheRecord,\n-                                    parametersWithScopes.getAuthenticationScheme()\n-                            ),\n-                            cacheRecords,\n-                            SdkType.MSAL,\n-                            true\n-                    )\n-            );\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenSilentResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        return acquireTokenSilentResult;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public List<ICacheRecord> getAccounts(@NonNull final CommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-        );\n-\n-        final List<ICacheRecord> accountsInCache =\n-                parameters\n-                        .getOAuth2TokenCache()\n-                        .getAccountsWithAggregatedAccountData(\n-                                null, // * wildcard\n-                                parameters.getClientId()\n-                        );\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-                        .put(TelemetryEventStrings.Key.ACCOUNTS_NUMBER, Integer.toString(accountsInCache.size()))\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, TelemetryEventStrings.Value.TRUE)\n-        );\n-\n-        return accountsInCache;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public boolean removeAccount(\n-            @NonNull final RemoveAccountCommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        String realm = null;\n-\n-        if (parameters.getAccount() != null) {\n-            realm = parameters.getAccount().getRealm();\n-        }\n-\n-        final boolean localRemoveAccountSuccess = !parameters\n-                .getOAuth2TokenCache()\n-                .removeAccount(\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getEnvironment(),\n-                        parameters.getClientId(),\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getHomeAccountId(),\n-                        realm\n-                ).isEmpty();\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, String.valueOf(localRemoveAccountSuccess))\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        return localRemoveAccountSuccess;\n-    }\n-\n-    @Override\n-    public boolean getDeviceMode(CommandParameters parameters) throws Exception {\n-        final String methodName = \":getDeviceMode\";\n-\n-        final String errorMessage = \"LocalMSALController is not eligible to use the broker. Do not check sharedDevice mode and return false immediately.\";\n-        com.microsoft.identity.common.internal.logging.Logger.warn(TAG + methodName, errorMessage);\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public List<ICacheRecord> getCurrentAccount(CommandParameters parameters) throws Exception {\n-        return getAccounts(parameters);\n-    }\n-\n-    @Override\n-    public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) throws Exception {\n-        return removeAccount(parameters);\n-    }\n-\n-    @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n-        // Logging start of method\n-        final String methodName = \":deviceCodeFlowAuthRequest\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Authorizing user code...\"\n-        );\n-\n-        // Default scopes here\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parametersWithScopes)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 1: Get user code\n-        // Populate global authorization request\n-        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n-\n-        // Call method defined in oAuth2Strategy to request authorization\n-        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n-\n-        validateServiceResult(authorizationResult);\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow authorization step finished...\"\n-        );\n-        logResult(TAG, authorizationResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        return authorizationResult;\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(\n-            final AuthorizationResult authorizationResult,\n-            final DeviceCodeFlowCommandParameters parameters)\n-            throws MsalException, ClientException, IOException, InterruptedException {\n-\n-        // Logging start of method\n-        final String methodName = \":acquireDeviceCodeFlowToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Polling for token...\"\n-        );\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        // Create empty AcquireTokenResult object\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        // Assign authorization result\n-        acquireTokenResult.setAuthorizationResult(authorizationResult);\n-\n-        // Fetch the Authorization Response\n-        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parameters\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 2: Poll for token\n-        TokenResult tokenResult = null;\n-\n-        // Create token request outside of loop so it isn't re-created after every loop\n-        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n-                mAuthorizationRequest,\n-                authorizationResponse,\n-                parameters.getAuthenticationScheme()\n-        );\n-\n-        // Fetch wait interval\n-        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n-\n-        String errorCode = \"authorization_pending\";\n-\n-        // Loop to send multiple requests checking for token\n-        while (errorCode.equals(\"authorization_pending\")) {\n-            errorCode = \"\"; // Reset error code\n-\n-            // Execute Token Request\n-            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n-\n-            if (tokenResult.getErrorResponse() != null) {\n-                errorCode = tokenResult.getErrorResponse().getError();\n-            }\n-\n-            if (errorCode.equals(\"authorization_pending\")) {\n-                // interval is passed through params\n-                Thread.sleep(interval);\n-            }\n-        }\n-\n-        // Assign token result\n-        acquireTokenResult.setTokenResult(tokenResult);\n-\n-        // Validate request success, may throw MsalServiceException\n-        validateServiceResult(tokenResult);\n-\n-        // If the token is valid, save it into token cache\n-        final List<ICacheRecord> records = saveTokens(\n-                oAuth2Strategy,\n-                mAuthorizationRequest,\n-                acquireTokenResult.getTokenResult().getTokenResponse(),\n-                parameters.getOAuth2TokenCache()\n-        );\n-\n-        // Once the token is stored, fetch and assign the authentication result\n-        final ICacheRecord newestRecord = records.get(0);\n-        acquireTokenResult.setLocalAuthenticationResult(\n-                new LocalAuthenticationResult(\n-                        finalizeCacheRecordForResult(\n-                                newestRecord,\n-                                parameters.getAuthenticationScheme()\n-                        ),\n-                        records,\n-                        SdkType.MSAL,\n-                        false\n-                )\n-        );\n-\n-        logResult(TAG, tokenResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    /**\n-     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n-     * This method is called in both parts of the DCF protocol.\n-     * @param result result object to be checked\n-     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n-     */\n-    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n-        // If result was unsuccessful, create an exception\n-        if (!result.getSuccess()) {\n-            // Create ServiceException object\n-            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n-\n-            // Convert ServiceException to MsalServiceException, then throw\n-            throw new MsalServiceException(\n-                    serviceException.getErrorCode(),\n-                    serviceException.getMessage(),\n-                    serviceException.getHttpStatusCode(),\n-                    serviceException\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Given an error response object, create a serviceException object using the predefined error codes.\n-     * @param response error response object to be checked\n-     * @return an exception object\n-     */\n-    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {\n-        // Based on error code, fetch the error message\n-        String errorCode = response.getError();\n-        String errorMessage = null;\n-\n-        // Check response code against pre-defined error codes\n-        switch (errorCode) {\n-            case ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_MESSAGE;\n-                break;\n-            default:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_DEFAULT_ERROR_MESSAGE;\n-        }\n-\n-        // Create a ServiceException object and return it\n-        return new ServiceException(\n-                errorCode,\n-                errorMessage,\n-                ServiceException.DEFAULT_STATUS_CODE,\n-                null\n-        );\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MjQwMw==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462582403", "body": "Do we actually want to throw all these exceptions? Or should this method handle some of these directly?", "bodyText": "Do we actually want to throw all these exceptions? Or should this method handle some of these directly?", "bodyHTML": "<p dir=\"auto\">Do we actually want to throw all these exceptions? Or should this method handle some of these directly?</p>", "author": "shahzaibj", "createdAt": "2020-07-29T20:54:24Z", "path": "msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java", "diffHunk": "@@ -463,14 +468,224 @@ public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) t\n     }\n \n     @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n+        // Logging start of method\n+        final String methodName = \":deviceCodeFlowAuthRequest\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Authorizing user code...\"\n+        );\n+\n+        // Default scopes here\n+        final Set<String> mergedScopes = addDefaultScopes(parameters);\n+\n+        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n+                .toBuilder()\n+                .scopes(mergedScopes)\n+                .build();\n+\n+        logParameters(TAG, parametersWithScopes);\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putProperties(parametersWithScopes)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 1: Get user code\n+        // Populate global authorization request\n+        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n+\n+        // Call method defined in oAuth2Strategy to request authorization\n+        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n+\n+        validateServiceResult(authorizationResult);\n+\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow authorization step finished...\"\n+        );\n+        logResult(TAG, authorizationResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        return authorizationResult;\n     }\n \n     @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(final AuthorizationResult authorizationResult, DeviceCodeFlowCommandParameters commandParameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AcquireTokenResult acquireDeviceCodeFlowToken(\n+            final AuthorizationResult authorizationResult,\n+            final DeviceCodeFlowCommandParameters parameters)\n+            throws MsalException, ClientException, IOException, InterruptedException {", "originalCommit": "dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY5NTQ1MA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462695450", "bodyText": "I think it's fine as is? MsalException should be thrown since we want to communicate that to the command class. I feel the other three would point to an error on our end.", "author": "t-fadura", "createdAt": "2020-07-30T02:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MjQwMw=="}], "type": "inlineReview", "revised_code": {"commit": "db4160a3861d0ee64f555150baba754033aba357", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java b/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\ndeleted file mode 100644\nindex 0bbf36bb..00000000\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\n+++ /dev/null\n", "chunk": "@@ -1,691 +0,0 @@\n-//  Copyright (c) Microsoft Corporation.\n-//  All rights reserved.\n-//\n-//  This code is licensed under the MIT License.\n-//\n-//  Permission is hereby granted, free of charge, to any person obtaining a copy\n-//  of this software and associated documentation files(the \"Software\"), to deal\n-//  in the Software without restriction, including without limitation the rights\n-//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n-//  copies of the Software, and to permit persons to whom the Software is\n-//  furnished to do so, subject to the following conditions :\n-//\n-//  The above copyright notice and this permission notice shall be included in\n-//  all copies or substantial portions of the Software.\n-//\n-//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-//  THE SOFTWARE.\n-package com.microsoft.identity.client.internal.controllers;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.text.TextUtils;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.WorkerThread;\n-\n-import com.microsoft.identity.client.exception.MsalException;\n-import com.microsoft.identity.client.exception.MsalServiceException;\n-import com.microsoft.identity.client.exception.MsalUiRequiredException;\n-import com.microsoft.identity.common.exception.ArgumentException;\n-import com.microsoft.identity.common.exception.ClientException;\n-import com.microsoft.identity.common.exception.ErrorStrings;\n-import com.microsoft.identity.common.exception.ServiceException;\n-import com.microsoft.identity.common.internal.authorities.Authority;\n-import com.microsoft.identity.common.internal.authscheme.AbstractAuthenticationScheme;\n-import com.microsoft.identity.common.internal.cache.ICacheRecord;\n-import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n-import com.microsoft.identity.common.internal.controllers.BaseController;\n-import com.microsoft.identity.common.internal.dto.AccountRecord;\n-import com.microsoft.identity.common.internal.logging.Logger;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStatus;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStrategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.IErrorResponse;\n-import com.microsoft.identity.common.internal.providers.oauth2.IResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2TokenCache;\n-import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n-import com.microsoft.identity.common.internal.request.SdkType;\n-import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n-import com.microsoft.identity.common.internal.result.LocalAuthenticationResult;\n-import com.microsoft.identity.common.internal.telemetry.Telemetry;\n-import com.microsoft.identity.common.internal.telemetry.TelemetryEventStrings;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiEndEvent;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiStartEvent;\n-import com.microsoft.identity.common.internal.ui.AuthorizationStrategyFactory;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import static com.microsoft.identity.common.adal.internal.net.HttpWebRequest.throwIfNetworkNotAvailable;\n-\n-public class LocalMSALController extends BaseController {\n-\n-    private static final String TAG = LocalMSALController.class.getSimpleName();\n-\n-    private AuthorizationStrategy mAuthorizationStrategy = null;\n-    private AuthorizationRequest mAuthorizationRequest = null;\n-\n-    @Override\n-    public AcquireTokenResult acquireToken(\n-            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException, IOException, ArgumentException {\n-        final String methodName = \":acquireToken\";\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        //00) Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final InteractiveTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        //0) Get known authority result\n-        throwIfNetworkNotAvailable(\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes.isPowerOptCheckEnabled()\n-        );\n-\n-        Authority.KnownAuthorityResult authorityResult = Authority.getKnownAuthorityResult(parametersWithScopes.getAuthority());\n-\n-        //0.1 If not known throw resulting exception\n-        if (!authorityResult.getKnown()) {\n-            Telemetry.emit(\n-                    new ApiEndEvent()\n-                            .putException(authorityResult.getClientException())\n-                            .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-            );\n-\n-            throw authorityResult.getClientException();\n-        }\n-\n-        // Build up params for Strategy construction\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        //1) Get oAuth2Strategy for Authority Type\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-\n-        //2) Request authorization interactively\n-        final AuthorizationResult result = performAuthorizationRequest(\n-                oAuth2Strategy,\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes\n-        );\n-        acquireTokenResult.setAuthorizationResult(result);\n-\n-        logResult(TAG, result);\n-\n-        if (result.getAuthorizationStatus().equals(AuthorizationStatus.SUCCESS)) {\n-            //3) Exchange authorization code for token\n-            final TokenResult tokenResult = performTokenRequest(\n-                    oAuth2Strategy,\n-                    mAuthorizationRequest,\n-                    result.getAuthorizationResponse(),\n-                    parametersWithScopes\n-            );\n-\n-            acquireTokenResult.setTokenResult(tokenResult);\n-\n-            if (tokenResult != null && tokenResult.getSuccess()) {\n-                //4) Save tokens in token cache\n-                final List<ICacheRecord> records = saveTokens(\n-                        oAuth2Strategy,\n-                        mAuthorizationRequest,\n-                        tokenResult.getTokenResponse(),\n-                        parametersWithScopes.getOAuth2TokenCache()\n-                );\n-\n-                // The first element in the returned list is the item we *just* saved, the rest of\n-                // the elements are necessary to construct the full IAccount + TenantProfile\n-                final ICacheRecord newestRecord = records.get(0);\n-\n-                acquireTokenResult.setLocalAuthenticationResult(\n-                        new LocalAuthenticationResult(\n-                                finalizeCacheRecordForResult(\n-                                        newestRecord,\n-                                        parametersWithScopes.getAuthenticationScheme()\n-                                ),\n-                                records,\n-                                SdkType.MSAL,\n-                                false\n-                        )\n-                );\n-            }\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    private AuthorizationResult performAuthorizationRequest(@NonNull final OAuth2Strategy strategy,\n-                                                            @NonNull final Context context,\n-                                                            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException {\n-\n-        throwIfNetworkNotAvailable(context, parameters.isPowerOptCheckEnabled());\n-\n-        mAuthorizationStrategy = AuthorizationStrategyFactory.getInstance()\n-                .getAuthorizationStrategy(\n-                        parameters\n-                );\n-        mAuthorizationRequest = getAuthorizationRequest(strategy, parameters);\n-\n-        final Future<AuthorizationResult> future = strategy.requestAuthorization(\n-                mAuthorizationRequest,\n-                mAuthorizationStrategy\n-        );\n-\n-        final AuthorizationResult result = future.get();\n-\n-        return result;\n-    }\n-\n-    @Override\n-    public void completeAcquireToken(final int requestCode,\n-                                     final int resultCode,\n-                                     final Intent data) {\n-        final String methodName = \":completeAcquireToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Completing acquire token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-                        .put(TelemetryEventStrings.Key.RESULT_CODE, String.valueOf(resultCode))\n-                        .put(TelemetryEventStrings.Key.REQUEST_CODE, String.valueOf(requestCode))\n-        );\n-\n-        mAuthorizationStrategy.completeAuthorization(requestCode, resultCode, data);\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireTokenSilent(\n-            @NonNull final SilentTokenCommandParameters parameters)\n-            throws IOException, ClientException, ArgumentException, ServiceException {\n-        final String methodName = \":acquireTokenSilent\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token silently...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        final AcquireTokenResult acquireTokenSilentResult = new AcquireTokenResult();\n-\n-        //Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final SilentTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        final OAuth2TokenCache tokenCache = parametersWithScopes.getOAuth2TokenCache();\n-\n-        final AccountRecord targetAccount = getCachedAccountRecord(parametersWithScopes);\n-\n-        // Build up params for Strategy construction\n-        final AbstractAuthenticationScheme authScheme = parametersWithScopes.getAuthenticationScheme();\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy strategy = parametersWithScopes.getAuthority().createOAuth2Strategy(strategyParameters);\n-\n-        final List<ICacheRecord> cacheRecords = tokenCache.loadWithAggregatedAccountData(\n-                parametersWithScopes.getClientId(),\n-                TextUtils.join(\" \", parametersWithScopes.getScopes()),\n-                targetAccount,\n-                authScheme\n-        );\n-\n-        // The first element is the 'fully-loaded' CacheRecord which may contain the AccountRecord,\n-        // AccessTokenRecord, RefreshTokenRecord, and IdTokenRecord... (if all of those artifacts exist)\n-        // subsequent CacheRecords represent other profiles (projections) of this principal in\n-        // other tenants. Those tokens will be 'sparse', meaning that their AT/RT will not be loaded\n-        final ICacheRecord fullCacheRecord = cacheRecords.get(0);\n-\n-        if (accessTokenIsNull(fullCacheRecord)\n-                || refreshTokenIsNull(fullCacheRecord)\n-                || parametersWithScopes.isForceRefresh()\n-                || !isRequestAuthorityRealmSameAsATRealm(parametersWithScopes.getAuthority(), fullCacheRecord.getAccessToken())\n-                || !strategy.validateCachedResult(authScheme, fullCacheRecord)) {\n-            if (!refreshTokenIsNull(fullCacheRecord)) {\n-                // No AT found, but the RT checks out, so we'll use it\n-                Logger.verbose(\n-                        TAG + methodName,\n-                        \"No access token found, but RT is available.\"\n-                );\n-\n-                renewAccessToken(\n-                        parametersWithScopes,\n-                        acquireTokenSilentResult,\n-                        tokenCache,\n-                        strategy,\n-                        fullCacheRecord\n-                );\n-            } else {\n-                //TODO need the refactor, should just throw the ui required exception, rather than\n-                // wrap the exception later in the exception wrapper.\n-                final ClientException exception = new ClientException(\n-                        MsalUiRequiredException.NO_TOKENS_FOUND,\n-                        \"No refresh token was found. \"\n-                );\n-\n-                Telemetry.emit(\n-                        new ApiEndEvent()\n-                                .putException(exception)\n-                                .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-                );\n-\n-                throw exception;\n-            }\n-        } else if (fullCacheRecord.getAccessToken().isExpired()) {\n-            Logger.warn(\n-                    TAG + methodName,\n-                    \"Access token is expired. Removing from cache...\"\n-            );\n-            // Remove the expired token\n-            tokenCache.removeCredential(fullCacheRecord.getAccessToken());\n-\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Renewing access token...\"\n-            );\n-            // Request a new AT\n-            renewAccessToken(\n-                    parametersWithScopes,\n-                    acquireTokenSilentResult,\n-                    tokenCache,\n-                    strategy,\n-                    fullCacheRecord\n-            );\n-        } else {\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Returning silent result\"\n-            );\n-            // the result checks out, return that....\n-            acquireTokenSilentResult.setLocalAuthenticationResult(\n-                    new LocalAuthenticationResult(\n-                            finalizeCacheRecordForResult(\n-                                    fullCacheRecord,\n-                                    parametersWithScopes.getAuthenticationScheme()\n-                            ),\n-                            cacheRecords,\n-                            SdkType.MSAL,\n-                            true\n-                    )\n-            );\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenSilentResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        return acquireTokenSilentResult;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public List<ICacheRecord> getAccounts(@NonNull final CommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-        );\n-\n-        final List<ICacheRecord> accountsInCache =\n-                parameters\n-                        .getOAuth2TokenCache()\n-                        .getAccountsWithAggregatedAccountData(\n-                                null, // * wildcard\n-                                parameters.getClientId()\n-                        );\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-                        .put(TelemetryEventStrings.Key.ACCOUNTS_NUMBER, Integer.toString(accountsInCache.size()))\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, TelemetryEventStrings.Value.TRUE)\n-        );\n-\n-        return accountsInCache;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public boolean removeAccount(\n-            @NonNull final RemoveAccountCommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        String realm = null;\n-\n-        if (parameters.getAccount() != null) {\n-            realm = parameters.getAccount().getRealm();\n-        }\n-\n-        final boolean localRemoveAccountSuccess = !parameters\n-                .getOAuth2TokenCache()\n-                .removeAccount(\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getEnvironment(),\n-                        parameters.getClientId(),\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getHomeAccountId(),\n-                        realm\n-                ).isEmpty();\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, String.valueOf(localRemoveAccountSuccess))\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        return localRemoveAccountSuccess;\n-    }\n-\n-    @Override\n-    public boolean getDeviceMode(CommandParameters parameters) throws Exception {\n-        final String methodName = \":getDeviceMode\";\n-\n-        final String errorMessage = \"LocalMSALController is not eligible to use the broker. Do not check sharedDevice mode and return false immediately.\";\n-        com.microsoft.identity.common.internal.logging.Logger.warn(TAG + methodName, errorMessage);\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public List<ICacheRecord> getCurrentAccount(CommandParameters parameters) throws Exception {\n-        return getAccounts(parameters);\n-    }\n-\n-    @Override\n-    public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) throws Exception {\n-        return removeAccount(parameters);\n-    }\n-\n-    @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n-        // Logging start of method\n-        final String methodName = \":deviceCodeFlowAuthRequest\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Authorizing user code...\"\n-        );\n-\n-        // Default scopes here\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parametersWithScopes)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 1: Get user code\n-        // Populate global authorization request\n-        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n-\n-        // Call method defined in oAuth2Strategy to request authorization\n-        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n-\n-        validateServiceResult(authorizationResult);\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow authorization step finished...\"\n-        );\n-        logResult(TAG, authorizationResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        return authorizationResult;\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(\n-            final AuthorizationResult authorizationResult,\n-            final DeviceCodeFlowCommandParameters parameters)\n-            throws MsalException, ClientException, IOException, InterruptedException {\n-\n-        // Logging start of method\n-        final String methodName = \":acquireDeviceCodeFlowToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Polling for token...\"\n-        );\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        // Create empty AcquireTokenResult object\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        // Assign authorization result\n-        acquireTokenResult.setAuthorizationResult(authorizationResult);\n-\n-        // Fetch the Authorization Response\n-        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parameters\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 2: Poll for token\n-        TokenResult tokenResult = null;\n-\n-        // Create token request outside of loop so it isn't re-created after every loop\n-        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n-                mAuthorizationRequest,\n-                authorizationResponse,\n-                parameters.getAuthenticationScheme()\n-        );\n-\n-        // Fetch wait interval\n-        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n-\n-        String errorCode = \"authorization_pending\";\n-\n-        // Loop to send multiple requests checking for token\n-        while (errorCode.equals(\"authorization_pending\")) {\n-            errorCode = \"\"; // Reset error code\n-\n-            // Execute Token Request\n-            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n-\n-            if (tokenResult.getErrorResponse() != null) {\n-                errorCode = tokenResult.getErrorResponse().getError();\n-            }\n-\n-            if (errorCode.equals(\"authorization_pending\")) {\n-                // interval is passed through params\n-                Thread.sleep(interval);\n-            }\n-        }\n-\n-        // Assign token result\n-        acquireTokenResult.setTokenResult(tokenResult);\n-\n-        // Validate request success, may throw MsalServiceException\n-        validateServiceResult(tokenResult);\n-\n-        // If the token is valid, save it into token cache\n-        final List<ICacheRecord> records = saveTokens(\n-                oAuth2Strategy,\n-                mAuthorizationRequest,\n-                acquireTokenResult.getTokenResult().getTokenResponse(),\n-                parameters.getOAuth2TokenCache()\n-        );\n-\n-        // Once the token is stored, fetch and assign the authentication result\n-        final ICacheRecord newestRecord = records.get(0);\n-        acquireTokenResult.setLocalAuthenticationResult(\n-                new LocalAuthenticationResult(\n-                        finalizeCacheRecordForResult(\n-                                newestRecord,\n-                                parameters.getAuthenticationScheme()\n-                        ),\n-                        records,\n-                        SdkType.MSAL,\n-                        false\n-                )\n-        );\n-\n-        logResult(TAG, tokenResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    /**\n-     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n-     * This method is called in both parts of the DCF protocol.\n-     * @param result result object to be checked\n-     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n-     */\n-    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n-        // If result was unsuccessful, create an exception\n-        if (!result.getSuccess()) {\n-            // Create ServiceException object\n-            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n-\n-            // Convert ServiceException to MsalServiceException, then throw\n-            throw new MsalServiceException(\n-                    serviceException.getErrorCode(),\n-                    serviceException.getMessage(),\n-                    serviceException.getHttpStatusCode(),\n-                    serviceException\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Given an error response object, create a serviceException object using the predefined error codes.\n-     * @param response error response object to be checked\n-     * @return an exception object\n-     */\n-    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {\n-        // Based on error code, fetch the error message\n-        String errorCode = response.getError();\n-        String errorMessage = null;\n-\n-        // Check response code against pre-defined error codes\n-        switch (errorCode) {\n-            case ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_MESSAGE;\n-                break;\n-            default:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_DEFAULT_ERROR_MESSAGE;\n-        }\n-\n-        // Create a ServiceException object and return it\n-        return new ServiceException(\n-                errorCode,\n-                errorMessage,\n-                ServiceException.DEFAULT_STATUS_CODE,\n-                null\n-        );\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MzU4Ng==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462583586", "body": "Can we get here and get method invoked on null object?", "bodyText": "Can we get here and get method invoked on null object?", "bodyHTML": "<p dir=\"auto\">Can we get here and get method invoked on null object?</p>", "author": "shahzaibj", "createdAt": "2020-07-29T20:56:40Z", "path": "msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java", "diffHunk": "@@ -463,14 +468,224 @@ public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) t\n     }\n \n     @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n+        // Logging start of method\n+        final String methodName = \":deviceCodeFlowAuthRequest\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Authorizing user code...\"\n+        );\n+\n+        // Default scopes here\n+        final Set<String> mergedScopes = addDefaultScopes(parameters);\n+\n+        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n+                .toBuilder()\n+                .scopes(mergedScopes)\n+                .build();\n+\n+        logParameters(TAG, parametersWithScopes);\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putProperties(parametersWithScopes)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 1: Get user code\n+        // Populate global authorization request\n+        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n+\n+        // Call method defined in oAuth2Strategy to request authorization\n+        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n+\n+        validateServiceResult(authorizationResult);\n+\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow authorization step finished...\"\n+        );\n+        logResult(TAG, authorizationResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        return authorizationResult;\n     }\n \n     @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(final AuthorizationResult authorizationResult, DeviceCodeFlowCommandParameters commandParameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AcquireTokenResult acquireDeviceCodeFlowToken(\n+            final AuthorizationResult authorizationResult,\n+            final DeviceCodeFlowCommandParameters parameters)\n+            throws MsalException, ClientException, IOException, InterruptedException {\n+\n+        // Logging start of method\n+        final String methodName = \":acquireDeviceCodeFlowToken\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Polling for token...\"\n+        );\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        // Create empty AcquireTokenResult object\n+        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n+\n+        // Assign authorization result\n+        acquireTokenResult.setAuthorizationResult(authorizationResult);\n+\n+        // Fetch the Authorization Response\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parameters\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 2: Poll for token\n+        TokenResult tokenResult = null;\n+\n+        // Create token request outside of loop so it isn't re-created after every loop\n+        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n+                mAuthorizationRequest,\n+                authorizationResponse,\n+                parameters.getAuthenticationScheme()\n+        );\n+\n+        // Fetch wait interval\n+        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n+\n+        String errorCode = \"authorization_pending\";\n+\n+        // Loop to send multiple requests checking for token\n+        while (errorCode.equals(\"authorization_pending\")) {\n+            errorCode = \"\"; // Reset error code\n+\n+            // Execute Token Request\n+            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n+\n+            if (tokenResult.getErrorResponse() != null) {\n+                errorCode = tokenResult.getErrorResponse().getError();\n+            }\n+\n+            if (errorCode.equals(\"authorization_pending\")) {\n+                // interval is passed through params\n+                Thread.sleep(interval);\n+            }\n+        }\n+\n+        // Assign token result\n+        acquireTokenResult.setTokenResult(tokenResult);", "originalCommit": "dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY5MDkxNA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462690914", "bodyText": "I don't think so, acquireTokenResult is manually created earlier in the method.", "author": "t-fadura", "createdAt": "2020-07-30T02:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4MzU4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "db4160a3861d0ee64f555150baba754033aba357", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java b/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\ndeleted file mode 100644\nindex 0bbf36bb..00000000\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\n+++ /dev/null\n", "chunk": "@@ -1,691 +0,0 @@\n-//  Copyright (c) Microsoft Corporation.\n-//  All rights reserved.\n-//\n-//  This code is licensed under the MIT License.\n-//\n-//  Permission is hereby granted, free of charge, to any person obtaining a copy\n-//  of this software and associated documentation files(the \"Software\"), to deal\n-//  in the Software without restriction, including without limitation the rights\n-//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n-//  copies of the Software, and to permit persons to whom the Software is\n-//  furnished to do so, subject to the following conditions :\n-//\n-//  The above copyright notice and this permission notice shall be included in\n-//  all copies or substantial portions of the Software.\n-//\n-//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-//  THE SOFTWARE.\n-package com.microsoft.identity.client.internal.controllers;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.text.TextUtils;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.WorkerThread;\n-\n-import com.microsoft.identity.client.exception.MsalException;\n-import com.microsoft.identity.client.exception.MsalServiceException;\n-import com.microsoft.identity.client.exception.MsalUiRequiredException;\n-import com.microsoft.identity.common.exception.ArgumentException;\n-import com.microsoft.identity.common.exception.ClientException;\n-import com.microsoft.identity.common.exception.ErrorStrings;\n-import com.microsoft.identity.common.exception.ServiceException;\n-import com.microsoft.identity.common.internal.authorities.Authority;\n-import com.microsoft.identity.common.internal.authscheme.AbstractAuthenticationScheme;\n-import com.microsoft.identity.common.internal.cache.ICacheRecord;\n-import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n-import com.microsoft.identity.common.internal.controllers.BaseController;\n-import com.microsoft.identity.common.internal.dto.AccountRecord;\n-import com.microsoft.identity.common.internal.logging.Logger;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStatus;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStrategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.IErrorResponse;\n-import com.microsoft.identity.common.internal.providers.oauth2.IResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2TokenCache;\n-import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n-import com.microsoft.identity.common.internal.request.SdkType;\n-import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n-import com.microsoft.identity.common.internal.result.LocalAuthenticationResult;\n-import com.microsoft.identity.common.internal.telemetry.Telemetry;\n-import com.microsoft.identity.common.internal.telemetry.TelemetryEventStrings;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiEndEvent;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiStartEvent;\n-import com.microsoft.identity.common.internal.ui.AuthorizationStrategyFactory;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import static com.microsoft.identity.common.adal.internal.net.HttpWebRequest.throwIfNetworkNotAvailable;\n-\n-public class LocalMSALController extends BaseController {\n-\n-    private static final String TAG = LocalMSALController.class.getSimpleName();\n-\n-    private AuthorizationStrategy mAuthorizationStrategy = null;\n-    private AuthorizationRequest mAuthorizationRequest = null;\n-\n-    @Override\n-    public AcquireTokenResult acquireToken(\n-            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException, IOException, ArgumentException {\n-        final String methodName = \":acquireToken\";\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        //00) Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final InteractiveTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        //0) Get known authority result\n-        throwIfNetworkNotAvailable(\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes.isPowerOptCheckEnabled()\n-        );\n-\n-        Authority.KnownAuthorityResult authorityResult = Authority.getKnownAuthorityResult(parametersWithScopes.getAuthority());\n-\n-        //0.1 If not known throw resulting exception\n-        if (!authorityResult.getKnown()) {\n-            Telemetry.emit(\n-                    new ApiEndEvent()\n-                            .putException(authorityResult.getClientException())\n-                            .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-            );\n-\n-            throw authorityResult.getClientException();\n-        }\n-\n-        // Build up params for Strategy construction\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        //1) Get oAuth2Strategy for Authority Type\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-\n-        //2) Request authorization interactively\n-        final AuthorizationResult result = performAuthorizationRequest(\n-                oAuth2Strategy,\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes\n-        );\n-        acquireTokenResult.setAuthorizationResult(result);\n-\n-        logResult(TAG, result);\n-\n-        if (result.getAuthorizationStatus().equals(AuthorizationStatus.SUCCESS)) {\n-            //3) Exchange authorization code for token\n-            final TokenResult tokenResult = performTokenRequest(\n-                    oAuth2Strategy,\n-                    mAuthorizationRequest,\n-                    result.getAuthorizationResponse(),\n-                    parametersWithScopes\n-            );\n-\n-            acquireTokenResult.setTokenResult(tokenResult);\n-\n-            if (tokenResult != null && tokenResult.getSuccess()) {\n-                //4) Save tokens in token cache\n-                final List<ICacheRecord> records = saveTokens(\n-                        oAuth2Strategy,\n-                        mAuthorizationRequest,\n-                        tokenResult.getTokenResponse(),\n-                        parametersWithScopes.getOAuth2TokenCache()\n-                );\n-\n-                // The first element in the returned list is the item we *just* saved, the rest of\n-                // the elements are necessary to construct the full IAccount + TenantProfile\n-                final ICacheRecord newestRecord = records.get(0);\n-\n-                acquireTokenResult.setLocalAuthenticationResult(\n-                        new LocalAuthenticationResult(\n-                                finalizeCacheRecordForResult(\n-                                        newestRecord,\n-                                        parametersWithScopes.getAuthenticationScheme()\n-                                ),\n-                                records,\n-                                SdkType.MSAL,\n-                                false\n-                        )\n-                );\n-            }\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    private AuthorizationResult performAuthorizationRequest(@NonNull final OAuth2Strategy strategy,\n-                                                            @NonNull final Context context,\n-                                                            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException {\n-\n-        throwIfNetworkNotAvailable(context, parameters.isPowerOptCheckEnabled());\n-\n-        mAuthorizationStrategy = AuthorizationStrategyFactory.getInstance()\n-                .getAuthorizationStrategy(\n-                        parameters\n-                );\n-        mAuthorizationRequest = getAuthorizationRequest(strategy, parameters);\n-\n-        final Future<AuthorizationResult> future = strategy.requestAuthorization(\n-                mAuthorizationRequest,\n-                mAuthorizationStrategy\n-        );\n-\n-        final AuthorizationResult result = future.get();\n-\n-        return result;\n-    }\n-\n-    @Override\n-    public void completeAcquireToken(final int requestCode,\n-                                     final int resultCode,\n-                                     final Intent data) {\n-        final String methodName = \":completeAcquireToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Completing acquire token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-                        .put(TelemetryEventStrings.Key.RESULT_CODE, String.valueOf(resultCode))\n-                        .put(TelemetryEventStrings.Key.REQUEST_CODE, String.valueOf(requestCode))\n-        );\n-\n-        mAuthorizationStrategy.completeAuthorization(requestCode, resultCode, data);\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireTokenSilent(\n-            @NonNull final SilentTokenCommandParameters parameters)\n-            throws IOException, ClientException, ArgumentException, ServiceException {\n-        final String methodName = \":acquireTokenSilent\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token silently...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        final AcquireTokenResult acquireTokenSilentResult = new AcquireTokenResult();\n-\n-        //Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final SilentTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        final OAuth2TokenCache tokenCache = parametersWithScopes.getOAuth2TokenCache();\n-\n-        final AccountRecord targetAccount = getCachedAccountRecord(parametersWithScopes);\n-\n-        // Build up params for Strategy construction\n-        final AbstractAuthenticationScheme authScheme = parametersWithScopes.getAuthenticationScheme();\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy strategy = parametersWithScopes.getAuthority().createOAuth2Strategy(strategyParameters);\n-\n-        final List<ICacheRecord> cacheRecords = tokenCache.loadWithAggregatedAccountData(\n-                parametersWithScopes.getClientId(),\n-                TextUtils.join(\" \", parametersWithScopes.getScopes()),\n-                targetAccount,\n-                authScheme\n-        );\n-\n-        // The first element is the 'fully-loaded' CacheRecord which may contain the AccountRecord,\n-        // AccessTokenRecord, RefreshTokenRecord, and IdTokenRecord... (if all of those artifacts exist)\n-        // subsequent CacheRecords represent other profiles (projections) of this principal in\n-        // other tenants. Those tokens will be 'sparse', meaning that their AT/RT will not be loaded\n-        final ICacheRecord fullCacheRecord = cacheRecords.get(0);\n-\n-        if (accessTokenIsNull(fullCacheRecord)\n-                || refreshTokenIsNull(fullCacheRecord)\n-                || parametersWithScopes.isForceRefresh()\n-                || !isRequestAuthorityRealmSameAsATRealm(parametersWithScopes.getAuthority(), fullCacheRecord.getAccessToken())\n-                || !strategy.validateCachedResult(authScheme, fullCacheRecord)) {\n-            if (!refreshTokenIsNull(fullCacheRecord)) {\n-                // No AT found, but the RT checks out, so we'll use it\n-                Logger.verbose(\n-                        TAG + methodName,\n-                        \"No access token found, but RT is available.\"\n-                );\n-\n-                renewAccessToken(\n-                        parametersWithScopes,\n-                        acquireTokenSilentResult,\n-                        tokenCache,\n-                        strategy,\n-                        fullCacheRecord\n-                );\n-            } else {\n-                //TODO need the refactor, should just throw the ui required exception, rather than\n-                // wrap the exception later in the exception wrapper.\n-                final ClientException exception = new ClientException(\n-                        MsalUiRequiredException.NO_TOKENS_FOUND,\n-                        \"No refresh token was found. \"\n-                );\n-\n-                Telemetry.emit(\n-                        new ApiEndEvent()\n-                                .putException(exception)\n-                                .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-                );\n-\n-                throw exception;\n-            }\n-        } else if (fullCacheRecord.getAccessToken().isExpired()) {\n-            Logger.warn(\n-                    TAG + methodName,\n-                    \"Access token is expired. Removing from cache...\"\n-            );\n-            // Remove the expired token\n-            tokenCache.removeCredential(fullCacheRecord.getAccessToken());\n-\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Renewing access token...\"\n-            );\n-            // Request a new AT\n-            renewAccessToken(\n-                    parametersWithScopes,\n-                    acquireTokenSilentResult,\n-                    tokenCache,\n-                    strategy,\n-                    fullCacheRecord\n-            );\n-        } else {\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Returning silent result\"\n-            );\n-            // the result checks out, return that....\n-            acquireTokenSilentResult.setLocalAuthenticationResult(\n-                    new LocalAuthenticationResult(\n-                            finalizeCacheRecordForResult(\n-                                    fullCacheRecord,\n-                                    parametersWithScopes.getAuthenticationScheme()\n-                            ),\n-                            cacheRecords,\n-                            SdkType.MSAL,\n-                            true\n-                    )\n-            );\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenSilentResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        return acquireTokenSilentResult;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public List<ICacheRecord> getAccounts(@NonNull final CommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-        );\n-\n-        final List<ICacheRecord> accountsInCache =\n-                parameters\n-                        .getOAuth2TokenCache()\n-                        .getAccountsWithAggregatedAccountData(\n-                                null, // * wildcard\n-                                parameters.getClientId()\n-                        );\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-                        .put(TelemetryEventStrings.Key.ACCOUNTS_NUMBER, Integer.toString(accountsInCache.size()))\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, TelemetryEventStrings.Value.TRUE)\n-        );\n-\n-        return accountsInCache;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public boolean removeAccount(\n-            @NonNull final RemoveAccountCommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        String realm = null;\n-\n-        if (parameters.getAccount() != null) {\n-            realm = parameters.getAccount().getRealm();\n-        }\n-\n-        final boolean localRemoveAccountSuccess = !parameters\n-                .getOAuth2TokenCache()\n-                .removeAccount(\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getEnvironment(),\n-                        parameters.getClientId(),\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getHomeAccountId(),\n-                        realm\n-                ).isEmpty();\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, String.valueOf(localRemoveAccountSuccess))\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        return localRemoveAccountSuccess;\n-    }\n-\n-    @Override\n-    public boolean getDeviceMode(CommandParameters parameters) throws Exception {\n-        final String methodName = \":getDeviceMode\";\n-\n-        final String errorMessage = \"LocalMSALController is not eligible to use the broker. Do not check sharedDevice mode and return false immediately.\";\n-        com.microsoft.identity.common.internal.logging.Logger.warn(TAG + methodName, errorMessage);\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public List<ICacheRecord> getCurrentAccount(CommandParameters parameters) throws Exception {\n-        return getAccounts(parameters);\n-    }\n-\n-    @Override\n-    public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) throws Exception {\n-        return removeAccount(parameters);\n-    }\n-\n-    @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n-        // Logging start of method\n-        final String methodName = \":deviceCodeFlowAuthRequest\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Authorizing user code...\"\n-        );\n-\n-        // Default scopes here\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parametersWithScopes)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 1: Get user code\n-        // Populate global authorization request\n-        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n-\n-        // Call method defined in oAuth2Strategy to request authorization\n-        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n-\n-        validateServiceResult(authorizationResult);\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow authorization step finished...\"\n-        );\n-        logResult(TAG, authorizationResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        return authorizationResult;\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(\n-            final AuthorizationResult authorizationResult,\n-            final DeviceCodeFlowCommandParameters parameters)\n-            throws MsalException, ClientException, IOException, InterruptedException {\n-\n-        // Logging start of method\n-        final String methodName = \":acquireDeviceCodeFlowToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Polling for token...\"\n-        );\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        // Create empty AcquireTokenResult object\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        // Assign authorization result\n-        acquireTokenResult.setAuthorizationResult(authorizationResult);\n-\n-        // Fetch the Authorization Response\n-        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parameters\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 2: Poll for token\n-        TokenResult tokenResult = null;\n-\n-        // Create token request outside of loop so it isn't re-created after every loop\n-        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n-                mAuthorizationRequest,\n-                authorizationResponse,\n-                parameters.getAuthenticationScheme()\n-        );\n-\n-        // Fetch wait interval\n-        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n-\n-        String errorCode = \"authorization_pending\";\n-\n-        // Loop to send multiple requests checking for token\n-        while (errorCode.equals(\"authorization_pending\")) {\n-            errorCode = \"\"; // Reset error code\n-\n-            // Execute Token Request\n-            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n-\n-            if (tokenResult.getErrorResponse() != null) {\n-                errorCode = tokenResult.getErrorResponse().getError();\n-            }\n-\n-            if (errorCode.equals(\"authorization_pending\")) {\n-                // interval is passed through params\n-                Thread.sleep(interval);\n-            }\n-        }\n-\n-        // Assign token result\n-        acquireTokenResult.setTokenResult(tokenResult);\n-\n-        // Validate request success, may throw MsalServiceException\n-        validateServiceResult(tokenResult);\n-\n-        // If the token is valid, save it into token cache\n-        final List<ICacheRecord> records = saveTokens(\n-                oAuth2Strategy,\n-                mAuthorizationRequest,\n-                acquireTokenResult.getTokenResult().getTokenResponse(),\n-                parameters.getOAuth2TokenCache()\n-        );\n-\n-        // Once the token is stored, fetch and assign the authentication result\n-        final ICacheRecord newestRecord = records.get(0);\n-        acquireTokenResult.setLocalAuthenticationResult(\n-                new LocalAuthenticationResult(\n-                        finalizeCacheRecordForResult(\n-                                newestRecord,\n-                                parameters.getAuthenticationScheme()\n-                        ),\n-                        records,\n-                        SdkType.MSAL,\n-                        false\n-                )\n-        );\n-\n-        logResult(TAG, tokenResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    /**\n-     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n-     * This method is called in both parts of the DCF protocol.\n-     * @param result result object to be checked\n-     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n-     */\n-    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n-        // If result was unsuccessful, create an exception\n-        if (!result.getSuccess()) {\n-            // Create ServiceException object\n-            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n-\n-            // Convert ServiceException to MsalServiceException, then throw\n-            throw new MsalServiceException(\n-                    serviceException.getErrorCode(),\n-                    serviceException.getMessage(),\n-                    serviceException.getHttpStatusCode(),\n-                    serviceException\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Given an error response object, create a serviceException object using the predefined error codes.\n-     * @param response error response object to be checked\n-     * @return an exception object\n-     */\n-    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {\n-        // Based on error code, fetch the error message\n-        String errorCode = response.getError();\n-        String errorMessage = null;\n-\n-        // Check response code against pre-defined error codes\n-        switch (errorCode) {\n-            case ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_MESSAGE;\n-                break;\n-            default:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_DEFAULT_ERROR_MESSAGE;\n-        }\n-\n-        // Create a ServiceException object and return it\n-        return new ServiceException(\n-                errorCode,\n-                errorMessage,\n-                ServiceException.DEFAULT_STATUS_CODE,\n-                null\n-        );\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4Mzc4NA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462583784", "body": "@AdamBJohnsonx recently wrote a `sleepSafely` method, consider using that here", "bodyText": "@AdamBJohnsonx recently wrote a sleepSafely method, consider using that here", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/AdamBJohnsonx/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/AdamBJohnsonx\">@AdamBJohnsonx</a> recently wrote a <code>sleepSafely</code> method, consider using that here</p>", "author": "shahzaibj", "createdAt": "2020-07-29T20:57:03Z", "path": "msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java", "diffHunk": "@@ -463,14 +468,224 @@ public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) t\n     }\n \n     @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n+        // Logging start of method\n+        final String methodName = \":deviceCodeFlowAuthRequest\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Authorizing user code...\"\n+        );\n+\n+        // Default scopes here\n+        final Set<String> mergedScopes = addDefaultScopes(parameters);\n+\n+        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n+                .toBuilder()\n+                .scopes(mergedScopes)\n+                .build();\n+\n+        logParameters(TAG, parametersWithScopes);\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putProperties(parametersWithScopes)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 1: Get user code\n+        // Populate global authorization request\n+        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n+\n+        // Call method defined in oAuth2Strategy to request authorization\n+        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n+\n+        validateServiceResult(authorizationResult);\n+\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow authorization step finished...\"\n+        );\n+        logResult(TAG, authorizationResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        return authorizationResult;\n     }\n \n     @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(final AuthorizationResult authorizationResult, DeviceCodeFlowCommandParameters commandParameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AcquireTokenResult acquireDeviceCodeFlowToken(\n+            final AuthorizationResult authorizationResult,\n+            final DeviceCodeFlowCommandParameters parameters)\n+            throws MsalException, ClientException, IOException, InterruptedException {\n+\n+        // Logging start of method\n+        final String methodName = \":acquireDeviceCodeFlowToken\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Polling for token...\"\n+        );\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        // Create empty AcquireTokenResult object\n+        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n+\n+        // Assign authorization result\n+        acquireTokenResult.setAuthorizationResult(authorizationResult);\n+\n+        // Fetch the Authorization Response\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parameters\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 2: Poll for token\n+        TokenResult tokenResult = null;\n+\n+        // Create token request outside of loop so it isn't re-created after every loop\n+        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n+                mAuthorizationRequest,\n+                authorizationResponse,\n+                parameters.getAuthenticationScheme()\n+        );\n+\n+        // Fetch wait interval\n+        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n+\n+        String errorCode = \"authorization_pending\";\n+\n+        // Loop to send multiple requests checking for token\n+        while (errorCode.equals(\"authorization_pending\")) {\n+            errorCode = \"\"; // Reset error code\n+\n+            // Execute Token Request\n+            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n+\n+            if (tokenResult.getErrorResponse() != null) {\n+                errorCode = tokenResult.getErrorResponse().getError();\n+            }\n+\n+            if (errorCode.equals(\"authorization_pending\")) {\n+                // interval is passed through params\n+                Thread.sleep(interval);", "originalCommit": "dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzMjUxNQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r463132515", "bodyText": "Using that now!", "author": "t-fadura", "createdAt": "2020-07-30T16:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4Mzc4NA=="}], "type": "inlineReview", "revised_code": {"commit": "db4160a3861d0ee64f555150baba754033aba357", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java b/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\ndeleted file mode 100644\nindex 0bbf36bb..00000000\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\n+++ /dev/null\n", "chunk": "@@ -1,691 +0,0 @@\n-//  Copyright (c) Microsoft Corporation.\n-//  All rights reserved.\n-//\n-//  This code is licensed under the MIT License.\n-//\n-//  Permission is hereby granted, free of charge, to any person obtaining a copy\n-//  of this software and associated documentation files(the \"Software\"), to deal\n-//  in the Software without restriction, including without limitation the rights\n-//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n-//  copies of the Software, and to permit persons to whom the Software is\n-//  furnished to do so, subject to the following conditions :\n-//\n-//  The above copyright notice and this permission notice shall be included in\n-//  all copies or substantial portions of the Software.\n-//\n-//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-//  THE SOFTWARE.\n-package com.microsoft.identity.client.internal.controllers;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.text.TextUtils;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.WorkerThread;\n-\n-import com.microsoft.identity.client.exception.MsalException;\n-import com.microsoft.identity.client.exception.MsalServiceException;\n-import com.microsoft.identity.client.exception.MsalUiRequiredException;\n-import com.microsoft.identity.common.exception.ArgumentException;\n-import com.microsoft.identity.common.exception.ClientException;\n-import com.microsoft.identity.common.exception.ErrorStrings;\n-import com.microsoft.identity.common.exception.ServiceException;\n-import com.microsoft.identity.common.internal.authorities.Authority;\n-import com.microsoft.identity.common.internal.authscheme.AbstractAuthenticationScheme;\n-import com.microsoft.identity.common.internal.cache.ICacheRecord;\n-import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n-import com.microsoft.identity.common.internal.controllers.BaseController;\n-import com.microsoft.identity.common.internal.dto.AccountRecord;\n-import com.microsoft.identity.common.internal.logging.Logger;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStatus;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStrategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.IErrorResponse;\n-import com.microsoft.identity.common.internal.providers.oauth2.IResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2TokenCache;\n-import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n-import com.microsoft.identity.common.internal.request.SdkType;\n-import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n-import com.microsoft.identity.common.internal.result.LocalAuthenticationResult;\n-import com.microsoft.identity.common.internal.telemetry.Telemetry;\n-import com.microsoft.identity.common.internal.telemetry.TelemetryEventStrings;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiEndEvent;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiStartEvent;\n-import com.microsoft.identity.common.internal.ui.AuthorizationStrategyFactory;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import static com.microsoft.identity.common.adal.internal.net.HttpWebRequest.throwIfNetworkNotAvailable;\n-\n-public class LocalMSALController extends BaseController {\n-\n-    private static final String TAG = LocalMSALController.class.getSimpleName();\n-\n-    private AuthorizationStrategy mAuthorizationStrategy = null;\n-    private AuthorizationRequest mAuthorizationRequest = null;\n-\n-    @Override\n-    public AcquireTokenResult acquireToken(\n-            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException, IOException, ArgumentException {\n-        final String methodName = \":acquireToken\";\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        //00) Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final InteractiveTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        //0) Get known authority result\n-        throwIfNetworkNotAvailable(\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes.isPowerOptCheckEnabled()\n-        );\n-\n-        Authority.KnownAuthorityResult authorityResult = Authority.getKnownAuthorityResult(parametersWithScopes.getAuthority());\n-\n-        //0.1 If not known throw resulting exception\n-        if (!authorityResult.getKnown()) {\n-            Telemetry.emit(\n-                    new ApiEndEvent()\n-                            .putException(authorityResult.getClientException())\n-                            .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-            );\n-\n-            throw authorityResult.getClientException();\n-        }\n-\n-        // Build up params for Strategy construction\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        //1) Get oAuth2Strategy for Authority Type\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-\n-        //2) Request authorization interactively\n-        final AuthorizationResult result = performAuthorizationRequest(\n-                oAuth2Strategy,\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes\n-        );\n-        acquireTokenResult.setAuthorizationResult(result);\n-\n-        logResult(TAG, result);\n-\n-        if (result.getAuthorizationStatus().equals(AuthorizationStatus.SUCCESS)) {\n-            //3) Exchange authorization code for token\n-            final TokenResult tokenResult = performTokenRequest(\n-                    oAuth2Strategy,\n-                    mAuthorizationRequest,\n-                    result.getAuthorizationResponse(),\n-                    parametersWithScopes\n-            );\n-\n-            acquireTokenResult.setTokenResult(tokenResult);\n-\n-            if (tokenResult != null && tokenResult.getSuccess()) {\n-                //4) Save tokens in token cache\n-                final List<ICacheRecord> records = saveTokens(\n-                        oAuth2Strategy,\n-                        mAuthorizationRequest,\n-                        tokenResult.getTokenResponse(),\n-                        parametersWithScopes.getOAuth2TokenCache()\n-                );\n-\n-                // The first element in the returned list is the item we *just* saved, the rest of\n-                // the elements are necessary to construct the full IAccount + TenantProfile\n-                final ICacheRecord newestRecord = records.get(0);\n-\n-                acquireTokenResult.setLocalAuthenticationResult(\n-                        new LocalAuthenticationResult(\n-                                finalizeCacheRecordForResult(\n-                                        newestRecord,\n-                                        parametersWithScopes.getAuthenticationScheme()\n-                                ),\n-                                records,\n-                                SdkType.MSAL,\n-                                false\n-                        )\n-                );\n-            }\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    private AuthorizationResult performAuthorizationRequest(@NonNull final OAuth2Strategy strategy,\n-                                                            @NonNull final Context context,\n-                                                            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException {\n-\n-        throwIfNetworkNotAvailable(context, parameters.isPowerOptCheckEnabled());\n-\n-        mAuthorizationStrategy = AuthorizationStrategyFactory.getInstance()\n-                .getAuthorizationStrategy(\n-                        parameters\n-                );\n-        mAuthorizationRequest = getAuthorizationRequest(strategy, parameters);\n-\n-        final Future<AuthorizationResult> future = strategy.requestAuthorization(\n-                mAuthorizationRequest,\n-                mAuthorizationStrategy\n-        );\n-\n-        final AuthorizationResult result = future.get();\n-\n-        return result;\n-    }\n-\n-    @Override\n-    public void completeAcquireToken(final int requestCode,\n-                                     final int resultCode,\n-                                     final Intent data) {\n-        final String methodName = \":completeAcquireToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Completing acquire token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-                        .put(TelemetryEventStrings.Key.RESULT_CODE, String.valueOf(resultCode))\n-                        .put(TelemetryEventStrings.Key.REQUEST_CODE, String.valueOf(requestCode))\n-        );\n-\n-        mAuthorizationStrategy.completeAuthorization(requestCode, resultCode, data);\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireTokenSilent(\n-            @NonNull final SilentTokenCommandParameters parameters)\n-            throws IOException, ClientException, ArgumentException, ServiceException {\n-        final String methodName = \":acquireTokenSilent\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token silently...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        final AcquireTokenResult acquireTokenSilentResult = new AcquireTokenResult();\n-\n-        //Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final SilentTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        final OAuth2TokenCache tokenCache = parametersWithScopes.getOAuth2TokenCache();\n-\n-        final AccountRecord targetAccount = getCachedAccountRecord(parametersWithScopes);\n-\n-        // Build up params for Strategy construction\n-        final AbstractAuthenticationScheme authScheme = parametersWithScopes.getAuthenticationScheme();\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy strategy = parametersWithScopes.getAuthority().createOAuth2Strategy(strategyParameters);\n-\n-        final List<ICacheRecord> cacheRecords = tokenCache.loadWithAggregatedAccountData(\n-                parametersWithScopes.getClientId(),\n-                TextUtils.join(\" \", parametersWithScopes.getScopes()),\n-                targetAccount,\n-                authScheme\n-        );\n-\n-        // The first element is the 'fully-loaded' CacheRecord which may contain the AccountRecord,\n-        // AccessTokenRecord, RefreshTokenRecord, and IdTokenRecord... (if all of those artifacts exist)\n-        // subsequent CacheRecords represent other profiles (projections) of this principal in\n-        // other tenants. Those tokens will be 'sparse', meaning that their AT/RT will not be loaded\n-        final ICacheRecord fullCacheRecord = cacheRecords.get(0);\n-\n-        if (accessTokenIsNull(fullCacheRecord)\n-                || refreshTokenIsNull(fullCacheRecord)\n-                || parametersWithScopes.isForceRefresh()\n-                || !isRequestAuthorityRealmSameAsATRealm(parametersWithScopes.getAuthority(), fullCacheRecord.getAccessToken())\n-                || !strategy.validateCachedResult(authScheme, fullCacheRecord)) {\n-            if (!refreshTokenIsNull(fullCacheRecord)) {\n-                // No AT found, but the RT checks out, so we'll use it\n-                Logger.verbose(\n-                        TAG + methodName,\n-                        \"No access token found, but RT is available.\"\n-                );\n-\n-                renewAccessToken(\n-                        parametersWithScopes,\n-                        acquireTokenSilentResult,\n-                        tokenCache,\n-                        strategy,\n-                        fullCacheRecord\n-                );\n-            } else {\n-                //TODO need the refactor, should just throw the ui required exception, rather than\n-                // wrap the exception later in the exception wrapper.\n-                final ClientException exception = new ClientException(\n-                        MsalUiRequiredException.NO_TOKENS_FOUND,\n-                        \"No refresh token was found. \"\n-                );\n-\n-                Telemetry.emit(\n-                        new ApiEndEvent()\n-                                .putException(exception)\n-                                .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-                );\n-\n-                throw exception;\n-            }\n-        } else if (fullCacheRecord.getAccessToken().isExpired()) {\n-            Logger.warn(\n-                    TAG + methodName,\n-                    \"Access token is expired. Removing from cache...\"\n-            );\n-            // Remove the expired token\n-            tokenCache.removeCredential(fullCacheRecord.getAccessToken());\n-\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Renewing access token...\"\n-            );\n-            // Request a new AT\n-            renewAccessToken(\n-                    parametersWithScopes,\n-                    acquireTokenSilentResult,\n-                    tokenCache,\n-                    strategy,\n-                    fullCacheRecord\n-            );\n-        } else {\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Returning silent result\"\n-            );\n-            // the result checks out, return that....\n-            acquireTokenSilentResult.setLocalAuthenticationResult(\n-                    new LocalAuthenticationResult(\n-                            finalizeCacheRecordForResult(\n-                                    fullCacheRecord,\n-                                    parametersWithScopes.getAuthenticationScheme()\n-                            ),\n-                            cacheRecords,\n-                            SdkType.MSAL,\n-                            true\n-                    )\n-            );\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenSilentResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        return acquireTokenSilentResult;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public List<ICacheRecord> getAccounts(@NonNull final CommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-        );\n-\n-        final List<ICacheRecord> accountsInCache =\n-                parameters\n-                        .getOAuth2TokenCache()\n-                        .getAccountsWithAggregatedAccountData(\n-                                null, // * wildcard\n-                                parameters.getClientId()\n-                        );\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-                        .put(TelemetryEventStrings.Key.ACCOUNTS_NUMBER, Integer.toString(accountsInCache.size()))\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, TelemetryEventStrings.Value.TRUE)\n-        );\n-\n-        return accountsInCache;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public boolean removeAccount(\n-            @NonNull final RemoveAccountCommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        String realm = null;\n-\n-        if (parameters.getAccount() != null) {\n-            realm = parameters.getAccount().getRealm();\n-        }\n-\n-        final boolean localRemoveAccountSuccess = !parameters\n-                .getOAuth2TokenCache()\n-                .removeAccount(\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getEnvironment(),\n-                        parameters.getClientId(),\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getHomeAccountId(),\n-                        realm\n-                ).isEmpty();\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, String.valueOf(localRemoveAccountSuccess))\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        return localRemoveAccountSuccess;\n-    }\n-\n-    @Override\n-    public boolean getDeviceMode(CommandParameters parameters) throws Exception {\n-        final String methodName = \":getDeviceMode\";\n-\n-        final String errorMessage = \"LocalMSALController is not eligible to use the broker. Do not check sharedDevice mode and return false immediately.\";\n-        com.microsoft.identity.common.internal.logging.Logger.warn(TAG + methodName, errorMessage);\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public List<ICacheRecord> getCurrentAccount(CommandParameters parameters) throws Exception {\n-        return getAccounts(parameters);\n-    }\n-\n-    @Override\n-    public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) throws Exception {\n-        return removeAccount(parameters);\n-    }\n-\n-    @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n-        // Logging start of method\n-        final String methodName = \":deviceCodeFlowAuthRequest\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Authorizing user code...\"\n-        );\n-\n-        // Default scopes here\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parametersWithScopes)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 1: Get user code\n-        // Populate global authorization request\n-        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n-\n-        // Call method defined in oAuth2Strategy to request authorization\n-        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n-\n-        validateServiceResult(authorizationResult);\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow authorization step finished...\"\n-        );\n-        logResult(TAG, authorizationResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        return authorizationResult;\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(\n-            final AuthorizationResult authorizationResult,\n-            final DeviceCodeFlowCommandParameters parameters)\n-            throws MsalException, ClientException, IOException, InterruptedException {\n-\n-        // Logging start of method\n-        final String methodName = \":acquireDeviceCodeFlowToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Polling for token...\"\n-        );\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        // Create empty AcquireTokenResult object\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        // Assign authorization result\n-        acquireTokenResult.setAuthorizationResult(authorizationResult);\n-\n-        // Fetch the Authorization Response\n-        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parameters\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 2: Poll for token\n-        TokenResult tokenResult = null;\n-\n-        // Create token request outside of loop so it isn't re-created after every loop\n-        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n-                mAuthorizationRequest,\n-                authorizationResponse,\n-                parameters.getAuthenticationScheme()\n-        );\n-\n-        // Fetch wait interval\n-        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n-\n-        String errorCode = \"authorization_pending\";\n-\n-        // Loop to send multiple requests checking for token\n-        while (errorCode.equals(\"authorization_pending\")) {\n-            errorCode = \"\"; // Reset error code\n-\n-            // Execute Token Request\n-            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n-\n-            if (tokenResult.getErrorResponse() != null) {\n-                errorCode = tokenResult.getErrorResponse().getError();\n-            }\n-\n-            if (errorCode.equals(\"authorization_pending\")) {\n-                // interval is passed through params\n-                Thread.sleep(interval);\n-            }\n-        }\n-\n-        // Assign token result\n-        acquireTokenResult.setTokenResult(tokenResult);\n-\n-        // Validate request success, may throw MsalServiceException\n-        validateServiceResult(tokenResult);\n-\n-        // If the token is valid, save it into token cache\n-        final List<ICacheRecord> records = saveTokens(\n-                oAuth2Strategy,\n-                mAuthorizationRequest,\n-                acquireTokenResult.getTokenResult().getTokenResponse(),\n-                parameters.getOAuth2TokenCache()\n-        );\n-\n-        // Once the token is stored, fetch and assign the authentication result\n-        final ICacheRecord newestRecord = records.get(0);\n-        acquireTokenResult.setLocalAuthenticationResult(\n-                new LocalAuthenticationResult(\n-                        finalizeCacheRecordForResult(\n-                                newestRecord,\n-                                parameters.getAuthenticationScheme()\n-                        ),\n-                        records,\n-                        SdkType.MSAL,\n-                        false\n-                )\n-        );\n-\n-        logResult(TAG, tokenResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    /**\n-     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n-     * This method is called in both parts of the DCF protocol.\n-     * @param result result object to be checked\n-     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n-     */\n-    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n-        // If result was unsuccessful, create an exception\n-        if (!result.getSuccess()) {\n-            // Create ServiceException object\n-            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n-\n-            // Convert ServiceException to MsalServiceException, then throw\n-            throw new MsalServiceException(\n-                    serviceException.getErrorCode(),\n-                    serviceException.getMessage(),\n-                    serviceException.getHttpStatusCode(),\n-                    serviceException\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Given an error response object, create a serviceException object using the predefined error codes.\n-     * @param response error response object to be checked\n-     * @return an exception object\n-     */\n-    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {\n-        // Based on error code, fetch the error message\n-        String errorCode = response.getError();\n-        String errorMessage = null;\n-\n-        // Check response code against pre-defined error codes\n-        switch (errorCode) {\n-            case ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_MESSAGE;\n-                break;\n-            default:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_DEFAULT_ERROR_MESSAGE;\n-        }\n-\n-        // Create a ServiceException object and return it\n-        return new ServiceException(\n-                errorCode,\n-                errorMessage,\n-                ServiceException.DEFAULT_STATUS_CODE,\n-                null\n-        );\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NDE2Nw==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462584167", "body": "nit: final", "bodyText": "nit: final", "bodyHTML": "<p dir=\"auto\">nit: final</p>", "author": "shahzaibj", "createdAt": "2020-07-29T20:57:46Z", "path": "msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java", "diffHunk": "@@ -463,14 +468,224 @@ public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) t\n     }\n \n     @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n+        // Logging start of method\n+        final String methodName = \":deviceCodeFlowAuthRequest\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Authorizing user code...\"\n+        );\n+\n+        // Default scopes here\n+        final Set<String> mergedScopes = addDefaultScopes(parameters);\n+\n+        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n+                .toBuilder()\n+                .scopes(mergedScopes)\n+                .build();\n+\n+        logParameters(TAG, parametersWithScopes);\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putProperties(parametersWithScopes)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 1: Get user code\n+        // Populate global authorization request\n+        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n+\n+        // Call method defined in oAuth2Strategy to request authorization\n+        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n+\n+        validateServiceResult(authorizationResult);\n+\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow authorization step finished...\"\n+        );\n+        logResult(TAG, authorizationResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        return authorizationResult;\n     }\n \n     @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(final AuthorizationResult authorizationResult, DeviceCodeFlowCommandParameters commandParameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AcquireTokenResult acquireDeviceCodeFlowToken(\n+            final AuthorizationResult authorizationResult,\n+            final DeviceCodeFlowCommandParameters parameters)\n+            throws MsalException, ClientException, IOException, InterruptedException {\n+\n+        // Logging start of method\n+        final String methodName = \":acquireDeviceCodeFlowToken\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Polling for token...\"\n+        );\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        // Create empty AcquireTokenResult object\n+        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n+\n+        // Assign authorization result\n+        acquireTokenResult.setAuthorizationResult(authorizationResult);\n+\n+        // Fetch the Authorization Response\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parameters\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 2: Poll for token\n+        TokenResult tokenResult = null;\n+\n+        // Create token request outside of loop so it isn't re-created after every loop\n+        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n+                mAuthorizationRequest,\n+                authorizationResponse,\n+                parameters.getAuthenticationScheme()\n+        );\n+\n+        // Fetch wait interval\n+        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n+\n+        String errorCode = \"authorization_pending\";\n+\n+        // Loop to send multiple requests checking for token\n+        while (errorCode.equals(\"authorization_pending\")) {\n+            errorCode = \"\"; // Reset error code\n+\n+            // Execute Token Request\n+            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n+\n+            if (tokenResult.getErrorResponse() != null) {\n+                errorCode = tokenResult.getErrorResponse().getError();\n+            }\n+\n+            if (errorCode.equals(\"authorization_pending\")) {\n+                // interval is passed through params\n+                Thread.sleep(interval);\n+            }\n+        }\n+\n+        // Assign token result\n+        acquireTokenResult.setTokenResult(tokenResult);\n+\n+        // Validate request success, may throw MsalServiceException\n+        validateServiceResult(tokenResult);\n+\n+        // If the token is valid, save it into token cache\n+        final List<ICacheRecord> records = saveTokens(\n+                oAuth2Strategy,\n+                mAuthorizationRequest,\n+                acquireTokenResult.getTokenResult().getTokenResponse(),\n+                parameters.getOAuth2TokenCache()\n+        );\n+\n+        // Once the token is stored, fetch and assign the authentication result\n+        final ICacheRecord newestRecord = records.get(0);\n+        acquireTokenResult.setLocalAuthenticationResult(\n+                new LocalAuthenticationResult(\n+                        finalizeCacheRecordForResult(\n+                                newestRecord,\n+                                parameters.getAuthenticationScheme()\n+                        ),\n+                        records,\n+                        SdkType.MSAL,\n+                        false\n+                )\n+        );\n+\n+        logResult(TAG, tokenResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putResult(acquireTokenResult)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        return acquireTokenResult;\n+    }\n+\n+    /**\n+     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n+     * This method is called in both parts of the DCF protocol.\n+     * @param result result object to be checked\n+     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n+     */\n+    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n+        // If result was unsuccessful, create an exception\n+        if (!result.getSuccess()) {\n+            // Create ServiceException object\n+            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());", "originalCommit": "dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db4160a3861d0ee64f555150baba754033aba357", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java b/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\ndeleted file mode 100644\nindex 0bbf36bb..00000000\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\n+++ /dev/null\n", "chunk": "@@ -1,691 +0,0 @@\n-//  Copyright (c) Microsoft Corporation.\n-//  All rights reserved.\n-//\n-//  This code is licensed under the MIT License.\n-//\n-//  Permission is hereby granted, free of charge, to any person obtaining a copy\n-//  of this software and associated documentation files(the \"Software\"), to deal\n-//  in the Software without restriction, including without limitation the rights\n-//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n-//  copies of the Software, and to permit persons to whom the Software is\n-//  furnished to do so, subject to the following conditions :\n-//\n-//  The above copyright notice and this permission notice shall be included in\n-//  all copies or substantial portions of the Software.\n-//\n-//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-//  THE SOFTWARE.\n-package com.microsoft.identity.client.internal.controllers;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.text.TextUtils;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.WorkerThread;\n-\n-import com.microsoft.identity.client.exception.MsalException;\n-import com.microsoft.identity.client.exception.MsalServiceException;\n-import com.microsoft.identity.client.exception.MsalUiRequiredException;\n-import com.microsoft.identity.common.exception.ArgumentException;\n-import com.microsoft.identity.common.exception.ClientException;\n-import com.microsoft.identity.common.exception.ErrorStrings;\n-import com.microsoft.identity.common.exception.ServiceException;\n-import com.microsoft.identity.common.internal.authorities.Authority;\n-import com.microsoft.identity.common.internal.authscheme.AbstractAuthenticationScheme;\n-import com.microsoft.identity.common.internal.cache.ICacheRecord;\n-import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n-import com.microsoft.identity.common.internal.controllers.BaseController;\n-import com.microsoft.identity.common.internal.dto.AccountRecord;\n-import com.microsoft.identity.common.internal.logging.Logger;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStatus;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStrategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.IErrorResponse;\n-import com.microsoft.identity.common.internal.providers.oauth2.IResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2TokenCache;\n-import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n-import com.microsoft.identity.common.internal.request.SdkType;\n-import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n-import com.microsoft.identity.common.internal.result.LocalAuthenticationResult;\n-import com.microsoft.identity.common.internal.telemetry.Telemetry;\n-import com.microsoft.identity.common.internal.telemetry.TelemetryEventStrings;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiEndEvent;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiStartEvent;\n-import com.microsoft.identity.common.internal.ui.AuthorizationStrategyFactory;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import static com.microsoft.identity.common.adal.internal.net.HttpWebRequest.throwIfNetworkNotAvailable;\n-\n-public class LocalMSALController extends BaseController {\n-\n-    private static final String TAG = LocalMSALController.class.getSimpleName();\n-\n-    private AuthorizationStrategy mAuthorizationStrategy = null;\n-    private AuthorizationRequest mAuthorizationRequest = null;\n-\n-    @Override\n-    public AcquireTokenResult acquireToken(\n-            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException, IOException, ArgumentException {\n-        final String methodName = \":acquireToken\";\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        //00) Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final InteractiveTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        //0) Get known authority result\n-        throwIfNetworkNotAvailable(\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes.isPowerOptCheckEnabled()\n-        );\n-\n-        Authority.KnownAuthorityResult authorityResult = Authority.getKnownAuthorityResult(parametersWithScopes.getAuthority());\n-\n-        //0.1 If not known throw resulting exception\n-        if (!authorityResult.getKnown()) {\n-            Telemetry.emit(\n-                    new ApiEndEvent()\n-                            .putException(authorityResult.getClientException())\n-                            .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-            );\n-\n-            throw authorityResult.getClientException();\n-        }\n-\n-        // Build up params for Strategy construction\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        //1) Get oAuth2Strategy for Authority Type\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-\n-        //2) Request authorization interactively\n-        final AuthorizationResult result = performAuthorizationRequest(\n-                oAuth2Strategy,\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes\n-        );\n-        acquireTokenResult.setAuthorizationResult(result);\n-\n-        logResult(TAG, result);\n-\n-        if (result.getAuthorizationStatus().equals(AuthorizationStatus.SUCCESS)) {\n-            //3) Exchange authorization code for token\n-            final TokenResult tokenResult = performTokenRequest(\n-                    oAuth2Strategy,\n-                    mAuthorizationRequest,\n-                    result.getAuthorizationResponse(),\n-                    parametersWithScopes\n-            );\n-\n-            acquireTokenResult.setTokenResult(tokenResult);\n-\n-            if (tokenResult != null && tokenResult.getSuccess()) {\n-                //4) Save tokens in token cache\n-                final List<ICacheRecord> records = saveTokens(\n-                        oAuth2Strategy,\n-                        mAuthorizationRequest,\n-                        tokenResult.getTokenResponse(),\n-                        parametersWithScopes.getOAuth2TokenCache()\n-                );\n-\n-                // The first element in the returned list is the item we *just* saved, the rest of\n-                // the elements are necessary to construct the full IAccount + TenantProfile\n-                final ICacheRecord newestRecord = records.get(0);\n-\n-                acquireTokenResult.setLocalAuthenticationResult(\n-                        new LocalAuthenticationResult(\n-                                finalizeCacheRecordForResult(\n-                                        newestRecord,\n-                                        parametersWithScopes.getAuthenticationScheme()\n-                                ),\n-                                records,\n-                                SdkType.MSAL,\n-                                false\n-                        )\n-                );\n-            }\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    private AuthorizationResult performAuthorizationRequest(@NonNull final OAuth2Strategy strategy,\n-                                                            @NonNull final Context context,\n-                                                            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException {\n-\n-        throwIfNetworkNotAvailable(context, parameters.isPowerOptCheckEnabled());\n-\n-        mAuthorizationStrategy = AuthorizationStrategyFactory.getInstance()\n-                .getAuthorizationStrategy(\n-                        parameters\n-                );\n-        mAuthorizationRequest = getAuthorizationRequest(strategy, parameters);\n-\n-        final Future<AuthorizationResult> future = strategy.requestAuthorization(\n-                mAuthorizationRequest,\n-                mAuthorizationStrategy\n-        );\n-\n-        final AuthorizationResult result = future.get();\n-\n-        return result;\n-    }\n-\n-    @Override\n-    public void completeAcquireToken(final int requestCode,\n-                                     final int resultCode,\n-                                     final Intent data) {\n-        final String methodName = \":completeAcquireToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Completing acquire token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-                        .put(TelemetryEventStrings.Key.RESULT_CODE, String.valueOf(resultCode))\n-                        .put(TelemetryEventStrings.Key.REQUEST_CODE, String.valueOf(requestCode))\n-        );\n-\n-        mAuthorizationStrategy.completeAuthorization(requestCode, resultCode, data);\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireTokenSilent(\n-            @NonNull final SilentTokenCommandParameters parameters)\n-            throws IOException, ClientException, ArgumentException, ServiceException {\n-        final String methodName = \":acquireTokenSilent\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token silently...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        final AcquireTokenResult acquireTokenSilentResult = new AcquireTokenResult();\n-\n-        //Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final SilentTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        final OAuth2TokenCache tokenCache = parametersWithScopes.getOAuth2TokenCache();\n-\n-        final AccountRecord targetAccount = getCachedAccountRecord(parametersWithScopes);\n-\n-        // Build up params for Strategy construction\n-        final AbstractAuthenticationScheme authScheme = parametersWithScopes.getAuthenticationScheme();\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy strategy = parametersWithScopes.getAuthority().createOAuth2Strategy(strategyParameters);\n-\n-        final List<ICacheRecord> cacheRecords = tokenCache.loadWithAggregatedAccountData(\n-                parametersWithScopes.getClientId(),\n-                TextUtils.join(\" \", parametersWithScopes.getScopes()),\n-                targetAccount,\n-                authScheme\n-        );\n-\n-        // The first element is the 'fully-loaded' CacheRecord which may contain the AccountRecord,\n-        // AccessTokenRecord, RefreshTokenRecord, and IdTokenRecord... (if all of those artifacts exist)\n-        // subsequent CacheRecords represent other profiles (projections) of this principal in\n-        // other tenants. Those tokens will be 'sparse', meaning that their AT/RT will not be loaded\n-        final ICacheRecord fullCacheRecord = cacheRecords.get(0);\n-\n-        if (accessTokenIsNull(fullCacheRecord)\n-                || refreshTokenIsNull(fullCacheRecord)\n-                || parametersWithScopes.isForceRefresh()\n-                || !isRequestAuthorityRealmSameAsATRealm(parametersWithScopes.getAuthority(), fullCacheRecord.getAccessToken())\n-                || !strategy.validateCachedResult(authScheme, fullCacheRecord)) {\n-            if (!refreshTokenIsNull(fullCacheRecord)) {\n-                // No AT found, but the RT checks out, so we'll use it\n-                Logger.verbose(\n-                        TAG + methodName,\n-                        \"No access token found, but RT is available.\"\n-                );\n-\n-                renewAccessToken(\n-                        parametersWithScopes,\n-                        acquireTokenSilentResult,\n-                        tokenCache,\n-                        strategy,\n-                        fullCacheRecord\n-                );\n-            } else {\n-                //TODO need the refactor, should just throw the ui required exception, rather than\n-                // wrap the exception later in the exception wrapper.\n-                final ClientException exception = new ClientException(\n-                        MsalUiRequiredException.NO_TOKENS_FOUND,\n-                        \"No refresh token was found. \"\n-                );\n-\n-                Telemetry.emit(\n-                        new ApiEndEvent()\n-                                .putException(exception)\n-                                .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-                );\n-\n-                throw exception;\n-            }\n-        } else if (fullCacheRecord.getAccessToken().isExpired()) {\n-            Logger.warn(\n-                    TAG + methodName,\n-                    \"Access token is expired. Removing from cache...\"\n-            );\n-            // Remove the expired token\n-            tokenCache.removeCredential(fullCacheRecord.getAccessToken());\n-\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Renewing access token...\"\n-            );\n-            // Request a new AT\n-            renewAccessToken(\n-                    parametersWithScopes,\n-                    acquireTokenSilentResult,\n-                    tokenCache,\n-                    strategy,\n-                    fullCacheRecord\n-            );\n-        } else {\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Returning silent result\"\n-            );\n-            // the result checks out, return that....\n-            acquireTokenSilentResult.setLocalAuthenticationResult(\n-                    new LocalAuthenticationResult(\n-                            finalizeCacheRecordForResult(\n-                                    fullCacheRecord,\n-                                    parametersWithScopes.getAuthenticationScheme()\n-                            ),\n-                            cacheRecords,\n-                            SdkType.MSAL,\n-                            true\n-                    )\n-            );\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenSilentResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        return acquireTokenSilentResult;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public List<ICacheRecord> getAccounts(@NonNull final CommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-        );\n-\n-        final List<ICacheRecord> accountsInCache =\n-                parameters\n-                        .getOAuth2TokenCache()\n-                        .getAccountsWithAggregatedAccountData(\n-                                null, // * wildcard\n-                                parameters.getClientId()\n-                        );\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-                        .put(TelemetryEventStrings.Key.ACCOUNTS_NUMBER, Integer.toString(accountsInCache.size()))\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, TelemetryEventStrings.Value.TRUE)\n-        );\n-\n-        return accountsInCache;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public boolean removeAccount(\n-            @NonNull final RemoveAccountCommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        String realm = null;\n-\n-        if (parameters.getAccount() != null) {\n-            realm = parameters.getAccount().getRealm();\n-        }\n-\n-        final boolean localRemoveAccountSuccess = !parameters\n-                .getOAuth2TokenCache()\n-                .removeAccount(\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getEnvironment(),\n-                        parameters.getClientId(),\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getHomeAccountId(),\n-                        realm\n-                ).isEmpty();\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, String.valueOf(localRemoveAccountSuccess))\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        return localRemoveAccountSuccess;\n-    }\n-\n-    @Override\n-    public boolean getDeviceMode(CommandParameters parameters) throws Exception {\n-        final String methodName = \":getDeviceMode\";\n-\n-        final String errorMessage = \"LocalMSALController is not eligible to use the broker. Do not check sharedDevice mode and return false immediately.\";\n-        com.microsoft.identity.common.internal.logging.Logger.warn(TAG + methodName, errorMessage);\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public List<ICacheRecord> getCurrentAccount(CommandParameters parameters) throws Exception {\n-        return getAccounts(parameters);\n-    }\n-\n-    @Override\n-    public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) throws Exception {\n-        return removeAccount(parameters);\n-    }\n-\n-    @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n-        // Logging start of method\n-        final String methodName = \":deviceCodeFlowAuthRequest\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Authorizing user code...\"\n-        );\n-\n-        // Default scopes here\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parametersWithScopes)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 1: Get user code\n-        // Populate global authorization request\n-        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n-\n-        // Call method defined in oAuth2Strategy to request authorization\n-        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n-\n-        validateServiceResult(authorizationResult);\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow authorization step finished...\"\n-        );\n-        logResult(TAG, authorizationResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        return authorizationResult;\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(\n-            final AuthorizationResult authorizationResult,\n-            final DeviceCodeFlowCommandParameters parameters)\n-            throws MsalException, ClientException, IOException, InterruptedException {\n-\n-        // Logging start of method\n-        final String methodName = \":acquireDeviceCodeFlowToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Polling for token...\"\n-        );\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        // Create empty AcquireTokenResult object\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        // Assign authorization result\n-        acquireTokenResult.setAuthorizationResult(authorizationResult);\n-\n-        // Fetch the Authorization Response\n-        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parameters\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 2: Poll for token\n-        TokenResult tokenResult = null;\n-\n-        // Create token request outside of loop so it isn't re-created after every loop\n-        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n-                mAuthorizationRequest,\n-                authorizationResponse,\n-                parameters.getAuthenticationScheme()\n-        );\n-\n-        // Fetch wait interval\n-        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n-\n-        String errorCode = \"authorization_pending\";\n-\n-        // Loop to send multiple requests checking for token\n-        while (errorCode.equals(\"authorization_pending\")) {\n-            errorCode = \"\"; // Reset error code\n-\n-            // Execute Token Request\n-            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n-\n-            if (tokenResult.getErrorResponse() != null) {\n-                errorCode = tokenResult.getErrorResponse().getError();\n-            }\n-\n-            if (errorCode.equals(\"authorization_pending\")) {\n-                // interval is passed through params\n-                Thread.sleep(interval);\n-            }\n-        }\n-\n-        // Assign token result\n-        acquireTokenResult.setTokenResult(tokenResult);\n-\n-        // Validate request success, may throw MsalServiceException\n-        validateServiceResult(tokenResult);\n-\n-        // If the token is valid, save it into token cache\n-        final List<ICacheRecord> records = saveTokens(\n-                oAuth2Strategy,\n-                mAuthorizationRequest,\n-                acquireTokenResult.getTokenResult().getTokenResponse(),\n-                parameters.getOAuth2TokenCache()\n-        );\n-\n-        // Once the token is stored, fetch and assign the authentication result\n-        final ICacheRecord newestRecord = records.get(0);\n-        acquireTokenResult.setLocalAuthenticationResult(\n-                new LocalAuthenticationResult(\n-                        finalizeCacheRecordForResult(\n-                                newestRecord,\n-                                parameters.getAuthenticationScheme()\n-                        ),\n-                        records,\n-                        SdkType.MSAL,\n-                        false\n-                )\n-        );\n-\n-        logResult(TAG, tokenResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    /**\n-     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n-     * This method is called in both parts of the DCF protocol.\n-     * @param result result object to be checked\n-     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n-     */\n-    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n-        // If result was unsuccessful, create an exception\n-        if (!result.getSuccess()) {\n-            // Create ServiceException object\n-            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n-\n-            // Convert ServiceException to MsalServiceException, then throw\n-            throw new MsalServiceException(\n-                    serviceException.getErrorCode(),\n-                    serviceException.getMessage(),\n-                    serviceException.getHttpStatusCode(),\n-                    serviceException\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Given an error response object, create a serviceException object using the predefined error codes.\n-     * @param response error response object to be checked\n-     * @return an exception object\n-     */\n-    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {\n-        // Based on error code, fetch the error message\n-        String errorCode = response.getError();\n-        String errorMessage = null;\n-\n-        // Check response code against pre-defined error codes\n-        switch (errorCode) {\n-            case ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_MESSAGE;\n-                break;\n-            default:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_DEFAULT_ERROR_MESSAGE;\n-        }\n-\n-        // Create a ServiceException object and return it\n-        return new ServiceException(\n-                errorCode,\n-                errorMessage,\n-                ServiceException.DEFAULT_STATUS_CODE,\n-                null\n-        );\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NDYyMA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462584620", "body": "Why are we creating a ServiceException when we want to throw `MsalServiceException`? Why not create the latter directly?", "bodyText": "Why are we creating a ServiceException when we want to throw MsalServiceException? Why not create the latter directly?", "bodyHTML": "<p dir=\"auto\">Why are we creating a ServiceException when we want to throw <code>MsalServiceException</code>? Why not create the latter directly?</p>", "author": "shahzaibj", "createdAt": "2020-07-29T20:58:35Z", "path": "msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java", "diffHunk": "@@ -463,14 +468,224 @@ public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) t\n     }\n \n     @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n+        // Logging start of method\n+        final String methodName = \":deviceCodeFlowAuthRequest\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Authorizing user code...\"\n+        );\n+\n+        // Default scopes here\n+        final Set<String> mergedScopes = addDefaultScopes(parameters);\n+\n+        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n+                .toBuilder()\n+                .scopes(mergedScopes)\n+                .build();\n+\n+        logParameters(TAG, parametersWithScopes);\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putProperties(parametersWithScopes)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 1: Get user code\n+        // Populate global authorization request\n+        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n+\n+        // Call method defined in oAuth2Strategy to request authorization\n+        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n+\n+        validateServiceResult(authorizationResult);\n+\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow authorization step finished...\"\n+        );\n+        logResult(TAG, authorizationResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        return authorizationResult;\n     }\n \n     @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(final AuthorizationResult authorizationResult, DeviceCodeFlowCommandParameters commandParameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AcquireTokenResult acquireDeviceCodeFlowToken(\n+            final AuthorizationResult authorizationResult,\n+            final DeviceCodeFlowCommandParameters parameters)\n+            throws MsalException, ClientException, IOException, InterruptedException {\n+\n+        // Logging start of method\n+        final String methodName = \":acquireDeviceCodeFlowToken\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Polling for token...\"\n+        );\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        // Create empty AcquireTokenResult object\n+        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n+\n+        // Assign authorization result\n+        acquireTokenResult.setAuthorizationResult(authorizationResult);\n+\n+        // Fetch the Authorization Response\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parameters\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 2: Poll for token\n+        TokenResult tokenResult = null;\n+\n+        // Create token request outside of loop so it isn't re-created after every loop\n+        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n+                mAuthorizationRequest,\n+                authorizationResponse,\n+                parameters.getAuthenticationScheme()\n+        );\n+\n+        // Fetch wait interval\n+        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n+\n+        String errorCode = \"authorization_pending\";\n+\n+        // Loop to send multiple requests checking for token\n+        while (errorCode.equals(\"authorization_pending\")) {\n+            errorCode = \"\"; // Reset error code\n+\n+            // Execute Token Request\n+            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n+\n+            if (tokenResult.getErrorResponse() != null) {\n+                errorCode = tokenResult.getErrorResponse().getError();\n+            }\n+\n+            if (errorCode.equals(\"authorization_pending\")) {\n+                // interval is passed through params\n+                Thread.sleep(interval);\n+            }\n+        }\n+\n+        // Assign token result\n+        acquireTokenResult.setTokenResult(tokenResult);\n+\n+        // Validate request success, may throw MsalServiceException\n+        validateServiceResult(tokenResult);\n+\n+        // If the token is valid, save it into token cache\n+        final List<ICacheRecord> records = saveTokens(\n+                oAuth2Strategy,\n+                mAuthorizationRequest,\n+                acquireTokenResult.getTokenResult().getTokenResponse(),\n+                parameters.getOAuth2TokenCache()\n+        );\n+\n+        // Once the token is stored, fetch and assign the authentication result\n+        final ICacheRecord newestRecord = records.get(0);\n+        acquireTokenResult.setLocalAuthenticationResult(\n+                new LocalAuthenticationResult(\n+                        finalizeCacheRecordForResult(\n+                                newestRecord,\n+                                parameters.getAuthenticationScheme()\n+                        ),\n+                        records,\n+                        SdkType.MSAL,\n+                        false\n+                )\n+        );\n+\n+        logResult(TAG, tokenResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putResult(acquireTokenResult)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        return acquireTokenResult;\n+    }\n+\n+    /**\n+     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n+     * This method is called in both parts of the DCF protocol.\n+     * @param result result object to be checked\n+     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n+     */\n+    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n+        // If result was unsuccessful, create an exception\n+        if (!result.getSuccess()) {\n+            // Create ServiceException object\n+            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n+\n+            // Convert ServiceException to MsalServiceException, then throw\n+            throw new MsalServiceException(", "originalCommit": "dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NzQxNw==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462597417", "bodyText": "I was looking at some other code and it seems like a ServiceException is part of creating an MsalServiceExeption object. the ServiceException is included as the \"throwable\". I figured this would be useful somepoint down the line but it would make sense to just create an MsalServiceException right away.", "author": "t-fadura", "createdAt": "2020-07-29T21:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NDYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "db4160a3861d0ee64f555150baba754033aba357", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java b/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\ndeleted file mode 100644\nindex 0bbf36bb..00000000\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\n+++ /dev/null\n", "chunk": "@@ -1,691 +0,0 @@\n-//  Copyright (c) Microsoft Corporation.\n-//  All rights reserved.\n-//\n-//  This code is licensed under the MIT License.\n-//\n-//  Permission is hereby granted, free of charge, to any person obtaining a copy\n-//  of this software and associated documentation files(the \"Software\"), to deal\n-//  in the Software without restriction, including without limitation the rights\n-//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n-//  copies of the Software, and to permit persons to whom the Software is\n-//  furnished to do so, subject to the following conditions :\n-//\n-//  The above copyright notice and this permission notice shall be included in\n-//  all copies or substantial portions of the Software.\n-//\n-//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-//  THE SOFTWARE.\n-package com.microsoft.identity.client.internal.controllers;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.text.TextUtils;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.WorkerThread;\n-\n-import com.microsoft.identity.client.exception.MsalException;\n-import com.microsoft.identity.client.exception.MsalServiceException;\n-import com.microsoft.identity.client.exception.MsalUiRequiredException;\n-import com.microsoft.identity.common.exception.ArgumentException;\n-import com.microsoft.identity.common.exception.ClientException;\n-import com.microsoft.identity.common.exception.ErrorStrings;\n-import com.microsoft.identity.common.exception.ServiceException;\n-import com.microsoft.identity.common.internal.authorities.Authority;\n-import com.microsoft.identity.common.internal.authscheme.AbstractAuthenticationScheme;\n-import com.microsoft.identity.common.internal.cache.ICacheRecord;\n-import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n-import com.microsoft.identity.common.internal.controllers.BaseController;\n-import com.microsoft.identity.common.internal.dto.AccountRecord;\n-import com.microsoft.identity.common.internal.logging.Logger;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStatus;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStrategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.IErrorResponse;\n-import com.microsoft.identity.common.internal.providers.oauth2.IResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2TokenCache;\n-import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n-import com.microsoft.identity.common.internal.request.SdkType;\n-import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n-import com.microsoft.identity.common.internal.result.LocalAuthenticationResult;\n-import com.microsoft.identity.common.internal.telemetry.Telemetry;\n-import com.microsoft.identity.common.internal.telemetry.TelemetryEventStrings;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiEndEvent;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiStartEvent;\n-import com.microsoft.identity.common.internal.ui.AuthorizationStrategyFactory;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import static com.microsoft.identity.common.adal.internal.net.HttpWebRequest.throwIfNetworkNotAvailable;\n-\n-public class LocalMSALController extends BaseController {\n-\n-    private static final String TAG = LocalMSALController.class.getSimpleName();\n-\n-    private AuthorizationStrategy mAuthorizationStrategy = null;\n-    private AuthorizationRequest mAuthorizationRequest = null;\n-\n-    @Override\n-    public AcquireTokenResult acquireToken(\n-            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException, IOException, ArgumentException {\n-        final String methodName = \":acquireToken\";\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        //00) Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final InteractiveTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        //0) Get known authority result\n-        throwIfNetworkNotAvailable(\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes.isPowerOptCheckEnabled()\n-        );\n-\n-        Authority.KnownAuthorityResult authorityResult = Authority.getKnownAuthorityResult(parametersWithScopes.getAuthority());\n-\n-        //0.1 If not known throw resulting exception\n-        if (!authorityResult.getKnown()) {\n-            Telemetry.emit(\n-                    new ApiEndEvent()\n-                            .putException(authorityResult.getClientException())\n-                            .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-            );\n-\n-            throw authorityResult.getClientException();\n-        }\n-\n-        // Build up params for Strategy construction\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        //1) Get oAuth2Strategy for Authority Type\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-\n-        //2) Request authorization interactively\n-        final AuthorizationResult result = performAuthorizationRequest(\n-                oAuth2Strategy,\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes\n-        );\n-        acquireTokenResult.setAuthorizationResult(result);\n-\n-        logResult(TAG, result);\n-\n-        if (result.getAuthorizationStatus().equals(AuthorizationStatus.SUCCESS)) {\n-            //3) Exchange authorization code for token\n-            final TokenResult tokenResult = performTokenRequest(\n-                    oAuth2Strategy,\n-                    mAuthorizationRequest,\n-                    result.getAuthorizationResponse(),\n-                    parametersWithScopes\n-            );\n-\n-            acquireTokenResult.setTokenResult(tokenResult);\n-\n-            if (tokenResult != null && tokenResult.getSuccess()) {\n-                //4) Save tokens in token cache\n-                final List<ICacheRecord> records = saveTokens(\n-                        oAuth2Strategy,\n-                        mAuthorizationRequest,\n-                        tokenResult.getTokenResponse(),\n-                        parametersWithScopes.getOAuth2TokenCache()\n-                );\n-\n-                // The first element in the returned list is the item we *just* saved, the rest of\n-                // the elements are necessary to construct the full IAccount + TenantProfile\n-                final ICacheRecord newestRecord = records.get(0);\n-\n-                acquireTokenResult.setLocalAuthenticationResult(\n-                        new LocalAuthenticationResult(\n-                                finalizeCacheRecordForResult(\n-                                        newestRecord,\n-                                        parametersWithScopes.getAuthenticationScheme()\n-                                ),\n-                                records,\n-                                SdkType.MSAL,\n-                                false\n-                        )\n-                );\n-            }\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    private AuthorizationResult performAuthorizationRequest(@NonNull final OAuth2Strategy strategy,\n-                                                            @NonNull final Context context,\n-                                                            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException {\n-\n-        throwIfNetworkNotAvailable(context, parameters.isPowerOptCheckEnabled());\n-\n-        mAuthorizationStrategy = AuthorizationStrategyFactory.getInstance()\n-                .getAuthorizationStrategy(\n-                        parameters\n-                );\n-        mAuthorizationRequest = getAuthorizationRequest(strategy, parameters);\n-\n-        final Future<AuthorizationResult> future = strategy.requestAuthorization(\n-                mAuthorizationRequest,\n-                mAuthorizationStrategy\n-        );\n-\n-        final AuthorizationResult result = future.get();\n-\n-        return result;\n-    }\n-\n-    @Override\n-    public void completeAcquireToken(final int requestCode,\n-                                     final int resultCode,\n-                                     final Intent data) {\n-        final String methodName = \":completeAcquireToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Completing acquire token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-                        .put(TelemetryEventStrings.Key.RESULT_CODE, String.valueOf(resultCode))\n-                        .put(TelemetryEventStrings.Key.REQUEST_CODE, String.valueOf(requestCode))\n-        );\n-\n-        mAuthorizationStrategy.completeAuthorization(requestCode, resultCode, data);\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireTokenSilent(\n-            @NonNull final SilentTokenCommandParameters parameters)\n-            throws IOException, ClientException, ArgumentException, ServiceException {\n-        final String methodName = \":acquireTokenSilent\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token silently...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        final AcquireTokenResult acquireTokenSilentResult = new AcquireTokenResult();\n-\n-        //Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final SilentTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        final OAuth2TokenCache tokenCache = parametersWithScopes.getOAuth2TokenCache();\n-\n-        final AccountRecord targetAccount = getCachedAccountRecord(parametersWithScopes);\n-\n-        // Build up params for Strategy construction\n-        final AbstractAuthenticationScheme authScheme = parametersWithScopes.getAuthenticationScheme();\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy strategy = parametersWithScopes.getAuthority().createOAuth2Strategy(strategyParameters);\n-\n-        final List<ICacheRecord> cacheRecords = tokenCache.loadWithAggregatedAccountData(\n-                parametersWithScopes.getClientId(),\n-                TextUtils.join(\" \", parametersWithScopes.getScopes()),\n-                targetAccount,\n-                authScheme\n-        );\n-\n-        // The first element is the 'fully-loaded' CacheRecord which may contain the AccountRecord,\n-        // AccessTokenRecord, RefreshTokenRecord, and IdTokenRecord... (if all of those artifacts exist)\n-        // subsequent CacheRecords represent other profiles (projections) of this principal in\n-        // other tenants. Those tokens will be 'sparse', meaning that their AT/RT will not be loaded\n-        final ICacheRecord fullCacheRecord = cacheRecords.get(0);\n-\n-        if (accessTokenIsNull(fullCacheRecord)\n-                || refreshTokenIsNull(fullCacheRecord)\n-                || parametersWithScopes.isForceRefresh()\n-                || !isRequestAuthorityRealmSameAsATRealm(parametersWithScopes.getAuthority(), fullCacheRecord.getAccessToken())\n-                || !strategy.validateCachedResult(authScheme, fullCacheRecord)) {\n-            if (!refreshTokenIsNull(fullCacheRecord)) {\n-                // No AT found, but the RT checks out, so we'll use it\n-                Logger.verbose(\n-                        TAG + methodName,\n-                        \"No access token found, but RT is available.\"\n-                );\n-\n-                renewAccessToken(\n-                        parametersWithScopes,\n-                        acquireTokenSilentResult,\n-                        tokenCache,\n-                        strategy,\n-                        fullCacheRecord\n-                );\n-            } else {\n-                //TODO need the refactor, should just throw the ui required exception, rather than\n-                // wrap the exception later in the exception wrapper.\n-                final ClientException exception = new ClientException(\n-                        MsalUiRequiredException.NO_TOKENS_FOUND,\n-                        \"No refresh token was found. \"\n-                );\n-\n-                Telemetry.emit(\n-                        new ApiEndEvent()\n-                                .putException(exception)\n-                                .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-                );\n-\n-                throw exception;\n-            }\n-        } else if (fullCacheRecord.getAccessToken().isExpired()) {\n-            Logger.warn(\n-                    TAG + methodName,\n-                    \"Access token is expired. Removing from cache...\"\n-            );\n-            // Remove the expired token\n-            tokenCache.removeCredential(fullCacheRecord.getAccessToken());\n-\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Renewing access token...\"\n-            );\n-            // Request a new AT\n-            renewAccessToken(\n-                    parametersWithScopes,\n-                    acquireTokenSilentResult,\n-                    tokenCache,\n-                    strategy,\n-                    fullCacheRecord\n-            );\n-        } else {\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Returning silent result\"\n-            );\n-            // the result checks out, return that....\n-            acquireTokenSilentResult.setLocalAuthenticationResult(\n-                    new LocalAuthenticationResult(\n-                            finalizeCacheRecordForResult(\n-                                    fullCacheRecord,\n-                                    parametersWithScopes.getAuthenticationScheme()\n-                            ),\n-                            cacheRecords,\n-                            SdkType.MSAL,\n-                            true\n-                    )\n-            );\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenSilentResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        return acquireTokenSilentResult;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public List<ICacheRecord> getAccounts(@NonNull final CommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-        );\n-\n-        final List<ICacheRecord> accountsInCache =\n-                parameters\n-                        .getOAuth2TokenCache()\n-                        .getAccountsWithAggregatedAccountData(\n-                                null, // * wildcard\n-                                parameters.getClientId()\n-                        );\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-                        .put(TelemetryEventStrings.Key.ACCOUNTS_NUMBER, Integer.toString(accountsInCache.size()))\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, TelemetryEventStrings.Value.TRUE)\n-        );\n-\n-        return accountsInCache;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public boolean removeAccount(\n-            @NonNull final RemoveAccountCommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        String realm = null;\n-\n-        if (parameters.getAccount() != null) {\n-            realm = parameters.getAccount().getRealm();\n-        }\n-\n-        final boolean localRemoveAccountSuccess = !parameters\n-                .getOAuth2TokenCache()\n-                .removeAccount(\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getEnvironment(),\n-                        parameters.getClientId(),\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getHomeAccountId(),\n-                        realm\n-                ).isEmpty();\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, String.valueOf(localRemoveAccountSuccess))\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        return localRemoveAccountSuccess;\n-    }\n-\n-    @Override\n-    public boolean getDeviceMode(CommandParameters parameters) throws Exception {\n-        final String methodName = \":getDeviceMode\";\n-\n-        final String errorMessage = \"LocalMSALController is not eligible to use the broker. Do not check sharedDevice mode and return false immediately.\";\n-        com.microsoft.identity.common.internal.logging.Logger.warn(TAG + methodName, errorMessage);\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public List<ICacheRecord> getCurrentAccount(CommandParameters parameters) throws Exception {\n-        return getAccounts(parameters);\n-    }\n-\n-    @Override\n-    public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) throws Exception {\n-        return removeAccount(parameters);\n-    }\n-\n-    @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n-        // Logging start of method\n-        final String methodName = \":deviceCodeFlowAuthRequest\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Authorizing user code...\"\n-        );\n-\n-        // Default scopes here\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parametersWithScopes)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 1: Get user code\n-        // Populate global authorization request\n-        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n-\n-        // Call method defined in oAuth2Strategy to request authorization\n-        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n-\n-        validateServiceResult(authorizationResult);\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow authorization step finished...\"\n-        );\n-        logResult(TAG, authorizationResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        return authorizationResult;\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(\n-            final AuthorizationResult authorizationResult,\n-            final DeviceCodeFlowCommandParameters parameters)\n-            throws MsalException, ClientException, IOException, InterruptedException {\n-\n-        // Logging start of method\n-        final String methodName = \":acquireDeviceCodeFlowToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Polling for token...\"\n-        );\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        // Create empty AcquireTokenResult object\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        // Assign authorization result\n-        acquireTokenResult.setAuthorizationResult(authorizationResult);\n-\n-        // Fetch the Authorization Response\n-        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parameters\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 2: Poll for token\n-        TokenResult tokenResult = null;\n-\n-        // Create token request outside of loop so it isn't re-created after every loop\n-        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n-                mAuthorizationRequest,\n-                authorizationResponse,\n-                parameters.getAuthenticationScheme()\n-        );\n-\n-        // Fetch wait interval\n-        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n-\n-        String errorCode = \"authorization_pending\";\n-\n-        // Loop to send multiple requests checking for token\n-        while (errorCode.equals(\"authorization_pending\")) {\n-            errorCode = \"\"; // Reset error code\n-\n-            // Execute Token Request\n-            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n-\n-            if (tokenResult.getErrorResponse() != null) {\n-                errorCode = tokenResult.getErrorResponse().getError();\n-            }\n-\n-            if (errorCode.equals(\"authorization_pending\")) {\n-                // interval is passed through params\n-                Thread.sleep(interval);\n-            }\n-        }\n-\n-        // Assign token result\n-        acquireTokenResult.setTokenResult(tokenResult);\n-\n-        // Validate request success, may throw MsalServiceException\n-        validateServiceResult(tokenResult);\n-\n-        // If the token is valid, save it into token cache\n-        final List<ICacheRecord> records = saveTokens(\n-                oAuth2Strategy,\n-                mAuthorizationRequest,\n-                acquireTokenResult.getTokenResult().getTokenResponse(),\n-                parameters.getOAuth2TokenCache()\n-        );\n-\n-        // Once the token is stored, fetch and assign the authentication result\n-        final ICacheRecord newestRecord = records.get(0);\n-        acquireTokenResult.setLocalAuthenticationResult(\n-                new LocalAuthenticationResult(\n-                        finalizeCacheRecordForResult(\n-                                newestRecord,\n-                                parameters.getAuthenticationScheme()\n-                        ),\n-                        records,\n-                        SdkType.MSAL,\n-                        false\n-                )\n-        );\n-\n-        logResult(TAG, tokenResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    /**\n-     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n-     * This method is called in both parts of the DCF protocol.\n-     * @param result result object to be checked\n-     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n-     */\n-    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n-        // If result was unsuccessful, create an exception\n-        if (!result.getSuccess()) {\n-            // Create ServiceException object\n-            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n-\n-            // Convert ServiceException to MsalServiceException, then throw\n-            throw new MsalServiceException(\n-                    serviceException.getErrorCode(),\n-                    serviceException.getMessage(),\n-                    serviceException.getHttpStatusCode(),\n-                    serviceException\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Given an error response object, create a serviceException object using the predefined error codes.\n-     * @param response error response object to be checked\n-     * @return an exception object\n-     */\n-    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {\n-        // Based on error code, fetch the error message\n-        String errorCode = response.getError();\n-        String errorMessage = null;\n-\n-        // Check response code against pre-defined error codes\n-        switch (errorCode) {\n-            case ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_MESSAGE;\n-                break;\n-            default:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_DEFAULT_ERROR_MESSAGE;\n-        }\n-\n-        // Create a ServiceException object and return it\n-        return new ServiceException(\n-                errorCode,\n-                errorMessage,\n-                ServiceException.DEFAULT_STATUS_CODE,\n-                null\n-        );\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NDg2Mg==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462584862", "body": "nit: final", "bodyText": "nit: final", "bodyHTML": "<p dir=\"auto\">nit: final</p>", "author": "shahzaibj", "createdAt": "2020-07-29T20:58:54Z", "path": "msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java", "diffHunk": "@@ -463,14 +468,224 @@ public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) t\n     }\n \n     @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n+        // Logging start of method\n+        final String methodName = \":deviceCodeFlowAuthRequest\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Authorizing user code...\"\n+        );\n+\n+        // Default scopes here\n+        final Set<String> mergedScopes = addDefaultScopes(parameters);\n+\n+        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n+                .toBuilder()\n+                .scopes(mergedScopes)\n+                .build();\n+\n+        logParameters(TAG, parametersWithScopes);\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putProperties(parametersWithScopes)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 1: Get user code\n+        // Populate global authorization request\n+        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n+\n+        // Call method defined in oAuth2Strategy to request authorization\n+        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n+\n+        validateServiceResult(authorizationResult);\n+\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow authorization step finished...\"\n+        );\n+        logResult(TAG, authorizationResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        return authorizationResult;\n     }\n \n     @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(final AuthorizationResult authorizationResult, DeviceCodeFlowCommandParameters commandParameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AcquireTokenResult acquireDeviceCodeFlowToken(\n+            final AuthorizationResult authorizationResult,\n+            final DeviceCodeFlowCommandParameters parameters)\n+            throws MsalException, ClientException, IOException, InterruptedException {\n+\n+        // Logging start of method\n+        final String methodName = \":acquireDeviceCodeFlowToken\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Polling for token...\"\n+        );\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        // Create empty AcquireTokenResult object\n+        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n+\n+        // Assign authorization result\n+        acquireTokenResult.setAuthorizationResult(authorizationResult);\n+\n+        // Fetch the Authorization Response\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parameters\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 2: Poll for token\n+        TokenResult tokenResult = null;\n+\n+        // Create token request outside of loop so it isn't re-created after every loop\n+        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n+                mAuthorizationRequest,\n+                authorizationResponse,\n+                parameters.getAuthenticationScheme()\n+        );\n+\n+        // Fetch wait interval\n+        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n+\n+        String errorCode = \"authorization_pending\";\n+\n+        // Loop to send multiple requests checking for token\n+        while (errorCode.equals(\"authorization_pending\")) {\n+            errorCode = \"\"; // Reset error code\n+\n+            // Execute Token Request\n+            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n+\n+            if (tokenResult.getErrorResponse() != null) {\n+                errorCode = tokenResult.getErrorResponse().getError();\n+            }\n+\n+            if (errorCode.equals(\"authorization_pending\")) {\n+                // interval is passed through params\n+                Thread.sleep(interval);\n+            }\n+        }\n+\n+        // Assign token result\n+        acquireTokenResult.setTokenResult(tokenResult);\n+\n+        // Validate request success, may throw MsalServiceException\n+        validateServiceResult(tokenResult);\n+\n+        // If the token is valid, save it into token cache\n+        final List<ICacheRecord> records = saveTokens(\n+                oAuth2Strategy,\n+                mAuthorizationRequest,\n+                acquireTokenResult.getTokenResult().getTokenResponse(),\n+                parameters.getOAuth2TokenCache()\n+        );\n+\n+        // Once the token is stored, fetch and assign the authentication result\n+        final ICacheRecord newestRecord = records.get(0);\n+        acquireTokenResult.setLocalAuthenticationResult(\n+                new LocalAuthenticationResult(\n+                        finalizeCacheRecordForResult(\n+                                newestRecord,\n+                                parameters.getAuthenticationScheme()\n+                        ),\n+                        records,\n+                        SdkType.MSAL,\n+                        false\n+                )\n+        );\n+\n+        logResult(TAG, tokenResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putResult(acquireTokenResult)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        return acquireTokenResult;\n+    }\n+\n+    /**\n+     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n+     * This method is called in both parts of the DCF protocol.\n+     * @param result result object to be checked\n+     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n+     */\n+    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n+        // If result was unsuccessful, create an exception\n+        if (!result.getSuccess()) {\n+            // Create ServiceException object\n+            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n+\n+            // Convert ServiceException to MsalServiceException, then throw\n+            throw new MsalServiceException(\n+                    serviceException.getErrorCode(),\n+                    serviceException.getMessage(),\n+                    serviceException.getHttpStatusCode(),\n+                    serviceException\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Given an error response object, create a serviceException object using the predefined error codes.\n+     * @param response error response object to be checked\n+     * @return an exception object\n+     */\n+    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {\n+        // Based on error code, fetch the error message\n+        String errorCode = response.getError();\n+        String errorMessage = null;", "originalCommit": "dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db4160a3861d0ee64f555150baba754033aba357", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java b/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\ndeleted file mode 100644\nindex 0bbf36bb..00000000\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\n+++ /dev/null\n", "chunk": "@@ -1,691 +0,0 @@\n-//  Copyright (c) Microsoft Corporation.\n-//  All rights reserved.\n-//\n-//  This code is licensed under the MIT License.\n-//\n-//  Permission is hereby granted, free of charge, to any person obtaining a copy\n-//  of this software and associated documentation files(the \"Software\"), to deal\n-//  in the Software without restriction, including without limitation the rights\n-//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n-//  copies of the Software, and to permit persons to whom the Software is\n-//  furnished to do so, subject to the following conditions :\n-//\n-//  The above copyright notice and this permission notice shall be included in\n-//  all copies or substantial portions of the Software.\n-//\n-//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-//  THE SOFTWARE.\n-package com.microsoft.identity.client.internal.controllers;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.text.TextUtils;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.WorkerThread;\n-\n-import com.microsoft.identity.client.exception.MsalException;\n-import com.microsoft.identity.client.exception.MsalServiceException;\n-import com.microsoft.identity.client.exception.MsalUiRequiredException;\n-import com.microsoft.identity.common.exception.ArgumentException;\n-import com.microsoft.identity.common.exception.ClientException;\n-import com.microsoft.identity.common.exception.ErrorStrings;\n-import com.microsoft.identity.common.exception.ServiceException;\n-import com.microsoft.identity.common.internal.authorities.Authority;\n-import com.microsoft.identity.common.internal.authscheme.AbstractAuthenticationScheme;\n-import com.microsoft.identity.common.internal.cache.ICacheRecord;\n-import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n-import com.microsoft.identity.common.internal.controllers.BaseController;\n-import com.microsoft.identity.common.internal.dto.AccountRecord;\n-import com.microsoft.identity.common.internal.logging.Logger;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStatus;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStrategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.IErrorResponse;\n-import com.microsoft.identity.common.internal.providers.oauth2.IResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2TokenCache;\n-import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n-import com.microsoft.identity.common.internal.request.SdkType;\n-import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n-import com.microsoft.identity.common.internal.result.LocalAuthenticationResult;\n-import com.microsoft.identity.common.internal.telemetry.Telemetry;\n-import com.microsoft.identity.common.internal.telemetry.TelemetryEventStrings;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiEndEvent;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiStartEvent;\n-import com.microsoft.identity.common.internal.ui.AuthorizationStrategyFactory;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import static com.microsoft.identity.common.adal.internal.net.HttpWebRequest.throwIfNetworkNotAvailable;\n-\n-public class LocalMSALController extends BaseController {\n-\n-    private static final String TAG = LocalMSALController.class.getSimpleName();\n-\n-    private AuthorizationStrategy mAuthorizationStrategy = null;\n-    private AuthorizationRequest mAuthorizationRequest = null;\n-\n-    @Override\n-    public AcquireTokenResult acquireToken(\n-            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException, IOException, ArgumentException {\n-        final String methodName = \":acquireToken\";\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        //00) Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final InteractiveTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        //0) Get known authority result\n-        throwIfNetworkNotAvailable(\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes.isPowerOptCheckEnabled()\n-        );\n-\n-        Authority.KnownAuthorityResult authorityResult = Authority.getKnownAuthorityResult(parametersWithScopes.getAuthority());\n-\n-        //0.1 If not known throw resulting exception\n-        if (!authorityResult.getKnown()) {\n-            Telemetry.emit(\n-                    new ApiEndEvent()\n-                            .putException(authorityResult.getClientException())\n-                            .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-            );\n-\n-            throw authorityResult.getClientException();\n-        }\n-\n-        // Build up params for Strategy construction\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        //1) Get oAuth2Strategy for Authority Type\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-\n-        //2) Request authorization interactively\n-        final AuthorizationResult result = performAuthorizationRequest(\n-                oAuth2Strategy,\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes\n-        );\n-        acquireTokenResult.setAuthorizationResult(result);\n-\n-        logResult(TAG, result);\n-\n-        if (result.getAuthorizationStatus().equals(AuthorizationStatus.SUCCESS)) {\n-            //3) Exchange authorization code for token\n-            final TokenResult tokenResult = performTokenRequest(\n-                    oAuth2Strategy,\n-                    mAuthorizationRequest,\n-                    result.getAuthorizationResponse(),\n-                    parametersWithScopes\n-            );\n-\n-            acquireTokenResult.setTokenResult(tokenResult);\n-\n-            if (tokenResult != null && tokenResult.getSuccess()) {\n-                //4) Save tokens in token cache\n-                final List<ICacheRecord> records = saveTokens(\n-                        oAuth2Strategy,\n-                        mAuthorizationRequest,\n-                        tokenResult.getTokenResponse(),\n-                        parametersWithScopes.getOAuth2TokenCache()\n-                );\n-\n-                // The first element in the returned list is the item we *just* saved, the rest of\n-                // the elements are necessary to construct the full IAccount + TenantProfile\n-                final ICacheRecord newestRecord = records.get(0);\n-\n-                acquireTokenResult.setLocalAuthenticationResult(\n-                        new LocalAuthenticationResult(\n-                                finalizeCacheRecordForResult(\n-                                        newestRecord,\n-                                        parametersWithScopes.getAuthenticationScheme()\n-                                ),\n-                                records,\n-                                SdkType.MSAL,\n-                                false\n-                        )\n-                );\n-            }\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    private AuthorizationResult performAuthorizationRequest(@NonNull final OAuth2Strategy strategy,\n-                                                            @NonNull final Context context,\n-                                                            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException {\n-\n-        throwIfNetworkNotAvailable(context, parameters.isPowerOptCheckEnabled());\n-\n-        mAuthorizationStrategy = AuthorizationStrategyFactory.getInstance()\n-                .getAuthorizationStrategy(\n-                        parameters\n-                );\n-        mAuthorizationRequest = getAuthorizationRequest(strategy, parameters);\n-\n-        final Future<AuthorizationResult> future = strategy.requestAuthorization(\n-                mAuthorizationRequest,\n-                mAuthorizationStrategy\n-        );\n-\n-        final AuthorizationResult result = future.get();\n-\n-        return result;\n-    }\n-\n-    @Override\n-    public void completeAcquireToken(final int requestCode,\n-                                     final int resultCode,\n-                                     final Intent data) {\n-        final String methodName = \":completeAcquireToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Completing acquire token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-                        .put(TelemetryEventStrings.Key.RESULT_CODE, String.valueOf(resultCode))\n-                        .put(TelemetryEventStrings.Key.REQUEST_CODE, String.valueOf(requestCode))\n-        );\n-\n-        mAuthorizationStrategy.completeAuthorization(requestCode, resultCode, data);\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireTokenSilent(\n-            @NonNull final SilentTokenCommandParameters parameters)\n-            throws IOException, ClientException, ArgumentException, ServiceException {\n-        final String methodName = \":acquireTokenSilent\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token silently...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        final AcquireTokenResult acquireTokenSilentResult = new AcquireTokenResult();\n-\n-        //Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final SilentTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        final OAuth2TokenCache tokenCache = parametersWithScopes.getOAuth2TokenCache();\n-\n-        final AccountRecord targetAccount = getCachedAccountRecord(parametersWithScopes);\n-\n-        // Build up params for Strategy construction\n-        final AbstractAuthenticationScheme authScheme = parametersWithScopes.getAuthenticationScheme();\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy strategy = parametersWithScopes.getAuthority().createOAuth2Strategy(strategyParameters);\n-\n-        final List<ICacheRecord> cacheRecords = tokenCache.loadWithAggregatedAccountData(\n-                parametersWithScopes.getClientId(),\n-                TextUtils.join(\" \", parametersWithScopes.getScopes()),\n-                targetAccount,\n-                authScheme\n-        );\n-\n-        // The first element is the 'fully-loaded' CacheRecord which may contain the AccountRecord,\n-        // AccessTokenRecord, RefreshTokenRecord, and IdTokenRecord... (if all of those artifacts exist)\n-        // subsequent CacheRecords represent other profiles (projections) of this principal in\n-        // other tenants. Those tokens will be 'sparse', meaning that their AT/RT will not be loaded\n-        final ICacheRecord fullCacheRecord = cacheRecords.get(0);\n-\n-        if (accessTokenIsNull(fullCacheRecord)\n-                || refreshTokenIsNull(fullCacheRecord)\n-                || parametersWithScopes.isForceRefresh()\n-                || !isRequestAuthorityRealmSameAsATRealm(parametersWithScopes.getAuthority(), fullCacheRecord.getAccessToken())\n-                || !strategy.validateCachedResult(authScheme, fullCacheRecord)) {\n-            if (!refreshTokenIsNull(fullCacheRecord)) {\n-                // No AT found, but the RT checks out, so we'll use it\n-                Logger.verbose(\n-                        TAG + methodName,\n-                        \"No access token found, but RT is available.\"\n-                );\n-\n-                renewAccessToken(\n-                        parametersWithScopes,\n-                        acquireTokenSilentResult,\n-                        tokenCache,\n-                        strategy,\n-                        fullCacheRecord\n-                );\n-            } else {\n-                //TODO need the refactor, should just throw the ui required exception, rather than\n-                // wrap the exception later in the exception wrapper.\n-                final ClientException exception = new ClientException(\n-                        MsalUiRequiredException.NO_TOKENS_FOUND,\n-                        \"No refresh token was found. \"\n-                );\n-\n-                Telemetry.emit(\n-                        new ApiEndEvent()\n-                                .putException(exception)\n-                                .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-                );\n-\n-                throw exception;\n-            }\n-        } else if (fullCacheRecord.getAccessToken().isExpired()) {\n-            Logger.warn(\n-                    TAG + methodName,\n-                    \"Access token is expired. Removing from cache...\"\n-            );\n-            // Remove the expired token\n-            tokenCache.removeCredential(fullCacheRecord.getAccessToken());\n-\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Renewing access token...\"\n-            );\n-            // Request a new AT\n-            renewAccessToken(\n-                    parametersWithScopes,\n-                    acquireTokenSilentResult,\n-                    tokenCache,\n-                    strategy,\n-                    fullCacheRecord\n-            );\n-        } else {\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Returning silent result\"\n-            );\n-            // the result checks out, return that....\n-            acquireTokenSilentResult.setLocalAuthenticationResult(\n-                    new LocalAuthenticationResult(\n-                            finalizeCacheRecordForResult(\n-                                    fullCacheRecord,\n-                                    parametersWithScopes.getAuthenticationScheme()\n-                            ),\n-                            cacheRecords,\n-                            SdkType.MSAL,\n-                            true\n-                    )\n-            );\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenSilentResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        return acquireTokenSilentResult;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public List<ICacheRecord> getAccounts(@NonNull final CommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-        );\n-\n-        final List<ICacheRecord> accountsInCache =\n-                parameters\n-                        .getOAuth2TokenCache()\n-                        .getAccountsWithAggregatedAccountData(\n-                                null, // * wildcard\n-                                parameters.getClientId()\n-                        );\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-                        .put(TelemetryEventStrings.Key.ACCOUNTS_NUMBER, Integer.toString(accountsInCache.size()))\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, TelemetryEventStrings.Value.TRUE)\n-        );\n-\n-        return accountsInCache;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public boolean removeAccount(\n-            @NonNull final RemoveAccountCommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        String realm = null;\n-\n-        if (parameters.getAccount() != null) {\n-            realm = parameters.getAccount().getRealm();\n-        }\n-\n-        final boolean localRemoveAccountSuccess = !parameters\n-                .getOAuth2TokenCache()\n-                .removeAccount(\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getEnvironment(),\n-                        parameters.getClientId(),\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getHomeAccountId(),\n-                        realm\n-                ).isEmpty();\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, String.valueOf(localRemoveAccountSuccess))\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        return localRemoveAccountSuccess;\n-    }\n-\n-    @Override\n-    public boolean getDeviceMode(CommandParameters parameters) throws Exception {\n-        final String methodName = \":getDeviceMode\";\n-\n-        final String errorMessage = \"LocalMSALController is not eligible to use the broker. Do not check sharedDevice mode and return false immediately.\";\n-        com.microsoft.identity.common.internal.logging.Logger.warn(TAG + methodName, errorMessage);\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public List<ICacheRecord> getCurrentAccount(CommandParameters parameters) throws Exception {\n-        return getAccounts(parameters);\n-    }\n-\n-    @Override\n-    public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) throws Exception {\n-        return removeAccount(parameters);\n-    }\n-\n-    @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n-        // Logging start of method\n-        final String methodName = \":deviceCodeFlowAuthRequest\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Authorizing user code...\"\n-        );\n-\n-        // Default scopes here\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parametersWithScopes)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 1: Get user code\n-        // Populate global authorization request\n-        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n-\n-        // Call method defined in oAuth2Strategy to request authorization\n-        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n-\n-        validateServiceResult(authorizationResult);\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow authorization step finished...\"\n-        );\n-        logResult(TAG, authorizationResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        return authorizationResult;\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(\n-            final AuthorizationResult authorizationResult,\n-            final DeviceCodeFlowCommandParameters parameters)\n-            throws MsalException, ClientException, IOException, InterruptedException {\n-\n-        // Logging start of method\n-        final String methodName = \":acquireDeviceCodeFlowToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Polling for token...\"\n-        );\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        // Create empty AcquireTokenResult object\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        // Assign authorization result\n-        acquireTokenResult.setAuthorizationResult(authorizationResult);\n-\n-        // Fetch the Authorization Response\n-        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parameters\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 2: Poll for token\n-        TokenResult tokenResult = null;\n-\n-        // Create token request outside of loop so it isn't re-created after every loop\n-        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n-                mAuthorizationRequest,\n-                authorizationResponse,\n-                parameters.getAuthenticationScheme()\n-        );\n-\n-        // Fetch wait interval\n-        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n-\n-        String errorCode = \"authorization_pending\";\n-\n-        // Loop to send multiple requests checking for token\n-        while (errorCode.equals(\"authorization_pending\")) {\n-            errorCode = \"\"; // Reset error code\n-\n-            // Execute Token Request\n-            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n-\n-            if (tokenResult.getErrorResponse() != null) {\n-                errorCode = tokenResult.getErrorResponse().getError();\n-            }\n-\n-            if (errorCode.equals(\"authorization_pending\")) {\n-                // interval is passed through params\n-                Thread.sleep(interval);\n-            }\n-        }\n-\n-        // Assign token result\n-        acquireTokenResult.setTokenResult(tokenResult);\n-\n-        // Validate request success, may throw MsalServiceException\n-        validateServiceResult(tokenResult);\n-\n-        // If the token is valid, save it into token cache\n-        final List<ICacheRecord> records = saveTokens(\n-                oAuth2Strategy,\n-                mAuthorizationRequest,\n-                acquireTokenResult.getTokenResult().getTokenResponse(),\n-                parameters.getOAuth2TokenCache()\n-        );\n-\n-        // Once the token is stored, fetch and assign the authentication result\n-        final ICacheRecord newestRecord = records.get(0);\n-        acquireTokenResult.setLocalAuthenticationResult(\n-                new LocalAuthenticationResult(\n-                        finalizeCacheRecordForResult(\n-                                newestRecord,\n-                                parameters.getAuthenticationScheme()\n-                        ),\n-                        records,\n-                        SdkType.MSAL,\n-                        false\n-                )\n-        );\n-\n-        logResult(TAG, tokenResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    /**\n-     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n-     * This method is called in both parts of the DCF protocol.\n-     * @param result result object to be checked\n-     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n-     */\n-    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n-        // If result was unsuccessful, create an exception\n-        if (!result.getSuccess()) {\n-            // Create ServiceException object\n-            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n-\n-            // Convert ServiceException to MsalServiceException, then throw\n-            throw new MsalServiceException(\n-                    serviceException.getErrorCode(),\n-                    serviceException.getMessage(),\n-                    serviceException.getHttpStatusCode(),\n-                    serviceException\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Given an error response object, create a serviceException object using the predefined error codes.\n-     * @param response error response object to be checked\n-     * @return an exception object\n-     */\n-    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {\n-        // Based on error code, fetch the error message\n-        String errorCode = response.getError();\n-        String errorMessage = null;\n-\n-        // Check response code against pre-defined error codes\n-        switch (errorCode) {\n-            case ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_MESSAGE;\n-                break;\n-            default:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_DEFAULT_ERROR_MESSAGE;\n-        }\n-\n-        // Create a ServiceException object and return it\n-        return new ServiceException(\n-                errorCode,\n-                errorMessage,\n-                ServiceException.DEFAULT_STATUS_CODE,\n-                null\n-        );\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NDk1OQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462584959", "body": "nit: nonnull and final", "bodyText": "nit: nonnull and final", "bodyHTML": "<p dir=\"auto\">nit: nonnull and final</p>", "author": "shahzaibj", "createdAt": "2020-07-29T20:59:03Z", "path": "msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java", "diffHunk": "@@ -463,14 +468,224 @@ public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) t\n     }\n \n     @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n+        // Logging start of method\n+        final String methodName = \":deviceCodeFlowAuthRequest\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Authorizing user code...\"\n+        );\n+\n+        // Default scopes here\n+        final Set<String> mergedScopes = addDefaultScopes(parameters);\n+\n+        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n+                .toBuilder()\n+                .scopes(mergedScopes)\n+                .build();\n+\n+        logParameters(TAG, parametersWithScopes);\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putProperties(parametersWithScopes)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 1: Get user code\n+        // Populate global authorization request\n+        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n+\n+        // Call method defined in oAuth2Strategy to request authorization\n+        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n+\n+        validateServiceResult(authorizationResult);\n+\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow authorization step finished...\"\n+        );\n+        logResult(TAG, authorizationResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        return authorizationResult;\n     }\n \n     @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(final AuthorizationResult authorizationResult, DeviceCodeFlowCommandParameters commandParameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AcquireTokenResult acquireDeviceCodeFlowToken(\n+            final AuthorizationResult authorizationResult,\n+            final DeviceCodeFlowCommandParameters parameters)\n+            throws MsalException, ClientException, IOException, InterruptedException {\n+\n+        // Logging start of method\n+        final String methodName = \":acquireDeviceCodeFlowToken\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Polling for token...\"\n+        );\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        // Create empty AcquireTokenResult object\n+        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n+\n+        // Assign authorization result\n+        acquireTokenResult.setAuthorizationResult(authorizationResult);\n+\n+        // Fetch the Authorization Response\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parameters\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 2: Poll for token\n+        TokenResult tokenResult = null;\n+\n+        // Create token request outside of loop so it isn't re-created after every loop\n+        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n+                mAuthorizationRequest,\n+                authorizationResponse,\n+                parameters.getAuthenticationScheme()\n+        );\n+\n+        // Fetch wait interval\n+        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n+\n+        String errorCode = \"authorization_pending\";\n+\n+        // Loop to send multiple requests checking for token\n+        while (errorCode.equals(\"authorization_pending\")) {\n+            errorCode = \"\"; // Reset error code\n+\n+            // Execute Token Request\n+            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n+\n+            if (tokenResult.getErrorResponse() != null) {\n+                errorCode = tokenResult.getErrorResponse().getError();\n+            }\n+\n+            if (errorCode.equals(\"authorization_pending\")) {\n+                // interval is passed through params\n+                Thread.sleep(interval);\n+            }\n+        }\n+\n+        // Assign token result\n+        acquireTokenResult.setTokenResult(tokenResult);\n+\n+        // Validate request success, may throw MsalServiceException\n+        validateServiceResult(tokenResult);\n+\n+        // If the token is valid, save it into token cache\n+        final List<ICacheRecord> records = saveTokens(\n+                oAuth2Strategy,\n+                mAuthorizationRequest,\n+                acquireTokenResult.getTokenResult().getTokenResponse(),\n+                parameters.getOAuth2TokenCache()\n+        );\n+\n+        // Once the token is stored, fetch and assign the authentication result\n+        final ICacheRecord newestRecord = records.get(0);\n+        acquireTokenResult.setLocalAuthenticationResult(\n+                new LocalAuthenticationResult(\n+                        finalizeCacheRecordForResult(\n+                                newestRecord,\n+                                parameters.getAuthenticationScheme()\n+                        ),\n+                        records,\n+                        SdkType.MSAL,\n+                        false\n+                )\n+        );\n+\n+        logResult(TAG, tokenResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putResult(acquireTokenResult)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        return acquireTokenResult;\n+    }\n+\n+    /**\n+     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n+     * This method is called in both parts of the DCF protocol.\n+     * @param result result object to be checked\n+     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n+     */\n+    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n+        // If result was unsuccessful, create an exception\n+        if (!result.getSuccess()) {\n+            // Create ServiceException object\n+            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n+\n+            // Convert ServiceException to MsalServiceException, then throw\n+            throw new MsalServiceException(\n+                    serviceException.getErrorCode(),\n+                    serviceException.getMessage(),\n+                    serviceException.getHttpStatusCode(),\n+                    serviceException\n+            );\n+        }\n+    }\n+\n+    /**\n+     * Given an error response object, create a serviceException object using the predefined error codes.\n+     * @param response error response object to be checked\n+     * @return an exception object\n+     */\n+    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {", "originalCommit": "dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db4160a3861d0ee64f555150baba754033aba357", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java b/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\ndeleted file mode 100644\nindex 0bbf36bb..00000000\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\n+++ /dev/null\n", "chunk": "@@ -1,691 +0,0 @@\n-//  Copyright (c) Microsoft Corporation.\n-//  All rights reserved.\n-//\n-//  This code is licensed under the MIT License.\n-//\n-//  Permission is hereby granted, free of charge, to any person obtaining a copy\n-//  of this software and associated documentation files(the \"Software\"), to deal\n-//  in the Software without restriction, including without limitation the rights\n-//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n-//  copies of the Software, and to permit persons to whom the Software is\n-//  furnished to do so, subject to the following conditions :\n-//\n-//  The above copyright notice and this permission notice shall be included in\n-//  all copies or substantial portions of the Software.\n-//\n-//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-//  THE SOFTWARE.\n-package com.microsoft.identity.client.internal.controllers;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.text.TextUtils;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.WorkerThread;\n-\n-import com.microsoft.identity.client.exception.MsalException;\n-import com.microsoft.identity.client.exception.MsalServiceException;\n-import com.microsoft.identity.client.exception.MsalUiRequiredException;\n-import com.microsoft.identity.common.exception.ArgumentException;\n-import com.microsoft.identity.common.exception.ClientException;\n-import com.microsoft.identity.common.exception.ErrorStrings;\n-import com.microsoft.identity.common.exception.ServiceException;\n-import com.microsoft.identity.common.internal.authorities.Authority;\n-import com.microsoft.identity.common.internal.authscheme.AbstractAuthenticationScheme;\n-import com.microsoft.identity.common.internal.cache.ICacheRecord;\n-import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n-import com.microsoft.identity.common.internal.controllers.BaseController;\n-import com.microsoft.identity.common.internal.dto.AccountRecord;\n-import com.microsoft.identity.common.internal.logging.Logger;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStatus;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStrategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.IErrorResponse;\n-import com.microsoft.identity.common.internal.providers.oauth2.IResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2TokenCache;\n-import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n-import com.microsoft.identity.common.internal.request.SdkType;\n-import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n-import com.microsoft.identity.common.internal.result.LocalAuthenticationResult;\n-import com.microsoft.identity.common.internal.telemetry.Telemetry;\n-import com.microsoft.identity.common.internal.telemetry.TelemetryEventStrings;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiEndEvent;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiStartEvent;\n-import com.microsoft.identity.common.internal.ui.AuthorizationStrategyFactory;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import static com.microsoft.identity.common.adal.internal.net.HttpWebRequest.throwIfNetworkNotAvailable;\n-\n-public class LocalMSALController extends BaseController {\n-\n-    private static final String TAG = LocalMSALController.class.getSimpleName();\n-\n-    private AuthorizationStrategy mAuthorizationStrategy = null;\n-    private AuthorizationRequest mAuthorizationRequest = null;\n-\n-    @Override\n-    public AcquireTokenResult acquireToken(\n-            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException, IOException, ArgumentException {\n-        final String methodName = \":acquireToken\";\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        //00) Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final InteractiveTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        //0) Get known authority result\n-        throwIfNetworkNotAvailable(\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes.isPowerOptCheckEnabled()\n-        );\n-\n-        Authority.KnownAuthorityResult authorityResult = Authority.getKnownAuthorityResult(parametersWithScopes.getAuthority());\n-\n-        //0.1 If not known throw resulting exception\n-        if (!authorityResult.getKnown()) {\n-            Telemetry.emit(\n-                    new ApiEndEvent()\n-                            .putException(authorityResult.getClientException())\n-                            .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-            );\n-\n-            throw authorityResult.getClientException();\n-        }\n-\n-        // Build up params for Strategy construction\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        //1) Get oAuth2Strategy for Authority Type\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-\n-        //2) Request authorization interactively\n-        final AuthorizationResult result = performAuthorizationRequest(\n-                oAuth2Strategy,\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes\n-        );\n-        acquireTokenResult.setAuthorizationResult(result);\n-\n-        logResult(TAG, result);\n-\n-        if (result.getAuthorizationStatus().equals(AuthorizationStatus.SUCCESS)) {\n-            //3) Exchange authorization code for token\n-            final TokenResult tokenResult = performTokenRequest(\n-                    oAuth2Strategy,\n-                    mAuthorizationRequest,\n-                    result.getAuthorizationResponse(),\n-                    parametersWithScopes\n-            );\n-\n-            acquireTokenResult.setTokenResult(tokenResult);\n-\n-            if (tokenResult != null && tokenResult.getSuccess()) {\n-                //4) Save tokens in token cache\n-                final List<ICacheRecord> records = saveTokens(\n-                        oAuth2Strategy,\n-                        mAuthorizationRequest,\n-                        tokenResult.getTokenResponse(),\n-                        parametersWithScopes.getOAuth2TokenCache()\n-                );\n-\n-                // The first element in the returned list is the item we *just* saved, the rest of\n-                // the elements are necessary to construct the full IAccount + TenantProfile\n-                final ICacheRecord newestRecord = records.get(0);\n-\n-                acquireTokenResult.setLocalAuthenticationResult(\n-                        new LocalAuthenticationResult(\n-                                finalizeCacheRecordForResult(\n-                                        newestRecord,\n-                                        parametersWithScopes.getAuthenticationScheme()\n-                                ),\n-                                records,\n-                                SdkType.MSAL,\n-                                false\n-                        )\n-                );\n-            }\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    private AuthorizationResult performAuthorizationRequest(@NonNull final OAuth2Strategy strategy,\n-                                                            @NonNull final Context context,\n-                                                            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException {\n-\n-        throwIfNetworkNotAvailable(context, parameters.isPowerOptCheckEnabled());\n-\n-        mAuthorizationStrategy = AuthorizationStrategyFactory.getInstance()\n-                .getAuthorizationStrategy(\n-                        parameters\n-                );\n-        mAuthorizationRequest = getAuthorizationRequest(strategy, parameters);\n-\n-        final Future<AuthorizationResult> future = strategy.requestAuthorization(\n-                mAuthorizationRequest,\n-                mAuthorizationStrategy\n-        );\n-\n-        final AuthorizationResult result = future.get();\n-\n-        return result;\n-    }\n-\n-    @Override\n-    public void completeAcquireToken(final int requestCode,\n-                                     final int resultCode,\n-                                     final Intent data) {\n-        final String methodName = \":completeAcquireToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Completing acquire token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-                        .put(TelemetryEventStrings.Key.RESULT_CODE, String.valueOf(resultCode))\n-                        .put(TelemetryEventStrings.Key.REQUEST_CODE, String.valueOf(requestCode))\n-        );\n-\n-        mAuthorizationStrategy.completeAuthorization(requestCode, resultCode, data);\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireTokenSilent(\n-            @NonNull final SilentTokenCommandParameters parameters)\n-            throws IOException, ClientException, ArgumentException, ServiceException {\n-        final String methodName = \":acquireTokenSilent\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token silently...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        final AcquireTokenResult acquireTokenSilentResult = new AcquireTokenResult();\n-\n-        //Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final SilentTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        final OAuth2TokenCache tokenCache = parametersWithScopes.getOAuth2TokenCache();\n-\n-        final AccountRecord targetAccount = getCachedAccountRecord(parametersWithScopes);\n-\n-        // Build up params for Strategy construction\n-        final AbstractAuthenticationScheme authScheme = parametersWithScopes.getAuthenticationScheme();\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy strategy = parametersWithScopes.getAuthority().createOAuth2Strategy(strategyParameters);\n-\n-        final List<ICacheRecord> cacheRecords = tokenCache.loadWithAggregatedAccountData(\n-                parametersWithScopes.getClientId(),\n-                TextUtils.join(\" \", parametersWithScopes.getScopes()),\n-                targetAccount,\n-                authScheme\n-        );\n-\n-        // The first element is the 'fully-loaded' CacheRecord which may contain the AccountRecord,\n-        // AccessTokenRecord, RefreshTokenRecord, and IdTokenRecord... (if all of those artifacts exist)\n-        // subsequent CacheRecords represent other profiles (projections) of this principal in\n-        // other tenants. Those tokens will be 'sparse', meaning that their AT/RT will not be loaded\n-        final ICacheRecord fullCacheRecord = cacheRecords.get(0);\n-\n-        if (accessTokenIsNull(fullCacheRecord)\n-                || refreshTokenIsNull(fullCacheRecord)\n-                || parametersWithScopes.isForceRefresh()\n-                || !isRequestAuthorityRealmSameAsATRealm(parametersWithScopes.getAuthority(), fullCacheRecord.getAccessToken())\n-                || !strategy.validateCachedResult(authScheme, fullCacheRecord)) {\n-            if (!refreshTokenIsNull(fullCacheRecord)) {\n-                // No AT found, but the RT checks out, so we'll use it\n-                Logger.verbose(\n-                        TAG + methodName,\n-                        \"No access token found, but RT is available.\"\n-                );\n-\n-                renewAccessToken(\n-                        parametersWithScopes,\n-                        acquireTokenSilentResult,\n-                        tokenCache,\n-                        strategy,\n-                        fullCacheRecord\n-                );\n-            } else {\n-                //TODO need the refactor, should just throw the ui required exception, rather than\n-                // wrap the exception later in the exception wrapper.\n-                final ClientException exception = new ClientException(\n-                        MsalUiRequiredException.NO_TOKENS_FOUND,\n-                        \"No refresh token was found. \"\n-                );\n-\n-                Telemetry.emit(\n-                        new ApiEndEvent()\n-                                .putException(exception)\n-                                .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-                );\n-\n-                throw exception;\n-            }\n-        } else if (fullCacheRecord.getAccessToken().isExpired()) {\n-            Logger.warn(\n-                    TAG + methodName,\n-                    \"Access token is expired. Removing from cache...\"\n-            );\n-            // Remove the expired token\n-            tokenCache.removeCredential(fullCacheRecord.getAccessToken());\n-\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Renewing access token...\"\n-            );\n-            // Request a new AT\n-            renewAccessToken(\n-                    parametersWithScopes,\n-                    acquireTokenSilentResult,\n-                    tokenCache,\n-                    strategy,\n-                    fullCacheRecord\n-            );\n-        } else {\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Returning silent result\"\n-            );\n-            // the result checks out, return that....\n-            acquireTokenSilentResult.setLocalAuthenticationResult(\n-                    new LocalAuthenticationResult(\n-                            finalizeCacheRecordForResult(\n-                                    fullCacheRecord,\n-                                    parametersWithScopes.getAuthenticationScheme()\n-                            ),\n-                            cacheRecords,\n-                            SdkType.MSAL,\n-                            true\n-                    )\n-            );\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenSilentResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        return acquireTokenSilentResult;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public List<ICacheRecord> getAccounts(@NonNull final CommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-        );\n-\n-        final List<ICacheRecord> accountsInCache =\n-                parameters\n-                        .getOAuth2TokenCache()\n-                        .getAccountsWithAggregatedAccountData(\n-                                null, // * wildcard\n-                                parameters.getClientId()\n-                        );\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-                        .put(TelemetryEventStrings.Key.ACCOUNTS_NUMBER, Integer.toString(accountsInCache.size()))\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, TelemetryEventStrings.Value.TRUE)\n-        );\n-\n-        return accountsInCache;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public boolean removeAccount(\n-            @NonNull final RemoveAccountCommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        String realm = null;\n-\n-        if (parameters.getAccount() != null) {\n-            realm = parameters.getAccount().getRealm();\n-        }\n-\n-        final boolean localRemoveAccountSuccess = !parameters\n-                .getOAuth2TokenCache()\n-                .removeAccount(\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getEnvironment(),\n-                        parameters.getClientId(),\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getHomeAccountId(),\n-                        realm\n-                ).isEmpty();\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, String.valueOf(localRemoveAccountSuccess))\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        return localRemoveAccountSuccess;\n-    }\n-\n-    @Override\n-    public boolean getDeviceMode(CommandParameters parameters) throws Exception {\n-        final String methodName = \":getDeviceMode\";\n-\n-        final String errorMessage = \"LocalMSALController is not eligible to use the broker. Do not check sharedDevice mode and return false immediately.\";\n-        com.microsoft.identity.common.internal.logging.Logger.warn(TAG + methodName, errorMessage);\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public List<ICacheRecord> getCurrentAccount(CommandParameters parameters) throws Exception {\n-        return getAccounts(parameters);\n-    }\n-\n-    @Override\n-    public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) throws Exception {\n-        return removeAccount(parameters);\n-    }\n-\n-    @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n-        // Logging start of method\n-        final String methodName = \":deviceCodeFlowAuthRequest\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Authorizing user code...\"\n-        );\n-\n-        // Default scopes here\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parametersWithScopes)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 1: Get user code\n-        // Populate global authorization request\n-        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n-\n-        // Call method defined in oAuth2Strategy to request authorization\n-        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n-\n-        validateServiceResult(authorizationResult);\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow authorization step finished...\"\n-        );\n-        logResult(TAG, authorizationResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        return authorizationResult;\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(\n-            final AuthorizationResult authorizationResult,\n-            final DeviceCodeFlowCommandParameters parameters)\n-            throws MsalException, ClientException, IOException, InterruptedException {\n-\n-        // Logging start of method\n-        final String methodName = \":acquireDeviceCodeFlowToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Polling for token...\"\n-        );\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        // Create empty AcquireTokenResult object\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        // Assign authorization result\n-        acquireTokenResult.setAuthorizationResult(authorizationResult);\n-\n-        // Fetch the Authorization Response\n-        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parameters\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 2: Poll for token\n-        TokenResult tokenResult = null;\n-\n-        // Create token request outside of loop so it isn't re-created after every loop\n-        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n-                mAuthorizationRequest,\n-                authorizationResponse,\n-                parameters.getAuthenticationScheme()\n-        );\n-\n-        // Fetch wait interval\n-        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n-\n-        String errorCode = \"authorization_pending\";\n-\n-        // Loop to send multiple requests checking for token\n-        while (errorCode.equals(\"authorization_pending\")) {\n-            errorCode = \"\"; // Reset error code\n-\n-            // Execute Token Request\n-            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n-\n-            if (tokenResult.getErrorResponse() != null) {\n-                errorCode = tokenResult.getErrorResponse().getError();\n-            }\n-\n-            if (errorCode.equals(\"authorization_pending\")) {\n-                // interval is passed through params\n-                Thread.sleep(interval);\n-            }\n-        }\n-\n-        // Assign token result\n-        acquireTokenResult.setTokenResult(tokenResult);\n-\n-        // Validate request success, may throw MsalServiceException\n-        validateServiceResult(tokenResult);\n-\n-        // If the token is valid, save it into token cache\n-        final List<ICacheRecord> records = saveTokens(\n-                oAuth2Strategy,\n-                mAuthorizationRequest,\n-                acquireTokenResult.getTokenResult().getTokenResponse(),\n-                parameters.getOAuth2TokenCache()\n-        );\n-\n-        // Once the token is stored, fetch and assign the authentication result\n-        final ICacheRecord newestRecord = records.get(0);\n-        acquireTokenResult.setLocalAuthenticationResult(\n-                new LocalAuthenticationResult(\n-                        finalizeCacheRecordForResult(\n-                                newestRecord,\n-                                parameters.getAuthenticationScheme()\n-                        ),\n-                        records,\n-                        SdkType.MSAL,\n-                        false\n-                )\n-        );\n-\n-        logResult(TAG, tokenResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    /**\n-     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n-     * This method is called in both parts of the DCF protocol.\n-     * @param result result object to be checked\n-     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n-     */\n-    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n-        // If result was unsuccessful, create an exception\n-        if (!result.getSuccess()) {\n-            // Create ServiceException object\n-            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n-\n-            // Convert ServiceException to MsalServiceException, then throw\n-            throw new MsalServiceException(\n-                    serviceException.getErrorCode(),\n-                    serviceException.getMessage(),\n-                    serviceException.getHttpStatusCode(),\n-                    serviceException\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Given an error response object, create a serviceException object using the predefined error codes.\n-     * @param response error response object to be checked\n-     * @return an exception object\n-     */\n-    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {\n-        // Based on error code, fetch the error message\n-        String errorCode = response.getError();\n-        String errorMessage = null;\n-\n-        // Check response code against pre-defined error codes\n-        switch (errorCode) {\n-            case ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_MESSAGE;\n-                break;\n-            default:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_DEFAULT_ERROR_MESSAGE;\n-        }\n-\n-        // Create a ServiceException object and return it\n-        return new ServiceException(\n-                errorCode,\n-                errorMessage,\n-                ServiceException.DEFAULT_STATUS_CODE,\n-                null\n-        );\n-    }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NTUwOA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462585508", "body": "At this point, is this error code coming from the service?", "bodyText": "At this point, is this error code coming from the service?", "bodyHTML": "<p dir=\"auto\">At this point, is this error code coming from the service?</p>", "author": "shahzaibj", "createdAt": "2020-07-29T21:00:04Z", "path": "msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java", "diffHunk": "@@ -463,14 +468,224 @@ public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) t\n     }\n \n     @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n+        // Logging start of method\n+        final String methodName = \":deviceCodeFlowAuthRequest\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Authorizing user code...\"\n+        );\n+\n+        // Default scopes here\n+        final Set<String> mergedScopes = addDefaultScopes(parameters);\n+\n+        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n+                .toBuilder()\n+                .scopes(mergedScopes)\n+                .build();\n+\n+        logParameters(TAG, parametersWithScopes);\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putProperties(parametersWithScopes)\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 1: Get user code\n+        // Populate global authorization request\n+        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n+\n+        // Call method defined in oAuth2Strategy to request authorization\n+        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n+\n+        validateServiceResult(authorizationResult);\n+\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow authorization step finished...\"\n+        );\n+        logResult(TAG, authorizationResult);\n+\n+        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n+        Telemetry.emit(\n+                new ApiEndEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n+        );\n+\n+        return authorizationResult;\n     }\n \n     @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(final AuthorizationResult authorizationResult, DeviceCodeFlowCommandParameters commandParameters) throws Exception {\n-        // TODO: Placeholder to avoid inheritance error. Will be implemented after Command/Controller level PR in Common\n-        return null;\n+    public AcquireTokenResult acquireDeviceCodeFlowToken(\n+            final AuthorizationResult authorizationResult,\n+            final DeviceCodeFlowCommandParameters parameters)\n+            throws MsalException, ClientException, IOException, InterruptedException {\n+\n+        // Logging start of method\n+        final String methodName = \":acquireDeviceCodeFlowToken\";\n+        Logger.verbose(\n+                TAG + methodName,\n+                \"Device Code Flow: Polling for token...\"\n+        );\n+\n+        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n+        Telemetry.emit(\n+                new ApiStartEvent()\n+                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n+        );\n+\n+        // Create empty AcquireTokenResult object\n+        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n+\n+        // Assign authorization result\n+        acquireTokenResult.setAuthorizationResult(authorizationResult);\n+\n+        // Fetch the Authorization Response\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        // Create OAuth2Strategy using commandParameters and strategyParameters\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n+\n+        final OAuth2Strategy oAuth2Strategy = parameters\n+                .getAuthority()\n+                .createOAuth2Strategy(strategyParameters);\n+\n+        // DCF protocol step 2: Poll for token\n+        TokenResult tokenResult = null;\n+\n+        // Create token request outside of loop so it isn't re-created after every loop\n+        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n+                mAuthorizationRequest,\n+                authorizationResponse,\n+                parameters.getAuthenticationScheme()\n+        );\n+\n+        // Fetch wait interval\n+        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n+\n+        String errorCode = \"authorization_pending\";\n+\n+        // Loop to send multiple requests checking for token\n+        while (errorCode.equals(\"authorization_pending\")) {\n+            errorCode = \"\"; // Reset error code\n+\n+            // Execute Token Request\n+            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n+\n+            if (tokenResult.getErrorResponse() != null) {\n+                errorCode = tokenResult.getErrorResponse().getError();\n+            }\n+\n+            if (errorCode.equals(\"authorization_pending\")) {", "originalCommit": "dc5440c3b99b8d2f8ef041617e51269c48b71bd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxNjQ0Nw==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r462616447", "bodyText": "Error is returned from server after each token poll attempt", "author": "t-fadura", "createdAt": "2020-07-29T22:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU4NTUwOA=="}], "type": "inlineReview", "revised_code": {"commit": "db4160a3861d0ee64f555150baba754033aba357", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java b/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\ndeleted file mode 100644\nindex 0bbf36bb..00000000\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/controllers/LocalMSALController.java\n+++ /dev/null\n", "chunk": "@@ -1,691 +0,0 @@\n-//  Copyright (c) Microsoft Corporation.\n-//  All rights reserved.\n-//\n-//  This code is licensed under the MIT License.\n-//\n-//  Permission is hereby granted, free of charge, to any person obtaining a copy\n-//  of this software and associated documentation files(the \"Software\"), to deal\n-//  in the Software without restriction, including without limitation the rights\n-//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n-//  copies of the Software, and to permit persons to whom the Software is\n-//  furnished to do so, subject to the following conditions :\n-//\n-//  The above copyright notice and this permission notice shall be included in\n-//  all copies or substantial portions of the Software.\n-//\n-//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-//  THE SOFTWARE.\n-package com.microsoft.identity.client.internal.controllers;\n-\n-import android.content.Context;\n-import android.content.Intent;\n-import android.text.TextUtils;\n-\n-import androidx.annotation.NonNull;\n-import androidx.annotation.WorkerThread;\n-\n-import com.microsoft.identity.client.exception.MsalException;\n-import com.microsoft.identity.client.exception.MsalServiceException;\n-import com.microsoft.identity.client.exception.MsalUiRequiredException;\n-import com.microsoft.identity.common.exception.ArgumentException;\n-import com.microsoft.identity.common.exception.ClientException;\n-import com.microsoft.identity.common.exception.ErrorStrings;\n-import com.microsoft.identity.common.exception.ServiceException;\n-import com.microsoft.identity.common.internal.authorities.Authority;\n-import com.microsoft.identity.common.internal.authscheme.AbstractAuthenticationScheme;\n-import com.microsoft.identity.common.internal.cache.ICacheRecord;\n-import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n-import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n-import com.microsoft.identity.common.internal.controllers.BaseController;\n-import com.microsoft.identity.common.internal.dto.AccountRecord;\n-import com.microsoft.identity.common.internal.logging.Logger;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n-import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationRequest;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStatus;\n-import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationStrategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.IErrorResponse;\n-import com.microsoft.identity.common.internal.providers.oauth2.IResult;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n-import com.microsoft.identity.common.internal.providers.oauth2.OAuth2TokenCache;\n-import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n-import com.microsoft.identity.common.internal.request.SdkType;\n-import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n-import com.microsoft.identity.common.internal.result.LocalAuthenticationResult;\n-import com.microsoft.identity.common.internal.telemetry.Telemetry;\n-import com.microsoft.identity.common.internal.telemetry.TelemetryEventStrings;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiEndEvent;\n-import com.microsoft.identity.common.internal.telemetry.events.ApiStartEvent;\n-import com.microsoft.identity.common.internal.ui.AuthorizationStrategyFactory;\n-\n-import java.io.IOException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import static com.microsoft.identity.common.adal.internal.net.HttpWebRequest.throwIfNetworkNotAvailable;\n-\n-public class LocalMSALController extends BaseController {\n-\n-    private static final String TAG = LocalMSALController.class.getSimpleName();\n-\n-    private AuthorizationStrategy mAuthorizationStrategy = null;\n-    private AuthorizationRequest mAuthorizationRequest = null;\n-\n-    @Override\n-    public AcquireTokenResult acquireToken(\n-            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException, IOException, ArgumentException {\n-        final String methodName = \":acquireToken\";\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        //00) Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final InteractiveTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        //0) Get known authority result\n-        throwIfNetworkNotAvailable(\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes.isPowerOptCheckEnabled()\n-        );\n-\n-        Authority.KnownAuthorityResult authorityResult = Authority.getKnownAuthorityResult(parametersWithScopes.getAuthority());\n-\n-        //0.1 If not known throw resulting exception\n-        if (!authorityResult.getKnown()) {\n-            Telemetry.emit(\n-                    new ApiEndEvent()\n-                            .putException(authorityResult.getClientException())\n-                            .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-            );\n-\n-            throw authorityResult.getClientException();\n-        }\n-\n-        // Build up params for Strategy construction\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        //1) Get oAuth2Strategy for Authority Type\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-\n-        //2) Request authorization interactively\n-        final AuthorizationResult result = performAuthorizationRequest(\n-                oAuth2Strategy,\n-                parametersWithScopes.getAndroidApplicationContext(),\n-                parametersWithScopes\n-        );\n-        acquireTokenResult.setAuthorizationResult(result);\n-\n-        logResult(TAG, result);\n-\n-        if (result.getAuthorizationStatus().equals(AuthorizationStatus.SUCCESS)) {\n-            //3) Exchange authorization code for token\n-            final TokenResult tokenResult = performTokenRequest(\n-                    oAuth2Strategy,\n-                    mAuthorizationRequest,\n-                    result.getAuthorizationResponse(),\n-                    parametersWithScopes\n-            );\n-\n-            acquireTokenResult.setTokenResult(tokenResult);\n-\n-            if (tokenResult != null && tokenResult.getSuccess()) {\n-                //4) Save tokens in token cache\n-                final List<ICacheRecord> records = saveTokens(\n-                        oAuth2Strategy,\n-                        mAuthorizationRequest,\n-                        tokenResult.getTokenResponse(),\n-                        parametersWithScopes.getOAuth2TokenCache()\n-                );\n-\n-                // The first element in the returned list is the item we *just* saved, the rest of\n-                // the elements are necessary to construct the full IAccount + TenantProfile\n-                final ICacheRecord newestRecord = records.get(0);\n-\n-                acquireTokenResult.setLocalAuthenticationResult(\n-                        new LocalAuthenticationResult(\n-                                finalizeCacheRecordForResult(\n-                                        newestRecord,\n-                                        parametersWithScopes.getAuthenticationScheme()\n-                                ),\n-                                records,\n-                                SdkType.MSAL,\n-                                false\n-                        )\n-                );\n-            }\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    private AuthorizationResult performAuthorizationRequest(@NonNull final OAuth2Strategy strategy,\n-                                                            @NonNull final Context context,\n-                                                            @NonNull final InteractiveTokenCommandParameters parameters)\n-            throws ExecutionException, InterruptedException, ClientException {\n-\n-        throwIfNetworkNotAvailable(context, parameters.isPowerOptCheckEnabled());\n-\n-        mAuthorizationStrategy = AuthorizationStrategyFactory.getInstance()\n-                .getAuthorizationStrategy(\n-                        parameters\n-                );\n-        mAuthorizationRequest = getAuthorizationRequest(strategy, parameters);\n-\n-        final Future<AuthorizationResult> future = strategy.requestAuthorization(\n-                mAuthorizationRequest,\n-                mAuthorizationStrategy\n-        );\n-\n-        final AuthorizationResult result = future.get();\n-\n-        return result;\n-    }\n-\n-    @Override\n-    public void completeAcquireToken(final int requestCode,\n-                                     final int resultCode,\n-                                     final Intent data) {\n-        final String methodName = \":completeAcquireToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Completing acquire token...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-                        .put(TelemetryEventStrings.Key.RESULT_CODE, String.valueOf(resultCode))\n-                        .put(TelemetryEventStrings.Key.REQUEST_CODE, String.valueOf(requestCode))\n-        );\n-\n-        mAuthorizationStrategy.completeAuthorization(requestCode, resultCode, data);\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_COMPLETE_ACQUIRE_TOKEN_INTERACTIVE)\n-        );\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireTokenSilent(\n-            @NonNull final SilentTokenCommandParameters parameters)\n-            throws IOException, ClientException, ArgumentException, ServiceException {\n-        final String methodName = \":acquireTokenSilent\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Acquiring token silently...\"\n-        );\n-\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        final AcquireTokenResult acquireTokenSilentResult = new AcquireTokenResult();\n-\n-        //Validate MSAL Parameters\n-        parameters.validate();\n-\n-        // Add default scopes\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final SilentTokenCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        final OAuth2TokenCache tokenCache = parametersWithScopes.getOAuth2TokenCache();\n-\n-        final AccountRecord targetAccount = getCachedAccountRecord(parametersWithScopes);\n-\n-        // Build up params for Strategy construction\n-        final AbstractAuthenticationScheme authScheme = parametersWithScopes.getAuthenticationScheme();\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy strategy = parametersWithScopes.getAuthority().createOAuth2Strategy(strategyParameters);\n-\n-        final List<ICacheRecord> cacheRecords = tokenCache.loadWithAggregatedAccountData(\n-                parametersWithScopes.getClientId(),\n-                TextUtils.join(\" \", parametersWithScopes.getScopes()),\n-                targetAccount,\n-                authScheme\n-        );\n-\n-        // The first element is the 'fully-loaded' CacheRecord which may contain the AccountRecord,\n-        // AccessTokenRecord, RefreshTokenRecord, and IdTokenRecord... (if all of those artifacts exist)\n-        // subsequent CacheRecords represent other profiles (projections) of this principal in\n-        // other tenants. Those tokens will be 'sparse', meaning that their AT/RT will not be loaded\n-        final ICacheRecord fullCacheRecord = cacheRecords.get(0);\n-\n-        if (accessTokenIsNull(fullCacheRecord)\n-                || refreshTokenIsNull(fullCacheRecord)\n-                || parametersWithScopes.isForceRefresh()\n-                || !isRequestAuthorityRealmSameAsATRealm(parametersWithScopes.getAuthority(), fullCacheRecord.getAccessToken())\n-                || !strategy.validateCachedResult(authScheme, fullCacheRecord)) {\n-            if (!refreshTokenIsNull(fullCacheRecord)) {\n-                // No AT found, but the RT checks out, so we'll use it\n-                Logger.verbose(\n-                        TAG + methodName,\n-                        \"No access token found, but RT is available.\"\n-                );\n-\n-                renewAccessToken(\n-                        parametersWithScopes,\n-                        acquireTokenSilentResult,\n-                        tokenCache,\n-                        strategy,\n-                        fullCacheRecord\n-                );\n-            } else {\n-                //TODO need the refactor, should just throw the ui required exception, rather than\n-                // wrap the exception later in the exception wrapper.\n-                final ClientException exception = new ClientException(\n-                        MsalUiRequiredException.NO_TOKENS_FOUND,\n-                        \"No refresh token was found. \"\n-                );\n-\n-                Telemetry.emit(\n-                        new ApiEndEvent()\n-                                .putException(exception)\n-                                .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-                );\n-\n-                throw exception;\n-            }\n-        } else if (fullCacheRecord.getAccessToken().isExpired()) {\n-            Logger.warn(\n-                    TAG + methodName,\n-                    \"Access token is expired. Removing from cache...\"\n-            );\n-            // Remove the expired token\n-            tokenCache.removeCredential(fullCacheRecord.getAccessToken());\n-\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Renewing access token...\"\n-            );\n-            // Request a new AT\n-            renewAccessToken(\n-                    parametersWithScopes,\n-                    acquireTokenSilentResult,\n-                    tokenCache,\n-                    strategy,\n-                    fullCacheRecord\n-            );\n-        } else {\n-            Logger.verbose(\n-                    TAG + methodName,\n-                    \"Returning silent result\"\n-            );\n-            // the result checks out, return that....\n-            acquireTokenSilentResult.setLocalAuthenticationResult(\n-                    new LocalAuthenticationResult(\n-                            finalizeCacheRecordForResult(\n-                                    fullCacheRecord,\n-                                    parametersWithScopes.getAuthenticationScheme()\n-                            ),\n-                            cacheRecords,\n-                            SdkType.MSAL,\n-                            true\n-                    )\n-            );\n-        }\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenSilentResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_ACQUIRE_TOKEN_SILENT)\n-        );\n-\n-        return acquireTokenSilentResult;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public List<ICacheRecord> getAccounts(@NonNull final CommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-        );\n-\n-        final List<ICacheRecord> accountsInCache =\n-                parameters\n-                        .getOAuth2TokenCache()\n-                        .getAccountsWithAggregatedAccountData(\n-                                null, // * wildcard\n-                                parameters.getClientId()\n-                        );\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_GET_ACCOUNTS)\n-                        .put(TelemetryEventStrings.Key.ACCOUNTS_NUMBER, Integer.toString(accountsInCache.size()))\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, TelemetryEventStrings.Value.TRUE)\n-        );\n-\n-        return accountsInCache;\n-    }\n-\n-    @Override\n-    @WorkerThread\n-    public boolean removeAccount(\n-            @NonNull final RemoveAccountCommandParameters parameters) {\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parameters)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        String realm = null;\n-\n-        if (parameters.getAccount() != null) {\n-            realm = parameters.getAccount().getRealm();\n-        }\n-\n-        final boolean localRemoveAccountSuccess = !parameters\n-                .getOAuth2TokenCache()\n-                .removeAccount(\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getEnvironment(),\n-                        parameters.getClientId(),\n-                        parameters.getAccount() == null ? null : parameters.getAccount().getHomeAccountId(),\n-                        realm\n-                ).isEmpty();\n-\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .put(TelemetryEventStrings.Key.IS_SUCCESSFUL, String.valueOf(localRemoveAccountSuccess))\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_REMOVE_ACCOUNT)\n-        );\n-\n-        return localRemoveAccountSuccess;\n-    }\n-\n-    @Override\n-    public boolean getDeviceMode(CommandParameters parameters) throws Exception {\n-        final String methodName = \":getDeviceMode\";\n-\n-        final String errorMessage = \"LocalMSALController is not eligible to use the broker. Do not check sharedDevice mode and return false immediately.\";\n-        com.microsoft.identity.common.internal.logging.Logger.warn(TAG + methodName, errorMessage);\n-\n-        return false;\n-    }\n-\n-    @Override\n-    public List<ICacheRecord> getCurrentAccount(CommandParameters parameters) throws Exception {\n-        return getAccounts(parameters);\n-    }\n-\n-    @Override\n-    public boolean removeCurrentAccount(RemoveAccountCommandParameters parameters) throws Exception {\n-        return removeAccount(parameters);\n-    }\n-\n-    @Override\n-    public AuthorizationResult deviceCodeFlowAuthRequest(final DeviceCodeFlowCommandParameters parameters) throws MsalException, ClientException, IOException {\n-        // Logging start of method\n-        final String methodName = \":deviceCodeFlowAuthRequest\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Authorizing user code...\"\n-        );\n-\n-        // Default scopes here\n-        final Set<String> mergedScopes = addDefaultScopes(parameters);\n-\n-        final DeviceCodeFlowCommandParameters parametersWithScopes = parameters\n-                .toBuilder()\n-                .scopes(mergedScopes)\n-                .build();\n-\n-        logParameters(TAG, parametersWithScopes);\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putProperties(parametersWithScopes)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parametersWithScopes.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parametersWithScopes\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 1: Get user code\n-        // Populate global authorization request\n-        mAuthorizationRequest = getAuthorizationRequest(oAuth2Strategy, parametersWithScopes);\n-\n-        // Call method defined in oAuth2Strategy to request authorization\n-        final AuthorizationResult authorizationResult = oAuth2Strategy.getDeviceCode((MicrosoftStsAuthorizationRequest) mAuthorizationRequest, null);\n-\n-        validateServiceResult(authorizationResult);\n-\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow authorization step finished...\"\n-        );\n-        logResult(TAG, authorizationResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_ACQUIRE_URL_AND_CODE)\n-        );\n-\n-        return authorizationResult;\n-    }\n-\n-    @Override\n-    public AcquireTokenResult acquireDeviceCodeFlowToken(\n-            final AuthorizationResult authorizationResult,\n-            final DeviceCodeFlowCommandParameters parameters)\n-            throws MsalException, ClientException, IOException, InterruptedException {\n-\n-        // Logging start of method\n-        final String methodName = \":acquireDeviceCodeFlowToken\";\n-        Logger.verbose(\n-                TAG + methodName,\n-                \"Device Code Flow: Polling for token...\"\n-        );\n-\n-        // Start telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiStartEvent()\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        // Create empty AcquireTokenResult object\n-        final AcquireTokenResult acquireTokenResult = new AcquireTokenResult();\n-\n-        // Assign authorization result\n-        acquireTokenResult.setAuthorizationResult(authorizationResult);\n-\n-        // Fetch the Authorization Response\n-        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n-\n-        // Create OAuth2Strategy using commandParameters and strategyParameters\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n-        strategyParameters.setContext(parameters.getAndroidApplicationContext());\n-\n-        final OAuth2Strategy oAuth2Strategy = parameters\n-                .getAuthority()\n-                .createOAuth2Strategy(strategyParameters);\n-\n-        // DCF protocol step 2: Poll for token\n-        TokenResult tokenResult = null;\n-\n-        // Create token request outside of loop so it isn't re-created after every loop\n-        final MicrosoftStsTokenRequest tokenRequest = (MicrosoftStsTokenRequest) oAuth2Strategy.createTokenRequest(\n-                mAuthorizationRequest,\n-                authorizationResponse,\n-                parameters.getAuthenticationScheme()\n-        );\n-\n-        // Fetch wait interval\n-        final int interval = Integer.parseInt(authorizationResponse.getInterval()) * 1000;\n-\n-        String errorCode = \"authorization_pending\";\n-\n-        // Loop to send multiple requests checking for token\n-        while (errorCode.equals(\"authorization_pending\")) {\n-            errorCode = \"\"; // Reset error code\n-\n-            // Execute Token Request\n-            tokenResult = oAuth2Strategy.requestToken(tokenRequest);\n-\n-            if (tokenResult.getErrorResponse() != null) {\n-                errorCode = tokenResult.getErrorResponse().getError();\n-            }\n-\n-            if (errorCode.equals(\"authorization_pending\")) {\n-                // interval is passed through params\n-                Thread.sleep(interval);\n-            }\n-        }\n-\n-        // Assign token result\n-        acquireTokenResult.setTokenResult(tokenResult);\n-\n-        // Validate request success, may throw MsalServiceException\n-        validateServiceResult(tokenResult);\n-\n-        // If the token is valid, save it into token cache\n-        final List<ICacheRecord> records = saveTokens(\n-                oAuth2Strategy,\n-                mAuthorizationRequest,\n-                acquireTokenResult.getTokenResult().getTokenResponse(),\n-                parameters.getOAuth2TokenCache()\n-        );\n-\n-        // Once the token is stored, fetch and assign the authentication result\n-        final ICacheRecord newestRecord = records.get(0);\n-        acquireTokenResult.setLocalAuthenticationResult(\n-                new LocalAuthenticationResult(\n-                        finalizeCacheRecordForResult(\n-                                newestRecord,\n-                                parameters.getAuthenticationScheme()\n-                        ),\n-                        records,\n-                        SdkType.MSAL,\n-                        false\n-                )\n-        );\n-\n-        logResult(TAG, tokenResult);\n-\n-        // End telemetry with LOCAL_DEVICE_CODE_FLOW_POLLING\n-        Telemetry.emit(\n-                new ApiEndEvent()\n-                        .putResult(acquireTokenResult)\n-                        .putApiId(TelemetryEventStrings.Api.LOCAL_DEVICE_CODE_FLOW_POLLING)\n-        );\n-\n-        return acquireTokenResult;\n-    }\n-\n-    /**\n-     * Helper method to check if a result object is valid (was a success). If not, an exception will be generated and thrown.\n-     * This method is called in both parts of the DCF protocol.\n-     * @param result result object to be checked\n-     * @throws MsalServiceException MsalServiceException object reflecting error code returned by the result\n-     */\n-    private void validateServiceResult(@NonNull IResult result) throws MsalServiceException {\n-        // If result was unsuccessful, create an exception\n-        if (!result.getSuccess()) {\n-            // Create ServiceException object\n-            ServiceException serviceException = createServiceExceptionForDeviceCodeFlow(result.getErrorResponse());\n-\n-            // Convert ServiceException to MsalServiceException, then throw\n-            throw new MsalServiceException(\n-                    serviceException.getErrorCode(),\n-                    serviceException.getMessage(),\n-                    serviceException.getHttpStatusCode(),\n-                    serviceException\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Given an error response object, create a serviceException object using the predefined error codes.\n-     * @param response error response object to be checked\n-     * @return an exception object\n-     */\n-    private ServiceException createServiceExceptionForDeviceCodeFlow(IErrorResponse response) {\n-        // Based on error code, fetch the error message\n-        String errorCode = response.getError();\n-        String errorMessage = null;\n-\n-        // Check response code against pre-defined error codes\n-        switch (errorCode) {\n-            case ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_MESSAGE;\n-                break;\n-            case ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_CODE:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_INVALID_GRANT_MESSAGE;\n-                break;\n-            default:\n-                errorMessage = ErrorStrings.DEVICE_CODE_FLOW_DEFAULT_ERROR_MESSAGE;\n-        }\n-\n-        // Create a ServiceException object and return it\n-        return new ServiceException(\n-                errorCode,\n-                errorMessage,\n-                ServiceException.DEFAULT_STATUS_CODE,\n-                null\n-        );\n-    }\n-}\n", "next_change": null}]}}, {"oid": "b9bd9ff763ae426bda2ff76d03e0bcd2edf3ce33", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/b9bd9ff763ae426bda2ff76d03e0bcd2edf3ce33", "message": "Updated internal, some suggestion fixes", "committedDate": "2020-07-29T22:07:58Z", "type": "commit"}, {"oid": "ec58b60875ed8e3ee1bfb32d7d76f2d5e0dc5b0f", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/ec58b60875ed8e3ee1bfb32d7d76f2d5e0dc5b0f", "message": "Fix conflict in internal common", "committedDate": "2020-07-30T01:17:39Z", "type": "commit"}, {"oid": "bd94dcfb8599f62be4075a22a4c5cd01ec2df967", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/bd94dcfb8599f62be4075a22a4c5cd01ec2df967", "message": "Boolean method for authorization_pending", "committedDate": "2020-07-30T18:49:53Z", "type": "commit"}, {"oid": "07d8d0130b81edad5f81e5cd913165918e18e9fc", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/07d8d0130b81edad5f81e5cd913165918e18e9fc", "message": "removed one exception from acquireDeviceCodeFlowToken", "committedDate": "2020-07-30T18:51:14Z", "type": "commit"}, {"oid": "b9533e83c83fc43b81c52415b260940eacc70983", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/b9533e83c83fc43b81c52415b260940eacc70983", "message": "Merge branch 'dev' of https://github.com/AzureAD/microsoft-authentication-library-for-android into t-fadura/dcf-main", "committedDate": "2020-07-30T19:24:04Z", "type": "commit"}, {"oid": "7b74cf6df0979cbdc8310699c308dc29d46468b0", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/7b74cf6df0979cbdc8310699c308dc29d46468b0", "message": "Passing authorityUri for tenant without parsing", "committedDate": "2020-07-30T21:34:18Z", "type": "commit"}, {"oid": "d8e585d5780d1fc22c47b42c308c0c55a2459553", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/d8e585d5780d1fc22c47b42c308c0c55a2459553", "message": "working on test", "committedDate": "2020-07-31T16:21:12Z", "type": "commit"}, {"oid": "2d9b236bf4d92c725a0adac7f86574a526d1951d", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/2d9b236bf4d92c725a0adac7f86574a526d1951d", "message": "Migration into Common update", "committedDate": "2020-07-31T16:55:01Z", "type": "commit"}, {"oid": "55e8153e3426f096df3710411a8b3932f054c27b", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/55e8153e3426f096df3710411a8b3932f054c27b", "message": "removed LocalMsalController.java from branch (now in common)", "committedDate": "2020-07-31T16:57:34Z", "type": "commit"}, {"oid": "87888ba41b406e4b13f370d4a9fb42328cb540fe", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/87888ba41b406e4b13f370d4a9fb42328cb540fe", "message": "Fixed api-side tests", "committedDate": "2020-07-31T17:13:28Z", "type": "commit"}, {"oid": "5154a1a543fdabc8926ae55b899a7ea4c4e457f7", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/5154a1a543fdabc8926ae55b899a7ea4c4e457f7", "message": "getDeviceCode() testing", "committedDate": "2020-07-31T18:45:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0MDE2NQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r463840165", "body": "nit: \"The device_code expires.  No need to continue polling for the token\"", "bodyText": "nit: \"The device_code expires.  No need to continue polling for the token\"", "bodyHTML": "<p dir=\"auto\">nit: \"The device_code expires.  No need to continue polling for the token\"</p>", "author": "rpdome", "createdAt": "2020-07-31T21:04:07Z", "path": "msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java", "diffHunk": "@@ -46,6 +46,6 @@ public AcquireTokenResult execute() throws Exception {\n                 \"ABCDEFGH\",\n                 \"Follow these instructions to authenticate.\");\n \n-        throw new MsalServiceException(\"expired_token\", \"This exception reflects an error in the token polling step in Device Code Flow (expired token).\", null);\n+        throw new ServiceException(\"expired_token\", \"This exception reflects an error in the token polling step in Device Code Flow (expired token).\", null);", "originalCommit": "5154a1a543fdabc8926ae55b899a7ea4c4e457f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8fd81d1809ed7e2a1fce83f7d36c946018694fa6", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java b/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java\nindex 0fdccfd0..e416b26e 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java\n", "chunk": "@@ -46,6 +47,6 @@ public class ShadowDeviceCodeFlowCommandTokenError {\n                 \"ABCDEFGH\",\n                 \"Follow these instructions to authenticate.\");\n \n-        throw new ServiceException(\"expired_token\", \"This exception reflects an error in the token polling step in Device Code Flow (expired token).\", null);\n+        throw new ServiceException(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE, \"The device_code expired. No need to continue polling for the token (expired token).\", null);\n     }\n }\n", "next_change": {"commit": "e705026b5c605415cf6e5cc2a6f97cb06a26c0f1", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java b/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java\nindex e416b26e..988b9b4a 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java\n", "chunk": "@@ -47,6 +47,6 @@ public class ShadowDeviceCodeFlowCommandTokenError {\n                 \"ABCDEFGH\",\n                 \"Follow these instructions to authenticate.\");\n \n-        throw new ServiceException(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE, \"The device_code expired. No need to continue polling for the token (expired token).\", null);\n+        throw new ServiceException(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_ERROR_CODE, \"The device_code expired. No need to continue polling for the token (expired token).\", null);\n     }\n }\n", "next_change": {"commit": "e37bf595d80bbeb1b045761769c80c30ddeaa5fc", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java b/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java\nindex 988b9b4a..9fc1a652 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/shadows/ShadowDeviceCodeFlowCommandTokenError.java\n", "chunk": "@@ -42,10 +45,16 @@ public class ShadowDeviceCodeFlowCommandTokenError {\n \n     public AcquireTokenResult execute() throws Exception {\n         final DeviceCodeFlowCommandCallback callback = (DeviceCodeFlowCommandCallback) mDeviceCodeFlowCommand.getCallback();\n+\n+        // 15 minutes is the default timeout.\n+        final Date expiryDate = new Date();\n+        expiryDate.setTime(expiryDate.getTime() + TimeUnit.MINUTES.toMillis(15));\n+\n         callback.onUserCodeReceived(\n                 \"https://login.microsoftonline.com/common/oauth2/deviceauth\",\n                 \"ABCDEFGH\",\n-                \"Follow these instructions to authenticate.\");\n+                \"Follow these instructions to authenticate.\",\n+                expiryDate);\n \n         throw new ServiceException(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_ERROR_CODE, \"The device_code expired. No need to continue polling for the token (expired token).\", null);\n     }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0MDU5OA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r463840598", "body": "why removing NonNull?", "bodyText": "why removing NonNull?", "bodyHTML": "<p dir=\"auto\">why removing NonNull?</p>", "author": "rpdome", "createdAt": "2020-07-31T21:04:39Z", "path": "msal/src/main/java/com/microsoft/identity/client/IPublicClientApplication.java", "diffHunk": "@@ -189,21 +191,21 @@ void acquireToken(@NonNull final Activity activity,\n          * @param userCode user code\n          * @param message instruction message\n          */\n-        void onUserCodeReceived(@NonNull String vUri, @NonNull String userCode, @NonNull String message);\n+        void onUserCodeReceived(String vUri, String userCode, String message);", "originalCommit": "5154a1a543fdabc8926ae55b899a7ea4c4e457f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0MDc3OQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r463840779", "bodyText": "here and below", "author": "rpdome", "createdAt": "2020-07-31T21:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0MDU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NzM1Mg==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r463887352", "bodyText": "I think it was because this was inconsistent with the rest of the code, but I went ahead and added NonNull to the rest of the callback", "author": "t-fadura", "createdAt": "2020-07-31T23:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0MDU5OA=="}], "type": "inlineReview", "revised_code": {"commit": "8fd81d1809ed7e2a1fce83f7d36c946018694fa6", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/IPublicClientApplication.java b/msal/src/main/java/com/microsoft/identity/client/IPublicClientApplication.java\nindex fbcd03c2..c4900d04 100644\n--- a/msal/src/main/java/com/microsoft/identity/client/IPublicClientApplication.java\n+++ b/msal/src/main/java/com/microsoft/identity/client/IPublicClientApplication.java\n", "chunk": "@@ -191,21 +191,21 @@ public interface IPublicClientApplication {\n          * @param userCode user code\n          * @param message instruction message\n          */\n-        void onUserCodeReceived(String vUri, String userCode, String message);\n+        void onUserCodeReceived(@NonNull final String vUri, @NonNull final String userCode, @NonNull final String message);\n \n         /**\n          * Invoked once token is received and passes the {@link AuthenticationResult} object.\n          *\n          * @param authResult the authentication result\n          */\n-        void onTokenReceived(final AuthenticationResult authResult);\n+        void onTokenReceived(@NonNull final AuthenticationResult authResult);\n \n         /**\n          * Invoked if an error is encountered during the device code flow and passes the exception object.\n          *\n          * @param error error exception\n          */\n-        void onError(final MsalException error);\n+        void onError(@NonNull final MsalException error);\n     }\n \n }\n", "next_change": {"commit": "e1c6cad80e0aa4ec6cb32c8c5ee7ca52fa12f4c0", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/IPublicClientApplication.java b/msal/src/main/java/com/microsoft/identity/client/IPublicClientApplication.java\nindex c4900d04..b2a3501b 100644\n--- a/msal/src/main/java/com/microsoft/identity/client/IPublicClientApplication.java\n+++ b/msal/src/main/java/com/microsoft/identity/client/IPublicClientApplication.java\n", "chunk": "@@ -175,37 +229,43 @@ public interface IPublicClientApplication {\n      * Callback object used in Device Code Flow.\n      * This callback provides the following methods for communicating with the protocol.\n      * 1). Receiving authentication information (user_code, verification_uri, and instruction message)\n-     * via {@link DeviceCodeFlowCallback#onUserCodeReceived(String, String, String)}.\n+     * via {@link DeviceCodeFlowCallback#onUserCodeReceived(String, String, String, Date)}.\n      * 2). Receiving a successful authentication result containing a fresh access token\n-     * via {@link DeviceCodeFlowCallback#onTokenReceived(AuthenticationResult)}.\n+     * via {@link DeviceCodeFlowCallback#onTokenReceived(IAuthenticationResult)}.\n      * 3). Receiving an exception detailing what went wrong in the protocol\n      * via {@link DeviceCodeFlowCallback#onError(MsalException)}.\n-     *\n+     * <p>\n      * Refer to {@link PublicClientApplication#acquireTokenWithDeviceCode(String[], DeviceCodeFlowCallback)}.\n      */\n     interface DeviceCodeFlowCallback {\n         /**\n          * Invoked to display verification uri, user code, and instruction message during device code flow.\n          *\n-         * @param vUri verification uri\n-         * @param userCode user code\n-         * @param message instruction message\n+         * @param vUri                  verification uri\n+         * @param userCode              user code\n+         * @param message               instruction message\n+         * @param sessionExpirationDate the expiration date of DCF session to be displayed to the user ONLY.\n+         *                              When the session expires, onError() will return an exception with DEVICE_CODE_FLOW_EXPIRED_TOKEN_ERROR_CODE.\n+         *                              Please rely on that exception for non-UX purposes.\n          */\n-        void onUserCodeReceived(@NonNull final String vUri, @NonNull final String userCode, @NonNull final String message);\n+        void onUserCodeReceived(@NonNull final String vUri,\n+                                @NonNull final String userCode,\n+                                @NonNull final String message,\n+                                @NonNull final Date sessionExpirationDate);\n \n         /**\n          * Invoked once token is received and passes the {@link AuthenticationResult} object.\n          *\n          * @param authResult the authentication result\n          */\n-        void onTokenReceived(@NonNull final AuthenticationResult authResult);\n+        void onTokenReceived(@NonNull final IAuthenticationResult authResult);\n \n         /**\n          * Invoked if an error is encountered during the device code flow and passes the exception object.\n          *\n-         * @param error error exception\n+         * @param exception error exception\n          */\n-        void onError(@NonNull final MsalException error);\n+        void onError(@NonNull final MsalException exception);\n     }\n \n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0MTQ0Mg==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r463841442", "body": "what is this testing? why are we expecting IOException?", "bodyText": "what is this testing? why are we expecting IOException?", "bodyHTML": "<p dir=\"auto\">what is this testing? why are we expecting IOException?</p>", "author": "rpdome", "createdAt": "2020-07-31T21:05:51Z", "path": "msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/GetDeviceCodeTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) Microsoft Corporation.\n+// All rights reserved.\n+//\n+// This code is licensed under the MIT License.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files(the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions :\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+package com.microsoft.identity.client.e2e.tests.mocked;\n+\n+import com.microsoft.identity.client.PublicClientApplicationConfiguration;\n+import com.microsoft.identity.client.e2e.shadows.ShadowMsalUtils;\n+import com.microsoft.identity.client.e2e.tests.PublicClientApplicationAbstractTest;\n+import com.microsoft.identity.common.internal.authorities.AzureActiveDirectoryAuthority;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Configuration;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationErrorResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n+import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.identity.internal.testutils.TestConstants.Configurations.SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(shadows = {ShadowMsalUtils.class})\n+public class GetDeviceCodeTest extends PublicClientApplicationAbstractTest {\n+\n+    private MicrosoftStsAuthorizationRequest.Builder builder;\n+    private String urlBody;\n+    private OAuth2Strategy strategy;\n+\n+    @Before\n+    public void setup() {\n+        super.setup();\n+\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+        urlBody = ((AzureActiveDirectoryAuthority) config.getAuthorities().get(0)).getAudience().getCloudUrl();\n+        builder = new MicrosoftStsAuthorizationRequest.Builder();\n+        builder.setClientId(config.getClientId())\n+                .setScope(\"user.read\")\n+                .setState(\"State!\");\n+\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        strategy = new AzureActiveDirectoryOAuth2Strategy(\n+                new AzureActiveDirectoryOAuth2Configuration(),\n+                options\n+        );\n+    }\n+\n+    @Override\n+    public String getConfigFilePath() {\n+        return SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeSuccessResult() {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = builder.build();\n+        final AuthorizationResult authorizationResult = runGetDeviceCodeThread(authorizationRequest, urlBody);\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        Assert.assertTrue(authorizationResult.getSuccess());\n+        Assert.assertNotNull(authorizationResponse);\n+\n+        Assert.assertNotNull(authorizationResponse.getDeviceCode());\n+        Assert.assertNotNull(authorizationResponse.getUserCode());\n+        Assert.assertNotNull(authorizationResponse.getMessage());\n+        Assert.assertNotNull(authorizationResponse.getInterval());\n+        Assert.assertNotNull(authorizationResponse.getExpiresIn());\n+        Assert.assertNotNull(authorizationResponse.getVerificationUri());\n+\n+        Assert.assertNull(authorizationResult.getAuthorizationErrorResponse());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoClientId() {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = builder.setClientId(null).build();\n+        final AuthorizationResult authorizationResult = runGetDeviceCodeThread(authorizationRequest, urlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(\"invalid_request\", authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoScope() {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = builder.setScope(null).build();\n+        final AuthorizationResult authorizationResult = runGetDeviceCodeThread(authorizationRequest, urlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(\"invalid_request\", authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureBadScope() {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = builder.setScope(\"/\").build();\n+        final AuthorizationResult authorizationResult = runGetDeviceCodeThread(authorizationRequest, urlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(\"invalid_scope\", authorizationErrorResponse.getError());\n+    }\n+\n+    /**\n+     * Helper function to run getDeviceCode(). Catches exception\n+     * @param authorizationRequest request to send to getDeviceCode()\n+     * @param urlBody url to send to getDeviceCode()\n+     * @return authorizationResult from getDeviceCode()\n+     */\n+    private AuthorizationResult runGetDeviceCodeThread(final MicrosoftStsAuthorizationRequest authorizationRequest, final String urlBody) {", "originalCommit": "5154a1a543fdabc8926ae55b899a7ea4c4e457f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4NTk5OQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r463885999", "bodyText": "This should be removed. I was originally running getDeviceCode in a separate thread each time but I realized that wasn't necessary when testing. This was a helper function that set up the thread and everything, it's not actually a test method. The try catch just made it fail if an exception was thrown.", "author": "t-fadura", "createdAt": "2020-07-31T23:30:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0MTQ0Mg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0MzgxOQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r463843819", "body": "Where are we using ShadowDeviceCodeFlowCommandTokenError?\r\n\r\nAlso can we have test cases for each expected error from the token endpoint?\r\n authorization_declined, bad_verification_code, expired_token", "bodyText": "Where are we using ShadowDeviceCodeFlowCommandTokenError?\nAlso can we have test cases for each expected error from the token endpoint?\nauthorization_declined, bad_verification_code, expired_token", "bodyHTML": "<p dir=\"auto\">Where are we using ShadowDeviceCodeFlowCommandTokenError?</p>\n<p dir=\"auto\">Also can we have test cases for each expected error from the token endpoint?<br>\nauthorization_declined, bad_verification_code, expired_token</p>", "author": "rpdome", "createdAt": "2020-07-31T21:09:14Z", "path": "msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/GetDeviceCodeTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) Microsoft Corporation.\n+// All rights reserved.\n+//\n+// This code is licensed under the MIT License.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files(the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions :\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+package com.microsoft.identity.client.e2e.tests.mocked;\n+\n+import com.microsoft.identity.client.PublicClientApplicationConfiguration;\n+import com.microsoft.identity.client.e2e.shadows.ShadowMsalUtils;\n+import com.microsoft.identity.client.e2e.tests.PublicClientApplicationAbstractTest;\n+import com.microsoft.identity.common.internal.authorities.AzureActiveDirectoryAuthority;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Configuration;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationErrorResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n+import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+import java.io.IOException;\n+\n+import static com.microsoft.identity.internal.testutils.TestConstants.Configurations.SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+\n+@RunWith(RobolectricTestRunner.class)\n+@Config(shadows = {ShadowMsalUtils.class})\n+public class GetDeviceCodeTest extends PublicClientApplicationAbstractTest {\n+\n+    private MicrosoftStsAuthorizationRequest.Builder builder;\n+    private String urlBody;\n+    private OAuth2Strategy strategy;\n+\n+    @Before\n+    public void setup() {\n+        super.setup();\n+\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+        urlBody = ((AzureActiveDirectoryAuthority) config.getAuthorities().get(0)).getAudience().getCloudUrl();\n+        builder = new MicrosoftStsAuthorizationRequest.Builder();\n+        builder.setClientId(config.getClientId())\n+                .setScope(\"user.read\")\n+                .setState(\"State!\");\n+\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        strategy = new AzureActiveDirectoryOAuth2Strategy(\n+                new AzureActiveDirectoryOAuth2Configuration(),\n+                options\n+        );\n+    }\n+\n+    @Override\n+    public String getConfigFilePath() {\n+        return SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeSuccessResult() {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = builder.build();\n+        final AuthorizationResult authorizationResult = runGetDeviceCodeThread(authorizationRequest, urlBody);\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        Assert.assertTrue(authorizationResult.getSuccess());\n+        Assert.assertNotNull(authorizationResponse);\n+\n+        Assert.assertNotNull(authorizationResponse.getDeviceCode());\n+        Assert.assertNotNull(authorizationResponse.getUserCode());\n+        Assert.assertNotNull(authorizationResponse.getMessage());\n+        Assert.assertNotNull(authorizationResponse.getInterval());\n+        Assert.assertNotNull(authorizationResponse.getExpiresIn());\n+        Assert.assertNotNull(authorizationResponse.getVerificationUri());\n+\n+        Assert.assertNull(authorizationResult.getAuthorizationErrorResponse());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoClientId() {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = builder.setClientId(null).build();\n+        final AuthorizationResult authorizationResult = runGetDeviceCodeThread(authorizationRequest, urlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(\"invalid_request\", authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoScope() {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = builder.setScope(null).build();\n+        final AuthorizationResult authorizationResult = runGetDeviceCodeThread(authorizationRequest, urlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(\"invalid_request\", authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureBadScope() {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = builder.setScope(\"/\").build();\n+        final AuthorizationResult authorizationResult = runGetDeviceCodeThread(authorizationRequest, urlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(\"invalid_scope\", authorizationErrorResponse.getError());\n+    }\n+\n+    /**\n+     * Helper function to run getDeviceCode(). Catches exception\n+     * @param authorizationRequest request to send to getDeviceCode()\n+     * @param urlBody url to send to getDeviceCode()", "originalCommit": "5154a1a543fdabc8926ae55b899a7ea4c4e457f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4Njk3Mg==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r463886972", "bodyText": "ShadowDeviceCodeFlowCommandTokenError is used in DeviceCodeFlowAPITest. I was thinking of moving my getDeviceCode tests into that file and then adding the token tests into there as well.", "author": "t-fadura", "createdAt": "2020-07-31T23:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg0MzgxOQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "8fd81d1809ed7e2a1fce83f7d36c946018694fa6", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/8fd81d1809ed7e2a1fce83f7d36c946018694fa6", "message": "All testing for DCF in one file, DeviceCodeFlowApiTest.java", "committedDate": "2020-08-01T04:43:07Z", "type": "commit"}, {"oid": "e2fbaf322e7e7e813b0bcfd38fed73ab23dbda2c", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/e2fbaf322e7e7e813b0bcfd38fed73ab23dbda2c", "message": "update internal", "committedDate": "2020-08-04T15:57:44Z", "type": "commit"}, {"oid": "9edceae36e8b147447f66f78e14543d1a77c4532", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/9edceae36e8b147447f66f78e14543d1a77c4532", "message": "fix conflict", "committedDate": "2020-08-04T16:01:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxMDgzMw==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r465410833", "body": "Should these be removed?", "bodyText": "Should these be removed?", "bodyHTML": "<p dir=\"auto\">Should these be removed?</p>", "author": "shahzaibj", "createdAt": "2020-08-05T00:58:00Z", "path": "msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation.\n+// All rights reserved.\n+//\n+// This code is licensed under the MIT License.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files(the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions :\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+package com.microsoft.identity.client.e2e.tests.mocked;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.microsoft.identity.client.AuthenticationResult;\n+import com.microsoft.identity.client.IPublicClientApplication;\n+import com.microsoft.identity.client.PublicClientApplicationConfiguration;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandAuthError;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandSuccessful;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandTokenError;\n+import com.microsoft.identity.client.e2e.shadows.ShadowHttpRequestForMockedTest;\n+import com.microsoft.identity.client.e2e.shadows.ShadowMsalUtils;\n+import com.microsoft.identity.client.e2e.tests.PublicClientApplicationAbstractTest;\n+import com.microsoft.identity.client.e2e.utils.RoboTestUtils;\n+import com.microsoft.identity.client.exception.MsalException;\n+import com.microsoft.identity.common.exception.ClientException;\n+import com.microsoft.identity.common.exception.ErrorStrings;\n+import com.microsoft.identity.common.internal.authorities.AzureActiveDirectoryAuthority;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Configuration;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationErrorResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsOAuth2Configuration;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsOAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n+import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n+import com.microsoft.identity.common.internal.providers.oauth2.TokenRequest;\n+import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.UUID;\n+\n+import static com.microsoft.identity.internal.testutils.TestConstants.Configurations.SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+\n+/**\n+ * Testing class for the device code flow protocol. Currently only supporting testing for the API-side\n+ * of the protocol. Will be extended to test individual aspects of the flow.\n+ */\n+@RunWith(RobolectricTestRunner.class)\n+@Config(shadows = {ShadowMsalUtils.class})\n+public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n+\n+    private MicrosoftStsAuthorizationRequest.Builder mBuilder;\n+    private String mUrlBody;\n+    private OAuth2Strategy mStrategy;\n+    private MicrosoftStsTokenRequest mTokenRequest;\n+    private boolean mUserCodeReceived;\n+\n+    @Before\n+    public void setup() {\n+        super.setup();\n+\n+        // getDeviceCode() testing variables\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+        mUrlBody = ((AzureActiveDirectoryAuthority) config.getAuthorities().get(0)).getAudience().getCloudUrl();\n+        mBuilder = new MicrosoftStsAuthorizationRequest.Builder();\n+        mBuilder.setClientId(config.getClientId())\n+                .setScope(\"user.read\")\n+                .setState(\"State!\");\n+\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        mStrategy = new AzureActiveDirectoryOAuth2Strategy(\n+                new AzureActiveDirectoryOAuth2Configuration(),\n+                options\n+        );\n+\n+        // token request testing variable\n+        mTokenRequest = new MicrosoftStsTokenRequest();\n+        mTokenRequest.setCodeVerifier(\"\");\n+        mTokenRequest.setCorrelationId(UUID.fromString(\"a-b-c-d-e\"));\n+        mTokenRequest.setClientId(config.getClientId());\n+        mTokenRequest.setGrantType(TokenRequest.GrantTypes.DEVICE_CODE);\n+        mTokenRequest.setRedirectUri(config.getRedirectUri());\n+    }\n+\n+    @Override\n+    public String getConfigFilePath() {\n+        return SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+    }\n+\n+    //===========================================================================================================\n+    // getDeviceCode() Testing\n+    //===========================================================================================================\n+    @Test\n+    public void testGetDeviceCodeSuccessResult() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        Assert.assertTrue(authorizationResult.getSuccess());\n+        Assert.assertNotNull(authorizationResponse);\n+\n+        Assert.assertNotNull(authorizationResponse.getDeviceCode());\n+        Assert.assertNotNull(authorizationResponse.getUserCode());\n+        Assert.assertNotNull(authorizationResponse.getMessage());\n+        Assert.assertNotNull(authorizationResponse.getInterval());\n+        Assert.assertNotNull(authorizationResponse.getExpiresIn());\n+        Assert.assertNotNull(authorizationResponse.getVerificationUri());\n+\n+        Assert.assertNull(authorizationResult.getAuthorizationErrorResponse());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoClientId() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setClientId(null).build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_REQUEST, authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoScope() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setScope(null).build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_REQUEST, authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureBadScope() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setScope(\"/\").build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_SCOPE, authorizationErrorResponse.getError());\n+    }\n+\n+    //===========================================================================================================\n+    // Token Request Testing\n+    //===========================================================================================================x\n+    @Test\n+    public void testDeviceCodeFlowTokenInvalidRequest() throws IOException, ClientException {\n+        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n+        config.setAuthorityUrl(new URL(mUrlBody));\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n+\n+        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n+        Assert.assertNull(tokenResult.getTokenResponse());\n+        Assert.assertNotNull(tokenResult.getErrorResponse());\n+        Assert.assertEquals(ErrorStrings.INVALID_REQUEST, tokenResult.getErrorResponse().getError());\n+    }\n+\n+    @Test\n+    public void testDeviceCodeFlowTokenExpiredToken() throws IOException, ClientException {\n+        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n+        config.setAuthorityUrl(new URL(mUrlBody));\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n+\n+        // Previously authenticated code\n+        mTokenRequest.setDeviceCode(\n+                \"AAQABAAEAAAAm-06blBE1TpVMil8KPQ41e5vDLI7te0y-3XHYO_uurPryAiyBiPiKnjEVzAQZQzCyGZERne4a\" +\n+                        \"IwYAiBlQ8an93ENYuVOO-vEAt48FEJSEMQqq-zHZVD59bkc6eYIAViZKVvTv5_qilKj4uEjVE9BGkIxY5B6Uq1K8oWHEqzH-w6CiWjC8vQc6mSV_FPCbnAggAA\");\n+\n+        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n+        Assert.assertNull(tokenResult.getTokenResponse());\n+        Assert.assertNotNull(tokenResult.getErrorResponse());\n+        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE, tokenResult.getErrorResponse().getError());\n+    }\n+\n+    // A device code that has not yet been registered leads to invalid_grant, not bad_verification_code\n+//    @Test\n+//    public void testDeviceCodeFlowTokenBadVerificationCode() throws IOException, ClientException {\n+//        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n+//        config.setAuthorityUrl(new URL(mUrlBody));\n+//        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+//        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n+//        mTokenRequest.setDeviceCode(\n+//                \"AAQABAAEAAAAm-06blBE1TpVMil8KPQ41e5vDLI7te0y-3XHYO_uurPryAiyBiPiKnjEVzAQZQzCyGZERne4a\" +\n+//                        \"IwYAiBlQ8an93ENYuVOO-vEAt48FEJSEMQqq-zHZVD59bkc6eYIAViZKVvTv5_qilKj4uEjVE9BGkIxY5B6Uq1K8oWHEqzH-w6CiWjC8vQc6mSV_FPCbnAggBA\");\n+//\n+//        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n+//        Assert.assertNull(tokenResult.getTokenResponse());\n+//        Assert.assertNotNull(tokenResult.getErrorResponse());\n+//        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_BAD_VERIFICATION_CODE, tokenResult.getErrorResponse().getError());\n+//    }\n+\n+    // authorization_declined is triggered in the actual auth side\n+//    @Test\n+//    public void testDeviceCodeFlowTokenAuthorizationDeclined() throws IOException, ClientException {\n+//        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n+//        config.setAuthorityUrl(new URL(mUrlBody));\n+//        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+//        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n+//\n+//        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n+//        Assert.assertNull(tokenResult.getTokenResponse());\n+//        Assert.assertNotNull(tokenResult.getErrorResponse());\n+//        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE, tokenResult.getErrorResponse().getError());\n+//    }", "originalCommit": "9edceae36e8b147447f66f78e14543d1a77c4532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxMzAyOA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r465413028", "bodyText": "I think so, I wanted to let people take a look at them before I removed them, but I don't think they serve much purpose as is.", "author": "t-fadura", "createdAt": "2020-08-05T01:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxMDgzMw=="}], "type": "inlineReview", "revised_code": {"commit": "e705026b5c605415cf6e5cc2a6f97cb06a26c0f1", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 735c4186..1452a633 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -195,47 +212,35 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n         final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n         final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n \n+        final MicrosoftStsTokenRequest tokenRequest = createMockTokenRequest();\n+\n         // Previously authenticated code\n-        mTokenRequest.setDeviceCode(\n+        tokenRequest.setDeviceCode(\n                 \"AAQABAAEAAAAm-06blBE1TpVMil8KPQ41e5vDLI7te0y-3XHYO_uurPryAiyBiPiKnjEVzAQZQzCyGZERne4a\" +\n                         \"IwYAiBlQ8an93ENYuVOO-vEAt48FEJSEMQqq-zHZVD59bkc6eYIAViZKVvTv5_qilKj4uEjVE9BGkIxY5B6Uq1K8oWHEqzH-w6CiWjC8vQc6mSV_FPCbnAggAA\");\n \n-        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n+        final TokenResult tokenResult = strategy.requestToken(tokenRequest);\n         Assert.assertNull(tokenResult.getTokenResponse());\n         Assert.assertNotNull(tokenResult.getErrorResponse());\n-        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE, tokenResult.getErrorResponse().getError());\n+        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_ERROR_CODE, tokenResult.getErrorResponse().getError());\n     }\n \n-    // A device code that has not yet been registered leads to invalid_grant, not bad_verification_code\n-//    @Test\n-//    public void testDeviceCodeFlowTokenBadVerificationCode() throws IOException, ClientException {\n-//        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n-//        config.setAuthorityUrl(new URL(mUrlBody));\n-//        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n-//        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n-//        mTokenRequest.setDeviceCode(\n-//                \"AAQABAAEAAAAm-06blBE1TpVMil8KPQ41e5vDLI7te0y-3XHYO_uurPryAiyBiPiKnjEVzAQZQzCyGZERne4a\" +\n-//                        \"IwYAiBlQ8an93ENYuVOO-vEAt48FEJSEMQqq-zHZVD59bkc6eYIAViZKVvTv5_qilKj4uEjVE9BGkIxY5B6Uq1K8oWHEqzH-w6CiWjC8vQc6mSV_FPCbnAggBA\");\n-//\n-//        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n-//        Assert.assertNull(tokenResult.getTokenResponse());\n-//        Assert.assertNotNull(tokenResult.getErrorResponse());\n-//        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_BAD_VERIFICATION_CODE, tokenResult.getErrorResponse().getError());\n-//    }\n-\n-    // authorization_declined is triggered in the actual auth side\n-//    @Test\n-//    public void testDeviceCodeFlowTokenAuthorizationDeclined() throws IOException, ClientException {\n-//        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n-//        config.setAuthorityUrl(new URL(mUrlBody));\n-//        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n-//        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n-//\n-//        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n-//        Assert.assertNull(tokenResult.getTokenResponse());\n-//        Assert.assertNotNull(tokenResult.getErrorResponse());\n-//        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE, tokenResult.getErrorResponse().getError());\n-//    }\n+    /**\n+     * Helper function to create a mock token request.\n+     * @return a token request.\n+     */\n+    private MicrosoftStsTokenRequest createMockTokenRequest() {\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+\n+        final MicrosoftStsTokenRequest tokenRequest = new MicrosoftStsTokenRequest();\n+        tokenRequest.setCodeVerifier(\"\");\n+        tokenRequest.setCorrelationId(UUID.fromString(\"a-b-c-d-e\"));\n+        tokenRequest.setClientId(config.getClientId());\n+        tokenRequest.setGrantType(TokenRequest.GrantTypes.DEVICE_CODE);\n+        tokenRequest.setRedirectUri(config.getRedirectUri());\n+\n+        return tokenRequest;\n+    }\n \n     //===========================================================================================================\n     // API-Side Testing\n", "next_change": {"commit": "167da9ed8561c783162e4b48fba5a9e6211bead3", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 1452a633..c83076ae 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -234,10 +218,12 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n \n         final MicrosoftStsTokenRequest tokenRequest = new MicrosoftStsTokenRequest();\n         tokenRequest.setCodeVerifier(\"\");\n-        tokenRequest.setCorrelationId(UUID.fromString(\"a-b-c-d-e\"));\n+        tokenRequest.setCorrelationId(UUID.randomUUID());\n         tokenRequest.setClientId(config.getClientId());\n         tokenRequest.setGrantType(TokenRequest.GrantTypes.DEVICE_CODE);\n         tokenRequest.setRedirectUri(config.getRedirectUri());\n+        tokenRequest.setClientAppName(\"TestApp\");\n+        tokenRequest.setClientAppVersion(\"1.0\");\n \n         return tokenRequest;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxNDAyMA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r465414020", "body": "nit: Let's not use a class variable. Can we create a function that returns a new (mock) token request instead.", "bodyText": "nit: Let's not use a class variable. Can we create a function that returns a new (mock) token request instead.", "bodyHTML": "<p dir=\"auto\">nit: Let's not use a class variable. Can we create a function that returns a new (mock) token request instead.</p>", "author": "rpdome", "createdAt": "2020-08-05T01:09:59Z", "path": "msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation.\n+// All rights reserved.\n+//\n+// This code is licensed under the MIT License.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files(the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions :\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+package com.microsoft.identity.client.e2e.tests.mocked;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.microsoft.identity.client.AuthenticationResult;\n+import com.microsoft.identity.client.IPublicClientApplication;\n+import com.microsoft.identity.client.PublicClientApplicationConfiguration;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandAuthError;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandSuccessful;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandTokenError;\n+import com.microsoft.identity.client.e2e.shadows.ShadowHttpRequestForMockedTest;\n+import com.microsoft.identity.client.e2e.shadows.ShadowMsalUtils;\n+import com.microsoft.identity.client.e2e.tests.PublicClientApplicationAbstractTest;\n+import com.microsoft.identity.client.e2e.utils.RoboTestUtils;\n+import com.microsoft.identity.client.exception.MsalException;\n+import com.microsoft.identity.common.exception.ClientException;\n+import com.microsoft.identity.common.exception.ErrorStrings;\n+import com.microsoft.identity.common.internal.authorities.AzureActiveDirectoryAuthority;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Configuration;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationErrorResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsOAuth2Configuration;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsOAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n+import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n+import com.microsoft.identity.common.internal.providers.oauth2.TokenRequest;\n+import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.UUID;\n+\n+import static com.microsoft.identity.internal.testutils.TestConstants.Configurations.SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+\n+/**\n+ * Testing class for the device code flow protocol. Currently only supporting testing for the API-side\n+ * of the protocol. Will be extended to test individual aspects of the flow.\n+ */\n+@RunWith(RobolectricTestRunner.class)\n+@Config(shadows = {ShadowMsalUtils.class})\n+public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n+\n+    private MicrosoftStsAuthorizationRequest.Builder mBuilder;\n+    private String mUrlBody;\n+    private OAuth2Strategy mStrategy;\n+    private MicrosoftStsTokenRequest mTokenRequest;\n+    private boolean mUserCodeReceived;\n+\n+    @Before\n+    public void setup() {\n+        super.setup();\n+\n+        // getDeviceCode() testing variables\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+        mUrlBody = ((AzureActiveDirectoryAuthority) config.getAuthorities().get(0)).getAudience().getCloudUrl();\n+        mBuilder = new MicrosoftStsAuthorizationRequest.Builder();\n+        mBuilder.setClientId(config.getClientId())\n+                .setScope(\"user.read\")\n+                .setState(\"State!\");\n+\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        mStrategy = new AzureActiveDirectoryOAuth2Strategy(\n+                new AzureActiveDirectoryOAuth2Configuration(),\n+                options\n+        );\n+\n+        // token request testing variable\n+        mTokenRequest = new MicrosoftStsTokenRequest();\n+        mTokenRequest.setCodeVerifier(\"\");\n+        mTokenRequest.setCorrelationId(UUID.fromString(\"a-b-c-d-e\"));\n+        mTokenRequest.setClientId(config.getClientId());\n+        mTokenRequest.setGrantType(TokenRequest.GrantTypes.DEVICE_CODE);\n+        mTokenRequest.setRedirectUri(config.getRedirectUri());\n+    }\n+\n+    @Override\n+    public String getConfigFilePath() {\n+        return SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+    }\n+\n+    //===========================================================================================================\n+    // getDeviceCode() Testing\n+    //===========================================================================================================\n+    @Test\n+    public void testGetDeviceCodeSuccessResult() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        Assert.assertTrue(authorizationResult.getSuccess());\n+        Assert.assertNotNull(authorizationResponse);\n+\n+        Assert.assertNotNull(authorizationResponse.getDeviceCode());\n+        Assert.assertNotNull(authorizationResponse.getUserCode());\n+        Assert.assertNotNull(authorizationResponse.getMessage());\n+        Assert.assertNotNull(authorizationResponse.getInterval());\n+        Assert.assertNotNull(authorizationResponse.getExpiresIn());\n+        Assert.assertNotNull(authorizationResponse.getVerificationUri());\n+\n+        Assert.assertNull(authorizationResult.getAuthorizationErrorResponse());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoClientId() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setClientId(null).build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_REQUEST, authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoScope() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setScope(null).build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_REQUEST, authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureBadScope() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setScope(\"/\").build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_SCOPE, authorizationErrorResponse.getError());\n+    }\n+\n+    //===========================================================================================================\n+    // Token Request Testing\n+    //===========================================================================================================x\n+    @Test\n+    public void testDeviceCodeFlowTokenInvalidRequest() throws IOException, ClientException {\n+        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n+        config.setAuthorityUrl(new URL(mUrlBody));\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n+\n+        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);", "originalCommit": "9edceae36e8b147447f66f78e14543d1a77c4532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNDU5MA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r465424590", "bodyText": "Will do, cleaned out most of the setup methods and got rid of most class variables.", "author": "t-fadura", "createdAt": "2020-08-05T01:49:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxNDAyMA=="}], "type": "inlineReview", "revised_code": {"commit": "e705026b5c605415cf6e5cc2a6f97cb06a26c0f1", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 735c4186..1452a633 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -182,7 +197,9 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n         final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n         final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n \n-        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n+        final MicrosoftStsTokenRequest tokenRequest = createMockTokenRequest();\n+\n+        final TokenResult tokenResult = strategy.requestToken(tokenRequest);\n         Assert.assertNull(tokenResult.getTokenResponse());\n         Assert.assertNotNull(tokenResult.getErrorResponse());\n         Assert.assertEquals(ErrorStrings.INVALID_REQUEST, tokenResult.getErrorResponse().getError());\n", "next_change": {"commit": "80b1e9f89635b5550246874c5663bf01f7dfa735", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 1452a633..2a1eb370 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -192,10 +178,9 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n     //===========================================================================================================x\n     @Test\n     public void testDeviceCodeFlowTokenInvalidRequest() throws IOException, ClientException {\n-        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n-        config.setAuthorityUrl(new URL(mUrlBody));\n-        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n-        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+        final OAuth2Strategy strategy = config.getDefaultAuthority().createOAuth2Strategy(strategyParameters);\n \n         final MicrosoftStsTokenRequest tokenRequest = createMockTokenRequest();\n \n", "next_change": {"commit": "95477e19bf33e395ecd18e0aa8dd83044bbee57f", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 2a1eb370..68d24410 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -180,7 +183,9 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n     public void testDeviceCodeFlowTokenInvalidRequest() throws IOException, ClientException {\n         final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n         final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n-        final OAuth2Strategy strategy = config.getDefaultAuthority().createOAuth2Strategy(strategyParameters);\n+        final Authority defaultAuthority = config.getDefaultAuthority();\n+        Assert.assertNotNull(\"Default authority should not be null\", defaultAuthority);\n+        final OAuth2Strategy strategy = defaultAuthority.createOAuth2Strategy(strategyParameters);\n \n         final MicrosoftStsTokenRequest tokenRequest = createMockTokenRequest();\n \n", "next_change": {"commit": "f9725fcc3bed8f70636c9c482ae0a1994d5f94bc", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 68d24410..01932b3a 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -181,7 +180,7 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n     //===========================================================================================================x\n     @Test\n     public void testDeviceCodeFlowTokenInvalidRequest() throws IOException, ClientException {\n-        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        final OAuth2StrategyParameters strategyParameters = OAuth2StrategyParameters.builder().build();\n         final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n         final Authority defaultAuthority = config.getDefaultAuthority();\n         Assert.assertNotNull(\"Default authority should not be null\", defaultAuthority);\n", "next_change": null}]}}]}}, {"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 1452a633..2a1eb370 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -207,10 +192,9 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n \n     @Test\n     public void testDeviceCodeFlowTokenExpiredToken() throws IOException, ClientException {\n-        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n-        config.setAuthorityUrl(new URL(mUrlBody));\n-        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n-        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n+        final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+        final OAuth2Strategy strategy = config.getDefaultAuthority().createOAuth2Strategy(strategyParameters);\n \n         final MicrosoftStsTokenRequest tokenRequest = createMockTokenRequest();\n \n", "next_change": {"commit": "95477e19bf33e395ecd18e0aa8dd83044bbee57f", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 2a1eb370..68d24410 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -194,7 +199,10 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n     public void testDeviceCodeFlowTokenExpiredToken() throws IOException, ClientException {\n         final OAuth2StrategyParameters strategyParameters = new OAuth2StrategyParameters();\n         final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n-        final OAuth2Strategy strategy = config.getDefaultAuthority().createOAuth2Strategy(strategyParameters);\n+        final Authority defaultAuthority = config.getDefaultAuthority();\n+        Assert.assertNotNull(\"Default authority should not be null\", defaultAuthority);\n+        final OAuth2Strategy strategy = defaultAuthority.createOAuth2Strategy(strategyParameters);\n+        Assert.assertNotNull(\"Strategy should not be null\", strategy);\n \n         final MicrosoftStsTokenRequest tokenRequest = createMockTokenRequest();\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxNDI2NA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r465414264", "body": "given that it's the same mTokenRequest object with the test case above, why won't I hit ErrorStrings.INVALID_REQUEST here?", "bodyText": "given that it's the same mTokenRequest object with the test case above, why won't I hit ErrorStrings.INVALID_REQUEST here?", "bodyHTML": "<p dir=\"auto\">given that it's the same mTokenRequest object with the test case above, why won't I hit ErrorStrings.INVALID_REQUEST here?</p>", "author": "rpdome", "createdAt": "2020-08-05T01:10:55Z", "path": "msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation.\n+// All rights reserved.\n+//\n+// This code is licensed under the MIT License.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files(the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions :\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+package com.microsoft.identity.client.e2e.tests.mocked;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.microsoft.identity.client.AuthenticationResult;\n+import com.microsoft.identity.client.IPublicClientApplication;\n+import com.microsoft.identity.client.PublicClientApplicationConfiguration;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandAuthError;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandSuccessful;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandTokenError;\n+import com.microsoft.identity.client.e2e.shadows.ShadowHttpRequestForMockedTest;\n+import com.microsoft.identity.client.e2e.shadows.ShadowMsalUtils;\n+import com.microsoft.identity.client.e2e.tests.PublicClientApplicationAbstractTest;\n+import com.microsoft.identity.client.e2e.utils.RoboTestUtils;\n+import com.microsoft.identity.client.exception.MsalException;\n+import com.microsoft.identity.common.exception.ClientException;\n+import com.microsoft.identity.common.exception.ErrorStrings;\n+import com.microsoft.identity.common.internal.authorities.AzureActiveDirectoryAuthority;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Configuration;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationErrorResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsOAuth2Configuration;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsOAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n+import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n+import com.microsoft.identity.common.internal.providers.oauth2.TokenRequest;\n+import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.UUID;\n+\n+import static com.microsoft.identity.internal.testutils.TestConstants.Configurations.SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+\n+/**\n+ * Testing class for the device code flow protocol. Currently only supporting testing for the API-side\n+ * of the protocol. Will be extended to test individual aspects of the flow.\n+ */\n+@RunWith(RobolectricTestRunner.class)\n+@Config(shadows = {ShadowMsalUtils.class})\n+public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n+\n+    private MicrosoftStsAuthorizationRequest.Builder mBuilder;\n+    private String mUrlBody;\n+    private OAuth2Strategy mStrategy;\n+    private MicrosoftStsTokenRequest mTokenRequest;\n+    private boolean mUserCodeReceived;\n+\n+    @Before\n+    public void setup() {\n+        super.setup();\n+\n+        // getDeviceCode() testing variables\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+        mUrlBody = ((AzureActiveDirectoryAuthority) config.getAuthorities().get(0)).getAudience().getCloudUrl();\n+        mBuilder = new MicrosoftStsAuthorizationRequest.Builder();\n+        mBuilder.setClientId(config.getClientId())\n+                .setScope(\"user.read\")\n+                .setState(\"State!\");\n+\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        mStrategy = new AzureActiveDirectoryOAuth2Strategy(\n+                new AzureActiveDirectoryOAuth2Configuration(),\n+                options\n+        );\n+\n+        // token request testing variable\n+        mTokenRequest = new MicrosoftStsTokenRequest();\n+        mTokenRequest.setCodeVerifier(\"\");\n+        mTokenRequest.setCorrelationId(UUID.fromString(\"a-b-c-d-e\"));\n+        mTokenRequest.setClientId(config.getClientId());\n+        mTokenRequest.setGrantType(TokenRequest.GrantTypes.DEVICE_CODE);\n+        mTokenRequest.setRedirectUri(config.getRedirectUri());\n+    }\n+\n+    @Override\n+    public String getConfigFilePath() {\n+        return SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+    }\n+\n+    //===========================================================================================================\n+    // getDeviceCode() Testing\n+    //===========================================================================================================\n+    @Test\n+    public void testGetDeviceCodeSuccessResult() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        Assert.assertTrue(authorizationResult.getSuccess());\n+        Assert.assertNotNull(authorizationResponse);\n+\n+        Assert.assertNotNull(authorizationResponse.getDeviceCode());\n+        Assert.assertNotNull(authorizationResponse.getUserCode());\n+        Assert.assertNotNull(authorizationResponse.getMessage());\n+        Assert.assertNotNull(authorizationResponse.getInterval());\n+        Assert.assertNotNull(authorizationResponse.getExpiresIn());\n+        Assert.assertNotNull(authorizationResponse.getVerificationUri());\n+\n+        Assert.assertNull(authorizationResult.getAuthorizationErrorResponse());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoClientId() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setClientId(null).build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_REQUEST, authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoScope() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setScope(null).build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_REQUEST, authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureBadScope() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setScope(\"/\").build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_SCOPE, authorizationErrorResponse.getError());\n+    }\n+\n+    //===========================================================================================================\n+    // Token Request Testing\n+    //===========================================================================================================x\n+    @Test\n+    public void testDeviceCodeFlowTokenInvalidRequest() throws IOException, ClientException {\n+        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n+        config.setAuthorityUrl(new URL(mUrlBody));\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n+\n+        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n+        Assert.assertNull(tokenResult.getTokenResponse());\n+        Assert.assertNotNull(tokenResult.getErrorResponse());\n+        Assert.assertEquals(ErrorStrings.INVALID_REQUEST, tokenResult.getErrorResponse().getError());\n+    }\n+\n+    @Test\n+    public void testDeviceCodeFlowTokenExpiredToken() throws IOException, ClientException {\n+        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n+        config.setAuthorityUrl(new URL(mUrlBody));\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n+\n+        // Previously authenticated code\n+        mTokenRequest.setDeviceCode(", "originalCommit": "9edceae36e8b147447f66f78e14543d1a77c4532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNTQ0NA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r465425444", "bodyText": "INVALID_REQUEST was triggered in the test case above this one because the device code was not included. This one has a device code that I already authenticated on so it returns expired token.", "author": "t-fadura", "createdAt": "2020-08-05T01:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxNDI2NA=="}], "type": "inlineReview", "revised_code": {"commit": "e705026b5c605415cf6e5cc2a6f97cb06a26c0f1", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 735c4186..1452a633 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -195,47 +212,35 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n         final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n         final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n \n+        final MicrosoftStsTokenRequest tokenRequest = createMockTokenRequest();\n+\n         // Previously authenticated code\n-        mTokenRequest.setDeviceCode(\n+        tokenRequest.setDeviceCode(\n                 \"AAQABAAEAAAAm-06blBE1TpVMil8KPQ41e5vDLI7te0y-3XHYO_uurPryAiyBiPiKnjEVzAQZQzCyGZERne4a\" +\n                         \"IwYAiBlQ8an93ENYuVOO-vEAt48FEJSEMQqq-zHZVD59bkc6eYIAViZKVvTv5_qilKj4uEjVE9BGkIxY5B6Uq1K8oWHEqzH-w6CiWjC8vQc6mSV_FPCbnAggAA\");\n \n-        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n+        final TokenResult tokenResult = strategy.requestToken(tokenRequest);\n         Assert.assertNull(tokenResult.getTokenResponse());\n         Assert.assertNotNull(tokenResult.getErrorResponse());\n-        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE, tokenResult.getErrorResponse().getError());\n+        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_ERROR_CODE, tokenResult.getErrorResponse().getError());\n     }\n \n-    // A device code that has not yet been registered leads to invalid_grant, not bad_verification_code\n-//    @Test\n-//    public void testDeviceCodeFlowTokenBadVerificationCode() throws IOException, ClientException {\n-//        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n-//        config.setAuthorityUrl(new URL(mUrlBody));\n-//        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n-//        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n-//        mTokenRequest.setDeviceCode(\n-//                \"AAQABAAEAAAAm-06blBE1TpVMil8KPQ41e5vDLI7te0y-3XHYO_uurPryAiyBiPiKnjEVzAQZQzCyGZERne4a\" +\n-//                        \"IwYAiBlQ8an93ENYuVOO-vEAt48FEJSEMQqq-zHZVD59bkc6eYIAViZKVvTv5_qilKj4uEjVE9BGkIxY5B6Uq1K8oWHEqzH-w6CiWjC8vQc6mSV_FPCbnAggBA\");\n-//\n-//        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n-//        Assert.assertNull(tokenResult.getTokenResponse());\n-//        Assert.assertNotNull(tokenResult.getErrorResponse());\n-//        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_BAD_VERIFICATION_CODE, tokenResult.getErrorResponse().getError());\n-//    }\n-\n-    // authorization_declined is triggered in the actual auth side\n-//    @Test\n-//    public void testDeviceCodeFlowTokenAuthorizationDeclined() throws IOException, ClientException {\n-//        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n-//        config.setAuthorityUrl(new URL(mUrlBody));\n-//        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n-//        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n-//\n-//        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n-//        Assert.assertNull(tokenResult.getTokenResponse());\n-//        Assert.assertNotNull(tokenResult.getErrorResponse());\n-//        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE, tokenResult.getErrorResponse().getError());\n-//    }\n+    /**\n+     * Helper function to create a mock token request.\n+     * @return a token request.\n+     */\n+    private MicrosoftStsTokenRequest createMockTokenRequest() {\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+\n+        final MicrosoftStsTokenRequest tokenRequest = new MicrosoftStsTokenRequest();\n+        tokenRequest.setCodeVerifier(\"\");\n+        tokenRequest.setCorrelationId(UUID.fromString(\"a-b-c-d-e\"));\n+        tokenRequest.setClientId(config.getClientId());\n+        tokenRequest.setGrantType(TokenRequest.GrantTypes.DEVICE_CODE);\n+        tokenRequest.setRedirectUri(config.getRedirectUri());\n+\n+        return tokenRequest;\n+    }\n \n     //===========================================================================================================\n     // API-Side Testing\n", "next_change": {"commit": "167da9ed8561c783162e4b48fba5a9e6211bead3", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 1452a633..c83076ae 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -234,10 +218,12 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n \n         final MicrosoftStsTokenRequest tokenRequest = new MicrosoftStsTokenRequest();\n         tokenRequest.setCodeVerifier(\"\");\n-        tokenRequest.setCorrelationId(UUID.fromString(\"a-b-c-d-e\"));\n+        tokenRequest.setCorrelationId(UUID.randomUUID());\n         tokenRequest.setClientId(config.getClientId());\n         tokenRequest.setGrantType(TokenRequest.GrantTypes.DEVICE_CODE);\n         tokenRequest.setRedirectUri(config.getRedirectUri());\n+        tokenRequest.setClientAppName(\"TestApp\");\n+        tokenRequest.setClientAppVersion(\"1.0\");\n \n         return tokenRequest;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxNDQ1Mw==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r465414453", "body": "Why commented out?", "bodyText": "Why commented out?", "bodyHTML": "<p dir=\"auto\">Why commented out?</p>", "author": "rpdome", "createdAt": "2020-08-05T01:11:36Z", "path": "msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation.\n+// All rights reserved.\n+//\n+// This code is licensed under the MIT License.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files(the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions :\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+package com.microsoft.identity.client.e2e.tests.mocked;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.microsoft.identity.client.AuthenticationResult;\n+import com.microsoft.identity.client.IPublicClientApplication;\n+import com.microsoft.identity.client.PublicClientApplicationConfiguration;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandAuthError;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandSuccessful;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandTokenError;\n+import com.microsoft.identity.client.e2e.shadows.ShadowHttpRequestForMockedTest;\n+import com.microsoft.identity.client.e2e.shadows.ShadowMsalUtils;\n+import com.microsoft.identity.client.e2e.tests.PublicClientApplicationAbstractTest;\n+import com.microsoft.identity.client.e2e.utils.RoboTestUtils;\n+import com.microsoft.identity.client.exception.MsalException;\n+import com.microsoft.identity.common.exception.ClientException;\n+import com.microsoft.identity.common.exception.ErrorStrings;\n+import com.microsoft.identity.common.internal.authorities.AzureActiveDirectoryAuthority;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Configuration;\n+import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectoryOAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationErrorResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsOAuth2Configuration;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsOAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n+import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n+import com.microsoft.identity.common.internal.providers.oauth2.TokenRequest;\n+import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.UUID;\n+\n+import static com.microsoft.identity.internal.testutils.TestConstants.Configurations.SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+\n+/**\n+ * Testing class for the device code flow protocol. Currently only supporting testing for the API-side\n+ * of the protocol. Will be extended to test individual aspects of the flow.\n+ */\n+@RunWith(RobolectricTestRunner.class)\n+@Config(shadows = {ShadowMsalUtils.class})\n+public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n+\n+    private MicrosoftStsAuthorizationRequest.Builder mBuilder;\n+    private String mUrlBody;\n+    private OAuth2Strategy mStrategy;\n+    private MicrosoftStsTokenRequest mTokenRequest;\n+    private boolean mUserCodeReceived;\n+\n+    @Before\n+    public void setup() {\n+        super.setup();\n+\n+        // getDeviceCode() testing variables\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+        mUrlBody = ((AzureActiveDirectoryAuthority) config.getAuthorities().get(0)).getAudience().getCloudUrl();\n+        mBuilder = new MicrosoftStsAuthorizationRequest.Builder();\n+        mBuilder.setClientId(config.getClientId())\n+                .setScope(\"user.read\")\n+                .setState(\"State!\");\n+\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        mStrategy = new AzureActiveDirectoryOAuth2Strategy(\n+                new AzureActiveDirectoryOAuth2Configuration(),\n+                options\n+        );\n+\n+        // token request testing variable\n+        mTokenRequest = new MicrosoftStsTokenRequest();\n+        mTokenRequest.setCodeVerifier(\"\");\n+        mTokenRequest.setCorrelationId(UUID.fromString(\"a-b-c-d-e\"));\n+        mTokenRequest.setClientId(config.getClientId());\n+        mTokenRequest.setGrantType(TokenRequest.GrantTypes.DEVICE_CODE);\n+        mTokenRequest.setRedirectUri(config.getRedirectUri());\n+    }\n+\n+    @Override\n+    public String getConfigFilePath() {\n+        return SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+    }\n+\n+    //===========================================================================================================\n+    // getDeviceCode() Testing\n+    //===========================================================================================================\n+    @Test\n+    public void testGetDeviceCodeSuccessResult() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationResponse authorizationResponse = (MicrosoftStsAuthorizationResponse) authorizationResult.getAuthorizationResponse();\n+\n+        Assert.assertTrue(authorizationResult.getSuccess());\n+        Assert.assertNotNull(authorizationResponse);\n+\n+        Assert.assertNotNull(authorizationResponse.getDeviceCode());\n+        Assert.assertNotNull(authorizationResponse.getUserCode());\n+        Assert.assertNotNull(authorizationResponse.getMessage());\n+        Assert.assertNotNull(authorizationResponse.getInterval());\n+        Assert.assertNotNull(authorizationResponse.getExpiresIn());\n+        Assert.assertNotNull(authorizationResponse.getVerificationUri());\n+\n+        Assert.assertNull(authorizationResult.getAuthorizationErrorResponse());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoClientId() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setClientId(null).build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_REQUEST, authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureNoScope() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setScope(null).build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_REQUEST, authorizationErrorResponse.getError());\n+    }\n+\n+    @Test\n+    public void testGetDeviceCodeFailureBadScope() throws IOException {\n+        final MicrosoftStsAuthorizationRequest authorizationRequest = mBuilder.setScope(\"/\").build();\n+        final AuthorizationResult authorizationResult = mStrategy.getDeviceCode(authorizationRequest, mUrlBody);\n+        final MicrosoftStsAuthorizationErrorResponse authorizationErrorResponse = (MicrosoftStsAuthorizationErrorResponse) authorizationResult.getAuthorizationErrorResponse();\n+\n+        Assert.assertFalse(authorizationResult.getSuccess());\n+        Assert.assertNull(authorizationResult.getAuthorizationResponse());\n+\n+        Assert.assertNotNull(authorizationErrorResponse);\n+        Assert.assertEquals(ErrorStrings.INVALID_SCOPE, authorizationErrorResponse.getError());\n+    }\n+\n+    //===========================================================================================================\n+    // Token Request Testing\n+    //===========================================================================================================x\n+    @Test\n+    public void testDeviceCodeFlowTokenInvalidRequest() throws IOException, ClientException {\n+        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n+        config.setAuthorityUrl(new URL(mUrlBody));\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n+\n+        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n+        Assert.assertNull(tokenResult.getTokenResponse());\n+        Assert.assertNotNull(tokenResult.getErrorResponse());\n+        Assert.assertEquals(ErrorStrings.INVALID_REQUEST, tokenResult.getErrorResponse().getError());\n+    }\n+\n+    @Test\n+    public void testDeviceCodeFlowTokenExpiredToken() throws IOException, ClientException {\n+        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n+        config.setAuthorityUrl(new URL(mUrlBody));\n+        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n+        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n+\n+        // Previously authenticated code\n+        mTokenRequest.setDeviceCode(\n+                \"AAQABAAEAAAAm-06blBE1TpVMil8KPQ41e5vDLI7te0y-3XHYO_uurPryAiyBiPiKnjEVzAQZQzCyGZERne4a\" +\n+                        \"IwYAiBlQ8an93ENYuVOO-vEAt48FEJSEMQqq-zHZVD59bkc6eYIAViZKVvTv5_qilKj4uEjVE9BGkIxY5B6Uq1K8oWHEqzH-w6CiWjC8vQc6mSV_FPCbnAggAA\");\n+\n+        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n+        Assert.assertNull(tokenResult.getTokenResponse());\n+        Assert.assertNotNull(tokenResult.getErrorResponse());\n+        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE, tokenResult.getErrorResponse().getError());\n+    }\n+\n+    // A device code that has not yet been registered leads to invalid_grant, not bad_verification_code", "originalCommit": "9edceae36e8b147447f66f78e14543d1a77c4532", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMDc4OQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r465420789", "bodyText": "Removed these", "author": "t-fadura", "createdAt": "2020-08-05T01:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxNDQ1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e705026b5c605415cf6e5cc2a6f97cb06a26c0f1", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 735c4186..1452a633 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -195,47 +212,35 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n         final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n         final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n \n+        final MicrosoftStsTokenRequest tokenRequest = createMockTokenRequest();\n+\n         // Previously authenticated code\n-        mTokenRequest.setDeviceCode(\n+        tokenRequest.setDeviceCode(\n                 \"AAQABAAEAAAAm-06blBE1TpVMil8KPQ41e5vDLI7te0y-3XHYO_uurPryAiyBiPiKnjEVzAQZQzCyGZERne4a\" +\n                         \"IwYAiBlQ8an93ENYuVOO-vEAt48FEJSEMQqq-zHZVD59bkc6eYIAViZKVvTv5_qilKj4uEjVE9BGkIxY5B6Uq1K8oWHEqzH-w6CiWjC8vQc6mSV_FPCbnAggAA\");\n \n-        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n+        final TokenResult tokenResult = strategy.requestToken(tokenRequest);\n         Assert.assertNull(tokenResult.getTokenResponse());\n         Assert.assertNotNull(tokenResult.getErrorResponse());\n-        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_CODE, tokenResult.getErrorResponse().getError());\n+        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_EXPIRED_TOKEN_ERROR_CODE, tokenResult.getErrorResponse().getError());\n     }\n \n-    // A device code that has not yet been registered leads to invalid_grant, not bad_verification_code\n-//    @Test\n-//    public void testDeviceCodeFlowTokenBadVerificationCode() throws IOException, ClientException {\n-//        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n-//        config.setAuthorityUrl(new URL(mUrlBody));\n-//        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n-//        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n-//        mTokenRequest.setDeviceCode(\n-//                \"AAQABAAEAAAAm-06blBE1TpVMil8KPQ41e5vDLI7te0y-3XHYO_uurPryAiyBiPiKnjEVzAQZQzCyGZERne4a\" +\n-//                        \"IwYAiBlQ8an93ENYuVOO-vEAt48FEJSEMQqq-zHZVD59bkc6eYIAViZKVvTv5_qilKj4uEjVE9BGkIxY5B6Uq1K8oWHEqzH-w6CiWjC8vQc6mSV_FPCbnAggBA\");\n-//\n-//        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n-//        Assert.assertNull(tokenResult.getTokenResponse());\n-//        Assert.assertNotNull(tokenResult.getErrorResponse());\n-//        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_BAD_VERIFICATION_CODE, tokenResult.getErrorResponse().getError());\n-//    }\n-\n-    // authorization_declined is triggered in the actual auth side\n-//    @Test\n-//    public void testDeviceCodeFlowTokenAuthorizationDeclined() throws IOException, ClientException {\n-//        final MicrosoftStsOAuth2Configuration config = new MicrosoftStsOAuth2Configuration();\n-//        config.setAuthorityUrl(new URL(mUrlBody));\n-//        final OAuth2StrategyParameters options = new OAuth2StrategyParameters();\n-//        final OAuth2Strategy strategy = new MicrosoftStsOAuth2Strategy(config, options);\n-//\n-//        final TokenResult tokenResult = strategy.requestToken(mTokenRequest);\n-//        Assert.assertNull(tokenResult.getTokenResponse());\n-//        Assert.assertNotNull(tokenResult.getErrorResponse());\n-//        Assert.assertEquals(ErrorStrings.DEVICE_CODE_FLOW_AUTHORIZATION_DECLINED_CODE, tokenResult.getErrorResponse().getError());\n-//    }\n+    /**\n+     * Helper function to create a mock token request.\n+     * @return a token request.\n+     */\n+    private MicrosoftStsTokenRequest createMockTokenRequest() {\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+\n+        final MicrosoftStsTokenRequest tokenRequest = new MicrosoftStsTokenRequest();\n+        tokenRequest.setCodeVerifier(\"\");\n+        tokenRequest.setCorrelationId(UUID.fromString(\"a-b-c-d-e\"));\n+        tokenRequest.setClientId(config.getClientId());\n+        tokenRequest.setGrantType(TokenRequest.GrantTypes.DEVICE_CODE);\n+        tokenRequest.setRedirectUri(config.getRedirectUri());\n+\n+        return tokenRequest;\n+    }\n \n     //===========================================================================================================\n     // API-Side Testing\n", "next_change": {"commit": "167da9ed8561c783162e4b48fba5a9e6211bead3", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex 1452a633..c83076ae 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -234,10 +218,12 @@ public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n \n         final MicrosoftStsTokenRequest tokenRequest = new MicrosoftStsTokenRequest();\n         tokenRequest.setCodeVerifier(\"\");\n-        tokenRequest.setCorrelationId(UUID.fromString(\"a-b-c-d-e\"));\n+        tokenRequest.setCorrelationId(UUID.randomUUID());\n         tokenRequest.setClientId(config.getClientId());\n         tokenRequest.setGrantType(TokenRequest.GrantTypes.DEVICE_CODE);\n         tokenRequest.setRedirectUri(config.getRedirectUri());\n+        tokenRequest.setClientAppName(\"TestApp\");\n+        tokenRequest.setClientAppVersion(\"1.0\");\n \n         return tokenRequest;\n     }\n", "next_change": null}]}}]}}, {"oid": "e705026b5c605415cf6e5cc2a6f97cb06a26c0f1", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/e705026b5c605415cf6e5cc2a6f97cb06a26c0f1", "message": "less class variables in testing", "committedDate": "2020-08-05T01:53:00Z", "type": "commit"}, {"oid": "11935e901123d08c11b2ca54a3d4675215ccb052", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/11935e901123d08c11b2ca54a3d4675215ccb052", "message": "updated internal lib", "committedDate": "2020-08-05T02:15:41Z", "type": "commit"}, {"oid": "83d94b3b9b23dacdbd8d35a0914be2dbfd901bcd", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/83d94b3b9b23dacdbd8d35a0914be2dbfd901bcd", "message": "fixed authority issue, testing fixes", "committedDate": "2020-08-05T21:07:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzNzEzNQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466037135", "body": "Why can't we just use default authority?", "bodyText": "Why can't we just use default authority?", "bodyHTML": "<p dir=\"auto\">Why can't we just use default authority?</p>", "author": "shahzaibj", "createdAt": "2020-08-05T22:22:50Z", "path": "msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java", "diffHunk": "@@ -201,6 +201,10 @@ public static DeviceCodeFlowCommandParameters createDeviceCodeFlowCommandParamet\n             @NonNull String[] scopes){\n \n         // TODO: Consider implementing support for PoP\n+\n+        final String uri = ((AzureActiveDirectoryAuthority) configuration.getAuthorities().get(0)).getAudience().getCloudUrl();\n+        final Authority authority = Authority.getAuthorityFromAuthorityUrl(uri);\n+", "originalCommit": "83d94b3b9b23dacdbd8d35a0914be2dbfd901bcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0MDk0Mg==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466040942", "bodyText": "Default authority has \"common\" as tenantID", "author": "t-fadura", "createdAt": "2020-08-05T22:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzNzEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MDYwNA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466060604", "bodyText": "Default authority would be whatever was declared default in the config....or if there is only one declared then it would be that one authority. It would have common if the dev put common in the config, otherwise it won't. If it does have common, why is that a problem?", "author": "shahzaibj", "createdAt": "2020-08-05T23:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzNzEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Mzk4OA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466063988", "bodyText": "This is my config:\n\nCommon as the tenantID is what's causing /common to be added to the end of the authority url later down the line. This issue doesn't occur in acquireToken() because the command parameters for that also use a custom authority.", "author": "t-fadura", "createdAt": "2020-08-05T23:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzNzEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2NDQ2MQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466064461", "bodyText": "refer to getAuthorityUri() in AzureActiveDirectoryAuthroity, this is where the tenant is appended to the end of the authority.", "author": "t-fadura", "createdAt": "2020-08-05T23:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzNzEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2NDkyMw==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466064923", "bodyText": "Okay, I'm not completely clear on this. Let's sync up offline.", "author": "shahzaibj", "createdAt": "2020-08-05T23:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzNzEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3ODc2NQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466078765", "bodyText": "Synced offline with @t-fadura. There's a bug in MSAL and has been for quite some time and that's what's causing this issue. Created GitHub issue here: #1121", "author": "shahzaibj", "createdAt": "2020-08-06T00:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzNzEzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "80b1e9f89635b5550246874c5663bf01f7dfa735", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java b/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java\nindex fc2b2bec..926f7e33 100644\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java\n+++ b/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java\n", "chunk": "@@ -202,8 +202,7 @@ public class CommandParametersAdapter {\n \n         // TODO: Consider implementing support for PoP\n \n-        final String uri = ((AzureActiveDirectoryAuthority) configuration.getAuthorities().get(0)).getAudience().getCloudUrl();\n-        final Authority authority = Authority.getAuthorityFromAuthorityUrl(uri);\n+        final Authority authority = configuration.getDefaultAuthority();\n \n         final AbstractAuthenticationScheme authenticationScheme = new BearerAuthenticationSchemeInternal();\n \n", "next_change": {"commit": "9d2d431eea3bfdc3927c7dfc5b66566fe061a62e", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java b/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java\nindex 926f7e33..51fcfe94 100644\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java\n+++ b/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java\n", "chunk": "@@ -198,7 +199,7 @@ public class CommandParametersAdapter {\n     public static DeviceCodeFlowCommandParameters createDeviceCodeFlowCommandParameters(\n             @NonNull final PublicClientApplicationConfiguration configuration,\n             @NonNull final OAuth2TokenCache tokenCache,\n-            @NonNull String[] scopes){\n+            @NonNull String[] scopes) {\n \n         // TODO: Consider implementing support for PoP\n \n", "next_change": {"commit": "832a46a6df354b5579a4dab06fad17c7c3325ec9", "changed_code": [{"header": "diff --git a/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java b/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java\nindex 51fcfe94..01e46595 100644\n--- a/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java\n+++ b/msal/src/main/java/com/microsoft/identity/client/internal/CommandParametersAdapter.java\n", "chunk": "@@ -208,7 +213,7 @@ public class CommandParametersAdapter {\n         final AbstractAuthenticationScheme authenticationScheme = new BearerAuthenticationSchemeInternal();\n \n         final DeviceCodeFlowCommandParameters commandParameters = DeviceCodeFlowCommandParameters.builder()\n-                .androidApplicationContext(configuration.getAppContext())\n+                .platformComponents(AndroidPlatformComponents.createFromContext(configuration.getAppContext()))\n                 .applicationName(configuration.getAppContext().getPackageName())\n                 .applicationVersion(getPackageVersion(configuration.getAppContext()))\n                 .clientId(configuration.getClientId())\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzODA2MQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466038061", "body": "Why not `config.getDefaultAuthority().getAuthorityUrl().toString()`?", "bodyText": "Why not config.getDefaultAuthority().getAuthorityUrl().toString()?", "bodyHTML": "<p dir=\"auto\">Why not <code>config.getDefaultAuthority().getAuthorityUrl().toString()</code>?</p>", "author": "shahzaibj", "createdAt": "2020-08-05T22:25:24Z", "path": "msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation.\n+// All rights reserved.\n+//\n+// This code is licensed under the MIT License.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files(the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions :\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+package com.microsoft.identity.client.e2e.tests.mocked;\n+\n+import androidx.annotation.NonNull;\n+\n+import com.microsoft.identity.client.AuthenticationResult;\n+import com.microsoft.identity.client.IPublicClientApplication;\n+import com.microsoft.identity.client.PublicClientApplicationConfiguration;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandAuthError;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandSuccessful;\n+import com.microsoft.identity.client.e2e.shadows.ShadowDeviceCodeFlowCommandTokenError;\n+import com.microsoft.identity.client.e2e.shadows.ShadowMsalUtils;\n+import com.microsoft.identity.client.e2e.tests.PublicClientApplicationAbstractTest;\n+import com.microsoft.identity.client.e2e.utils.RoboTestUtils;\n+import com.microsoft.identity.client.exception.MsalException;\n+import com.microsoft.identity.common.exception.ClientException;\n+import com.microsoft.identity.common.exception.ErrorStrings;\n+import com.microsoft.identity.common.internal.authorities.Authority;\n+import com.microsoft.identity.common.internal.authorities.AzureActiveDirectoryAuthority;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationErrorResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationRequest;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsAuthorizationResponse;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsOAuth2Configuration;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsOAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.microsoft.microsoftsts.MicrosoftStsTokenRequest;\n+import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2Strategy;\n+import com.microsoft.identity.common.internal.providers.oauth2.OAuth2StrategyParameters;\n+import com.microsoft.identity.common.internal.providers.oauth2.TokenRequest;\n+import com.microsoft.identity.common.internal.providers.oauth2.TokenResult;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.annotation.Config;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.UUID;\n+\n+import static com.microsoft.identity.internal.testutils.TestConstants.Configurations.SINGLE_ACCOUNT_DCF_TEST_CONFIG_FILE_PATH;\n+\n+/**\n+ * Testing class for the device code flow protocol. Currently only supporting testing for the API-side\n+ * of the protocol. Will be extended to test individual aspects of the flow.\n+ */\n+@RunWith(RobolectricTestRunner.class)\n+@Config(shadows = {ShadowMsalUtils.class})\n+public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n+\n+    private String mUrlBody;\n+    private boolean mUserCodeReceived;\n+\n+    @Before\n+    public void setup() {\n+        super.setup();\n+\n+        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n+        mUrlBody = ((AzureActiveDirectoryAuthority) config.getAuthorities().get(0)).getAudience().getCloudUrl();", "originalCommit": "83d94b3b9b23dacdbd8d35a0914be2dbfd901bcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0MjM3NA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466042374", "bodyText": ".getAuthorityUrl() is not defined here, checked it in my code\nAlso tried type casting to AzureActiveDirectoryAuthority", "author": "t-fadura", "createdAt": "2020-08-05T22:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzODA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA0MjY1Nw==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466042657", "bodyText": "sorry, it was .getAuthorityURL, which returns a url with /common at the end", "author": "t-fadura", "createdAt": "2020-08-05T22:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzODA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MDkxMg==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466060912", "bodyText": "It probably returns /common at the end because you probably have common in your config. Even if it does, I'm not clear on why that is a problem and why we can't use that?", "author": "shahzaibj", "createdAt": "2020-08-05T23:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzODA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MzkwMA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466063900", "bodyText": "So that's essentially a developer error right? (They need to make sure they declare the correct authority in the config). In this case, it looks @t-fadura did declare the correct authority. I see his config authority is of the form cloud/tenantId. So getDefaultAuthority() should be returning that right?", "author": "shahzaibj", "createdAt": "2020-08-05T23:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzODA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2Nzk4MQ==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466067981", "bodyText": "My bad. I removed my original comment because I thought I was talking about a different thing.\nWhat Fadi was seeing is that somehow his authority has /common appended after tenant id, which is really weird. I'm not familiar with this layer, but most likely there's a bug here.", "author": "rpdome", "createdAt": "2020-08-05T23:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzODA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3NzU1Mg==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466077552", "bodyText": "Yup, sycned offline with @t-fadura, there's a bug here in MSAL and has been like this forever.", "author": "shahzaibj", "createdAt": "2020-08-06T00:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzODA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3ODc5NA==", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/pull/1112#discussion_r466078794", "bodyText": "Created GitHub issue: #1121", "author": "shahzaibj", "createdAt": "2020-08-06T00:36:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzODA2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "80b1e9f89635b5550246874c5663bf01f7dfa735", "changed_code": [{"header": "diff --git a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\nindex e00e7dc1..2a1eb370 100644\n--- a/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n+++ b/msal/src/test/java/com/microsoft/identity/client/e2e/tests/mocked/DeviceCodeFlowApiTest.java\n", "chunk": "@@ -71,15 +66,11 @@ import static com.microsoft.identity.internal.testutils.TestConstants.Configurat\n @Config(shadows = {ShadowMsalUtils.class})\n public class DeviceCodeFlowApiTest extends PublicClientApplicationAbstractTest {\n \n-    private String mUrlBody;\n     private boolean mUserCodeReceived;\n \n     @Before\n     public void setup() {\n         super.setup();\n-\n-        final PublicClientApplicationConfiguration config = mApplication.getConfiguration();\n-        mUrlBody = ((AzureActiveDirectoryAuthority) config.getAuthorities().get(0)).getAudience().getCloudUrl();\n     }\n \n     @Override\n", "next_change": null}]}}, {"oid": "80b1e9f89635b5550246874c5663bf01f7dfa735", "url": "https://github.com/AzureAD/microsoft-authentication-library-for-android/commit/80b1e9f89635b5550246874c5663bf01f7dfa735", "message": "Changed config file to fix default authority", "committedDate": "2020-08-06T01:01:14Z", "type": "commit"}]}