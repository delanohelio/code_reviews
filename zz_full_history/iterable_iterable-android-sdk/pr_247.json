{"pr_number": 247, "pr_title": "[MOB-1776] add way to specify mobile auth token", "pr_author": "davidtruong", "pr_createdAt": "2020-07-10T14:42:59Z", "pr_url": "https://github.com/Iterable/iterable-android-sdk/pull/247", "timeline": [{"oid": "0dfd9d9f62922d4622b5f4e7879c96ad38680480", "url": "https://github.com/Iterable/iterable-android-sdk/commit/0dfd9d9f62922d4622b5f4e7879c96ad38680480", "message": "initial pass of adding mobile auth tokens to the android sdk", "committedDate": "2020-07-10T14:21:59Z", "type": "commit"}, {"oid": "709c17bc9a7b8b44bea1287cae65e7fa08fa5a06", "url": "https://github.com/Iterable/iterable-android-sdk/commit/709c17bc9a7b8b44bea1287cae65e7fa08fa5a06", "message": "updates authToken format", "committedDate": "2020-07-10T14:36:27Z", "type": "commit"}, {"oid": "1cf615e501a9d0b8fcf1dbe83ceacbb6841315b7", "url": "https://github.com/Iterable/iterable-android-sdk/commit/1cf615e501a9d0b8fcf1dbe83ceacbb6841315b7", "message": "updates the auth token when the email is changes.", "committedDate": "2020-07-10T14:36:51Z", "type": "commit"}, {"oid": "9a09829320913d83603ab74ef23a1d99137d4b7f", "url": "https://github.com/Iterable/iterable-android-sdk/commit/9a09829320913d83603ab74ef23a1d99137d4b7f", "message": "Adds additional function w/ params for authToken and no callbacks.", "committedDate": "2020-07-10T14:39:23Z", "type": "commit"}, {"oid": "7935107e18976c2534bb51d003cec2bb49cc7fc6", "url": "https://github.com/Iterable/iterable-android-sdk/commit/7935107e18976c2534bb51d003cec2bb49cc7fc6", "message": "set token directly", "committedDate": "2020-07-10T18:45:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyOTQ0NQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r453129445", "body": "For now we just made the test pass by adding null. Actual test for authToken is missing.\r\nIf not in this ticket, we can have a seperate ticket for adding tests to this method.", "bodyText": "For now we just made the test pass by adding null. Actual test for authToken is missing.\nIf not in this ticket, we can have a seperate ticket for adding tests to this method.", "bodyHTML": "<p dir=\"auto\">For now we just made the test pass by adding null. Actual test for authToken is missing.<br>\nIf not in this ticket, we can have a seperate ticket for adding tests to this method.</p>", "author": "Ayyanchira", "createdAt": "2020-07-11T00:19:11Z", "path": "iterableapi/src/androidTest/java/com/iterable/iterableapi/IterableApiResponseTest.java", "diffHunk": "@@ -220,7 +220,7 @@ public void testConnectionError() throws Exception {\n         MockResponse response = new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY);\n         server.enqueue(response);\n \n-        IterableApiRequest request = new IterableApiRequest(\"fake_key\", \"\", new JSONObject(), IterableApiRequest.POST, null, new IterableHelper.FailureHandler() {\n+        IterableApiRequest request = new IterableApiRequest(\"fake_key\", \"\", new JSONObject(), IterableApiRequest.POST, null, null, new IterableHelper.FailureHandler() {", "originalCommit": "7935107e18976c2534bb51d003cec2bb49cc7fc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0NTE0NA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r453945144", "bodyText": "Ticket created", "author": "roninopf", "createdAt": "2020-07-13T21:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyOTQ0NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyOTQ2OA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r453129468", "body": "authToken instead of token", "bodyText": "authToken instead of token", "bodyHTML": "<p dir=\"auto\">authToken instead of token</p>", "author": "Ayyanchira", "createdAt": "2020-07-11T00:19:22Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -275,6 +276,18 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n+    /**\n+     * Set user email used for API calls\n+     * Calling this or `setUserId:` is required before making any API calls.\n+     *\n+     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n+     * @param email User email\n+     * @param authToken Authorization token\n+     */\n+    public void setEmail(@Nullable String email, @Nullable String token) {", "originalCommit": "7935107e18976c2534bb51d003cec2bb49cc7fc6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb02c1699670800de502e3eccdde6149be7ea840", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 8f7f2c6..e4eaa29 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -276,18 +275,6 @@ private static final String TAG = \"IterableApi\";\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or `setUserId:` is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    public void setEmail(@Nullable String email, @Nullable String token) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "80f6681d90bbfb69fa7fd61f2a263e253ded3651", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e4eaa29..d8d9704 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -275,6 +276,18 @@ private static final String TAG = \"IterableApi\";\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n+    /**\n+     * Set user email used for API calls\n+     * Calling this or `setUserId:` is required before making any API calls.\n+     *\n+     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n+     * @param email User email\n+     * @param authToken Authorization token\n+     */\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "571a96cf8ec5b7a05892c8d83e13cefcad33173e", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex d8d9704..1dec5fc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -276,18 +275,6 @@ private static final String TAG = \"IterableApi\";\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or `setUserId:` is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "4f4ae81abffbffbd7da2eee168789a821a67ba0e", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 1dec5fc..d24fd3d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -275,6 +276,18 @@ private static final String TAG = \"IterableApi\";\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n+    /**\n+     * Set user email used for API calls\n+     * Calling this or `setUserId:` is required before making any API calls.\n+     *\n+     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n+     * @param email User email\n+     * @param authToken Authorization token\n+     */\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "d372a48bcfc75aea7420f4dee6a3c89fd2f2f7d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex d24fd3d..d2d9e5f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -276,18 +275,6 @@ private static final String TAG = \"IterableApi\";\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or `setUserId:` is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "a1d8fc647f2eeb604c110973a30a64162ef229c9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex d2d9e5f..ac402db 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -269,12 +270,24 @@ private static final String TAG = \"IterableApi\";\n \n     /**\n      * Set user email used for API calls\n-     * Calling this or `setUserId:` is required before making any API calls.\n+     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n      *\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n+    /**\n+     * Set user email used for API calls\n+     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n+     *\n+     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n+     * @param email User email\n+     * @param authToken Authorization token\n+     */\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "fd1cbaabb910bc602d2622da043f336507f7711d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ac402db..bc6a7d0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -288,20 +288,20 @@ private static final String TAG = \"IterableApi\";\n      * @param authToken Authorization token\n      */\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            return;\n-        }\n+        if (_email != null && !_email.equals(email)) {\n+            onLogOut();\n \n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n+            _email = email;\n+            _userId = null;\n+            _authToken = authToken;\n+\n+            storeAuthData();\n \n-        onLogOut();\n-        _email = email;\n-        _userId = null;\n-        _authToken = authToken;\n-        storeAuthData();\n-        onLogIn();\n+            onLogIn();\n+        } else if (email != null && (_authToken == null || _authToken != authToken)) {\n+            _authToken = authToken;\n+            storeAuthData();\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "3648b4944ab08b771426e18caef749dbb5064454", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex bc6a7d0..5eb97af 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -298,7 +298,7 @@ private static final String TAG = \"IterableApi\";\n             storeAuthData();\n \n             onLogIn();\n-        } else if (email != null && (_authToken == null || _authToken != authToken)) {\n+        } else if (email != null && email.equals(_email) && (_authToken == null || _authToken != authToken)) {\n             _authToken = authToken;\n             storeAuthData();\n         }\n", "next_change": {"commit": "efea88220596dbd60c1dcd7126ca14b2f5a88e12", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 5eb97af..a3e360a 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -288,19 +288,28 @@ private static final String TAG = \"IterableApi\";\n      * @param authToken Authorization token\n      */\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && !_email.equals(email)) {\n+        if (email == null) {\n             onLogOut();\n \n-            _email = email;\n+            _email = null;\n             _userId = null;\n+            _authToken = null;\n+\n+            storeAuthData();\n+        } else if (_email.equals(email) && _authToken != authToken) {\n             _authToken = authToken;\n \n             storeAuthData();\n+        } else if (!_email.equals(email)) {\n+            onLogOut();\n \n-            onLogIn();\n-        } else if (email != null && email.equals(_email) && (_authToken == null || _authToken != authToken)) {\n+            _email = email;\n+            _userId = null;\n             _authToken = authToken;\n+\n             storeAuthData();\n+\n+            onLogIn();\n         }\n     }\n \n", "next_change": {"commit": "39a61a76f8d10594b69460757f9559a7962de741", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a3e360a..39570f6 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -288,29 +288,20 @@ private static final String TAG = \"IterableApi\";\n      * @param authToken Authorization token\n      */\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (email == null) {\n-            onLogOut();\n-\n-            _email = null;\n-            _userId = null;\n-            _authToken = null;\n-\n-            storeAuthData();\n-        } else if (_email.equals(email) && _authToken != authToken) {\n-            _authToken = authToken;\n-\n-            storeAuthData();\n-        } else if (!_email.equals(email)) {\n-            onLogOut();\n-\n-            _email = email;\n-            _userId = null;\n-            _authToken = authToken;\n-\n-            storeAuthData();\n+        if (_email != null && _email.equals(email)) {\n+            return;\n+        }\n \n-            onLogIn();\n+        if (_email == null && _userId == null && email == null) {\n+            return;\n         }\n+\n+        onLogOut();\n+        _email = email;\n+        _userId = null;\n+        _authToken = authToken;\n+        storeAuthData();\n+        onLogIn();\n     }\n \n     /**\n", "next_change": {"commit": "429adeba1a7b93b70405daab7c9a42ca0df70868", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 39570f6..f5653a6 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -300,6 +326,7 @@ private static final String TAG = \"IterableApi\";\n         _email = email;\n         _userId = null;\n         _authToken = authToken;\n+//        _authToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\";\n         storeAuthData();\n         onLogIn();\n     }\n", "next_change": {"commit": "e8e896e7f6fc9c7a67210ad002b8e56c6489d172", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex f5653a6..c7b5340 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -326,7 +335,6 @@ private static final String TAG = \"IterableApi\";\n         _email = email;\n         _userId = null;\n         _authToken = authToken;\n-//        _authToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\";\n         storeAuthData();\n         onLogIn();\n     }\n", "next_change": {"commit": "116518fb0f50a3ff033121a0e85da7a730352415", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex c7b5340..9313cf8 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -294,49 +290,17 @@ private static final String TAG = \"IterableApi\";\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        getAuthManager().requestNewAuthToken();\n-\n         onLogOut();\n         _email = email;\n         _userId = null;\n         storeAuthData();\n-        onLogIn();\n-    }\n \n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            if (_authToken == null && authToken == null) {\n-                return;\n+        getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n+            @Override\n+            public void onSuccess(@NonNull String authToken) {\n+                setAuthToken(authToken);\n             }\n-\n-            if (_authToken != null && _authToken.equals(authToken)) {\n-                return;\n-            }\n-\n-            _authToken = authToken;\n-            storeAuthData();\n-\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        onLogOut();\n-        _email = email;\n-        _userId = null;\n-        _authToken = authToken;\n-        storeAuthData();\n-        onLogIn();\n+        });\n     }\n \n     /**\n", "next_change": {"commit": "5a2c35091502c101e79bfca2391dbfdf39b7c4c4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9313cf8..713d3ab 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -295,12 +295,16 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n-            @Override\n-            public void onSuccess(@NonNull String authToken) {\n-                setAuthToken(authToken);\n-            }\n-        });\n+        if (email != null) {\n+            getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n+                @Override\n+                public void onSuccess(@NonNull String authToken) {\n+                    onSetAuthToken(authToken);\n+                }\n+            });\n+        } else {\n+            onSetAuthToken(null);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "a16ff86dd1460af0bdb6ae200aaae829b4a16481", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 713d3ab..e8936ab 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -296,14 +304,9 @@ private static final String TAG = \"IterableApi\";\n         storeAuthData();\n \n         if (email != null) {\n-            getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n-                @Override\n-                public void onSuccess(@NonNull String authToken) {\n-                    onSetAuthToken(authToken);\n-                }\n-            });\n+            getAuthManager().requestNewAuthToken(false);\n         } else {\n-            onSetAuthToken(null);\n+            setAuthToken(null);\n         }\n     }\n \n", "next_change": {"commit": "2db97108c261008ed4b1d5f29c70eaa4318b1275", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e8936ab..a15c5c9 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -297,17 +350,21 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n-    public void setEmail(@Nullable String email) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        if (_email != null && _email.equals(email)) {\n+            return;\n+        }\n+\n+        if (_email == null && _userId == null && email == null) {\n+            return;\n+        }\n+\n         onLogOut();\n         _email = email;\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "3287dc085a83f1e75e09982baad3625fb6684b8c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a15c5c9..3c9e5cd 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -364,7 +360,11 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        onLogin(authToken);\n+        if (email != null) {\n+            getAuthManager().requestNewAuthToken(false);\n+        } else {\n+            setAuthToken(null);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "ea141c605aca86d0d85418a66a8f1296263454d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd..882bb40 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -355,16 +359,13 @@ private static final String TAG = \"IterableApi\";\n             return;\n         }\n \n-        onLogOut();\n+        logoutPreviousUser();\n+\n         _email = email;\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40..45c33cc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,7 +365,11 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        onLogin(authToken);\n+        if (email != null) {\n+            getAuthManager().requestNewAuthToken(false);\n+        } else {\n+            setAuthToken(null);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "b6b77024af90a60aecb60d6f15264ab69f1b571b", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc..6496d51 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,11 +365,13 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+//        if (email != null) {\n+//            getAuthManager().requestNewAuthToken(false);\n+//        } else {\n+//            setAuthToken(null);\n+//        }\n+\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "ae2dedfa1de5ec18c047fa1edb42c431570702af", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 6496d51..c015230 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,12 +365,6 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-//        if (email != null) {\n-//            getAuthManager().requestNewAuthToken(false);\n-//        } else {\n-//            setAuthToken(null);\n-//        }\n-\n         onLogin(authToken);\n     }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex c015230..b03b5b1 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,149 +249,17 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, false);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b1..9b34a0d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d..96f643f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyOTQ3OQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r453129479", "body": "authToken instead of token", "bodyText": "authToken instead of token", "bodyHTML": "<p dir=\"auto\">authToken instead of token</p>", "author": "Ayyanchira", "createdAt": "2020-07-11T00:19:26Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -298,6 +312,18 @@ public void setEmail(@Nullable String email) {\n      * @param userId User ID\n      */\n     public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    /**\n+     * Set user ID used for API calls\n+     * Calling this or `setEmail:` is required before making any API calls.\n+     *\n+     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n+     * @param userId User ID\n+     * @param authToken Authorization token\n+     */\n+    public void setUserId(@Nullable String userId, @Nullable String token) {", "originalCommit": "7935107e18976c2534bb51d003cec2bb49cc7fc6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb02c1699670800de502e3eccdde6149be7ea840", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 8f7f2c6..e4eaa29 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -312,18 +298,6 @@ private static final String TAG = \"IterableApi\";\n      * @param userId User ID\n      */\n     public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or `setEmail:` is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     * @param authToken Authorization token\n-     */\n-    public void setUserId(@Nullable String userId, @Nullable String token) {\n         if (_userId != null && _userId.equals(userId)) {\n             return;\n         }\n", "next_change": {"commit": "80f6681d90bbfb69fa7fd61f2a263e253ded3651", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e4eaa29..d8d9704 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -298,6 +312,18 @@ private static final String TAG = \"IterableApi\";\n      * @param userId User ID\n      */\n     public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    /**\n+     * Set user ID used for API calls\n+     * Calling this or `setEmail:` is required before making any API calls.\n+     *\n+     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n+     * @param userId User ID\n+     * @param authToken Authorization token\n+     */\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n         if (_userId != null && _userId.equals(userId)) {\n             return;\n         }\n", "next_change": {"commit": "571a96cf8ec5b7a05892c8d83e13cefcad33173e", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex d8d9704..1dec5fc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -312,18 +298,6 @@ private static final String TAG = \"IterableApi\";\n      * @param userId User ID\n      */\n     public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or `setEmail:` is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     * @param authToken Authorization token\n-     */\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n         if (_userId != null && _userId.equals(userId)) {\n             return;\n         }\n", "next_change": {"commit": "4f4ae81abffbffbd7da2eee168789a821a67ba0e", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 1dec5fc..d24fd3d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -298,6 +312,18 @@ private static final String TAG = \"IterableApi\";\n      * @param userId User ID\n      */\n     public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    /**\n+     * Set user ID used for API calls\n+     * Calling this or `setEmail:` is required before making any API calls.\n+     *\n+     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n+     * @param userId User ID\n+     * @param authToken Authorization token\n+     */\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n         if (_userId != null && _userId.equals(userId)) {\n             return;\n         }\n", "next_change": {"commit": "d372a48bcfc75aea7420f4dee6a3c89fd2f2f7d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex d24fd3d..d2d9e5f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -312,18 +298,6 @@ private static final String TAG = \"IterableApi\";\n      * @param userId User ID\n      */\n     public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or `setEmail:` is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     * @param authToken Authorization token\n-     */\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n         if (_userId != null && _userId.equals(userId)) {\n             return;\n         }\n", "next_change": {"commit": "a1d8fc647f2eeb604c110973a30a64162ef229c9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex d2d9e5f..ac402db 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -286,18 +299,31 @@ private static final String TAG = \"IterableApi\";\n         onLogOut();\n         _email = email;\n         _userId = null;\n-        storeEmailAndUserId();\n+        _authToken = authToken;\n+        storeAuthData();\n         onLogIn();\n     }\n \n     /**\n      * Set user ID used for API calls\n-     * Calling this or `setEmail:` is required before making any API calls.\n+     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n      *\n      * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n      * @param userId User ID\n      */\n     public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    /**\n+     * Set user ID used for API calls\n+     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n+     *\n+     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n+     * @param userId User ID\n+     * @param authToken Authorization token\n+     */\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n         if (_userId != null && _userId.equals(userId)) {\n             return;\n         }\n", "next_change": {"commit": "fd1cbaabb910bc602d2622da043f336507f7711d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ac402db..bc6a7d0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -324,27 +324,27 @@ private static final String TAG = \"IterableApi\";\n      * @param authToken Authorization token\n      */\n     public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n+        if (_userId != null && !_userId.equals(userId)) {\n+            onLogOut();\n \n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n+            _email = null;\n+            _userId = userId;\n+            _authToken = authToken;\n+\n+            storeAuthData();\n \n-        onLogOut();\n-        _email = null;\n-        _userId = userId;\n-        _authToken = authToken;\n-        storeAuthData();\n-        onLogIn();\n+            onLogIn();\n+        } else if (userId != null & (_authToken == null || _authToken != authToken)) {\n+            _authToken = authToken;\n+            storeAuthData();\n+        }\n     }\n \n     /**\n      * Tracks a click on the uri if it is an iterable link.\n      * @param uri the\n      * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not a Iterable link.\n+     *                   or the original url if it is not an Iterable link.\n      */\n     public static void getAndTrackDeeplink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n         IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n", "next_change": {"commit": "a25ec805df060991fb94eccc3c19958650866398", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex bc6a7d0..bf05e3c 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -346,8 +399,8 @@ private static final String TAG = \"IterableApi\";\n      * @param onCallback Calls the callback handler with the destination location\n      *                   or the original url if it is not an Iterable link.\n      */\n-    public static void getAndTrackDeeplink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback, config.allowedProtocols);\n     }\n \n     /**\n", "next_change": {"commit": "2bfb786453bdc527544450f336e5a12990a98169", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex bf05e3c..7b35883 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -400,7 +402,7 @@ private static final String TAG = \"IterableApi\";\n      *                   or the original url if it is not an Iterable link.\n      */\n     public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback, config.allowedProtocols);\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyOTQ5Mg==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r453129492", "body": "Never saw space in constant before. If its intentional, we just need to be aware of this.", "bodyText": "Never saw space in constant before. If its intentional, we just need to be aware of this.", "bodyHTML": "<p dir=\"auto\">Never saw space in constant before. If its intentional, we just need to be aware of this.</p>", "author": "Ayyanchira", "createdAt": "2020-07-11T00:19:33Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java", "diffHunk": "@@ -18,6 +18,8 @@\n     public static final String HEADER_API_KEY           = \"Api-Key\";\n     public static final String HEADER_SDK_PLATFORM      = \"SDK-Platform\";\n     public static final String HEADER_SDK_VERSION       = \"SDK-Version\";\n+    public static final String HEADER_SDK_AUTHORIZATION = \"Authorization\";\n+    public static final String HEADER_SDK_AUTH_FORMAT   = \"Bearer \";", "originalCommit": "7935107e18976c2534bb51d003cec2bb49cc7fc6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0Mjk4OQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r453942989", "bodyText": "Yep, it's intentional", "author": "roninopf", "createdAt": "2020-07-13T21:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyOTQ5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ca6502bc7b5c61bf15671c926df382f9b6d064eb", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\nindex 744a734..089ac12 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n", "chunk": "@@ -20,6 +20,7 @@ public final class IterableConstants {\n     public static final String HEADER_SDK_VERSION       = \"SDK-Version\";\n     public static final String HEADER_SDK_AUTHORIZATION = \"Authorization\";\n     public static final String HEADER_SDK_AUTH_FORMAT   = \"Bearer \";\n+    public static final String HEADER_SDK_PROCESSOR_TYPE = \"SDK-Request-Processor\";\n     public static final String KEY_APPLICATION_NAME     = \"applicationName\";\n     public static final String KEY_CAMPAIGN_ID          = \"campaignId\";\n     public static final String KEY_CURRENT_EMAIL        = \"currentEmail\";\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyOTUwMg==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r453129502", "body": "authToken instead of token in method Signature", "bodyText": "authToken instead of token in method Signature", "bodyHTML": "<p dir=\"auto\">authToken instead of token in method Signature</p>", "author": "Ayyanchira", "createdAt": "2020-07-11T00:19:36Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java", "diffHunk": "@@ -287,37 +291,41 @@ protected void setRetryCount(int count) {\n     final String resourcePath;\n     final JSONObject json;\n     final String requestType;\n+    final String authToken;\n \n     IterableHelper.IterableActionHandler legacyCallback;\n     IterableHelper.SuccessHandler successCallback;\n     IterableHelper.FailureHandler failureCallback;\n \n-    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n+    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, String token, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {", "originalCommit": "7935107e18976c2534bb51d003cec2bb49cc7fc6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80f6681d90bbfb69fa7fd61f2a263e253ded3651", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex e14ed6f..1956778 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -297,35 +297,35 @@ class IterableApiRequest {\n     IterableHelper.SuccessHandler successCallback;\n     IterableHelper.FailureHandler failureCallback;\n \n-    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, String token, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n+    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, String authToken, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n         this.apiKey = apiKey;\n         this.baseUrl = baseUrl;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n-        this.authToken = token;\n+        this.authToken = authToken;\n         this.successCallback = onSuccess;\n         this.failureCallback = onFailure;\n     }\n \n-    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String token, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n+    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String authToken, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n         this.apiKey = apiKey;\n         this.baseUrl = null;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n-        this.authToken = token;\n+        this.authToken = authToken;\n         this.successCallback = onSuccess;\n         this.failureCallback = onFailure;\n     }\n \n-    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String token, final IterableHelper.IterableActionHandler callback) {\n+    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String authToken, final IterableHelper.IterableActionHandler callback) {\n         this.apiKey = apiKey;\n         this.baseUrl = null;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n-        this.authToken = token;\n+        this.authToken = authToken;\n         this.legacyCallback = callback;\n     }\n }\n", "next_change": {"commit": "a421a559c0378eb79e1d5946bc23f64f6275b549", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex 1956778..b5e316f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -328,4 +340,31 @@ class IterableApiRequest {\n         this.authToken = authToken;\n         this.legacyCallback = callback;\n     }\n+\n+    public JSONObject toJSONObject() throws JSONException {\n+        JSONObject jsonObject = new JSONObject();\n+        jsonObject.put(\"apiKey\", this.apiKey);\n+        jsonObject.put(\"endPoint\", this.resourcePath);\n+        jsonObject.put(\"auth\", this.authToken);\n+        jsonObject.put(\"requestType\", this.requestType);\n+        jsonObject.put(\"data\", this.json);\n+        return jsonObject;\n+    }\n+\n+    static IterableApiRequest fromJSON(JSONObject jsonData, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        try {\n+            String apikey = jsonData.getString(\"apiKey\");\n+            String resourcePath = jsonData.getString(\"endPoint\");\n+            String requestType = jsonData.getString(\"requestType\");\n+            String auth = \"\";\n+            if(jsonData.has(\"auth\")){\n+                auth = jsonData.getString(\"auth\");\n+            }\n+            JSONObject json = jsonData.getJSONObject(\"data\");\n+            return new IterableApiRequest(apikey,resourcePath, json, requestType, auth, onSuccess, onFailure );\n+        } catch (JSONException e) {\n+            IterableLogger.e(TAG, \"Failed to create Iterable request from JSON\");\n+        }\n+        return null;\n+    }\n }\n", "next_change": {"commit": "7c43cd0a60a1484762be178c64985709cea5b986", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex b5e316f..b70ac87 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -354,14 +354,14 @@ class IterableApiRequest {\n     static IterableApiRequest fromJSON(JSONObject jsonData, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n         try {\n             String apikey = jsonData.getString(\"apiKey\");\n-            String resourcePath = jsonData.getString(\"endPoint\");\n+            String resourcePath = jsonData.getString(\"resourcePath\");\n             String requestType = jsonData.getString(\"requestType\");\n-            String auth = \"\";\n-            if(jsonData.has(\"auth\")){\n-                auth = jsonData.getString(\"auth\");\n+            String authToken = \"\";\n+            if (jsonData.has(\"authToken\")) {\n+                authToken = jsonData.getString(\"authToken\");\n             }\n             JSONObject json = jsonData.getJSONObject(\"data\");\n-            return new IterableApiRequest(apikey,resourcePath, json, requestType, auth, onSuccess, onFailure );\n+            return new IterableApiRequest(apikey, resourcePath, json, requestType, authToken, onSuccess, onFailure);\n         } catch (JSONException e) {\n             IterableLogger.e(TAG, \"Failed to create Iterable request from JSON\");\n         }\n", "next_change": {"commit": "e4f693da77689c966cdb53442a5c6be554fe5664", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex b70ac87..ab3748a 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -368,3 +354,27 @@ class IterableApiRequest {\n         return null;\n     }\n }\n+\n+class IterableApiResponse {\n+    final boolean success;\n+    final int responseCode;\n+    final String responseBody;\n+    final JSONObject responseJson;\n+    final String errorMessage;\n+\n+    IterableApiResponse(boolean success, int responseCode, String responseBody, JSONObject responseJson, String errorMessage) {\n+        this.success = success;\n+        this.responseCode = responseCode;\n+        this.responseBody = responseBody;\n+        this.responseJson = responseJson;\n+        this.errorMessage = errorMessage;\n+    }\n+\n+    static IterableApiResponse success(int responseCode, String body, @NonNull JSONObject json) {\n+        return new IterableApiResponse(true, responseCode, body, json, null);\n+    }\n+\n+    static IterableApiResponse failure(int responseCode, String body, @Nullable JSONObject json, String errorMessage) {\n+        return new IterableApiResponse(false, responseCode, body, json, errorMessage);\n+    }\n+}\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyOTUwNQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r453129505", "body": "authToken instead of token in the method signature.", "bodyText": "authToken instead of token in the method signature.", "bodyHTML": "<p dir=\"auto\">authToken instead of token in the method signature.</p>", "author": "Ayyanchira", "createdAt": "2020-07-11T00:19:37Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java", "diffHunk": "@@ -287,37 +291,41 @@ protected void setRetryCount(int count) {\n     final String resourcePath;\n     final JSONObject json;\n     final String requestType;\n+    final String authToken;\n \n     IterableHelper.IterableActionHandler legacyCallback;\n     IterableHelper.SuccessHandler successCallback;\n     IterableHelper.FailureHandler failureCallback;\n \n-    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n+    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, String token, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n         this.apiKey = apiKey;\n         this.baseUrl = baseUrl;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n+        this.authToken = token;\n         this.successCallback = onSuccess;\n         this.failureCallback = onFailure;\n     }\n \n-    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n+    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String token, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {", "originalCommit": "7935107e18976c2534bb51d003cec2bb49cc7fc6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80f6681d90bbfb69fa7fd61f2a263e253ded3651", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex e14ed6f..1956778 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -297,35 +297,35 @@ class IterableApiRequest {\n     IterableHelper.SuccessHandler successCallback;\n     IterableHelper.FailureHandler failureCallback;\n \n-    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, String token, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n+    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, String authToken, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n         this.apiKey = apiKey;\n         this.baseUrl = baseUrl;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n-        this.authToken = token;\n+        this.authToken = authToken;\n         this.successCallback = onSuccess;\n         this.failureCallback = onFailure;\n     }\n \n-    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String token, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n+    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String authToken, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n         this.apiKey = apiKey;\n         this.baseUrl = null;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n-        this.authToken = token;\n+        this.authToken = authToken;\n         this.successCallback = onSuccess;\n         this.failureCallback = onFailure;\n     }\n \n-    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String token, final IterableHelper.IterableActionHandler callback) {\n+    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String authToken, final IterableHelper.IterableActionHandler callback) {\n         this.apiKey = apiKey;\n         this.baseUrl = null;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n-        this.authToken = token;\n+        this.authToken = authToken;\n         this.legacyCallback = callback;\n     }\n }\n", "next_change": {"commit": "a421a559c0378eb79e1d5946bc23f64f6275b549", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex 1956778..b5e316f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -328,4 +340,31 @@ class IterableApiRequest {\n         this.authToken = authToken;\n         this.legacyCallback = callback;\n     }\n+\n+    public JSONObject toJSONObject() throws JSONException {\n+        JSONObject jsonObject = new JSONObject();\n+        jsonObject.put(\"apiKey\", this.apiKey);\n+        jsonObject.put(\"endPoint\", this.resourcePath);\n+        jsonObject.put(\"auth\", this.authToken);\n+        jsonObject.put(\"requestType\", this.requestType);\n+        jsonObject.put(\"data\", this.json);\n+        return jsonObject;\n+    }\n+\n+    static IterableApiRequest fromJSON(JSONObject jsonData, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        try {\n+            String apikey = jsonData.getString(\"apiKey\");\n+            String resourcePath = jsonData.getString(\"endPoint\");\n+            String requestType = jsonData.getString(\"requestType\");\n+            String auth = \"\";\n+            if(jsonData.has(\"auth\")){\n+                auth = jsonData.getString(\"auth\");\n+            }\n+            JSONObject json = jsonData.getJSONObject(\"data\");\n+            return new IterableApiRequest(apikey,resourcePath, json, requestType, auth, onSuccess, onFailure );\n+        } catch (JSONException e) {\n+            IterableLogger.e(TAG, \"Failed to create Iterable request from JSON\");\n+        }\n+        return null;\n+    }\n }\n", "next_change": {"commit": "7c43cd0a60a1484762be178c64985709cea5b986", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex b5e316f..b70ac87 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -354,14 +354,14 @@ class IterableApiRequest {\n     static IterableApiRequest fromJSON(JSONObject jsonData, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n         try {\n             String apikey = jsonData.getString(\"apiKey\");\n-            String resourcePath = jsonData.getString(\"endPoint\");\n+            String resourcePath = jsonData.getString(\"resourcePath\");\n             String requestType = jsonData.getString(\"requestType\");\n-            String auth = \"\";\n-            if(jsonData.has(\"auth\")){\n-                auth = jsonData.getString(\"auth\");\n+            String authToken = \"\";\n+            if (jsonData.has(\"authToken\")) {\n+                authToken = jsonData.getString(\"authToken\");\n             }\n             JSONObject json = jsonData.getJSONObject(\"data\");\n-            return new IterableApiRequest(apikey,resourcePath, json, requestType, auth, onSuccess, onFailure );\n+            return new IterableApiRequest(apikey, resourcePath, json, requestType, authToken, onSuccess, onFailure);\n         } catch (JSONException e) {\n             IterableLogger.e(TAG, \"Failed to create Iterable request from JSON\");\n         }\n", "next_change": {"commit": "e4f693da77689c966cdb53442a5c6be554fe5664", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex b70ac87..ab3748a 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -368,3 +354,27 @@ class IterableApiRequest {\n         return null;\n     }\n }\n+\n+class IterableApiResponse {\n+    final boolean success;\n+    final int responseCode;\n+    final String responseBody;\n+    final JSONObject responseJson;\n+    final String errorMessage;\n+\n+    IterableApiResponse(boolean success, int responseCode, String responseBody, JSONObject responseJson, String errorMessage) {\n+        this.success = success;\n+        this.responseCode = responseCode;\n+        this.responseBody = responseBody;\n+        this.responseJson = responseJson;\n+        this.errorMessage = errorMessage;\n+    }\n+\n+    static IterableApiResponse success(int responseCode, String body, @NonNull JSONObject json) {\n+        return new IterableApiResponse(true, responseCode, body, json, null);\n+    }\n+\n+    static IterableApiResponse failure(int responseCode, String body, @Nullable JSONObject json, String errorMessage) {\n+        return new IterableApiResponse(false, responseCode, body, json, errorMessage);\n+    }\n+}\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyOTUwOA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r453129508", "body": "At several places, method signature have token while others have authToken. authToken everywhere will be great", "bodyText": "At several places, method signature have token while others have authToken. authToken everywhere will be great", "bodyHTML": "<p dir=\"auto\">At several places, method signature have token while others have authToken. authToken everywhere will be great</p>", "author": "Ayyanchira", "createdAt": "2020-07-11T00:19:41Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java", "diffHunk": "@@ -287,37 +291,41 @@ protected void setRetryCount(int count) {\n     final String resourcePath;\n     final JSONObject json;\n     final String requestType;\n+    final String authToken;\n \n     IterableHelper.IterableActionHandler legacyCallback;\n     IterableHelper.SuccessHandler successCallback;\n     IterableHelper.FailureHandler failureCallback;\n \n-    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n+    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, String token, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n         this.apiKey = apiKey;\n         this.baseUrl = baseUrl;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n+        this.authToken = token;\n         this.successCallback = onSuccess;\n         this.failureCallback = onFailure;\n     }\n \n-    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n+    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String token, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n         this.apiKey = apiKey;\n         this.baseUrl = null;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n+        this.authToken = token;\n         this.successCallback = onSuccess;\n         this.failureCallback = onFailure;\n     }\n \n-    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, final IterableHelper.IterableActionHandler callback) {\n+    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String token, final IterableHelper.IterableActionHandler callback) {", "originalCommit": "7935107e18976c2534bb51d003cec2bb49cc7fc6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "80f6681d90bbfb69fa7fd61f2a263e253ded3651", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex e14ed6f..1956778 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -297,35 +297,35 @@ class IterableApiRequest {\n     IterableHelper.SuccessHandler successCallback;\n     IterableHelper.FailureHandler failureCallback;\n \n-    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, String token, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n+    IterableApiRequest(String apiKey, String baseUrl, String resourcePath, JSONObject json, String requestType, String authToken, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n         this.apiKey = apiKey;\n         this.baseUrl = baseUrl;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n-        this.authToken = token;\n+        this.authToken = authToken;\n         this.successCallback = onSuccess;\n         this.failureCallback = onFailure;\n     }\n \n-    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String token, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n+    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String authToken, IterableHelper.SuccessHandler onSuccess, IterableHelper.FailureHandler onFailure) {\n         this.apiKey = apiKey;\n         this.baseUrl = null;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n-        this.authToken = token;\n+        this.authToken = authToken;\n         this.successCallback = onSuccess;\n         this.failureCallback = onFailure;\n     }\n \n-    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String token, final IterableHelper.IterableActionHandler callback) {\n+    IterableApiRequest(String apiKey, String resourcePath, JSONObject json, String requestType, String authToken, final IterableHelper.IterableActionHandler callback) {\n         this.apiKey = apiKey;\n         this.baseUrl = null;\n         this.resourcePath = resourcePath;\n         this.json = json;\n         this.requestType = requestType;\n-        this.authToken = token;\n+        this.authToken = authToken;\n         this.legacyCallback = callback;\n     }\n }\n", "next_change": {"commit": "a421a559c0378eb79e1d5946bc23f64f6275b549", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex 1956778..b5e316f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -328,4 +340,31 @@ class IterableApiRequest {\n         this.authToken = authToken;\n         this.legacyCallback = callback;\n     }\n+\n+    public JSONObject toJSONObject() throws JSONException {\n+        JSONObject jsonObject = new JSONObject();\n+        jsonObject.put(\"apiKey\", this.apiKey);\n+        jsonObject.put(\"endPoint\", this.resourcePath);\n+        jsonObject.put(\"auth\", this.authToken);\n+        jsonObject.put(\"requestType\", this.requestType);\n+        jsonObject.put(\"data\", this.json);\n+        return jsonObject;\n+    }\n+\n+    static IterableApiRequest fromJSON(JSONObject jsonData, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        try {\n+            String apikey = jsonData.getString(\"apiKey\");\n+            String resourcePath = jsonData.getString(\"endPoint\");\n+            String requestType = jsonData.getString(\"requestType\");\n+            String auth = \"\";\n+            if(jsonData.has(\"auth\")){\n+                auth = jsonData.getString(\"auth\");\n+            }\n+            JSONObject json = jsonData.getJSONObject(\"data\");\n+            return new IterableApiRequest(apikey,resourcePath, json, requestType, auth, onSuccess, onFailure );\n+        } catch (JSONException e) {\n+            IterableLogger.e(TAG, \"Failed to create Iterable request from JSON\");\n+        }\n+        return null;\n+    }\n }\n", "next_change": {"commit": "7c43cd0a60a1484762be178c64985709cea5b986", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex b5e316f..b70ac87 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -354,14 +354,14 @@ class IterableApiRequest {\n     static IterableApiRequest fromJSON(JSONObject jsonData, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n         try {\n             String apikey = jsonData.getString(\"apiKey\");\n-            String resourcePath = jsonData.getString(\"endPoint\");\n+            String resourcePath = jsonData.getString(\"resourcePath\");\n             String requestType = jsonData.getString(\"requestType\");\n-            String auth = \"\";\n-            if(jsonData.has(\"auth\")){\n-                auth = jsonData.getString(\"auth\");\n+            String authToken = \"\";\n+            if (jsonData.has(\"authToken\")) {\n+                authToken = jsonData.getString(\"authToken\");\n             }\n             JSONObject json = jsonData.getJSONObject(\"data\");\n-            return new IterableApiRequest(apikey,resourcePath, json, requestType, auth, onSuccess, onFailure );\n+            return new IterableApiRequest(apikey, resourcePath, json, requestType, authToken, onSuccess, onFailure);\n         } catch (JSONException e) {\n             IterableLogger.e(TAG, \"Failed to create Iterable request from JSON\");\n         }\n", "next_change": {"commit": "e4f693da77689c966cdb53442a5c6be554fe5664", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex b70ac87..ab3748a 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -368,3 +354,27 @@ class IterableApiRequest {\n         return null;\n     }\n }\n+\n+class IterableApiResponse {\n+    final boolean success;\n+    final int responseCode;\n+    final String responseBody;\n+    final JSONObject responseJson;\n+    final String errorMessage;\n+\n+    IterableApiResponse(boolean success, int responseCode, String responseBody, JSONObject responseJson, String errorMessage) {\n+        this.success = success;\n+        this.responseCode = responseCode;\n+        this.responseBody = responseBody;\n+        this.responseJson = responseJson;\n+        this.errorMessage = errorMessage;\n+    }\n+\n+    static IterableApiResponse success(int responseCode, String body, @NonNull JSONObject json) {\n+        return new IterableApiResponse(true, responseCode, body, json, null);\n+    }\n+\n+    static IterableApiResponse failure(int responseCode, String body, @Nullable JSONObject json, String errorMessage) {\n+        return new IterableApiResponse(false, responseCode, body, json, errorMessage);\n+    }\n+}\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}, {"oid": "80f6681d90bbfb69fa7fd61f2a263e253ded3651", "url": "https://github.com/Iterable/iterable-android-sdk/commit/80f6681d90bbfb69fa7fd61f2a263e253ded3651", "message": "make parameter names clearer", "committedDate": "2020-07-13T21:28:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4Nzk4Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r453987983", "body": "\ud83d\udc4d", "bodyText": "\ud83d\udc4d", "bodyHTML": "<p dir=\"auto\"><g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png\">\ud83d\udc4d</g-emoji></p>", "author": "Ayyanchira", "createdAt": "2020-07-13T22:40:44Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -376,15 +403,15 @@ public boolean isIterableIntent(@Nullable Intent intent) {\n      * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n      * @param token Push token obtained from GCM or FCM\n      */\n-    public void registerDeviceToken(@NonNull String token) {\n-        registerDeviceToken(_email, _userId, getPushIntegrationName(), token, deviceAttributes);\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, getPushIntegrationName(), deviceToken, deviceAttributes);", "originalCommit": "80f6681d90bbfb69fa7fd61f2a263e253ded3651", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb02c1699670800de502e3eccdde6149be7ea840", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex d8d9704..e4eaa29 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -403,15 +376,15 @@ private static final String TAG = \"IterableApi\";\n      * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n      * @param token Push token obtained from GCM or FCM\n      */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    public void registerDeviceToken(@NonNull String token) {\n+        registerDeviceToken(_email, _userId, getPushIntegrationName(), token, deviceAttributes);\n     }\n \n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-        if (deviceToken != null) {\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @NonNull String applicationName, final @NonNull String token, final HashMap<String, String> deviceAttributes) {\n+        if (token != null) {\n             final Thread registrationThread = new Thread(new Runnable() {\n                 public void run() {\n-                    registerDeviceToken(email, userId, applicationName, deviceToken, null, deviceAttributes);\n+                    registerDeviceToken(email, userId, applicationName, token, null, deviceAttributes);\n                 }\n             });\n             registrationThread.start();\n", "next_change": {"commit": "4f4ae81abffbffbd7da2eee168789a821a67ba0e", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e4eaa29..d24fd3d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -376,15 +403,15 @@ private static final String TAG = \"IterableApi\";\n      * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n      * @param token Push token obtained from GCM or FCM\n      */\n-    public void registerDeviceToken(@NonNull String token) {\n-        registerDeviceToken(_email, _userId, getPushIntegrationName(), token, deviceAttributes);\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @NonNull String applicationName, final @NonNull String token, final HashMap<String, String> deviceAttributes) {\n-        if (token != null) {\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n             final Thread registrationThread = new Thread(new Runnable() {\n                 public void run() {\n-                    registerDeviceToken(email, userId, applicationName, token, null, deviceAttributes);\n+                    registerDeviceToken(email, userId, applicationName, deviceToken, null, deviceAttributes);\n                 }\n             });\n             registrationThread.start();\n", "next_change": {"commit": "d372a48bcfc75aea7420f4dee6a3c89fd2f2f7d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex d24fd3d..d2d9e5f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -403,15 +376,15 @@ private static final String TAG = \"IterableApi\";\n      * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n      * @param token Push token obtained from GCM or FCM\n      */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    public void registerDeviceToken(@NonNull String token) {\n+        registerDeviceToken(_email, _userId, getPushIntegrationName(), token, deviceAttributes);\n     }\n \n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-        if (deviceToken != null) {\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @NonNull String applicationName, final @NonNull String token, final HashMap<String, String> deviceAttributes) {\n+        if (token != null) {\n             final Thread registrationThread = new Thread(new Runnable() {\n                 public void run() {\n-                    registerDeviceToken(email, userId, applicationName, deviceToken, null, deviceAttributes);\n+                    registerDeviceToken(email, userId, applicationName, token, null, deviceAttributes);\n                 }\n             });\n             registrationThread.start();\n", "next_change": {"commit": "a1d8fc647f2eeb604c110973a30a64162ef229c9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex d2d9e5f..ac402db 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -376,15 +403,15 @@ private static final String TAG = \"IterableApi\";\n      * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n      * @param token Push token obtained from GCM or FCM\n      */\n-    public void registerDeviceToken(@NonNull String token) {\n-        registerDeviceToken(_email, _userId, getPushIntegrationName(), token, deviceAttributes);\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @NonNull String applicationName, final @NonNull String token, final HashMap<String, String> deviceAttributes) {\n-        if (token != null) {\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n             final Thread registrationThread = new Thread(new Runnable() {\n                 public void run() {\n-                    registerDeviceToken(email, userId, applicationName, token, null, deviceAttributes);\n+                    registerDeviceToken(email, userId, applicationName, deviceToken, null, deviceAttributes);\n                 }\n             });\n             registrationThread.start();\n", "next_change": {"commit": "5bb3beccabcb0aec45ab2e3a71b869571cafdaf1", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ac402db..97876cd 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -401,17 +391,17 @@ private static final String TAG = \"IterableApi\";\n     /**\n      * Registers a device token with Iterable.\n      * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param token Push token obtained from GCM or FCM\n+     * @param deviceToken Push token obtained from GCM or FCM\n      */\n     public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, getPushIntegrationName(), deviceToken, deviceAttributes);\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n         if (deviceToken != null) {\n             final Thread registrationThread = new Thread(new Runnable() {\n                 public void run() {\n-                    registerDeviceToken(email, userId, applicationName, deviceToken, null, deviceAttributes);\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n                 }\n             });\n             registrationThread.start();\n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 97876cd..b03b5b1 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -388,26 +321,6 @@ private static final String TAG = \"IterableApi\";\n         return false;\n     }\n \n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n-    }\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-        if (deviceToken != null) {\n-            final Thread registrationThread = new Thread(new Runnable() {\n-                public void run() {\n-                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-                }\n-            });\n-            registrationThread.start();\n-        }\n-    }\n-\n     /**\n      * Track an event.\n      * @param eventName\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b1..96f643f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -217,768 +203,810 @@ private static final String TAG = \"IterableApi\";\n         }\n     }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n-    }\n-\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-        if (isInitialized()) {\n-            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-                _authToken = authToken;\n-                storeAuthData();\n-                completeUserLogin();\n-            } else if (bypassAuth) {\n-                completeUserLogin();\n-            }\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+        apiClient.getInAppMessages(count, onCallback);\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n-    }\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n-    }\n-//---------------------------------------------------------------------------------------\n-//endregion\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-//region Public Functions\n-//---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n         }\n     }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n+        }\n+\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n     }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n+            return;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n         } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+            getAuthManager().requestNewAuthToken(false);\n         }\n     }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n         }\n-        return false;\n+\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n+\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n+\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n+    }\n+\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n+    }\n+\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n+    }\n+\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+        }\n+    }\n+\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n+        }\n+    }\n+\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n+        }\n+\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n+\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n+\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n+\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n+        }\n+\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n+\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n+        }\n+    }\n+//endregion\n+\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n+    }\n+\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n+    }\n+\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n+            return;\n+        }\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n      * @param dataFields\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+            return;\n+        }\n+\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n+\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    /**\n-     * Updates the status of the cart\n-     * @param items\n-     */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n+    }\n+\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n+    }\n+\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n+\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateCart(items);\n+        sharedInstance.retrieveEmailAndUserId();\n+\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n+\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n+    }\n+\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n+\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n+    }\n+\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n+    }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n+\n     /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+        }\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n+\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (_email == null && _userId == null && email == null) {\n+            return;\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n-    }\n+        logoutPreviousUser();\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-       if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n+            return;\n+        }\n \n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        logoutPreviousUser();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * Updates the current user.\n-     * @param dataFields\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n+//endregion\n \n+//region API public functions\n+//---------------------------------------------------------------------------------------\n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        if (!checkSDKInitialization()) {\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n \n     /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n      */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n-            return;\n-        }\n-\n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n     }\n \n     /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n      */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n-            return;\n-        }\n-\n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n-            return;\n-        }\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n \n-        apiClient.trackInAppDelivery(message);\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-\n-//---------------------------------------------------------------------------------------\n-//endregion\n-\n-//region Package-Protected Functions\n-//---------------------------------------------------------------------------------------\n-\n     /**\n-     * Get user email\n-     * @return user email\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n      */\n-    String getEmail() {\n-        return _email;\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n \n     /**\n-     * Get user ID\n-     * @return user ID\n+     * Returns whether or not the intent was sent from Iterable.\n      */\n-    String getUserId() {\n-        return _userId;\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        }\n+        return false;\n     }\n \n     /**\n-     * Get the authentication token\n-     * @return authentication token\n+     * Track an event.\n+     * @param eventName\n      */\n-    String getAuthToken() {\n-        return _authToken;\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-//---------------------------------------------------------------------------------------\n-//endregion\n-\n-//region Protected Functions\n-//---------------------------------------------------------------------------------------\n-\n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n-    }\n-\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Tracks when a push notification is opened on device.\n+     * Track an event.\n+     * @param eventName\n      * @param campaignId\n      * @param templateId\n+     * @param dataFields\n      */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n-    }\n-\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n-    }\n-\n-    /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n-     */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n-            return;\n-        }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Updates the status of the cart\n+     * @param items\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n-            return;\n-        }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n-    }\n-\n-//---------------------------------------------------------------------------------------\n-//endregion\n-\n-//region Private Functions\n-//---------------------------------------------------------------------------------------\n-\n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n-        }\n-    }\n-\n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n-    }\n-\n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n-    }\n-\n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n-        }\n-        return _deviceId;\n-    }\n-\n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n-        }\n+        apiClient.updateCart(items);\n     }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+    /**\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     */\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n-        }\n-\n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n-        }\n-\n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n-        }\n-\n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n-        }\n-\n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n-\n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n+    /**\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n+     */\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n-//---------------------------------------------------------------------------------------\n-//endregion\n+    /**\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     */\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n \n-//region new organization\n-//---------------------------------------------------------------------------------------\n-//region SDK initialization\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    /**\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n+     */\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+            return;\n         }\n \n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n-//endregion\n \n-//region SDK functions\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Updates the current user.\n+     * @param dataFields\n+     */\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n+     */\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    }\n+\n+    /**\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n+     */\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n+    }\n \n-        onLogin(authToken);\n+    /**\n+     * Disables the device from push notifications\n+     */\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    /**\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+    }\n+\n+    /**\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n     /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n      */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n-    }\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n         if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n+\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n     /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n      */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n+        }\n+\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n //endregion\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"oid": "4f4ae81abffbffbd7da2eee168789a821a67ba0e", "url": "https://github.com/Iterable/iterable-android-sdk/commit/4f4ae81abffbffbd7da2eee168789a821a67ba0e", "message": "pass authToken along for GET requests too", "committedDate": "2020-07-17T22:36:07Z", "type": "commit"}, {"oid": "019a4939bdabee4c08bbd8fe098a81098b95ea38", "url": "https://github.com/Iterable/iterable-android-sdk/commit/019a4939bdabee4c08bbd8fe098a81098b95ea38", "message": "check if authToken is null before including it", "committedDate": "2020-07-17T22:36:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2MzEzMQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r457563131", "body": "`setUserId:` is an iOS syntax.", "bodyText": "setUserId: is an iOS syntax.", "bodyHTML": "<p dir=\"auto\"><code>setUserId:</code> is an iOS syntax.</p>", "author": "vbabenkoru", "createdAt": "2020-07-20T17:08:02Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -275,6 +276,18 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n+    /**\n+     * Set user email used for API calls\n+     * Calling this or `setUserId:` is required before making any API calls.", "originalCommit": "019a4939bdabee4c08bbd8fe098a81098b95ea38", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb02c1699670800de502e3eccdde6149be7ea840", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex d24fd3d..e4eaa29 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -276,18 +275,6 @@ private static final String TAG = \"IterableApi\";\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or `setUserId:` is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "a1d8fc647f2eeb604c110973a30a64162ef229c9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e4eaa29..ac402db 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -269,12 +270,24 @@ private static final String TAG = \"IterableApi\";\n \n     /**\n      * Set user email used for API calls\n-     * Calling this or `setUserId:` is required before making any API calls.\n+     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n      *\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n+    /**\n+     * Set user email used for API calls\n+     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n+     *\n+     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n+     * @param email User email\n+     * @param authToken Authorization token\n+     */\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "fd1cbaabb910bc602d2622da043f336507f7711d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ac402db..bc6a7d0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -288,20 +288,20 @@ private static final String TAG = \"IterableApi\";\n      * @param authToken Authorization token\n      */\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            return;\n-        }\n+        if (_email != null && !_email.equals(email)) {\n+            onLogOut();\n \n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n+            _email = email;\n+            _userId = null;\n+            _authToken = authToken;\n+\n+            storeAuthData();\n \n-        onLogOut();\n-        _email = email;\n-        _userId = null;\n-        _authToken = authToken;\n-        storeAuthData();\n-        onLogIn();\n+            onLogIn();\n+        } else if (email != null && (_authToken == null || _authToken != authToken)) {\n+            _authToken = authToken;\n+            storeAuthData();\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "3648b4944ab08b771426e18caef749dbb5064454", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex bc6a7d0..5eb97af 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -298,7 +298,7 @@ private static final String TAG = \"IterableApi\";\n             storeAuthData();\n \n             onLogIn();\n-        } else if (email != null && (_authToken == null || _authToken != authToken)) {\n+        } else if (email != null && email.equals(_email) && (_authToken == null || _authToken != authToken)) {\n             _authToken = authToken;\n             storeAuthData();\n         }\n", "next_change": {"commit": "efea88220596dbd60c1dcd7126ca14b2f5a88e12", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 5eb97af..a3e360a 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -288,19 +288,28 @@ private static final String TAG = \"IterableApi\";\n      * @param authToken Authorization token\n      */\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && !_email.equals(email)) {\n+        if (email == null) {\n             onLogOut();\n \n-            _email = email;\n+            _email = null;\n             _userId = null;\n+            _authToken = null;\n+\n+            storeAuthData();\n+        } else if (_email.equals(email) && _authToken != authToken) {\n             _authToken = authToken;\n \n             storeAuthData();\n+        } else if (!_email.equals(email)) {\n+            onLogOut();\n \n-            onLogIn();\n-        } else if (email != null && email.equals(_email) && (_authToken == null || _authToken != authToken)) {\n+            _email = email;\n+            _userId = null;\n             _authToken = authToken;\n+\n             storeAuthData();\n+\n+            onLogIn();\n         }\n     }\n \n", "next_change": {"commit": "39a61a76f8d10594b69460757f9559a7962de741", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a3e360a..39570f6 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -288,29 +288,20 @@ private static final String TAG = \"IterableApi\";\n      * @param authToken Authorization token\n      */\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (email == null) {\n-            onLogOut();\n-\n-            _email = null;\n-            _userId = null;\n-            _authToken = null;\n-\n-            storeAuthData();\n-        } else if (_email.equals(email) && _authToken != authToken) {\n-            _authToken = authToken;\n-\n-            storeAuthData();\n-        } else if (!_email.equals(email)) {\n-            onLogOut();\n-\n-            _email = email;\n-            _userId = null;\n-            _authToken = authToken;\n-\n-            storeAuthData();\n+        if (_email != null && _email.equals(email)) {\n+            return;\n+        }\n \n-            onLogIn();\n+        if (_email == null && _userId == null && email == null) {\n+            return;\n         }\n+\n+        onLogOut();\n+        _email = email;\n+        _userId = null;\n+        _authToken = authToken;\n+        storeAuthData();\n+        onLogIn();\n     }\n \n     /**\n", "next_change": {"commit": "429adeba1a7b93b70405daab7c9a42ca0df70868", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 39570f6..f5653a6 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -300,6 +326,7 @@ private static final String TAG = \"IterableApi\";\n         _email = email;\n         _userId = null;\n         _authToken = authToken;\n+//        _authToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\";\n         storeAuthData();\n         onLogIn();\n     }\n", "next_change": {"commit": "e8e896e7f6fc9c7a67210ad002b8e56c6489d172", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex f5653a6..c7b5340 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -326,7 +335,6 @@ private static final String TAG = \"IterableApi\";\n         _email = email;\n         _userId = null;\n         _authToken = authToken;\n-//        _authToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\";\n         storeAuthData();\n         onLogIn();\n     }\n", "next_change": {"commit": "116518fb0f50a3ff033121a0e85da7a730352415", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex c7b5340..9313cf8 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -294,49 +290,17 @@ private static final String TAG = \"IterableApi\";\n      * @param email User email\n      */\n     public void setEmail(@Nullable String email) {\n-        getAuthManager().requestNewAuthToken();\n-\n         onLogOut();\n         _email = email;\n         _userId = null;\n         storeAuthData();\n-        onLogIn();\n-    }\n \n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     * @param authToken Authorization token\n-     */\n-    void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            if (_authToken == null && authToken == null) {\n-                return;\n+        getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n+            @Override\n+            public void onSuccess(@NonNull String authToken) {\n+                setAuthToken(authToken);\n             }\n-\n-            if (_authToken != null && _authToken.equals(authToken)) {\n-                return;\n-            }\n-\n-            _authToken = authToken;\n-            storeAuthData();\n-\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        onLogOut();\n-        _email = email;\n-        _userId = null;\n-        _authToken = authToken;\n-        storeAuthData();\n-        onLogIn();\n+        });\n     }\n \n     /**\n", "next_change": {"commit": "5a2c35091502c101e79bfca2391dbfdf39b7c4c4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9313cf8..713d3ab 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -295,12 +295,16 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n-            @Override\n-            public void onSuccess(@NonNull String authToken) {\n-                setAuthToken(authToken);\n-            }\n-        });\n+        if (email != null) {\n+            getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n+                @Override\n+                public void onSuccess(@NonNull String authToken) {\n+                    onSetAuthToken(authToken);\n+                }\n+            });\n+        } else {\n+            onSetAuthToken(null);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "a16ff86dd1460af0bdb6ae200aaae829b4a16481", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 713d3ab..e8936ab 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -296,14 +304,9 @@ private static final String TAG = \"IterableApi\";\n         storeAuthData();\n \n         if (email != null) {\n-            getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n-                @Override\n-                public void onSuccess(@NonNull String authToken) {\n-                    onSetAuthToken(authToken);\n-                }\n-            });\n+            getAuthManager().requestNewAuthToken(false);\n         } else {\n-            onSetAuthToken(null);\n+            setAuthToken(null);\n         }\n     }\n \n", "next_change": {"commit": "2db97108c261008ed4b1d5f29c70eaa4318b1275", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e8936ab..a15c5c9 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -297,17 +350,21 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n-    public void setEmail(@Nullable String email) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        if (_email != null && _email.equals(email)) {\n+            return;\n+        }\n+\n+        if (_email == null && _userId == null && email == null) {\n+            return;\n+        }\n+\n         onLogOut();\n         _email = email;\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "3287dc085a83f1e75e09982baad3625fb6684b8c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a15c5c9..3c9e5cd 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -364,7 +360,11 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        onLogin(authToken);\n+        if (email != null) {\n+            getAuthManager().requestNewAuthToken(false);\n+        } else {\n+            setAuthToken(null);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "ea141c605aca86d0d85418a66a8f1296263454d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd..882bb40 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -355,16 +359,13 @@ private static final String TAG = \"IterableApi\";\n             return;\n         }\n \n-        onLogOut();\n+        logoutPreviousUser();\n+\n         _email = email;\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40..45c33cc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,7 +365,11 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        onLogin(authToken);\n+        if (email != null) {\n+            getAuthManager().requestNewAuthToken(false);\n+        } else {\n+            setAuthToken(null);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "b6b77024af90a60aecb60d6f15264ab69f1b571b", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc..6496d51 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,11 +365,13 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+//        if (email != null) {\n+//            getAuthManager().requestNewAuthToken(false);\n+//        } else {\n+//            setAuthToken(null);\n+//        }\n+\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "ae2dedfa1de5ec18c047fa1edb42c431570702af", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 6496d51..c015230 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,12 +365,6 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-//        if (email != null) {\n-//            getAuthManager().requestNewAuthToken(false);\n-//        } else {\n-//            setAuthToken(null);\n-//        }\n-\n         onLogin(authToken);\n     }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex c015230..b03b5b1 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,149 +249,17 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, false);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b1..9b34a0d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d..96f643f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2MzcxMQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r457563711", "body": "Same as above", "bodyText": "Same as above", "bodyHTML": "<p dir=\"auto\">Same as above</p>", "author": "vbabenkoru", "createdAt": "2020-07-20T17:09:08Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -298,6 +312,18 @@ public void setEmail(@Nullable String email) {\n      * @param userId User ID\n      */\n     public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    /**\n+     * Set user ID used for API calls\n+     * Calling this or `setEmail:` is required before making any API calls.", "originalCommit": "019a4939bdabee4c08bbd8fe098a81098b95ea38", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fb02c1699670800de502e3eccdde6149be7ea840", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex d24fd3d..e4eaa29 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -312,18 +298,6 @@ private static final String TAG = \"IterableApi\";\n      * @param userId User ID\n      */\n     public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or `setEmail:` is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     * @param authToken Authorization token\n-     */\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n         if (_userId != null && _userId.equals(userId)) {\n             return;\n         }\n", "next_change": {"commit": "a1d8fc647f2eeb604c110973a30a64162ef229c9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e4eaa29..ac402db 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -286,18 +299,31 @@ private static final String TAG = \"IterableApi\";\n         onLogOut();\n         _email = email;\n         _userId = null;\n-        storeEmailAndUserId();\n+        _authToken = authToken;\n+        storeAuthData();\n         onLogIn();\n     }\n \n     /**\n      * Set user ID used for API calls\n-     * Calling this or `setEmail:` is required before making any API calls.\n+     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n      *\n      * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n      * @param userId User ID\n      */\n     public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    /**\n+     * Set user ID used for API calls\n+     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n+     *\n+     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n+     * @param userId User ID\n+     * @param authToken Authorization token\n+     */\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n         if (_userId != null && _userId.equals(userId)) {\n             return;\n         }\n", "next_change": {"commit": "fd1cbaabb910bc602d2622da043f336507f7711d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ac402db..bc6a7d0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -324,27 +324,27 @@ private static final String TAG = \"IterableApi\";\n      * @param authToken Authorization token\n      */\n     public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n+        if (_userId != null && !_userId.equals(userId)) {\n+            onLogOut();\n \n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n+            _email = null;\n+            _userId = userId;\n+            _authToken = authToken;\n+\n+            storeAuthData();\n \n-        onLogOut();\n-        _email = null;\n-        _userId = userId;\n-        _authToken = authToken;\n-        storeAuthData();\n-        onLogIn();\n+            onLogIn();\n+        } else if (userId != null & (_authToken == null || _authToken != authToken)) {\n+            _authToken = authToken;\n+            storeAuthData();\n+        }\n     }\n \n     /**\n      * Tracks a click on the uri if it is an iterable link.\n      * @param uri the\n      * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not a Iterable link.\n+     *                   or the original url if it is not an Iterable link.\n      */\n     public static void getAndTrackDeeplink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n         IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n", "next_change": {"commit": "a25ec805df060991fb94eccc3c19958650866398", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex bc6a7d0..bf05e3c 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -346,8 +399,8 @@ private static final String TAG = \"IterableApi\";\n      * @param onCallback Calls the callback handler with the destination location\n      *                   or the original url if it is not an Iterable link.\n      */\n-    public static void getAndTrackDeeplink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback, config.allowedProtocols);\n     }\n \n     /**\n", "next_change": {"commit": "2bfb786453bdc527544450f336e5a12990a98169", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex bf05e3c..7b35883 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -400,7 +402,7 @@ private static final String TAG = \"IterableApi\";\n      *                   or the original url if it is not an Iterable link.\n      */\n     public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback, config.allowedProtocols);\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2NDkyNA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r457564924", "body": "```suggestion\r\n                        urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT + iterableApiRequest.authToken);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT+iterableApiRequest.authToken);\n          \n          \n            \n                                    urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT + iterableApiRequest.authToken);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        urlConnection<span class=\"pl-k\">.</span>setRequestProperty(<span class=\"pl-smi\">IterableConstants</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>HEADER_SDK_AUTHORIZATION</span>, <span class=\"pl-smi\">IterableConstants</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>HEADER_SDK_AUTH_FORMAT</span><span class=\"pl-k x x-first x-last\">+</span>iterableApiRequest<span class=\"pl-k\">.</span>authToken);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        urlConnection<span class=\"pl-k\">.</span>setRequestProperty(<span class=\"pl-smi\">IterableConstants</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>HEADER_SDK_AUTHORIZATION</span>, <span class=\"pl-smi\">IterableConstants</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>HEADER_SDK_AUTH_FORMAT</span><span class=\"x x-first\"> </span><span class=\"pl-k x\">+</span><span class=\"x x-last\"> </span>iterableApiRequest<span class=\"pl-k\">.</span>authToken);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vbabenkoru", "createdAt": "2020-07-20T17:11:18Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java", "diffHunk": "@@ -84,6 +84,10 @@ protected String doInBackground(IterableApiRequest... params) {\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_PLATFORM, \"Android\");\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_VERSION, IterableConstants.ITBL_KEY_SDK_VERSION_NUMBER);\n \n+                    if (iterableApiRequest.authToken != null) {\n+                        urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT+iterableApiRequest.authToken);", "originalCommit": "019a4939bdabee4c08bbd8fe098a81098b95ea38", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1d8fc647f2eeb604c110973a30a64162ef229c9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex 9f3978c..5c1838c 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -85,7 +85,7 @@ class IterableRequest extends AsyncTask<IterableApiRequest, Void, String> {\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_VERSION, IterableConstants.ITBL_KEY_SDK_VERSION_NUMBER);\n \n                     if (iterableApiRequest.authToken != null) {\n-                        urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT+iterableApiRequest.authToken);\n+                        urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT + iterableApiRequest.authToken);\n                     }\n \n                     IterableLogger.v(TAG, \"GET Request \\nURI : \" + baseUrl + iterableApiRequest.resourcePath + buildHeaderString(urlConnection) + \"\\n body : \\n\" + iterableApiRequest.json.toString(2));\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2NTA5NQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r457565095", "body": "```suggestion\r\n                    urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT + iterableApiRequest.authToken);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT+iterableApiRequest.authToken);\n          \n          \n            \n                                urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT + iterableApiRequest.authToken);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    urlConnection<span class=\"pl-k\">.</span>setRequestProperty(<span class=\"pl-smi\">IterableConstants</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>HEADER_SDK_AUTHORIZATION</span>, <span class=\"pl-smi\">IterableConstants</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>HEADER_SDK_AUTH_FORMAT</span><span class=\"pl-k x x-first x-last\">+</span>iterableApiRequest<span class=\"pl-k\">.</span>authToken);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    urlConnection<span class=\"pl-k\">.</span>setRequestProperty(<span class=\"pl-smi\">IterableConstants</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>HEADER_SDK_AUTHORIZATION</span>, <span class=\"pl-smi\">IterableConstants</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>HEADER_SDK_AUTH_FORMAT</span><span class=\"x x-first\"> </span><span class=\"pl-k x\">+</span><span class=\"x x-last\"> </span>iterableApiRequest<span class=\"pl-k\">.</span>authToken);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "vbabenkoru", "createdAt": "2020-07-20T17:11:33Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java", "diffHunk": "@@ -100,6 +104,8 @@ protected String doInBackground(IterableApiRequest... params) {\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_API_KEY, iterableApiRequest.apiKey);\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_PLATFORM, \"Android\");\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_VERSION, IterableConstants.ITBL_KEY_SDK_VERSION_NUMBER);\n+                    //TODO: check if this is okay to pass in a null value to the authToken\n+                    urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT+iterableApiRequest.authToken);", "originalCommit": "019a4939bdabee4c08bbd8fe098a81098b95ea38", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1d8fc647f2eeb604c110973a30a64162ef229c9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex 9f3978c..5c1838c 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -104,8 +104,10 @@ class IterableRequest extends AsyncTask<IterableApiRequest, Void, String> {\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_API_KEY, iterableApiRequest.apiKey);\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_PLATFORM, \"Android\");\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_VERSION, IterableConstants.ITBL_KEY_SDK_VERSION_NUMBER);\n-                    //TODO: check if this is okay to pass in a null value to the authToken\n-                    urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT+iterableApiRequest.authToken);\n+\n+                    if (iterableApiRequest.authToken != null) {\n+                        urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT + iterableApiRequest.authToken);\n+                    }\n \n                     IterableLogger.v(TAG, \"POST Request \\nURI : \" + baseUrl + iterableApiRequest.resourcePath + buildHeaderString(urlConnection) + \"\\n body : \\n\" + iterableApiRequest.json.toString(2));\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2NTUyMg==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r457565522", "body": "I think it is better to insert it conditionally, like above for GET, otherwise it looks like the request is trying to authenticate and passes an empty token.", "bodyText": "I think it is better to insert it conditionally, like above for GET, otherwise it looks like the request is trying to authenticate and passes an empty token.", "bodyHTML": "<p dir=\"auto\">I think it is better to insert it conditionally, like above for GET, otherwise it looks like the request is trying to authenticate and passes an empty token.</p>", "author": "vbabenkoru", "createdAt": "2020-07-20T17:12:19Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java", "diffHunk": "@@ -100,6 +104,8 @@ protected String doInBackground(IterableApiRequest... params) {\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_API_KEY, iterableApiRequest.apiKey);\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_PLATFORM, \"Android\");\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_VERSION, IterableConstants.ITBL_KEY_SDK_VERSION_NUMBER);\n+                    //TODO: check if this is okay to pass in a null value to the authToken", "originalCommit": "019a4939bdabee4c08bbd8fe098a81098b95ea38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU5NjA4Nw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r457596087", "bodyText": "Whoops! I forgot this. Will add.", "author": "roninopf", "createdAt": "2020-07-20T18:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2NTUyMg=="}], "type": "inlineReview", "revised_code": {"commit": "a1d8fc647f2eeb604c110973a30a64162ef229c9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\nindex 9f3978c..5c1838c 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableRequest.java\n", "chunk": "@@ -104,8 +104,10 @@ class IterableRequest extends AsyncTask<IterableApiRequest, Void, String> {\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_API_KEY, iterableApiRequest.apiKey);\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_PLATFORM, \"Android\");\n                     urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_VERSION, IterableConstants.ITBL_KEY_SDK_VERSION_NUMBER);\n-                    //TODO: check if this is okay to pass in a null value to the authToken\n-                    urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT+iterableApiRequest.authToken);\n+\n+                    if (iterableApiRequest.authToken != null) {\n+                        urlConnection.setRequestProperty(IterableConstants.HEADER_SDK_AUTHORIZATION, IterableConstants.HEADER_SDK_AUTH_FORMAT + iterableApiRequest.authToken);\n+                    }\n \n                     IterableLogger.v(TAG, \"POST Request \\nURI : \" + baseUrl + iterableApiRequest.resourcePath + buildHeaderString(urlConnection) + \"\\n body : \\n\" + iterableApiRequest.json.toString(2));\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzU2NjM0Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r457566343", "body": "What do you think about `SHARED_PREFS_AUTH_TOKEN_KEY`? `AUTHTOKEN` seems a bit hard to read to me.", "bodyText": "What do you think about SHARED_PREFS_AUTH_TOKEN_KEY? AUTHTOKEN seems a bit hard to read to me.", "bodyHTML": "<p dir=\"auto\">What do you think about <code>SHARED_PREFS_AUTH_TOKEN_KEY</code>? <code>AUTHTOKEN</code> seems a bit hard to read to me.</p>", "author": "vbabenkoru", "createdAt": "2020-07-20T17:13:49Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java", "diffHunk": "@@ -95,6 +97,7 @@\n     public static final String SHARED_PREFS_EMAIL_KEY = \"itbl_email\";\n     public static final String SHARED_PREFS_USERID_KEY = \"itbl_userid\";\n     public static final String SHARED_PREFS_DEVICEID_KEY = \"itbl_deviceid\";\n+    public static final String SHARED_PREFS_AUTHTOKEN_KEY = \"itbl_authtoken\";", "originalCommit": "019a4939bdabee4c08bbd8fe098a81098b95ea38", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a1d8fc647f2eeb604c110973a30a64162ef229c9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\nindex 744a734..47c8fcc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n", "chunk": "@@ -97,7 +97,7 @@ public final class IterableConstants {\n     public static final String SHARED_PREFS_EMAIL_KEY = \"itbl_email\";\n     public static final String SHARED_PREFS_USERID_KEY = \"itbl_userid\";\n     public static final String SHARED_PREFS_DEVICEID_KEY = \"itbl_deviceid\";\n-    public static final String SHARED_PREFS_AUTHTOKEN_KEY = \"itbl_authtoken\";\n+    public static final String SHARED_PREFS_AUTH_TOKEN_KEY = \"itbl_authtoken\";\n     public static final String SHARED_PREFS_DDL_CHECKED_KEY = \"itbl_ddl_checked\";\n     public static final String SHARED_PREFS_EXPIRATION_SUFFIX = \"_expiration\";\n     public static final String SHARED_PREFS_OBJECT_SUFFIX = \"_object\";\n", "next_change": {"commit": "1402e45e7e57cc21915beed35588ebd81ada1627", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\nindex 47c8fcc..1f7d376 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n", "chunk": "@@ -106,6 +107,8 @@ public final class IterableConstants {\n     public static final String SHARED_PREFS_ATTRIBUTION_INFO_KEY = \"itbl_attribution_info\";\n     public static final int    SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS = 24;\n     public static final String SHARED_PREFS_FCM_MIGRATION_DONE_KEY = \"itbl_fcm_migration_done\";\n+    public static final String SHARED_PREFS_SAVED_CONFIGURATION = \"itbl_saved_configuration\";\n+    public static final String SHARED_PREFS_OFFLINE_MODE_BETA_KEY = \"offlineModeBeta\";\n \n     //Action buttons\n     public static final String ITBL_BUTTON_IDENTIFIER        = \"identifier\";\n", "next_change": {"commit": "28939af694278fd2a7b30b2999530c6a02f0d8d3", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\nindex 1f7d376..384851f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n", "chunk": "@@ -107,8 +109,6 @@ public final class IterableConstants {\n     public static final String SHARED_PREFS_ATTRIBUTION_INFO_KEY = \"itbl_attribution_info\";\n     public static final int    SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS = 24;\n     public static final String SHARED_PREFS_FCM_MIGRATION_DONE_KEY = \"itbl_fcm_migration_done\";\n-    public static final String SHARED_PREFS_SAVED_CONFIGURATION = \"itbl_saved_configuration\";\n-    public static final String SHARED_PREFS_OFFLINE_MODE_BETA_KEY = \"offlineModeBeta\";\n \n     //Action buttons\n     public static final String ITBL_BUTTON_IDENTIFIER        = \"identifier\";\n", "next_change": {"commit": "f44badd732e183dce2dc91992bddc750a7588f4f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\nindex 384851f..913af9a 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n", "chunk": "@@ -109,6 +109,8 @@ public final class IterableConstants {\n     public static final String SHARED_PREFS_ATTRIBUTION_INFO_KEY = \"itbl_attribution_info\";\n     public static final int    SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS = 24;\n     public static final String SHARED_PREFS_FCM_MIGRATION_DONE_KEY = \"itbl_fcm_migration_done\";\n+    public static final String SHARED_PREFS_SAVED_CONFIGURATION = \"itbl_saved_configuration\";\n+    public static final String SHARED_PREFS_OFFLINE_MODE_BETA_KEY = \"offlineModeBeta\";\n \n     //Action buttons\n     public static final String ITBL_BUTTON_IDENTIFIER        = \"identifier\";\n", "next_change": {"commit": "16bda798ab032b458fc28065041db976d9acd45f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\nindex 913af9a..7d57cd3 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n", "chunk": "@@ -111,6 +112,7 @@ public final class IterableConstants {\n     public static final String SHARED_PREFS_FCM_MIGRATION_DONE_KEY = \"itbl_fcm_migration_done\";\n     public static final String SHARED_PREFS_SAVED_CONFIGURATION = \"itbl_saved_configuration\";\n     public static final String SHARED_PREFS_OFFLINE_MODE_BETA_KEY = \"offlineModeBeta\";\n+    public static final String SHARED_PREFS_OFFLINE_MODE_KEY = \"offlineMode\";\n \n     //Action buttons\n     public static final String ITBL_BUTTON_IDENTIFIER        = \"identifier\";\n", "next_change": {"commit": "bd0594f237559bdcb0c0c15f8d1b2e38977c0972", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\nindex 7d57cd3..45ec525 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n", "chunk": "@@ -111,8 +110,7 @@ public final class IterableConstants {\n     public static final int    SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS = 24;\n     public static final String SHARED_PREFS_FCM_MIGRATION_DONE_KEY = \"itbl_fcm_migration_done\";\n     public static final String SHARED_PREFS_SAVED_CONFIGURATION = \"itbl_saved_configuration\";\n-    public static final String SHARED_PREFS_OFFLINE_MODE_BETA_KEY = \"offlineModeBeta\";\n-    public static final String SHARED_PREFS_OFFLINE_MODE_KEY = \"offlineMode\";\n+    public static final String SHARED_PREFS_OFFLINE_MODE_KEY = \"SDKOfflineMode\";\n \n     //Action buttons\n     public static final String ITBL_BUTTON_IDENTIFIER        = \"identifier\";\n", "next_change": {"commit": "b0e3f885090fc151951df5b0e7a6563ea9f797ee", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\nindex 45ec525..d2fa283 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableConstants.java\n", "chunk": "@@ -110,7 +111,7 @@ public final class IterableConstants {\n     public static final int    SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS = 24;\n     public static final String SHARED_PREFS_FCM_MIGRATION_DONE_KEY = \"itbl_fcm_migration_done\";\n     public static final String SHARED_PREFS_SAVED_CONFIGURATION = \"itbl_saved_configuration\";\n-    public static final String SHARED_PREFS_OFFLINE_MODE_KEY = \"SDKOfflineMode\";\n+    public static final String SHARED_PREFS_OFFLINE_MODE_KEY = \"itbl_offline_mode\";\n \n     //Action buttons\n     public static final String ITBL_BUTTON_IDENTIFIER        = \"identifier\";\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"oid": "a1d8fc647f2eeb604c110973a30a64162ef229c9", "url": "https://github.com/Iterable/iterable-android-sdk/commit/a1d8fc647f2eeb604c110973a30a64162ef229c9", "message": "add token check around POST requests", "committedDate": "2020-07-20T18:20:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYyNzAwOA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r457627008", "body": "lol", "bodyText": "lol", "bodyHTML": "<p dir=\"auto\">lol</p>", "author": "vbabenkoru", "createdAt": "2020-07-20T19:01:13Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -309,15 +335,16 @@ public void setUserId(@Nullable String userId) {\n         onLogOut();\n         _email = null;\n         _userId = userId;\n-        storeEmailAndUserId();\n+        _authToken = authToken;\n+        storeAuthData();\n         onLogIn();\n     }\n \n     /**\n      * Tracks a click on the uri if it is an iterable link.\n      * @param uri the\n      * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not a interable link.\n+     *                   or the original url if it is not a Iterable link.", "originalCommit": "a1d8fc647f2eeb604c110973a30a64162ef229c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY1NzgwOA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r457657808", "bodyText": "I realized I missed an \"an\" in there too ;)", "author": "roninopf", "createdAt": "2020-07-20T19:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzYyNzAwOA=="}], "type": "inlineReview", "revised_code": {"commit": "fb02c1699670800de502e3eccdde6149be7ea840", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ac402db..e4eaa29 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -335,8 +309,7 @@ private static final String TAG = \"IterableApi\";\n         onLogOut();\n         _email = null;\n         _userId = userId;\n-        _authToken = authToken;\n-        storeAuthData();\n+        storeEmailAndUserId();\n         onLogIn();\n     }\n \n", "next_change": {"commit": "70daeeb860779876ed1fc861b517689d77ea920c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e4eaa29..334ad89 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -309,7 +335,8 @@ private static final String TAG = \"IterableApi\";\n         onLogOut();\n         _email = null;\n         _userId = userId;\n-        storeEmailAndUserId();\n+        _authToken = authToken;\n+        storeAuthData();\n         onLogIn();\n     }\n \n", "next_change": {"commit": "fd1cbaabb910bc602d2622da043f336507f7711d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 334ad89..bc6a7d0 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -324,20 +324,20 @@ private static final String TAG = \"IterableApi\";\n      * @param authToken Authorization token\n      */\n     public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n+        if (_userId != null && !_userId.equals(userId)) {\n+            onLogOut();\n \n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n+            _email = null;\n+            _userId = userId;\n+            _authToken = authToken;\n+\n+            storeAuthData();\n \n-        onLogOut();\n-        _email = null;\n-        _userId = userId;\n-        _authToken = authToken;\n-        storeAuthData();\n-        onLogIn();\n+            onLogIn();\n+        } else if (userId != null & (_authToken == null || _authToken != authToken)) {\n+            _authToken = authToken;\n+            storeAuthData();\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "3648b4944ab08b771426e18caef749dbb5064454", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex bc6a7d0..5eb97af 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -334,7 +334,7 @@ private static final String TAG = \"IterableApi\";\n             storeAuthData();\n \n             onLogIn();\n-        } else if (userId != null & (_authToken == null || _authToken != authToken)) {\n+        } else if (userId != null && userId.equals(_userId) && (_authToken == null || _authToken != authToken)) {\n             _authToken = authToken;\n             storeAuthData();\n         }\n", "next_change": {"commit": "efea88220596dbd60c1dcd7126ca14b2f5a88e12", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 5eb97af..a3e360a 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -324,19 +333,28 @@ private static final String TAG = \"IterableApi\";\n      * @param authToken Authorization token\n      */\n     public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && !_userId.equals(userId)) {\n+        if (userId == null) {\n             onLogOut();\n \n             _email = null;\n-            _userId = userId;\n+            _userId = null;\n+            _authToken = null;\n+\n+            storeAuthData();\n+        } else if (_userId.equals(userId) && _authToken != authToken) {\n             _authToken = authToken;\n \n             storeAuthData();\n+        } else if (!_userId.equals(userId)) {\n+            onLogOut();\n \n-            onLogIn();\n-        } else if (userId != null && userId.equals(_userId) && (_authToken == null || _authToken != authToken)) {\n+            _email = null;\n+            _userId = userId;\n             _authToken = authToken;\n+\n             storeAuthData();\n+\n+            onLogIn();\n         }\n     }\n \n", "next_change": {"commit": "39a61a76f8d10594b69460757f9559a7962de741", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a3e360a..39570f6 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -333,29 +324,20 @@ private static final String TAG = \"IterableApi\";\n      * @param authToken Authorization token\n      */\n     public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (userId == null) {\n-            onLogOut();\n-\n-            _email = null;\n-            _userId = null;\n-            _authToken = null;\n-\n-            storeAuthData();\n-        } else if (_userId.equals(userId) && _authToken != authToken) {\n-            _authToken = authToken;\n-\n-            storeAuthData();\n-        } else if (!_userId.equals(userId)) {\n-            onLogOut();\n-\n-            _email = null;\n-            _userId = userId;\n-            _authToken = authToken;\n-\n-            storeAuthData();\n+        if (_userId != null && _userId.equals(userId)) {\n+            return;\n+        }\n \n-            onLogIn();\n+        if (_email == null && _userId == null && userId == null) {\n+            return;\n         }\n+\n+        onLogOut();\n+        _email = null;\n+        _userId = userId;\n+        _authToken = authToken;\n+        storeAuthData();\n+        onLogIn();\n     }\n \n     /**\n", "next_change": {"commit": "5a2c35091502c101e79bfca2391dbfdf39b7c4c4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 39570f6..713d3ab 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -323,22 +340,33 @@ private static final String TAG = \"IterableApi\";\n      * @param userId User ID\n      * @param authToken Authorization token\n      */\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n-        onLogOut();\n-        _email = null;\n-        _userId = userId;\n-        _authToken = authToken;\n-        storeAuthData();\n-        onLogIn();\n-    }\n+//    void setUserId(@Nullable String userId, @Nullable String authToken) {\n+//        if (_userId != null && _userId.equals(userId)) {\n+//            if (_authToken == null && authToken == null) {\n+//                return;\n+//            }\n+//\n+//            if (_authToken != null && _authToken.equals(authToken)) {\n+//                return;\n+//            }\n+//\n+//            _authToken = authToken;\n+//            storeAuthData();\n+//\n+//            return;\n+//        }\n+//\n+//        if (_email == null && _userId == null && userId == null) {\n+//            return;\n+//        }\n+//\n+//        onLogOut();\n+//        _email = null;\n+//        _userId = userId;\n+//        _authToken = authToken;\n+//        storeAuthData();\n+//        onLogIn();\n+//    }\n \n     /**\n      * Tracks a click on the uri if it is an iterable link.\n", "next_change": {"commit": "04ad748a9c1fd5a13abc9cef7feddf3cbd5721c4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 713d3ab..80ab082 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -332,42 +332,6 @@ private static final String TAG = \"IterableApi\";\n         }\n     }\n \n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     * @param authToken Authorization token\n-     */\n-//    void setUserId(@Nullable String userId, @Nullable String authToken) {\n-//        if (_userId != null && _userId.equals(userId)) {\n-//            if (_authToken == null && authToken == null) {\n-//                return;\n-//            }\n-//\n-//            if (_authToken != null && _authToken.equals(authToken)) {\n-//                return;\n-//            }\n-//\n-//            _authToken = authToken;\n-//            storeAuthData();\n-//\n-//            return;\n-//        }\n-//\n-//        if (_email == null && _userId == null && userId == null) {\n-//            return;\n-//        }\n-//\n-//        onLogOut();\n-//        _email = null;\n-//        _userId = userId;\n-//        _authToken = authToken;\n-//        storeAuthData();\n-//        onLogIn();\n-//    }\n-\n     /**\n      * Tracks a click on the uri if it is an iterable link.\n      * @param uri the\n", "next_change": {"commit": "a16ff86dd1460af0bdb6ae200aaae829b4a16481", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 80ab082..e8936ab 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -321,14 +324,9 @@ private static final String TAG = \"IterableApi\";\n         storeAuthData();\n \n         if (userId != null) {\n-            getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n-                @Override\n-                public void onSuccess(@NonNull String authToken) {\n-                    onSetAuthToken(authToken);\n-                }\n-            });\n+            getAuthManager().requestNewAuthToken(false);\n         } else {\n-            onSetAuthToken(null);\n+            setAuthToken(null);\n         }\n     }\n \n", "next_change": {"commit": "2db97108c261008ed4b1d5f29c70eaa4318b1275", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e8936ab..a15c5c9 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -318,16 +375,20 @@ private static final String TAG = \"IterableApi\";\n      * @param userId User ID\n      */\n     public void setUserId(@Nullable String userId) {\n+        if (_userId != null && _userId.equals(userId)) {\n+            return;\n+        }\n+\n+        if (_email == null && _userId == null && userId == null) {\n+            return;\n+        }\n+\n         onLogOut();\n         _email = null;\n         _userId = userId;\n         storeAuthData();\n \n-        if (userId != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+        completeUserLogin();\n     }\n \n     /**\n", "next_change": {"commit": "3287dc085a83f1e75e09982baad3625fb6684b8c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a15c5c9..3c9e5cd 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -388,7 +388,11 @@ private static final String TAG = \"IterableApi\";\n         _userId = userId;\n         storeAuthData();\n \n-        completeUserLogin();\n+        if (userId != null) {\n+            getAuthManager().requestNewAuthToken(false);\n+        } else {\n+            setAuthToken(null);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "ea141c605aca86d0d85418a66a8f1296263454d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd..882bb40 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -383,16 +384,13 @@ private static final String TAG = \"IterableApi\";\n             return;\n         }\n \n-        onLogOut();\n+        logoutPreviousUser();\n+\n         _email = null;\n         _userId = userId;\n         storeAuthData();\n \n-        if (userId != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+        completeUserLogin();\n     }\n \n     /**\n", "next_change": {"commit": "5cca36845fcf0bb85893ba45507deb41a8debc81", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40..9960903 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -390,7 +396,7 @@ private static final String TAG = \"IterableApi\";\n         _userId = userId;\n         storeAuthData();\n \n-        completeUserLogin();\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9960903..45c33cc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -396,7 +398,11 @@ private static final String TAG = \"IterableApi\";\n         _userId = userId;\n         storeAuthData();\n \n-        onLogin(authToken);\n+        if (userId != null) {\n+            getAuthManager().requestNewAuthToken(false);\n+        } else {\n+            setAuthToken(null);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "b6b77024af90a60aecb60d6f15264ab69f1b571b", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc..6496d51 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -398,11 +400,13 @@ private static final String TAG = \"IterableApi\";\n         _userId = userId;\n         storeAuthData();\n \n-        if (userId != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+//        if (userId != null) {\n+//            getAuthManager().requestNewAuthToken(false);\n+//        } else {\n+//            setAuthToken(null);\n+//        }\n+\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "ae2dedfa1de5ec18c047fa1edb42c431570702af", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 6496d51..c015230 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -400,12 +394,6 @@ private static final String TAG = \"IterableApi\";\n         _userId = userId;\n         storeAuthData();\n \n-//        if (userId != null) {\n-//            getAuthManager().requestNewAuthToken(false);\n-//        } else {\n-//            setAuthToken(null);\n-//        }\n-\n         onLogin(authToken);\n     }\n \n", "next_change": {"commit": "4100141101fdf973d456cd14e7c70478fe3b0024", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex c015230..baad255 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -397,6 +401,13 @@ private static final String TAG = \"IterableApi\";\n         onLogin(authToken);\n     }\n \n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n+        }\n+    }\n+\n     /**\n      * Tracks a click on the uri if it is an iterable link.\n      * @param uri the\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex baad255..9b34a0d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -247,165 +196,66 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-\n     /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n      */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n         }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n-    }\n-\n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n \n     /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n      *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n     }\n \n     /**\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d..96f643f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e4eaa29..334ad89 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -317,7 +344,7 @@ private static final String TAG = \"IterableApi\";\n      * Tracks a click on the uri if it is an iterable link.\n      * @param uri the\n      * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not a interable link.\n+     *                   or the original url if it is not an Iterable link.\n      */\n     public static void getAndTrackDeeplink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n         IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n", "next_change": {"commit": "a25ec805df060991fb94eccc3c19958650866398", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 334ad89..bf05e3c 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -346,8 +399,8 @@ private static final String TAG = \"IterableApi\";\n      * @param onCallback Calls the callback handler with the destination location\n      *                   or the original url if it is not an Iterable link.\n      */\n-    public static void getAndTrackDeeplink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback, config.allowedProtocols);\n     }\n \n     /**\n", "next_change": {"commit": "2bfb786453bdc527544450f336e5a12990a98169", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex bf05e3c..7b35883 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -400,7 +402,7 @@ private static final String TAG = \"IterableApi\";\n      *                   or the original url if it is not an Iterable link.\n      */\n     public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback, config.allowedProtocols);\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ac402db..e4eaa29 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -344,7 +317,7 @@ private static final String TAG = \"IterableApi\";\n      * Tracks a click on the uri if it is an iterable link.\n      * @param uri the\n      * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not a Iterable link.\n+     *                   or the original url if it is not a interable link.\n      */\n     public static void getAndTrackDeeplink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n         IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n", "next_change": {"commit": "70daeeb860779876ed1fc861b517689d77ea920c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e4eaa29..334ad89 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -317,7 +344,7 @@ private static final String TAG = \"IterableApi\";\n      * Tracks a click on the uri if it is an iterable link.\n      * @param uri the\n      * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not a interable link.\n+     *                   or the original url if it is not an Iterable link.\n      */\n     public static void getAndTrackDeeplink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n         IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n", "next_change": {"commit": "a25ec805df060991fb94eccc3c19958650866398", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 334ad89..bf05e3c 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -346,8 +399,8 @@ private static final String TAG = \"IterableApi\";\n      * @param onCallback Calls the callback handler with the destination location\n      *                   or the original url if it is not an Iterable link.\n      */\n-    public static void getAndTrackDeeplink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback, config.allowedProtocols);\n     }\n \n     /**\n", "next_change": {"commit": "2bfb786453bdc527544450f336e5a12990a98169", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex bf05e3c..7b35883 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -400,7 +402,7 @@ private static final String TAG = \"IterableApi\";\n      *                   or the original url if it is not an Iterable link.\n      */\n     public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback, config.allowedProtocols);\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}]}}, {"oid": "70daeeb860779876ed1fc861b517689d77ea920c", "url": "https://github.com/Iterable/iterable-android-sdk/commit/70daeeb860779876ed1fc861b517689d77ea920c", "message": "comment typo", "committedDate": "2020-07-20T19:59:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1NjAyOA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r459656028", "body": "@davidtruong @Ayyanchira @roninopf Looks like this breaks the public API. We should fix this before shipping a release.", "bodyText": "@davidtruong @Ayyanchira @roninopf Looks like this breaks the public API. We should fix this before shipping a release.", "bodyHTML": "<p dir=\"auto\"><a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/davidtruong/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/davidtruong\">@davidtruong</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/Ayyanchira/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/Ayyanchira\">@Ayyanchira</a> <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/roninopf/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/roninopf\">@roninopf</a> Looks like this breaks the public API. We should fix this before shipping a release.</p>", "author": "vbabenkoru", "createdAt": "2020-07-23T18:46:17Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -499,17 +526,28 @@ public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Null\n      * @param newEmail New email\n      */\n     public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null);\n+        updateEmail(newEmail, null, null, null);\n     }\n \n     /**\n      * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param authToken Authorization token\n+     */\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    /**\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n      * @param newEmail New email\n+     * @param authToken\n      * @param successHandler Success handler. Called when the server returns a success code.\n      * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {", "originalCommit": "70daeeb860779876ed1fc861b517689d77ea920c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1ODM3OA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/247#discussion_r459658378", "bodyText": "We'll need to include another updateEmail overload with (new email, on success, on failure) for backwards compatability.", "author": "davidtruong", "createdAt": "2020-07-23T18:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1NjAyOA=="}], "type": "inlineReview", "revised_code": {"commit": "fb02c1699670800de502e3eccdde6149be7ea840", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 334ad89..e4eaa29 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -526,28 +499,17 @@ private static final String TAG = \"IterableApi\";\n      * @param newEmail New email\n      */\n     public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        updateEmail(newEmail, null, null);\n     }\n \n     /**\n      * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param authToken Authorization token\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n-    }\n-\n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n      * @param newEmail New email\n-     * @param authToken\n      * @param successHandler Success handler. Called when the server returns a success code.\n      * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n         if (!checkSDKInitialization()) {\n             IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n                     \"calling updateEmail\");\n", "next_change": {"commit": "882a42d848c3df273be40df4d013748ce08a7e2f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e4eaa29..2f3003c 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -499,17 +526,28 @@ private static final String TAG = \"IterableApi\";\n      * @param newEmail New email\n      */\n     public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null);\n+        updateEmail(newEmail, null, null, null);\n     }\n \n     /**\n      * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param authToken Authorization token\n+     */\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    /**\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n      * @param newEmail New email\n+     * @param authToken\n      * @param successHandler Success handler. Called when the server returns a success code.\n      * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n         if (!checkSDKInitialization()) {\n             IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n                     \"calling updateEmail\");\n", "next_change": {"commit": "39a61a76f8d10594b69460757f9559a7962de741", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 2f3003c..39570f6 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -547,7 +559,7 @@ private static final String TAG = \"IterableApi\";\n      * @param successHandler Success handler. Called when the server returns a success code.\n      * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+    private void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n         if (!checkSDKInitialization()) {\n             IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n                     \"calling updateEmail\");\n", "next_change": {"commit": "9289d2f90dae400b87ce93490afc7dccd675cb9a", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 39570f6..eeabb59 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -559,7 +569,7 @@ private static final String TAG = \"IterableApi\";\n      * @param successHandler Success handler. Called when the server returns a success code.\n      * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    private void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n         if (!checkSDKInitialization()) {\n             IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n                     \"calling updateEmail\");\n", "next_change": {"commit": "b2157dc6d41300e43a92665963be297e8aa6df6f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex eeabb59..b6e256f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -569,7 +582,7 @@ private static final String TAG = \"IterableApi\";\n      * @param successHandler Success handler. Called when the server returns a success code.\n      * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+    private void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n         if (!checkSDKInitialization()) {\n             IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n                     \"calling updateEmail\");\n", "next_change": {"commit": "116518fb0f50a3ff033121a0e85da7a730352415", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b6e256f..9313cf8 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -571,19 +558,7 @@ private static final String TAG = \"IterableApi\";\n      * @param failureHandler Failure handler. Called when the server call failed.\n      */\n     public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, _authToken, successHandler, failureHandler);\n-    }\n-\n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param authToken\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    private void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n+       if (!checkSDKInitialization()) {\n             IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n                     \"calling updateEmail\");\n             if (failureHandler != null) {\n", "next_change": {"commit": "06888274345669bd35a1a765be8fc5a6ae2a5842", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9313cf8..e26ded1 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -567,38 +534,22 @@ private static final String TAG = \"IterableApi\";\n             }\n             return;\n         }\n-        JSONObject requestJSON = new JSONObject();\n \n-        try {\n-            if (_email != null) {\n-                requestJSON.put(IterableConstants.KEY_CURRENT_EMAIL, _email);\n-            } else {\n-                requestJSON.put(IterableConstants.KEY_CURRENT_USERID, _userId);\n-            }\n-            requestJSON.put(IterableConstants.KEY_NEW_EMAIL, newEmail);\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n \n-            sendPostRequest(IterableConstants.ENDPOINT_UPDATE_EMAIL, requestJSON, new IterableHelper.SuccessHandler() {\n-                @Override\n-                public void onSuccess(@NonNull JSONObject data) {\n-                    if (_email != null) {\n-                        _email = newEmail;\n-                    }\n-                    getAuthManager().requestNewAuthToken(false, new IterableHelper.SuccessAuthHandler() {\n-                        @Override\n-                        public void onSuccess(@NonNull String authToken) {\n-                            setAuthToken(authToken);\n-                        }\n-                    });\n-\n-                    storeAuthData();\n-                    if (successHandler != null) {\n-                        successHandler.onSuccess(data);\n-                    }\n                 }\n-            }, failureHandler);\n-        } catch (JSONException e) {\n-            e.printStackTrace();\n-        }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n", "next_change": {"commit": "a97b5c87477bf940a89ec91aef427ee2a1d44d44", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e26ded1..b01454d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -539,14 +590,14 @@ IterableApi() {\n             @Override\n             public void onSuccess(@NonNull JSONObject data) {\n                 if (_email != null) {\n-                    _email = newEmail;\n+                    setEmail(newEmail, authToken);\n                 }\n \n                 storeAuthData();\n                 getAuthManager().requestNewAuthToken(false);\n+\n                 if (successHandler != null) {\n                     successHandler.onSuccess(data);\n-\n                 }\n             }\n         }, failureHandler);\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b01454d..45c33cc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -590,14 +593,14 @@ private static final String TAG = \"IterableApi\";\n             @Override\n             public void onSuccess(@NonNull JSONObject data) {\n                 if (_email != null) {\n-                    setEmail(newEmail, authToken);\n+                    _email = newEmail;\n                 }\n \n                 storeAuthData();\n                 getAuthManager().requestNewAuthToken(false);\n-\n                 if (successHandler != null) {\n                     successHandler.onSuccess(data);\n+\n                 }\n             }\n         }, failureHandler);\n", "next_change": {"commit": "b7e917f87f001eb456bcefc0039751a451713647", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc..ee7cf34 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -593,14 +598,14 @@ private static final String TAG = \"IterableApi\";\n             @Override\n             public void onSuccess(@NonNull JSONObject data) {\n                 if (_email != null) {\n-                    _email = newEmail;\n+                    setEmail(newEmail, authToken);\n                 }\n \n                 storeAuthData();\n                 getAuthManager().requestNewAuthToken(false);\n+\n                 if (successHandler != null) {\n                     successHandler.onSuccess(data);\n-\n                 }\n             }\n         }, failureHandler);\n", "next_change": {"commit": "bd0594f237559bdcb0c0c15f8d1b2e38977c0972", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ee7cf34..fc9cbc4 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -598,14 +585,14 @@ private static final String TAG = \"IterableApi\";\n             @Override\n             public void onSuccess(@NonNull JSONObject data) {\n                 if (_email != null) {\n-                    setEmail(newEmail, authToken);\n+                    _email = newEmail;\n                 }\n \n                 storeAuthData();\n                 getAuthManager().requestNewAuthToken(false);\n-\n                 if (successHandler != null) {\n                     successHandler.onSuccess(data);\n+\n                 }\n             }\n         }, failureHandler);\n", "next_change": {"commit": "42ae0158572533f77068dc93e7c01807f61c29da", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex fc9cbc4..9e125a7 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -585,14 +598,14 @@ private static final String TAG = \"IterableApi\";\n             @Override\n             public void onSuccess(@NonNull JSONObject data) {\n                 if (_email != null) {\n-                    _email = newEmail;\n+                    setEmail(newEmail, authToken);\n                 }\n \n                 storeAuthData();\n                 getAuthManager().requestNewAuthToken(false);\n+\n                 if (successHandler != null) {\n                     successHandler.onSuccess(data);\n-\n                 }\n             }\n         }, failureHandler);\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9e125a7..96f643f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -505,634 +785,332 @@ private static final String TAG = \"IterableApi\";\n      */\n     public void track(@NonNull String eventName, int campaignId, int templateId) {\n         track(eventName, campaignId, templateId, null);\n-    }\n-\n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n-    }\n-\n-    /**\n-     * Updates the status of the cart\n-     * @param items\n-     */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n-\n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n-    }\n-\n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n-    }\n-\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n-    }\n-\n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-       if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n-\n-            return;\n-        }\n-\n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    setEmail(newEmail, authToken);\n-                }\n-\n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n-\n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n-\n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n-    }\n-\n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n-    }\n-\n-    private String getPushIntegrationName() {\n-        if (config.pushIntegrationName != null) {\n-            return config.pushIntegrationName;\n-        } else {\n-            return _applicationContext.getPackageName();\n-        }\n-    }\n-\n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n-    }\n-\n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n-    }\n-\n-    /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n-     */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n-    }\n-\n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.getInAppMessages(count, onCallback);\n-    }\n-\n-    /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n-     */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n-\n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n-    }\n-\n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n-            return;\n-        }\n-\n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n-    }\n-\n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n+    }\n+\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n-            return;\n-        }\n-\n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n-            return;\n-        }\n-\n-        apiClient.trackInAppDelivery(message);\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Consumes an InApp message.\n-     * @param messageId\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n-        }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n+    /**\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     */\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n \n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n         if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n             return;\n         }\n \n-        apiClient.trackInAppOpen(messageId);\n-    }\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n \n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n-     */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n-\n-//---------------------------------------------------------------------------------------\n-//endregion\n \n-//region Package-Protected Functions\n-//---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get user email\n-     * @return user email\n-     */\n-    String getEmail() {\n-        return _email;\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Get user ID\n-     * @return user ID\n+     * Disables the device from push notifications\n      */\n-    String getUserId() {\n-        return _userId;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Get the authentication token\n-     * @return authentication token\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n      */\n-    String getAuthToken() {\n-        return _authToken;\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-//---------------------------------------------------------------------------------------\n-//endregion\n-\n-//region Protected Functions\n-//---------------------------------------------------------------------------------------\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n \n-    /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n-     */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Tracks an in-app open.\n+     * @param message in-app message\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n-    }\n-\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n-    }\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n-    }\n-\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+            return;\n+        }\n+\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n             return;\n         }\n \n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n-\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Private Functions\n+//region DEPRECATED - API public functions\n //---------------------------------------------------------------------------------------\n-\n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n-\n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n     }\n+//endregion\n \n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n-    }\n-\n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInboxSession(session, inboxSessionId);\n     }\n \n     @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}