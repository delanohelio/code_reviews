{"pr_number": 284, "pr_title": "[MOB-2046] - Setting up database", "pr_author": "Ayyanchira", "pr_createdAt": "2020-11-12T01:53:24Z", "pr_url": "https://github.com/Iterable/iterable-android-sdk/pull/284", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3MTk5Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r524471993", "body": "I think this class has various levels of abstraction. It manages/create a database (low level), but also manages tasks. Tasks seem to be a higher level abstraction that may be better placed in its own class, especially if we're planning to use the database for other things in the future.", "bodyText": "I think this class has various levels of abstraction. It manages/create a database (low level), but also manages tasks. Tasks seem to be a higher level abstraction that may be better placed in its own class, especially if we're planning to use the database for other things in the future.", "bodyHTML": "<p dir=\"auto\">I think this class has various levels of abstraction. It manages/create a database (low level), but also manages tasks. Tasks seem to be a higher level abstraction that may be better placed in its own class, especially if we're planning to use the database for other things in the future.</p>", "author": "vbabenkoru", "createdAt": "2020-11-16T18:09:20Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableDataManager.java", "diffHunk": "@@ -0,0 +1,176 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteOpenHelper;\n+\n+public class IterableDataManager {\n+\n+    private static IterableDataManager sharedInstance;\n+\n+    private static final String TAG = \"IterableDataManager\";\n+    private static final String DATABASE_NAME = \"iterable_sdk.db\";\n+    private static final int DATABASE_VERSION = 1;\n+    private static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+\n+    private static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+    private ContentValues contentValues = new ContentValues();\n+    private boolean hasDatabaseError = false;\n+\n+    IterableDataManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableDataManager sharedInstance() {\n+        if(sharedInstance == null) {\n+            sharedInstance = new IterableDataManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /*\n+    * Create and insert a new task in the database\n+    *\n+    * */\n+    void createTask(String name) {", "originalCommit": "784ce12393d904547be5c4216a52a5eeefa11d76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "446e7d66f080c0b6fa4869bef7fd372d551c0dd2", "url": "https://github.com/Iterable/iterable-android-sdk/commit/446e7d66f080c0b6fa4869bef7fd372d551c0dd2", "message": "[MOB-2046] - Setting up database\n\n1. Created Datamanager\n2. Created DatabaseManager\n3. Created IterableTask class acting as dao for offline events", "committedDate": "2020-11-20T17:18:00Z", "type": "commit"}, {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "url": "https://github.com/Iterable/iterable-android-sdk/commit/2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "message": "Revision 1\n\n1. Renamed `IterableDataManager` to `IterableTaskManager`. Also renamed `IterableDatabaseManager` to `IterableTaskDatabaseManager`. For new modules needing database access, they can always use the SQLiteOpenHelper like `IterableTaskDatabaseManager`.\n2. Added more methods to IterableTaskManager to update the database entries for tasks.", "committedDate": "2020-11-20T17:19:09Z", "type": "commit"}, {"oid": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "url": "https://github.com/Iterable/iterable-android-sdk/commit/2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "message": "Revision 1\n\n1. Renamed `IterableDataManager` to `IterableTaskManager`. Also renamed `IterableDatabaseManager` to `IterableTaskDatabaseManager`. For new modules needing database access, they can always use the SQLiteOpenHelper like `IterableTaskDatabaseManager`.\n2. Added more methods to IterableTaskManager to update the database entries for tasks.", "committedDate": "2020-11-20T17:19:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjI4NA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042284", "body": "Remove", "bodyText": "Remove", "bodyHTML": "<p dir=\"auto\">Remove</p>", "author": "vbabenkoru", "createdAt": "2020-11-21T00:53:00Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -35,6 +38,7 @@\n      * {@link IterableApi} singleton instance\n      */\n     static volatile IterableApi sharedInstance = new IterableApi();\n+    private static IterableTaskManager dataManager;", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "458607a1f40f7fd9c10413f3e8e6964e0047d506", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 51fb1ee..557ad74 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -38,7 +35,6 @@ private static final String TAG = \"IterableApi\";\n      * {@link IterableApi} singleton instance\n      */\n     static volatile IterableApi sharedInstance = new IterableApi();\n-    private static IterableTaskManager dataManager;\n \n     private Context _applicationContext;\n     IterableConfig config;\n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 557ad74..b03b5b1 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -30,7 +27,6 @@ public class IterableApi {\n //region Variables\n //---------------------------------------------------------------------------------------\n private static final String TAG = \"IterableApi\";\n-\n     /**\n      * {@link IterableApi} singleton instance\n      */\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b1..9b34a0d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,38 +23,44 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-\n-//region Variables\n+//region SDK initialization\n //---------------------------------------------------------------------------------------\n-private static final String TAG = \"IterableApi\";\n-    /**\n-     * {@link IterableApi} singleton instance\n-     */\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n+    }\n \n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n+    }\n \n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-//---------------------------------------------------------------------------------------\n-//endregion\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n+        }\n+\n+        sharedInstance.retrieveEmailAndUserId();\n+\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n+\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n+    }\n+\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    }\n \n-//region Constructor\n-//---------------------------------------------------------------------------------------\n     IterableApi() {\n         config = new IterableConfig.Builder().build();\n     }\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d..96f643f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjMwNg==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042306", "body": "Remove", "bodyText": "Remove", "bodyHTML": "<p dir=\"auto\">Remove</p>", "author": "vbabenkoru", "createdAt": "2020-11-21T00:53:06Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java", "diffHunk": "@@ -307,6 +311,24 @@ public static void initialize(@NonNull Context context, @NonNull String apiKey,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n         IterablePushActionReceiver.processPendingAction(context);\n+\n+        //TODO: Temporary code to test. Datamanger would eventually either go to IterableRequest or apiInternal as architecture concretes.", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "458607a1f40f7fd9c10413f3e8e6964e0047d506", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 51fb1ee..557ad74 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -311,24 +307,6 @@ private static final String TAG = \"IterableApi\";\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n         IterablePushActionReceiver.processPendingAction(context);\n-\n-        //TODO: Temporary code to test. Datamanger would eventually either go to IterableRequest or apiInternal as architecture concretes.\n-        //TODO: Have test methods to test all TaskManager methods.\n-        if (dataManager == null) {\n-            dataManager = new IterableTaskManager();\n-        }\n-        dataManager.createTask(\"testTask\");\n-        ArrayList<String> taskIDsInDB = dataManager.getAllTaskIds();\n-        IterableLogger.v(TAG, \"These are the tasks in DB now..\");\n-        for (String taskId: taskIDsInDB\n-             ) {\n-            IterableLogger.v(\"Offline\", taskId);\n-            IterableTask task = dataManager.getTask(taskId);\n-            IterableLogger.v(TAG+\"Thats Task\",task.createdAt.toString());\n-            dataManager.updateModifiedAt(taskId, new Date());\n-        }\n-\n-\n     }\n \n     /**\n", "next_change": {"commit": "9fe092b6653b709eb59e85092641549475ac901f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 557ad74..e085947 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -306,6 +306,7 @@ private static final String TAG = \"IterableApi\";\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(sharedInstance.config.offlineProcessing);\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n", "next_change": {"commit": "cd6b41db6c9114d1b6a7bfb49b5ff4cb5b0771e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex e085947..be05479 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -310,6 +310,24 @@ private static final String TAG = \"IterableApi\";\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                try {\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(data.getBoolean(\"offlineModeBeta\"));\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"OfflineMode parameter not found\");\n+                }\n+            }\n+        }, new IterableHelper.FailureHandler() {\n+            @Override\n+            public void onFailure(@NonNull String reason, @Nullable JSONObject data) {\n+                IterableLogger.e(TAG, \"Failed to fetch remote configuration. Default values will be used\");\n+            }\n+        });\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "19b2053245b7171ddffbc4046af8c2a6ab616443", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex be05479..2bb6511 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -311,20 +311,16 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.SuccessHandler() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n             @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n+            public void execute(@Nullable String data) {\n                 try {\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(data.getBoolean(\"offlineModeBeta\"));\n+                    JSONObject jsonData = new JSONObject(data);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(jsonData.getBoolean(\"offlineModeBeta\"));\n                 } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"OfflineMode parameter not found\");\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n                 }\n             }\n-        }, new IterableHelper.FailureHandler() {\n-            @Override\n-            public void onFailure(@NonNull String reason, @Nullable JSONObject data) {\n-                IterableLogger.e(TAG, \"Failed to fetch remote configuration. Default values will be used\");\n-            }\n         });\n     }\n \n", "next_change": {"commit": "1402e45e7e57cc21915beed35588ebd81ada1627", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 2bb6511..9179736 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -306,17 +306,28 @@ private static final String TAG = \"IterableApi\";\n             sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n                     sharedInstance.config.inAppDisplayInterval);\n         }\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(sharedInstance.config.offlineProcessing);\n+        loadLastSavedConfiguration(context);\n         IterablePushActionReceiver.processPendingAction(context);\n     }\n \n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    }\n+\n     void fetchRemoteConfiguration() {\n         apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n             @Override\n             public void execute(@Nullable String data) {\n                 try {\n                     JSONObject jsonData = new JSONObject(data);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(jsonData.getBoolean(\"offlineModeBeta\"));\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, offlineConfiguration);\n+                    editor.apply();\n                 } catch (JSONException e) {\n                     IterableLogger.e(TAG, \"Failed to read remote configuration\");\n                 }\n", "next_change": {"commit": "2db97108c261008ed4b1d5f29c70eaa4318b1275", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9179736..a15c5c9 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -335,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "3287dc085a83f1e75e09982baad3625fb6684b8c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a15c5c9..3c9e5cd 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "ea141c605aca86d0d85418a66a8f1296263454d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd..882bb40 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40..45c33cc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "b7e917f87f001eb456bcefc0039751a451713647", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc..ee7cf34 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "bd0594f237559bdcb0c0c15f8d1b2e38977c0972", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex ee7cf34..fc9cbc4 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "42ae0158572533f77068dc93e7c01807f61c29da", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex fc9cbc4..9e125a7 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,6 +339,10 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "0818f8d620d08706d7157875d42030ea55730fe4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9e125a7..129e8fa 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -339,10 +339,6 @@ private static final String TAG = \"IterableApi\";\n         });\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n     /**\n      * Set user email used for API calls\n      * Calling this or {@link #setUserId(String)} is required before making any API calls.\n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 129e8fa..b03b5b1 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,149 +249,17 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b1..9b34a0d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d..96f643f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40..45c33cc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,6 +346,10 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n", "next_change": {"commit": "4100141101fdf973d456cd14e7c70478fe3b0024", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc..baad255 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -351,7 +351,9 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n         if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex baad255..b03b5b1 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,155 +249,12 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n     private void checkAndUpdateAuthToken(@Nullable String authToken) {\n         // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n         if (config.authHandler != null && authToken != null && authToken != _authToken) {\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b1..9b34a0d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d..96f643f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd..882bb40 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -346,7 +350,7 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n-    public void setEmail(@Nullable String email) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40..45c33cc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,6 +346,10 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n", "next_change": {"commit": "4100141101fdf973d456cd14e7c70478fe3b0024", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc..baad255 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -351,7 +351,9 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n         if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex baad255..b03b5b1 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,155 +249,12 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n     private void checkAndUpdateAuthToken(@Nullable String authToken) {\n         // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n         if (config.authHandler != null && authToken != null && authToken != _authToken) {\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b1..9b34a0d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d..96f643f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex a15c5c9..3c9e5cd 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,7 +346,7 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+    public void setEmail(@Nullable String email) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "ea141c605aca86d0d85418a66a8f1296263454d5", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd..882bb40 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -346,7 +350,7 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n-    public void setEmail(@Nullable String email) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n         }\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40..45c33cc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -350,6 +346,10 @@ private static final String TAG = \"IterableApi\";\n      * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n      * @param email User email\n      */\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n+    }\n+\n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n         if (_email != null && _email.equals(email)) {\n             return;\n", "next_change": {"commit": "4100141101fdf973d456cd14e7c70478fe3b0024", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc..baad255 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -351,7 +351,9 @@ private static final String TAG = \"IterableApi\";\n     }\n \n     public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n         if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex baad255..b03b5b1 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,155 +249,12 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n         boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n     private void checkAndUpdateAuthToken(@Nullable String authToken) {\n         // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n         if (config.authHandler != null && authToken != null && authToken != _authToken) {\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b1..9b34a0d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d..96f643f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 3c9e5cd..882bb40 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -355,16 +359,13 @@ private static final String TAG = \"IterableApi\";\n             return;\n         }\n \n-        onLogOut();\n+        logoutPreviousUser();\n+\n         _email = email;\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "d98744800d57b88d94d64a2d124eb6f24c35ffbf", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 882bb40..45c33cc 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,7 +365,11 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        onLogin(authToken);\n+        if (email != null) {\n+            getAuthManager().requestNewAuthToken(false);\n+        } else {\n+            setAuthToken(null);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "b6b77024af90a60aecb60d6f15264ab69f1b571b", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 45c33cc..6496d51 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,11 +365,13 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-        if (email != null) {\n-            getAuthManager().requestNewAuthToken(false);\n-        } else {\n-            setAuthToken(null);\n-        }\n+//        if (email != null) {\n+//            getAuthManager().requestNewAuthToken(false);\n+//        } else {\n+//            setAuthToken(null);\n+//        }\n+\n+        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "ae2dedfa1de5ec18c047fa1edb42c431570702af", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 6496d51..c015230 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -365,12 +365,6 @@ private static final String TAG = \"IterableApi\";\n         _userId = null;\n         storeAuthData();\n \n-//        if (email != null) {\n-//            getAuthManager().requestNewAuthToken(false);\n-//        } else {\n-//            setAuthToken(null);\n-//        }\n-\n         onLogin(authToken);\n     }\n \n", "next_change": {"commit": "25acec4bad334751cb3de23e5fe228afb2d1330d", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex c015230..b03b5b1 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -252,149 +249,17 @@ private static final String TAG = \"IterableApi\";\n \n //region Public Functions\n //---------------------------------------------------------------------------------------\n-\n-    /**\n-     * Get {@link IterableApi} singleton instance\n-     * @return {@link IterableApi} singleton instance\n-     */\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n-    }\n-\n-    /**\n-     * Initializes IterableApi\n-     * This method must be called from {@link Application#onCreate()}\n-     * Note: Make sure you also call {@link #setEmail(String)} or {@link #setUserId(String)} before calling other methods\n-     *\n-     * @param context Application context\n-     * @param apiKey Iterable Mobile API key\n-     * @param config {@link IterableConfig} object holding SDK configuration options\n-     */\n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n-\n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n-        }\n-\n-        sharedInstance.retrieveEmailAndUserId();\n-\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n-\n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n-\n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n-    }\n-\n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-    }\n-\n     static void loadLastSavedConfiguration(Context context) {\n         SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, false);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n         sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    void fetchRemoteConfiguration() {\n-        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-            @Override\n-            public void execute(@Nullable String data) {\n-                if (data == null) {\n-                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                    return;\n-                }\n-                try {\n-                    JSONObject jsonData = new JSONObject(data);\n-                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY);\n-                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                    SharedPreferences.Editor editor = sharedPref.edit();\n-                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_BETA_KEY, offlineConfiguration);\n-                    editor.apply();\n-                } catch (JSONException e) {\n-                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-                }\n-            }\n-        });\n-    }\n-\n-    /**\n-     * Set user email used for API calls\n-     * Calling this or {@link #setUserId(String)} is required before making any API calls.\n-     *\n-     * Note: This clears userId and persists the user email so you only need to call this once when the user logs in.\n-     * @param email User email\n-     */\n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n-    }\n-\n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        if (_email != null && _email.equals(email)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && email == null) {\n-            return;\n-        }\n-\n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n-    }\n-\n-    /**\n-     * Set user ID used for API calls\n-     * Calling this or {@link #setEmail(String)} is required before making any API calls.\n-     *\n-     * Note: This clears user email and persists the user ID so you only need to call this once when the user logs in.\n-     * @param userId User ID\n-     */\n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n-    }\n-\n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        if (_userId != null && _userId.equals(userId)) {\n-            return;\n-        }\n-\n-        if (_email == null && _userId == null && userId == null) {\n-            return;\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n-\n-        logoutPreviousUser();\n-\n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n-\n-        onLogin(authToken);\n     }\n \n     /**\n", "next_change": {"commit": "e48e52d64aaa33f03aa26bf2547aeb3669eaecd9", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex b03b5b1..9b34a0d 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -244,33 +196,77 @@ private static final String TAG = \"IterableApi\";\n     public void removeDeviceAttribute(String key) {\n         deviceAttributes.remove(key);\n     }\n-//---------------------------------------------------------------------------------------\n //endregion\n \n-//region Public Functions\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n+            return;\n+        }\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n+    }\n+\n+    /**\n+     * Consumes an InApp message.\n+     * @param messageId\n+     */\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n+            return;\n+        }\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n+    }\n+\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n+\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n+    }\n \n     /**\n      * Handles an App Link\n", "next_change": {"commit": "7beac5fc66dfaf7969a0c3c5d287e2a6e620d376", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\nindex 9b34a0d..96f643f 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableApi.java\n", "chunk": "@@ -23,1105 +22,1105 @@ import java.util.UUID;\n  * Created by David Truong dt@iterable.com\n  */\n public class IterableApi {\n-//region SDK initialization\n+//region SDK (private/internal)\n //---------------------------------------------------------------------------------------\n-    @NonNull\n-    public static IterableApi getInstance() {\n-        return sharedInstance;\n+    private static final String TAG = \"IterableApi\";\n+    private Context _applicationContext;\n+    IterableConfig config;\n+    private String _apiKey;\n+    private String _email;\n+    private String _userId;\n+    private String _authToken;\n+    private boolean _debugMode;\n+    private Bundle _payloadData;\n+    private IterableNotificationData _notificationData;\n+    private String _deviceId;\n+    private boolean _firstForegroundHandled;\n+\n+    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n+    private @Nullable IterableInAppManager inAppManager;\n+    private String inboxSessionId;\n+    private IterableAuthManager authManager;\n+    private HashMap<String, String> deviceAttributes = new HashMap<>();\n+\n+    void fetchRemoteConfiguration() {\n+        apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n+            @Override\n+            public void execute(@Nullable String data) {\n+                if (data == null) {\n+                    IterableLogger.e(TAG, \"Remote configuration returned null\");\n+                    return;\n+                }\n+                try {\n+                    JSONObject jsonData = new JSONObject(data);\n+                    boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n+                    sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n+                    SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+                    SharedPreferences.Editor editor = sharedPref.edit();\n+                    editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n+                    editor.apply();\n+                } catch (JSONException e) {\n+                    IterableLogger.e(TAG, \"Failed to read remote configuration\");\n+                }\n+            }\n+        });\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n-        initialize(context, apiKey, null);\n+    String getEmail() {\n+        return _email;\n     }\n \n-    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n-        sharedInstance._applicationContext = context.getApplicationContext();\n-        sharedInstance._apiKey = apiKey;\n-        sharedInstance.config = config;\n+    String getUserId() {\n+        return _userId;\n+    }\n \n-        if (sharedInstance.config == null) {\n-            sharedInstance.config = new IterableConfig.Builder().build();\n+    String getAuthToken() {\n+        return _authToken;\n+    }\n+\n+    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n+        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n+        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n+            setAuthToken(authToken);\n         }\n+    }\n \n-        sharedInstance.retrieveEmailAndUserId();\n+    /**\n+     * Stores attribution information.\n+     * @param attributionInfo Attribution information object\n+     */\n+    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n+        if (_applicationContext == null) {\n+            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+            return;\n+        }\n \n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n-        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n+        IterableUtil.saveExpirableJsonObject(\n+                getPreferences(),\n+                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n+                attributionInfo.toJSONObject(),\n+                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n+        );\n+    }\n \n-        if (sharedInstance.inAppManager == null) {\n-            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n-                    sharedInstance.config.inAppDisplayInterval);\n-        }\n+    HashMap getDeviceAttributes() {\n+        return deviceAttributes;\n+    }\n \n-        loadLastSavedConfiguration(context);\n-        IterablePushNotificationUtil.processPendingAction(context);\n+    /**\n+     * Returns the current context for the application.\n+     * @return\n+     */\n+    Context getMainActivityContext() {\n+        return _applicationContext;\n     }\n \n-    public static void setContext(Context context) {\n-        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+    /**\n+     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableAuthManager} instance\n+     */\n+    @NonNull\n+    IterableAuthManager getAuthManager() {\n+        if (authManager == null) {\n+            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+        }\n+        return authManager;\n     }\n \n-    IterableApi() {\n-        config = new IterableConfig.Builder().build();\n+    static void loadLastSavedConfiguration(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n+        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n+        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Set the notification icon with the given iconName.\n+     * @param context\n+     * @param iconName\n+     */\n+    static void setNotificationIcon(Context context, String iconName) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        SharedPreferences.Editor editor = sharedPref.edit();\n+        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n+        editor.commit();\n     }\n \n-    @VisibleForTesting\n-    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n-        config = new IterableConfig.Builder().build();\n-        this.apiClient = apiClient;\n-        this.inAppManager = inAppManager;\n+    /**\n+     * Returns the stored notification icon.\n+     * @param context\n+     * @return\n+     */\n+    static String getNotificationIcon(Context context) {\n+        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n+        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n+        return iconName;\n     }\n-//endregion\n \n-//region SDK public functions\n-    static volatile IterableApi sharedInstance = new IterableApi();\n+    /**\n+     * Sets debug mode.\n+     * @param debugMode\n+     */\n+    void setDebugMode(boolean debugMode) {\n+        _debugMode = debugMode;\n+    }\n \n     /**\n-     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableInAppManager} instance\n+     * Gets the current state of the debug mode.\n+     * @return\n      */\n-    @NonNull\n-    public IterableInAppManager getInAppManager() {\n-        if (inAppManager == null) {\n-            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n-                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n+    boolean getDebugMode() {\n+        return _debugMode;\n+    }\n+\n+    /**\n+     * Set the payload for a given intent if it is from Iterable.\n+     * @param intent\n+     */\n+    void setPayloadData(Intent intent) {\n+        Bundle extras = intent.getExtras();\n+        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n+            setPayloadData(extras);\n         }\n-        return inAppManager;\n     }\n \n     /**\n-     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n-     * or app link click from an email.\n-     * @return {@link IterableAttributionInfo} Object containing\n+     * Sets the payload bundle.\n+     * @param bundle\n      */\n-    @Nullable\n-    public IterableAttributionInfo getAttributionInfo() {\n-        return IterableAttributionInfo.fromJSONObject(\n-                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n-        );\n+    void setPayloadData(Bundle bundle) {\n+        _payloadData = bundle;\n     }\n \n-    public void setEmail(@Nullable String email) {\n-        setEmail(email, null);\n+    /**\n+     * Sets the IterableNotification data\n+     * @param data\n+     */\n+    void setNotificationData(IterableNotificationData data) {\n+        _notificationData = data;\n+        if (data != null) {\n+            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n+        }\n     }\n \n-    public void setEmail(@Nullable String email, @Nullable String authToken) {\n-        //Only if passed in same non-null email\n-        if (_email != null && _email.equals(email)) {\n-            checkAndUpdateAuthToken(authToken);\n+    /**\n+     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n+     * Now package-private. If you were previously using this method, use\n+     * {@link IterableInAppManager#getMessages()} instead\n+     *\n+     * @param count      the number of messages to fetch\n+     * @param onCallback\n+     */\n+    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (_email == null && _userId == null && email == null) {\n+        apiClient.getInAppMessages(count, onCallback);\n+    }\n+\n+    /**\n+     * Tracks in-app delivery events (per in-app)\n+     * @param message the in-app message to be tracked as delivered */\n+    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        logoutPreviousUser();\n-\n-        _email = email;\n-        _userId = null;\n-        storeAuthData();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            return;\n+        }\n \n-        onLogin(authToken);\n+        apiClient.trackInAppDelivery(message);\n     }\n \n-    public void setUserId(@Nullable String userId) {\n-        setUserId(userId, null);\n+    private String getPushIntegrationName() {\n+        if (config.pushIntegrationName != null) {\n+            return config.pushIntegrationName;\n+        } else {\n+            return _applicationContext.getPackageName();\n+        }\n     }\n \n-    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n-        //If same non null userId is passed\n-        if (_userId != null && _userId.equals(userId)) {\n-            checkAndUpdateAuthToken(authToken);\n-            return;\n+    private void logoutPreviousUser() {\n+        if (config.autoPushRegistration && isInitialized()) {\n+            disablePush();\n         }\n \n-        if (_email == null && _userId == null && userId == null) {\n+        getInAppManager().reset();\n+        getAuthManager().clearRefreshTimer();\n+\n+        apiClient.onLogout();\n+    }\n+\n+    private void onLogin(@Nullable String authToken) {\n+        if (!isInitialized()) {\n+            setAuthToken(null);\n             return;\n         }\n \n-        logoutPreviousUser();\n+        if (authToken != null) {\n+            setAuthToken(authToken);\n+        } else {\n+            getAuthManager().requestNewAuthToken(false);\n+        }\n+    }\n \n-        _email = null;\n-        _userId = userId;\n-        storeAuthData();\n+    private void completeUserLogin() {\n+        if (!isInitialized()) {\n+            return;\n+        }\n \n-        onLogin(authToken);\n-    }\n+        if (config.autoPushRegistration) {\n+            registerForPush();\n+        }\n \n-    public void setAuthToken(String authToken) {\n-        setAuthToken(authToken, false);\n+        getInAppManager().syncInApp();\n     }\n \n-    /**\n-     * Sets the icon to be displayed in notifications.\n-     * The icon name should match the resource name stored in the /res/drawable directory.\n-     * @param iconName\n-     */\n-    public void setNotificationIcon(@Nullable String iconName) {\n-        setNotificationIcon(_applicationContext, iconName);\n-    }\n+    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n+        @Override\n+        public void onSwitchToForeground() {\n+            onForeground();\n+        }\n \n-    /**\n-     * Retrieves the payload string for a given key.\n-     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n-     * @param key\n-     * @return Returns the requested payload data from the current push campaign if it exists.\n-     */\n-    @Nullable\n-    public String getPayloadData(@NonNull String key) {\n-        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n-    }\n+        @Override\n+        public void onSwitchToBackground() {}\n+    };\n \n-    /**\n-     * Retrieves all of the payload as a single Bundle Object\n-     * @return Bundle\n-     */\n-    @Nullable\n-    public Bundle getPayloadData() {\n-        return _payloadData;\n+    private void onForeground() {\n+        if (!_firstForegroundHandled) {\n+            _firstForegroundHandled = true;\n+            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n+                IterableLogger.d(TAG, \"Performing automatic push registration\");\n+                sharedInstance.registerForPush();\n+            }\n+            fetchRemoteConfiguration();\n+        }\n     }\n \n-    public void setDeviceAttribute(String key, String value) {\n-        deviceAttributes.put(key, value);\n+    private boolean isInitialized() {\n+        return _apiKey != null && (_email != null || _userId != null);\n     }\n \n-    public void removeDeviceAttribute(String key) {\n-        deviceAttributes.remove(key);\n+    private boolean checkSDKInitialization() {\n+        if (!isInitialized()) {\n+            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n+            return false;\n+        }\n+        return true;\n     }\n-//endregion\n \n-//region API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * Registers a device token with Iterable.\n-     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n-     * @param deviceToken Push token obtained from GCM or FCM\n-     */\n-    public void registerDeviceToken(@NonNull String deviceToken) {\n-        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n+    private SharedPreferences getPreferences() {\n+        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n-        trackPushOpen(campaignId, templateId, messageId, null);\n+    private String getDeviceId() {\n+        if (_deviceId == null) {\n+            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n+            if (_deviceId == null) {\n+                _deviceId = UUID.randomUUID().toString();\n+                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n+            }\n+        }\n+        return _deviceId;\n     }\n \n-    /**\n-     * Tracks when a push notification is opened on device.\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n-        if (messageId == null) {\n-            IterableLogger.e(TAG, \"messageId is null\");\n-            return;\n+    private void storeAuthData() {\n+        try {\n+            SharedPreferences.Editor editor = getPreferences().edit();\n+            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n+            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n+            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n+            editor.commit();\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n         }\n-\n-        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n-    /**\n-     * Consumes an InApp message.\n-     * @param messageId\n-     */\n-    public void inAppConsume(@NonNull String messageId) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n-            return;\n+    private void retrieveEmailAndUserId() {\n+        try {\n+            SharedPreferences prefs = getPreferences();\n+            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n+            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n+            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n+            if (_authToken != null) {\n+                getAuthManager().queueExpirationRefresh(_authToken);\n+            }\n+        } catch (Exception e) {\n+            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n         }\n-        inAppConsume(message, null, null);\n-        IterableLogger.printInfo();\n     }\n \n-    /**\n-     * Tracks InApp delete.\n-     * This method from informs Iterable about inApp messages deleted with additional paramters.\n-     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n-     *\n-     * @param message message object\n-     * @param source An enum describing how the in App delete was triggered\n-     * @param clickLocation The module in which the action happened\n-     */\n-    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n+        @Nullable\n+        @Override\n+        public String getEmail() {\n+            return _email;\n         }\n \n-        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n-    }\n+        @Nullable\n+        @Override\n+        public String getUserId() {\n+            return _userId;\n+        }\n \n-    /**\n-     * Tracks a click on the uri if it is an iterable link.\n-     * @param uri the\n-     * @param onCallback Calls the callback handler with the destination location\n-     *                   or the original url if it is not an Iterable link.\n-     */\n-    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n-        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n-    }\n+        @Nullable\n+        @Override\n+        public String getAuthToken() {\n+            return _authToken;\n+        }\n \n-    /**\n-     * Handles an App Link\n-     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n-     * {@link IterableUrlHandler} for handling\n-     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n-     *\n-     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n-     * in your deep link handler activity\n-     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n-     *            handler activity\n-     * @return whether or not the app link was handled\n-     */\n-    public boolean handleAppLink(@NonNull String uri) {\n-        IterableLogger.printInfo();\n+        @Override\n+        public String getApiKey() {\n+            return _apiKey;\n+        }\n \n-        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n-            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n-                @Override\n-                public void execute(String originalUrl) {\n-                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n-                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n-                }\n-            });\n-            return true;\n-        } else {\n-            IterableAction action = IterableAction.actionOpenUrl(uri);\n-            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        @Override\n+        public String getDeviceId() {\n+            return IterableApi.this.getDeviceId();\n         }\n-    }\n \n-    /**\n-     * Debugging function to send API calls to different url endpoints.\n-     * @param url\n-     */\n-    public static void overrideURLEndpointPath(@NonNull String url) {\n-        IterableRequestTask.overrideUrl = url;\n-    }\n+        @Override\n+        public Context getContext() {\n+            return _applicationContext;\n+        }\n \n-    /**\n-     * Returns whether or not the intent was sent from Iterable.\n-     */\n-    public boolean isIterableIntent(@Nullable Intent intent) {\n-        if (intent != null) {\n-            Bundle extras = intent.getExtras();\n-            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n+        @Override\n+        public void resetAuth() {\n+            IterableLogger.d(TAG, \"Resetting authToken\");\n+            _authToken = null;\n         }\n-        return false;\n     }\n+//endregion\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     */\n-    public void track(@NonNull String eventName) {\n-        track(eventName, 0, 0, null);\n+//region API functions (private/internal)\n+//---------------------------------------------------------------------------------------\n+    void setAuthToken(String authToken, boolean bypassAuth) {\n+        if (isInitialized()) {\n+            if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n+                _authToken = authToken;\n+                storeAuthData();\n+                completeUserLogin();\n+            } else if (bypassAuth) {\n+                completeUserLogin();\n+            }\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param dataFields\n-     */\n-    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n-        track(eventName, 0, 0, dataFields);\n+    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n+        if (deviceToken != null) {\n+            final Thread registrationThread = new Thread(new Runnable() {\n+                public void run() {\n+                    registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n+                }\n+            });\n+            registrationThread.start();\n+        }\n     }\n \n-    /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     */\n-    public void track(@NonNull String eventName, int campaignId, int templateId) {\n-        track(eventName, campaignId, templateId, null);\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n+        disableToken(email, userId, null, token, null, null);\n     }\n \n     /**\n-     * Track an event.\n-     * @param eventName\n-     * @param campaignId\n-     * @param templateId\n-     * @param dataFields\n+     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n+     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n+     * @param email User email for whom to disable the device.\n+     * @param userId User ID for whom to disable the device.\n+     * @param authToken\n+     * @param deviceToken The device token\n      */\n-    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n+    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n+        if (deviceToken == null) {\n+            IterableLogger.d(TAG, \"device token not available\");\n             return;\n         }\n-\n-        apiClient.track(eventName, campaignId, templateId, dataFields);\n+        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n     }\n \n     /**\n-     * Updates the status of the cart\n-     * @param items\n+     * Registers the GCM registration ID with Iterable.\n+     *\n+     * @param authToken\n+     * @param applicationName\n+     * @param deviceToken\n+     * @param dataFields\n      */\n-    public void updateCart(@NonNull List<CommerceItem> items) {\n+    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.updateCart(items);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n-        trackPurchase(total, items, null);\n-    }\n-\n-    /**\n-     * Tracks a purchase.\n-     * @param total total purchase amount\n-     * @param items list of purchased items\n-     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n-     */\n-    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n-        if (!checkSDKInitialization()) {\n+        if (deviceToken == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n             return;\n         }\n \n-        apiClient.trackPurchase(total, items, dataFields);\n-    }\n+        if (applicationName == null) {\n+            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n+        }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     */\n-    public void updateEmail(final @NonNull String newEmail) {\n-        updateEmail(newEmail, null, null, null);\n+        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n     }\n+//endregion\n \n-    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n-        updateEmail(newEmail, authToken, null, null);\n+//region SDK initialization\n+//---------------------------------------------------------------------------------------\n+    @NonNull\n+    public static IterableApi getInstance() {\n+        return sharedInstance;\n     }\n \n-    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        updateEmail(newEmail, null, successHandler, failureHandler);\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey) {\n+        initialize(context, apiKey, null);\n     }\n \n-    /**\n-     * Updates the current user's email.\n-     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n-     * @param newEmail New email\n-     * @param successHandler Success handler. Called when the server returns a success code.\n-     * @param failureHandler Failure handler. Called when the server call failed.\n-     */\n-    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n-        if (!checkSDKInitialization()) {\n-            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n-                    \"calling updateEmail\");\n-            if (failureHandler != null) {\n-                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n-                        \"userId before calling updateEmail\", null);\n-            }\n+    public static void initialize(@NonNull Context context, @NonNull String apiKey, @Nullable IterableConfig config) {\n+        sharedInstance._applicationContext = context.getApplicationContext();\n+        sharedInstance._apiKey = apiKey;\n+        sharedInstance.config = config;\n \n-            return;\n+        if (sharedInstance.config == null) {\n+            sharedInstance.config = new IterableConfig.Builder().build();\n         }\n \n-        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n-            @Override\n-            public void onSuccess(@NonNull JSONObject data) {\n-                if (_email != null) {\n-                    _email = newEmail;\n-                    _authToken = authToken;\n-                }\n+        sharedInstance.retrieveEmailAndUserId();\n \n-                storeAuthData();\n-                getAuthManager().requestNewAuthToken(false);\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n+        IterableActivityMonitor.getInstance().addCallback(sharedInstance.activityMonitorListener);\n \n-                if (successHandler != null) {\n-                    successHandler.onSuccess(data);\n-                }\n-            }\n-        }, failureHandler);\n-    }\n+        if (sharedInstance.inAppManager == null) {\n+            sharedInstance.inAppManager = new IterableInAppManager(sharedInstance, sharedInstance.config.inAppHandler,\n+                    sharedInstance.config.inAppDisplayInterval);\n+        }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields) {\n-        updateUser(dataFields, false);\n+        loadLastSavedConfiguration(context);\n+        IterablePushNotificationUtil.processPendingAction(context);\n     }\n \n-    /**\n-     * Updates the current user.\n-     * @param dataFields\n-     * @param mergeNestedObjects\n-     */\n-    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        apiClient.updateUser(dataFields, mergeNestedObjects);\n+    public static void setContext(Context context) {\n+        IterableActivityMonitor.getInstance().registerLifecycleCallbacks(context);\n     }\n \n-    /**\n-     * Registers for push notifications.\n-     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n-     * user email or user ID is set before calling this method.\n-     */\n-    public void registerForPush() {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    IterableApi() {\n+        config = new IterableConfig.Builder().build();\n+    }\n \n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.inAppManager = inAppManager;\n     }\n \n-    /**\n-     * Disables the device from push notifications\n-     */\n-    public void disablePush() {\n-        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n-        IterablePushRegistration.executePushRegistrationTask(data);\n+    @VisibleForTesting\n+    IterableApi(IterableApiClient apiClient, IterableInAppManager inAppManager) {\n+        config = new IterableConfig.Builder().build();\n+        this.apiClient = apiClient;\n+        this.inAppManager = inAppManager;\n     }\n+//endregion\n+\n+//region SDK public functions\n+    static volatile IterableApi sharedInstance = new IterableApi();\n \n     /**\n-     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n-     * @param emailListIds\n-     * @param unsubscribedChannelIds\n-     * @param unsubscribedMessageTypeIds\n+     * Returns an {@link IterableInAppManager} that can be used to manage in-app messages.\n+     * Make sure the Iterable API is initialized before calling this method.\n+     * @return {@link IterableInAppManager} instance\n      */\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n-        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n-    }\n-\n-    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n-        if (!checkSDKInitialization()) {\n-            return;\n+    @NonNull\n+    public IterableInAppManager getInAppManager() {\n+        if (inAppManager == null) {\n+            throw new RuntimeException(\"IterableApi must be initialized before calling getInAppManager(). \" +\n+                    \"Make sure you call IterableApi#initialize() in Application#onCreate\");\n         }\n-\n-        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n+        return inAppManager;\n     }\n \n     /**\n-     * Tracks an in-app open.\n-     * @param message in-app message\n+     * Returns the attribution information ({@link IterableAttributionInfo}) for last push open\n+     * or app link click from an email.\n+     * @return {@link IterableAttributionInfo} Object containing\n      */\n-    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n-            return;\n-        }\n+    @Nullable\n+    public IterableAttributionInfo getAttributionInfo() {\n+        return IterableAttributionInfo.fromJSONObject(\n+                IterableUtil.retrieveExpirableJsonObject(getPreferences(), IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY)\n+        );\n+    }\n \n-        apiClient.trackInAppOpen(message, location, inboxSessionId);\n+    public void setEmail(@Nullable String email) {\n+        setEmail(email, null);\n     }\n \n-    /**\n-     * Tracks when a link inside an in-app is clicked\n-     * @param message the in-app message to be tracked\n-     * @param clickedUrl the URL of the clicked link\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setEmail(@Nullable String email, @Nullable String authToken) {\n+        //Only if passed in same non-null email\n+        if (_email != null && _email.equals(email)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n+        if (_email == null && _userId == null && email == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n+        logoutPreviousUser();\n+\n+        _email = email;\n+        _userId = null;\n+        storeAuthData();\n+\n+        onLogin(authToken);\n     }\n \n-    /**\n-     * Tracks when an in-app has been closed\n-     * @param message the in-app message to be tracked\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation the location of the in-app for this event\n-     */\n-    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        if (!checkSDKInitialization()) {\n+    public void setUserId(@Nullable String userId) {\n+        setUserId(userId, null);\n+    }\n+\n+    public void setUserId(@Nullable String userId, @Nullable String authToken) {\n+        //If same non null userId is passed\n+        if (_userId != null && _userId.equals(userId)) {\n+            checkAndUpdateAuthToken(authToken);\n             return;\n         }\n \n-        if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+        if (_email == null && _userId == null && userId == null) {\n             return;\n         }\n \n-        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n-    }\n-//endregion\n+        logoutPreviousUser();\n \n-//region DEPRECATED - API public functions\n-//---------------------------------------------------------------------------------------\n-    /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId\n-     */\n-    @Deprecated\n-    public void trackInAppOpen(@NonNull String messageId) {\n-        IterableLogger.printInfo();\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+        _email = null;\n+        _userId = userId;\n+        storeAuthData();\n \n-        apiClient.trackInAppOpen(messageId);\n+        onLogin(authToken);\n+    }\n+\n+    public void setAuthToken(String authToken) {\n+        setAuthToken(authToken, false);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks an in-app open\n-     * @param messageId the ID of the in-app message\n-     * @param location where the in-app was opened\n+     * Sets the icon to be displayed in notifications.\n+     * The icon name should match the resource name stored in the /res/drawable directory.\n+     * @param iconName\n      */\n-    @Deprecated\n-    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppOpen(message, location);\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void setNotificationIcon(@Nullable String iconName) {\n+        setNotificationIcon(_applicationContext, iconName);\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n-     * @param location where the in-app was opened\n+     * Retrieves the payload string for a given key.\n+     * Used for deeplinking and retrieving extra data passed down along with a campaign.\n+     * @param key\n+     * @return Returns the requested payload data from the current push campaign if it exists.\n      */\n-    @Deprecated\n-    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n-        IterableLogger.printInfo();\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClick(message, clickedUrl, location);\n-        } else {\n-            trackInAppClick(messageId, clickedUrl);\n-        }\n+    @Nullable\n+    public String getPayloadData(@NonNull String key) {\n+        return (_payloadData != null) ? _payloadData.getString(key, null) : null;\n     }\n \n     /**\n-     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n-     * @param messageId the ID of the in-app message\n-     * @param clickedUrl the URL of the clicked link\n+     * Retrieves all of the payload as a single Bundle Object\n+     * @return Bundle\n      */\n-    @Deprecated\n-    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n+    @Nullable\n+    public Bundle getPayloadData() {\n+        return _payloadData;\n+    }\n \n-        apiClient.trackInAppClick(messageId, clickedUrl);\n+    public void setDeviceAttribute(String key, String value) {\n+        deviceAttributes.put(key, value);\n     }\n \n-    /**\n-     * (DEPRECATED) Tracks when an in-app has been closed\n-     * @param messageId the ID of the in-app message\n-     * @param clickedURL the URL of the clicked link\n-     * @param closeAction the method of how the in-app was closed\n-     * @param clickLocation where the in-app was closed\n-     */\n-    @Deprecated\n-    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n-        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n-        if (message != null) {\n-            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n-            IterableLogger.printInfo();\n-        } else {\n-            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n-        }\n+    public void removeDeviceAttribute(String key) {\n+        deviceAttributes.remove(key);\n     }\n //endregion\n \n-//region API functions (private/internal)\n+//region API public functions\n //---------------------------------------------------------------------------------------\n-    void setAuthToken(String authToken, boolean bypassAuth) {\n-    if (isInitialized()) {\n-        if ((authToken != null && !authToken.equalsIgnoreCase(_authToken)) || (_authToken != null && !_authToken.equalsIgnoreCase(authToken))) {\n-            _authToken = authToken;\n-            storeAuthData();\n-            completeUserLogin();\n-        } else if (bypassAuth) {\n-            completeUserLogin();\n-        }\n-    }\n-}\n-\n-    protected void registerDeviceToken(final @Nullable String email, final @Nullable String userId, final @Nullable String authToken, final @NonNull String applicationName, final @NonNull String deviceToken, final HashMap<String, String> deviceAttributes) {\n-    if (deviceToken != null) {\n-        final Thread registrationThread = new Thread(new Runnable() {\n-            public void run() {\n-                registerDeviceToken(email, userId, authToken, applicationName, deviceToken, null, deviceAttributes);\n-            }\n-        });\n-        registrationThread.start();\n+    /**\n+     * Registers a device token with Iterable.\n+     * Make sure {@link IterableConfig#pushIntegrationName} is set before calling this.\n+     * @param deviceToken Push token obtained from GCM or FCM\n+     */\n+    public void registerDeviceToken(@NonNull String deviceToken) {\n+        registerDeviceToken(_email, _userId, _authToken, getPushIntegrationName(), deviceToken, deviceAttributes);\n     }\n-}\n \n-    protected void disableToken(@Nullable String email, @Nullable String userId, @NonNull String token) {\n-        disableToken(email, userId, null, token, null, null);\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId) {\n+        trackPushOpen(campaignId, templateId, messageId, null);\n     }\n \n     /**\n-     * Internal api call made from IterablePushRegistration after a registrationToken is obtained.\n-     * It disables the device for all users with this device by default. If `email` or `userId` is provided, it will disable the device for the specific user.\n-     * @param email User email for whom to disable the device.\n-     * @param userId User ID for whom to disable the device.\n-     * @param authToken\n-     * @param deviceToken The device token\n+     * Tracks when a push notification is opened on device.\n+     * @param campaignId\n+     * @param templateId\n      */\n-    protected void disableToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String deviceToken, @Nullable IterableHelper.SuccessHandler onSuccess, @Nullable IterableHelper.FailureHandler onFailure) {\n-        if (deviceToken == null) {\n-            IterableLogger.d(TAG, \"device token not available\");\n+    public void trackPushOpen(int campaignId, int templateId, @NonNull String messageId, @Nullable JSONObject dataFields) {\n+        if (messageId == null) {\n+            IterableLogger.e(TAG, \"messageId is null\");\n             return;\n         }\n-        apiClient.disableToken(email, userId, authToken, deviceToken, onSuccess, onFailure);\n+\n+        apiClient.trackPushOpen(campaignId, templateId, messageId, dataFields);\n     }\n \n     /**\n-     * Registers the GCM registration ID with Iterable.\n-     *\n-     * @param authToken\n-     * @param applicationName\n-     * @param deviceToken\n-     * @param dataFields\n+     * Consumes an InApp message.\n+     * @param messageId\n      */\n-    protected void registerDeviceToken(@Nullable String email, @Nullable String userId, @Nullable String authToken, @NonNull String applicationName, @NonNull String deviceToken, @Nullable JSONObject dataFields, HashMap<String, String> deviceAttributes) {\n-        if (!checkSDKInitialization()) {\n-            return;\n-        }\n-\n-        if (deviceToken == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: token is null\");\n+    public void inAppConsume(@NonNull String messageId) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"inAppConsume: message is null\");\n             return;\n         }\n-\n-        if (applicationName == null) {\n-            IterableLogger.e(TAG, \"registerDeviceToken: applicationName is null, check that pushIntegrationName is set in IterableConfig\");\n-        }\n-\n-        apiClient.registerDeviceToken(email, userId, authToken, applicationName, deviceToken, dataFields, deviceAttributes);\n+        inAppConsume(message, null, null);\n+        IterableLogger.printInfo();\n     }\n-//endregion\n \n-//region library scoped\n-//---------------------------------------------------------------------------------------\n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+    /**\n+     * Tracks InApp delete.\n+     * This method from informs Iterable about inApp messages deleted with additional paramters.\n+     * Call this method from places where inApp deletion are invoked by user. The messages can be swiped to delete or can be deleted using the link to delete button.\n+     *\n+     * @param message message object\n+     * @param source An enum describing how the in App delete was triggered\n+     * @param clickLocation The module in which the action happened\n+     */\n+    public void inAppConsume(@NonNull IterableInAppMessage message, @Nullable IterableInAppDeleteActionType source, @Nullable IterableInAppLocation clickLocation) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (session == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n-            return;\n-        }\n-\n-        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n-            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n-            return;\n-        }\n+        apiClient.inAppConsume(message, source, clickLocation, inboxSessionId);\n+    }\n \n-        apiClient.trackInboxSession(session, inboxSessionId);\n+    /**\n+     * Tracks a click on the uri if it is an iterable link.\n+     * @param uri the\n+     * @param onCallback Calls the callback handler with the destination location\n+     *                   or the original url if it is not an Iterable link.\n+     */\n+    public void getAndTrackDeepLink(@NonNull String uri, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+        IterableDeeplinkManager.getAndTrackDeeplink(uri, onCallback);\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void setInboxSessionId(@Nullable String inboxSessionId) {\n-        this.inboxSessionId = inboxSessionId;\n+    /**\n+     * Handles an App Link\n+     * For Iterable links, it will track the click and retrieve the original URL, pass it to\n+     * {@link IterableUrlHandler} for handling\n+     * If it's not an Iterable link, it just passes the same URL to {@link IterableUrlHandler}\n+     *\n+     * Call this from {@link Activity#onCreate(Bundle)} and {@link Activity#onNewIntent(Intent)}\n+     * in your deep link handler activity\n+     * @param uri the URL obtained from {@link Intent#getData()} in your deep link\n+     *            handler activity\n+     * @return whether or not the app link was handled\n+     */\n+    public boolean handleAppLink(@NonNull String uri) {\n+        IterableLogger.printInfo();\n+\n+        if (IterableDeeplinkManager.isIterableDeeplink(uri)) {\n+            IterableDeeplinkManager.getAndTrackDeeplink(uri, new IterableHelper.IterableActionHandler() {\n+                @Override\n+                public void execute(String originalUrl) {\n+                    IterableAction action = IterableAction.actionOpenUrl(originalUrl);\n+                    IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+                }\n+            });\n+            return true;\n+        } else {\n+            IterableAction action = IterableAction.actionOpenUrl(uri);\n+            return IterableActionRunner.executeAction(getInstance().getMainActivityContext(), action, IterableActionSource.APP_LINK);\n+        }\n     }\n \n-    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n-    public void clearInboxSessionId() {\n-        this.inboxSessionId = null;\n+    /**\n+     * Debugging function to send API calls to different url endpoints.\n+     * @param url\n+     */\n+    public static void overrideURLEndpointPath(@NonNull String url) {\n+        IterableRequestTask.overrideUrl = url;\n     }\n-//endregion\n-\n-//region SDK (private/internal)\n-//---------------------------------------------------------------------------------------\n-    private static final String TAG = \"IterableApi\";\n-    private Context _applicationContext;\n-    IterableConfig config;\n-    private String _apiKey;\n-    private String _email;\n-    private String _userId;\n-    private String _authToken;\n-    private boolean _debugMode;\n-    private Bundle _payloadData;\n-    private IterableNotificationData _notificationData;\n-    private String _deviceId;\n-    private boolean _firstForegroundHandled;\n-\n-    IterableApiClient apiClient = new IterableApiClient(new IterableApiAuthProvider());\n-    private @Nullable IterableInAppManager inAppManager;\n-    private String inboxSessionId;\n-    private IterableAuthManager authManager;\n-    private HashMap<String, String> deviceAttributes = new HashMap<>();\n \n-    void fetchRemoteConfiguration() {\n-    apiClient.getRemoteConfiguration(new IterableHelper.IterableActionHandler() {\n-        @Override\n-        public void execute(@Nullable String data) {\n-            if (data == null) {\n-                IterableLogger.e(TAG, \"Remote configuration returned null\");\n-                return;\n-            }\n-            try {\n-                JSONObject jsonData = new JSONObject(data);\n-                boolean offlineConfiguration = jsonData.getBoolean(IterableConstants.KEY_OFFLINE_MODE);\n-                sharedInstance.apiClient.setOfflineProcessingEnabled(offlineConfiguration);\n-                SharedPreferences sharedPref = sharedInstance.getMainActivityContext().getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-                SharedPreferences.Editor editor = sharedPref.edit();\n-                editor.putBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, offlineConfiguration);\n-                editor.apply();\n-            } catch (JSONException e) {\n-                IterableLogger.e(TAG, \"Failed to read remote configuration\");\n-            }\n+    /**\n+     * Returns whether or not the intent was sent from Iterable.\n+     */\n+    public boolean isIterableIntent(@Nullable Intent intent) {\n+        if (intent != null) {\n+            Bundle extras = intent.getExtras();\n+            return (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY));\n         }\n-    });\n-}\n-\n-    String getEmail() {\n-        return _email;\n+        return false;\n     }\n \n-    String getUserId() {\n-        return _userId;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     */\n+    public void track(@NonNull String eventName) {\n+        track(eventName, 0, 0, null);\n     }\n \n-    String getAuthToken() {\n-        return _authToken;\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param dataFields\n+     */\n+    public void track(@NonNull String eventName, @Nullable JSONObject dataFields) {\n+        track(eventName, 0, 0, dataFields);\n     }\n \n-    private void checkAndUpdateAuthToken(@Nullable String authToken) {\n-        // If authHandler exists and if authToken is new, it will be considered as a call to update the authToken.\n-        if (config.authHandler != null && authToken != null && authToken != _authToken) {\n-            setAuthToken(authToken);\n-        }\n+    /**\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     */\n+    public void track(@NonNull String eventName, int campaignId, int templateId) {\n+        track(eventName, campaignId, templateId, null);\n     }\n \n     /**\n-     * Stores attribution information.\n-     * @param attributionInfo Attribution information object\n+     * Track an event.\n+     * @param eventName\n+     * @param campaignId\n+     * @param templateId\n+     * @param dataFields\n      */\n-    void setAttributionInfo(IterableAttributionInfo attributionInfo) {\n-        if (_applicationContext == null) {\n-            IterableLogger.e(TAG, \"setAttributionInfo: Iterable SDK is not initialized with a context.\");\n+    public void track(@NonNull String eventName, int campaignId, int templateId, @Nullable JSONObject dataFields) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        IterableUtil.saveExpirableJsonObject(\n-                getPreferences(),\n-                IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_KEY,\n-                attributionInfo.toJSONObject(),\n-                3600 * IterableConstants.SHARED_PREFS_ATTRIBUTION_INFO_EXPIRATION_HOURS * 1000\n-        );\n+        apiClient.track(eventName, campaignId, templateId, dataFields);\n     }\n \n-    HashMap getDeviceAttributes() {\n-        return deviceAttributes;\n+    /**\n+     * Updates the status of the cart\n+     * @param items\n+     */\n+    public void updateCart(@NonNull List<CommerceItem> items) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateCart(items);\n     }\n \n     /**\n-     * Returns the current context for the application.\n-     * @return\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n      */\n-    Context getMainActivityContext() {\n-        return _applicationContext;\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items) {\n+        trackPurchase(total, items, null);\n     }\n \n     /**\n-     * Returns an {@link IterableAuthManager} that can be used to manage mobile auth.\n-     * Make sure the Iterable API is initialized before calling this method.\n-     * @return {@link IterableAuthManager} instance\n+     * Tracks a purchase.\n+     * @param total total purchase amount\n+     * @param items list of purchased items\n+     * @param dataFields a `JSONObject` containing any additional information to save along with the event\n      */\n-    @NonNull\n-    IterableAuthManager getAuthManager() {\n-        if (authManager == null) {\n-            authManager = new IterableAuthManager(this, config.authHandler, config.expiringAuthTokenRefreshPeriod);\n+    public void trackPurchase(double total, @NonNull List<CommerceItem> items, @Nullable JSONObject dataFields) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-        return authManager;\n-    }\n \n-    static void loadLastSavedConfiguration(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.SHARED_PREFS_SAVED_CONFIGURATION, Context.MODE_PRIVATE);\n-        boolean offlineMode = sharedPref.getBoolean(IterableConstants.SHARED_PREFS_OFFLINE_MODE_KEY, false);\n-        sharedInstance.apiClient.setOfflineProcessingEnabled(offlineMode);\n+        apiClient.trackPurchase(total, items, dataFields);\n     }\n \n     /**\n-     * Set the notification icon with the given iconName.\n-     * @param context\n-     * @param iconName\n+     * Updates the current user's email.\n+     * Also updates the current email in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n      */\n-    static void setNotificationIcon(Context context, String iconName) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        SharedPreferences.Editor editor = sharedPref.edit();\n-        editor.putString(IterableConstants.NOTIFICATION_ICON_NAME, iconName);\n-        editor.commit();\n+    public void updateEmail(final @NonNull String newEmail) {\n+        updateEmail(newEmail, null, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @NonNull String authToken) {\n+        updateEmail(newEmail, authToken, null, null);\n+    }\n+\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        updateEmail(newEmail, null, successHandler, failureHandler);\n     }\n \n     /**\n-     * Returns the stored notification icon.\n-     * @param context\n-     * @return\n+     * Updates the current user's email.\n+     * Also updates the current email and authToken in this IterableAPI instance if the API call was successful.\n+     * @param newEmail New email\n+     * @param successHandler Success handler. Called when the server returns a success code.\n+     * @param failureHandler Failure handler. Called when the server call failed.\n      */\n-    static String getNotificationIcon(Context context) {\n-        SharedPreferences sharedPref = context.getSharedPreferences(IterableConstants.NOTIFICATION_ICON_NAME, Context.MODE_PRIVATE);\n-        String iconName = sharedPref.getString(IterableConstants.NOTIFICATION_ICON_NAME, \"\");\n-        return iconName;\n+    public void updateEmail(final @NonNull String newEmail, final @Nullable String authToken, final @Nullable IterableHelper.SuccessHandler successHandler, @Nullable IterableHelper.FailureHandler failureHandler) {\n+        if (!checkSDKInitialization()) {\n+            IterableLogger.e(TAG, \"The Iterable SDK must be initialized with email or userId before \" +\n+                    \"calling updateEmail\");\n+            if (failureHandler != null) {\n+                failureHandler.onFailure(\"The Iterable SDK must be initialized with email or \" +\n+                        \"userId before calling updateEmail\", null);\n+            }\n+\n+            return;\n+        }\n+\n+        apiClient.updateEmail(newEmail, new IterableHelper.SuccessHandler() {\n+            @Override\n+            public void onSuccess(@NonNull JSONObject data) {\n+                if (_email != null) {\n+                    _email = newEmail;\n+                    _authToken = authToken;\n+                }\n+\n+                storeAuthData();\n+                getAuthManager().requestNewAuthToken(false);\n+\n+                if (successHandler != null) {\n+                    successHandler.onSuccess(data);\n+                }\n+            }\n+        }, failureHandler);\n     }\n \n     /**\n-     * Sets debug mode.\n-     * @param debugMode\n+     * Updates the current user.\n+     * @param dataFields\n      */\n-    void setDebugMode(boolean debugMode) {\n-        _debugMode = debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields) {\n+        updateUser(dataFields, false);\n     }\n \n     /**\n-     * Gets the current state of the debug mode.\n-     * @return\n+     * Updates the current user.\n+     * @param dataFields\n+     * @param mergeNestedObjects\n      */\n-    boolean getDebugMode() {\n-        return _debugMode;\n+    public void updateUser(@NonNull JSONObject dataFields, Boolean mergeNestedObjects) {\n+        if (!checkSDKInitialization()) {\n+            return;\n+        }\n+\n+        apiClient.updateUser(dataFields, mergeNestedObjects);\n     }\n \n     /**\n-     * Set the payload for a given intent if it is from Iterable.\n-     * @param intent\n+     * Registers for push notifications.\n+     * Make sure the API is initialized with {@link IterableConfig#pushIntegrationName} defined, and\n+     * user email or user ID is set before calling this method.\n      */\n-    void setPayloadData(Intent intent) {\n-        Bundle extras = intent.getExtras();\n-        if (extras != null && extras.containsKey(IterableConstants.ITERABLE_DATA_KEY) && !IterableNotificationHelper.isGhostPush(extras)) {\n-            setPayloadData(extras);\n+    public void registerForPush() {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n+\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.ENABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the payload bundle.\n-     * @param bundle\n+     * Disables the device from push notifications\n      */\n-    void setPayloadData(Bundle bundle) {\n-        _payloadData = bundle;\n+    public void disablePush() {\n+        IterablePushRegistrationData data = new IterablePushRegistrationData(_email, _userId, _authToken, getPushIntegrationName(), IterablePushRegistrationData.PushRegistrationAction.DISABLE);\n+        IterablePushRegistration.executePushRegistrationTask(data);\n     }\n \n     /**\n-     * Sets the IterableNotification data\n-     * @param data\n-     */\n-    void setNotificationData(IterableNotificationData data) {\n-        _notificationData = data;\n-        if (data != null) {\n-            setAttributionInfo(new IterableAttributionInfo(data.getCampaignId(), data.getTemplateId(), data.getMessageId()));\n-        }\n+     * Updates the user subscription preferences. Passing in an empty array will clear the list, passing in null will not modify the list\n+     * @param emailListIds\n+     * @param unsubscribedChannelIds\n+     * @param unsubscribedMessageTypeIds\n+     */\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds) {\n+        updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, null, null, null);\n     }\n \n-    /**\n-     * Gets a list of InAppNotifications from Iterable; passes the result to the callback.\n-     * Now package-private. If you were previously using this method, use\n-     * {@link IterableInAppManager#getMessages()} instead\n-     *\n-     * @param count      the number of messages to fetch\n-     * @param onCallback\n-     */\n-    void getInAppMessages(int count, @NonNull IterableHelper.IterableActionHandler onCallback) {\n+    public void updateSubscriptions(@Nullable Integer[] emailListIds, @Nullable Integer[] unsubscribedChannelIds, @Nullable Integer[] unsubscribedMessageTypeIds, @Nullable Integer[] subscribedMessageTypeIDs, Integer campaignId, Integer templateId) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        apiClient.getInAppMessages(count, onCallback);\n+        apiClient.updateSubscriptions(emailListIds, unsubscribedChannelIds, unsubscribedMessageTypeIds, subscribedMessageTypeIDs, campaignId, templateId);\n     }\n \n     /**\n-     * Tracks in-app delivery events (per in-app)\n-     * @param message the in-app message to be tracked as delivered */\n-    void trackInAppDelivery(@NonNull IterableInAppMessage message) {\n+     * Tracks an in-app open.\n+     * @param message in-app message\n+     */\n+    public void trackInAppOpen(@NonNull IterableInAppMessage message, @NonNull IterableInAppLocation location) {\n         if (!checkSDKInitialization()) {\n             return;\n         }\n \n         if (message == null) {\n-            IterableLogger.e(TAG, \"trackInAppDelivery: message is null\");\n+            IterableLogger.e(TAG, \"trackInAppOpen: message is null\");\n             return;\n         }\n \n-        apiClient.trackInAppDelivery(message);\n-    }\n-\n-    private String getPushIntegrationName() {\n-    if (config.pushIntegrationName != null) {\n-        return config.pushIntegrationName;\n-    } else {\n-        return _applicationContext.getPackageName();\n+        apiClient.trackInAppOpen(message, location, inboxSessionId);\n     }\n-}\n \n-    private void logoutPreviousUser() {\n-        if (config.autoPushRegistration && isInitialized()) {\n-            disablePush();\n+    /**\n+     * Tracks when a link inside an in-app is clicked\n+     * @param message the in-app message to be tracked\n+     * @param clickedUrl the URL of the clicked link\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClick(@NonNull IterableInAppMessage message, @NonNull String clickedUrl, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        getInAppManager().reset();\n-        getAuthManager().clearRefreshTimer();\n-\n-        apiClient.onLogout();\n-    }\n-\n-    private void onLogin(@Nullable String authToken) {\n-        if (!isInitialized()) {\n-            setAuthToken(null);\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClick: message is null\");\n             return;\n         }\n \n-        if (authToken != null) {\n-            setAuthToken(authToken);\n-        } else {\n-            getAuthManager().requestNewAuthToken(false);\n-        }\n+        apiClient.trackInAppClick(message, clickedUrl, clickLocation, inboxSessionId);\n     }\n \n-    private void completeUserLogin() {\n-        if (!isInitialized()) {\n+    /**\n+     * Tracks when an in-app has been closed\n+     * @param message the in-app message to be tracked\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation the location of the in-app for this event\n+     */\n+    public void trackInAppClose(@NonNull IterableInAppMessage message, @Nullable String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        if (!checkSDKInitialization()) {\n             return;\n         }\n \n-        if (config.autoPushRegistration) {\n-            registerForPush();\n+        if (message == null) {\n+            IterableLogger.e(TAG, \"trackInAppClose: message is null\");\n+            return;\n         }\n \n-        getInAppManager().syncInApp();\n+        apiClient.trackInAppClose(message, clickedURL, closeAction, clickLocation, inboxSessionId);\n     }\n+//endregion\n \n-    private final IterableActivityMonitor.AppStateCallback activityMonitorListener = new IterableActivityMonitor.AppStateCallback() {\n-        @Override\n-        public void onSwitchToForeground() {\n-            onForeground();\n-        }\n-\n-        @Override\n-        public void onSwitchToBackground() {}\n-    };\n-\n-    private void onForeground() {\n-        if (!_firstForegroundHandled) {\n-            _firstForegroundHandled = true;\n-            if (sharedInstance.config.autoPushRegistration && sharedInstance.isInitialized()) {\n-                IterableLogger.d(TAG, \"Performing automatic push registration\");\n-                sharedInstance.registerForPush();\n-            }\n-            fetchRemoteConfiguration();\n+//region DEPRECATED - API public functions\n+//---------------------------------------------------------------------------------------\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId\n+     */\n+    @Deprecated\n+    public void trackInAppOpen(@NonNull String messageId) {\n+        IterableLogger.printInfo();\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private boolean isInitialized() {\n-        return _apiKey != null && (_email != null || _userId != null);\n+        apiClient.trackInAppOpen(messageId);\n     }\n \n-    private boolean checkSDKInitialization() {\n-        if (!isInitialized()) {\n-            IterableLogger.e(TAG, \"Iterable SDK must be initialized with an API key and user email/userId before calling SDK methods\");\n-            return false;\n+    /**\n+     * (DEPRECATED) Tracks an in-app open\n+     * @param messageId the ID of the in-app message\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppOpen(@NonNull String messageId, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppOpen(message, location);\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppOpen: could not find an in-app message with ID: \" + messageId);\n         }\n-        return true;\n-    }\n-\n-    private SharedPreferences getPreferences() {\n-        return _applicationContext.getSharedPreferences(IterableConstants.SHARED_PREFS_FILE, Context.MODE_PRIVATE);\n     }\n \n-    private String getDeviceId() {\n-        if (_deviceId == null) {\n-            _deviceId = getPreferences().getString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, null);\n-            if (_deviceId == null) {\n-                _deviceId = UUID.randomUUID().toString();\n-                getPreferences().edit().putString(IterableConstants.SHARED_PREFS_DEVICEID_KEY, _deviceId).apply();\n-            }\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     * @param location where the in-app was opened\n+     */\n+    @Deprecated\n+    void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl, @NonNull IterableInAppLocation location) {\n+        IterableLogger.printInfo();\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClick(message, clickedUrl, location);\n+        } else {\n+            trackInAppClick(messageId, clickedUrl);\n         }\n-        return _deviceId;\n     }\n \n-    private void storeAuthData() {\n-        try {\n-            SharedPreferences.Editor editor = getPreferences().edit();\n-            editor.putString(IterableConstants.SHARED_PREFS_EMAIL_KEY, _email);\n-            editor.putString(IterableConstants.SHARED_PREFS_USERID_KEY, _userId);\n-            editor.putString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, _authToken);\n-            editor.commit();\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while persisting email/userId\", e);\n+    /**\n+     * (DEPRECATED) Tracks when a link inside an in-app is clicked\n+     * @param messageId the ID of the in-app message\n+     * @param clickedUrl the URL of the clicked link\n+     */\n+    @Deprecated\n+    public void trackInAppClick(@NonNull String messageId, @NonNull String clickedUrl) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n-    }\n \n-    private void retrieveEmailAndUserId() {\n-        try {\n-            SharedPreferences prefs = getPreferences();\n-            _email = prefs.getString(IterableConstants.SHARED_PREFS_EMAIL_KEY, null);\n-            _userId = prefs.getString(IterableConstants.SHARED_PREFS_USERID_KEY, null);\n-            _authToken = prefs.getString(IterableConstants.SHARED_PREFS_AUTH_TOKEN_KEY, null);\n-            if (_authToken != null) {\n-                getAuthManager().queueExpirationRefresh(_authToken);\n-            }\n-        } catch (Exception e) {\n-            IterableLogger.e(TAG, \"Error while retrieving email/userId/authToken\", e);\n-        }\n+        apiClient.trackInAppClick(messageId, clickedUrl);\n     }\n \n-    private class IterableApiAuthProvider implements IterableApiClient.AuthProvider {\n-        @Nullable\n-        @Override\n-        public String getEmail() {\n-            return _email;\n+    /**\n+     * (DEPRECATED) Tracks when an in-app has been closed\n+     * @param messageId the ID of the in-app message\n+     * @param clickedURL the URL of the clicked link\n+     * @param closeAction the method of how the in-app was closed\n+     * @param clickLocation where the in-app was closed\n+     */\n+    @Deprecated\n+    void trackInAppClose(@NonNull String messageId, @NonNull String clickedURL, @NonNull IterableInAppCloseAction closeAction, @NonNull IterableInAppLocation clickLocation) {\n+        IterableInAppMessage message = getInAppManager().getMessageById(messageId);\n+        if (message != null) {\n+            trackInAppClose(message, clickedURL, closeAction, clickLocation);\n+            IterableLogger.printInfo();\n+        } else {\n+            IterableLogger.w(TAG, \"trackInAppClose: could not find an in-app message with ID: \" + messageId);\n         }\n+    }\n+//endregion\n \n-        @Nullable\n-        @Override\n-        public String getUserId() {\n-            return _userId;\n+//region library scoped\n+//---------------------------------------------------------------------------------------\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void trackInboxSession(@NonNull IterableInboxSession session) {\n+        if (!checkSDKInitialization()) {\n+            return;\n         }\n \n-        @Nullable\n-        @Override\n-        public String getAuthToken() {\n-            return _authToken;\n+        if (session == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: session is null\");\n+            return;\n         }\n \n-        @Override\n-        public String getApiKey() {\n-            return _apiKey;\n+        if (session.sessionStartTime == null || session.sessionEndTime == null) {\n+            IterableLogger.e(TAG, \"trackInboxSession: sessionStartTime and sessionEndTime must be set\");\n+            return;\n         }\n \n-        @Override\n-        public String getDeviceId() {\n-            return IterableApi.this.getDeviceId();\n-        }\n+        apiClient.trackInboxSession(session, inboxSessionId);\n+    }\n \n-        @Override\n-        public Context getContext() {\n-            return _applicationContext;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void setInboxSessionId(@Nullable String inboxSessionId) {\n+        this.inboxSessionId = inboxSessionId;\n+    }\n \n-        @Override\n-        public void resetAuth() {\n-            IterableLogger.d(TAG, \"Resetting authToken\");\n-            _authToken = null;\n-        }\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void clearInboxSessionId() {\n+        this.inboxSessionId = null;\n     }\n //endregion\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjU0Ng==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042546", "body": "How/when is this going to be used?", "bodyText": "How/when is this going to be used?", "bodyHTML": "<p dir=\"auto\">How/when is this going to be used?</p>", "author": "vbabenkoru", "createdAt": "2020-11-21T00:54:25Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.iterable.iterableapi;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+class IterableTask {\n+\n+    //String columns as stored in DB\n+    static final String TASK_ID = \"task_id\";\n+    static final String NAME = \"name\";\n+    static final String VERSION = \"version\";\n+    static final String CREATED_AT = \"created\";\n+    static final String MODIFIED_AT = \"modified\";\n+    static final String LAST_ATTEMPTED_AT = \"last_attempt\";\n+    static final String SCHEDULED_AT = \"scheduled\";\n+    static final String REQUESTED_AT = \"requested\";\n+    static final String PROCESSING = \"processing\";\n+    static final String FAILED = \"failed\";\n+    static final String BLOCKING = \"blocking\";\n+    static final String DATA = \"data\";\n+    static final String ERROR = \"error\";\n+    static final String TYPE = \"type\";\n+    static final String ATTEMPTS = \"attempts\";\n+\n+    int currentVersion = 1;\n+\n+    String id; //uuid generated for each task when getting created\n+    String name;//name of the api\n+    int version;//version for the task? Not sure. replicating as on iOS\n+    Date createdAt;\n+    Date modifiedAt;\n+    Date lastAttemptedAt;\n+    Date scheduledAt;\n+    Date requestedAt;\n+\n+    Boolean processing;\n+    Boolean failed;\n+    Boolean blocking;\n+\n+    //TODO: Confirm if data and failure data would be String converted from JSONObjects.\n+    Object data;\n+    Object taskFailureData;\n+    IterableTaskType taskType;\n+    int attempts;\n+\n+    //To be used when creating IterableTask from database\n+    public IterableTask(String id, @NonNull String name, @NonNull int version, @NonNull Date createdAt, Date modifiedAt, Date lastAttemptedAt, Date scheduledAt, Date requestedAt, Boolean processing, Boolean failed, Boolean blocking, Object data, Object taskFailureData, IterableTaskType taskType, int attempts) {\n+\n+        this.id = id;\n+        this.name = name;\n+        this.version = version;\n+        this.createdAt = createdAt;\n+        this.modifiedAt = modifiedAt;\n+        this.lastAttemptedAt = lastAttemptedAt;\n+        this.scheduledAt = scheduledAt;\n+        this.requestedAt = requestedAt;\n+        this.processing = processing;\n+        this.failed = failed;\n+        this.blocking = blocking;\n+        this.data = data;\n+        this.taskFailureData = taskFailureData;\n+        this.taskType = taskType;\n+        this.attempts = attempts;\n+    }\n+\n+    //Bare minimum one to be used when creating the Task\n+    public IterableTask(String name, IterableTaskType taskType) {\n+\n+        this.id = UUID.randomUUID().toString();\n+        this.name = name;\n+        this.createdAt = new Date();\n+        this.scheduledAt = new Date();\n+        this.requestedAt = new Date();\n+        this.taskType = taskType;\n+\n+    }\n+\n+    IterableTask updateTask(int attempts, Date lastAttemptedAt, Boolean processing, Date scheduledAt, Object data, Object taskFailureData) {", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTY2Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491663", "bodyText": "Not gonna be used. Deleting.", "author": "Ayyanchira", "createdAt": "2020-11-23T06:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjU0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java\nindex 2edc81a..fff41cd 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java\n", "chunk": "@@ -66,20 +65,15 @@ class IterableTask {\n     }\n \n     //Bare minimum one to be used when creating the Task\n-    public IterableTask(String name, IterableTaskType taskType) {\n-\n+    IterableTask(String name, IterableTaskType taskType) {\n         this.id = UUID.randomUUID().toString();\n         this.name = name;\n         this.createdAt = new Date();\n         this.scheduledAt = new Date();\n         this.requestedAt = new Date();\n         this.taskType = taskType;\n-\n     }\n \n-    IterableTask updateTask(int attempts, Date lastAttemptedAt, Boolean processing, Date scheduledAt, Object data, Object taskFailureData) {\n-        return new IterableTask(id, name, version, createdAt, modifiedAt, lastAttemptedAt, scheduledAt, requestedAt, processing, failed, blocking, data, taskFailureData, taskType, attempts);\n-    }\n }\n \n enum IterableTaskType {\n", "next_change": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java\nindex fff41cd..c79be23 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java\n", "chunk": "@@ -65,12 +65,13 @@ class IterableTask {\n     }\n \n     //Bare minimum one to be used when creating the Task\n-    IterableTask(String name, IterableTaskType taskType) {\n+    IterableTask(String name, IterableTaskType taskType, String data) {\n         this.id = UUID.randomUUID().toString();\n         this.name = name;\n         this.createdAt = new Date();\n         this.scheduledAt = new Date();\n         this.requestedAt = new Date();\n+        this.data = data;\n         this.taskType = taskType;\n     }\n \n", "next_change": {"commit": "4763626a0df992265a0099810f7eaf78045e4a7f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java\nindex c79be23..ef94171 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTask.java\n", "chunk": "@@ -80,6 +80,7 @@ class IterableTask {\n enum IterableTaskType {\n     API {\n         @Override\n+        @NonNull\n         public String toString() {\n             return \"API\";\n         }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjcyMQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042721", "body": "Is this designed just for the tasks? If we need to store something else, are we going to create a separate db or reuse this one?", "bodyText": "Is this designed just for the tasks? If we need to store something else, are we going to create a separate db or reuse this one?", "bodyHTML": "<p dir=\"auto\">Is this designed just for the tasks? If we need to store something else, are we going to create a separate db or reuse this one?</p>", "author": "vbabenkoru", "createdAt": "2020-11-21T00:55:10Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskDatabaseManager.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.Context;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteOpenHelper;\n+\n+class IterableTaskDatabaseManager extends SQLiteOpenHelper {", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTM1Nw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491357", "bodyText": "Made it generic.. Creation of all the tables can go here in its onCreate", "author": "Ayyanchira", "createdAt": "2020-11-23T06:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MjcyMQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0Mjc5Ng==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528042796", "body": "Depending on the answer to above, we probably need to scope the name to tasks only, or rename the class itself.", "bodyText": "Depending on the answer to above, we probably need to scope the name to tasks only, or rename the class itself.", "bodyHTML": "<p dir=\"auto\">Depending on the answer to above, we probably need to scope the name to tasks only, or rename the class itself.</p>", "author": "vbabenkoru", "createdAt": "2020-11-21T00:55:35Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskDatabaseManager.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.Context;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteOpenHelper;\n+\n+class IterableTaskDatabaseManager extends SQLiteOpenHelper {\n+    private static final String DATABASE_NAME = \"iterable_sdk.db\";", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTU4NA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491584", "bodyText": "Not changing the Iterable_sdk. Will keep it like this assuming we will need only one db and tables could be added in this class as feature set requiring table grows", "author": "Ayyanchira", "createdAt": "2020-11-23T06:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0Mjc5Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzI4Nw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528043287", "body": "Why is it using a class field vs. local variable for `contentValues`?", "bodyText": "Why is it using a class field vs. local variable for contentValues?", "bodyHTML": "<p dir=\"auto\">Why is it using a class field vs. local variable for <code>contentValues</code>?</p>", "author": "vbabenkoru", "createdAt": "2020-11-21T00:58:23Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,335 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\"+REPLACING_STRING+\"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableTaskDatabaseManager databaseManager;\n+    private ContentValues contentValues = new ContentValues();\n+    private boolean hasDatabaseError = false;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableTaskDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if(sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /*\n+    * Create and insert a new task in the database\n+    *\n+    * */\n+    String createTask(String name) {\n+\n+        if(database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if(iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if(iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if(iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if(iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if(iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if(iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if(iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if(iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if(iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME,null,contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        Object data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getBlob(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getBlob(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error,IterableTaskType.API,attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    ArrayList<String> getAllTaskIds() {\n+        if(!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if(cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            }while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+\n+        return taskIds;\n+    }\n+    /**\n+     * Gets number of rows in the event table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+            hasDatabaseError = false;\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    Boolean deleteAllTasks () {\n+        if (!precheck()) return false;\n+\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return true;\n+    }\n+\n+    Boolean deleteTask(String id) {\n+        if (! precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MTAwMA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528491000", "bodyText": "had it referenced from a website previously.. having it local is safe and prevent possible data leak. Thanks. Made them local", "author": "Ayyanchira", "createdAt": "2020-11-23T06:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzI4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 229b39a..b000a88 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -212,70 +224,140 @@ public class IterableTaskManager {\n         }\n         try {\n             count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n-            hasDatabaseError = false;\n         } catch (Throwable t) {\n             IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n         }\n         return count;\n     }\n \n-    Boolean deleteAllTasks () {\n-        if (!precheck()) return false;\n-\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n         int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n         IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n-        return true;\n+        return;\n     }\n \n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n     Boolean deleteTask(String id) {\n-        if (! precheck()) return false;\n+        if (!precheck()) return false;\n         int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n         IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n         return true;\n     }\n \n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n     Boolean updateModifiedAt(String id, Date date) {\n         if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n         contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n-        return updateTaskWithContentValues(id);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n     Boolean updateLastAttemptedAt(String id, Date date) {\n         if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n         contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n-        return updateTaskWithContentValues(id);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n     Boolean updateRequestedAt(String id, Date date) {\n         if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n         contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n-        return updateTaskWithContentValues(id);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n     Boolean updateScheduledAt(String id, Date date) {\n         if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n         contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n-        return updateTaskWithContentValues(id);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n     Boolean updateIsProcessing(String id, Boolean state) {\n         if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n         contentValues.put(IterableTask.PROCESSING, state);\n-        return updateTaskWithContentValues(id);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n     Boolean updateHasFailed(String id, Boolean state) {\n         if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n         contentValues.put(IterableTask.FAILED, state);\n-        return updateTaskWithContentValues(id);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n     Boolean updateAttempts(String id, int attempt) {\n         if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n         contentValues.put(IterableTask.ATTEMPTS, attempt);\n-        return updateTaskWithContentValues(id);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n     Boolean updateAttempts(String id) {\n         if (!precheck()) return false;\n         IterableTask task = getTask(id);\n", "next_change": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -358,8 +336,8 @@ public class IterableTaskManager {\n      * @param id Unique id for the task\n      * @return Whether or not the task was updated\n      */\n-    Boolean updateAttempts(String id) {\n-        if (!precheck()) return false;\n+    boolean incrementAttempts(String id) {\n+        if (!isDatabaseReady()) return false;\n         IterableTask task = getTask(id);\n         if (task == null) {\n             IterableLogger.e(TAG, \"No task found for id \" + id);\n", "next_change": {"commit": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 1bdf558..7e924b5 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -344,7 +357,7 @@ public class IterableTaskManager {\n             return false;\n         }\n         ContentValues contentValues = new ContentValues();\n-        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        contentValues.put(ATTEMPTS, task.attempts + 1);\n         return updateTaskWithContentValues(id, contentValues);\n     }\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzQwMQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528043401", "body": "Do we need to check for task count before running queries? I think in that case it'll just return nothing, which should be a valid return value.", "bodyText": "Do we need to check for task count before running queries? I think in that case it'll just return nothing, which should be a valid return value.", "bodyHTML": "<p dir=\"auto\">Do we need to check for task count before running queries? I think in that case it'll just return nothing, which should be a valid return value.</p>", "author": "vbabenkoru", "createdAt": "2020-11-21T00:59:05Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,335 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\"+REPLACING_STRING+\"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableTaskDatabaseManager databaseManager;\n+    private ContentValues contentValues = new ContentValues();\n+    private boolean hasDatabaseError = false;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableTaskDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if(sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /*\n+    * Create and insert a new task in the database\n+    *\n+    * */\n+    String createTask(String name) {\n+\n+        if(database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if(iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if(iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if(iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if(iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if(iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if(iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if(iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if(iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if(iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME,null,contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        Object data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getBlob(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getBlob(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error,IterableTaskType.API,attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    ArrayList<String> getAllTaskIds() {\n+        if(!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if(cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            }while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+\n+        return taskIds;\n+    }\n+    /**\n+     * Gets number of rows in the event table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+            hasDatabaseError = false;\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    Boolean deleteAllTasks () {\n+        if (!precheck()) return false;\n+\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return true;\n+    }\n+\n+    Boolean deleteTask(String id) {\n+        if (! precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.FAILED, state);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return updateTaskWithContentValues(id);\n+    }\n+\n+    private Boolean updateTaskWithContentValues(String id) {\n+        int result = database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id});\n+        contentValues.clear();\n+        if (result > 0) return true;\n+        else return false;\n+    }\n+\n+    private boolean precheck() {\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return false;\n+        }\n+        if (getTaskCount() == 0) {", "originalCommit": "2f3d7e03fcb01e8d9b2e0dd6c9c95c76c153b8bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQ5MDcxNw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r528490717", "bodyText": "Removing.. unnecessary overhead", "author": "Ayyanchira", "createdAt": "2020-11-23T06:27:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODA0MzQwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 229b39a..b000a88 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -283,15 +365,37 @@ public class IterableTaskManager {\n             IterableLogger.e(TAG, \"No task found for id \" + id);\n             return false;\n         }\n+        ContentValues contentValues = new ContentValues();\n         contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n-        return updateTaskWithContentValues(id);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n-    private Boolean updateTaskWithContentValues(String id) {\n-        int result = database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id});\n-        contentValues.clear();\n-        if (result > 0) return true;\n-        else return false;\n+    /**\n+     * Updates task with error data OfflineTask table\n+     *\n+     * @param id        Unique id for the task\n+     * @param errorData error received after processing the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateError(String id, String errorData) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ERROR, errorData);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates data for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param data required for the task. JSONObject converted to string\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateData(String id, String data) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.DATA, data);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n     private boolean precheck() {\n", "next_change": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -391,18 +369,26 @@ public class IterableTaskManager {\n      * @param data required for the task. JSONObject converted to string\n      * @return Whether or not the task was updated\n      */\n-    Boolean updateData(String id, String data) {\n-        if (!precheck()) return false;\n+    boolean updateData(String id, String data) {\n+        if (!isDatabaseReady()) return false;\n         ContentValues contentValues = new ContentValues();\n         contentValues.put(IterableTask.DATA, data);\n+        return updateTaskWithContentValues(id, contentValues);\n+    }\n+\n+    private boolean updateTaskWithContentValues(String id, ContentValues contentValues) {\n         return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n-    private boolean precheck() {\n+    private boolean isDatabaseReady() {\n         if (database == null) {\n             IterableLogger.e(TAG, \"Database not initialized\");\n             return false;\n         }\n+        if (!database.isOpen()) {\n+            IterableLogger.e(TAG, \"Database is closed\");\n+            return false;\n+        }\n         return true;\n     }\n \n", "next_change": null}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 229b39a..b000a88 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -299,37 +403,7 @@ public class IterableTaskManager {\n             IterableLogger.e(TAG, \"Database not initialized\");\n             return false;\n         }\n-        if (getTaskCount() == 0) {\n-            IterableLogger.d(TAG, \"No pending offline tasks found\");\n-            return false;\n-        }\n         return true;\n     }\n \n-    //TODO: Decide how the data and error are going to be stored. Is it going to be stringified JSON ?\n-//    Boolean updateError(String id, Object errorData) {\n-//        if (!precheck()) return false;\n-//        contentValues.put(IterableTask.ERROR, errorData);\n-//        return updateTaskWithContentValues(id);\n-//    }\n }\n-\n-\n-//TODO: To delete this enum if unnecessary\n-//enum OfflineTaskColumnIndex{\n-//    ID,\n-//   NAME,\n-//   VERSION,\n-//   CREATED,\n-//   MODIFIED,\n-//   LAST_ATTEMPTED,\n-//   SCHEDEULED,\n-//   REQUESTED,\n-//   PROCESSING,\n-//   FAILED,\n-//   BLOCKED,\n-//   DATA,\n-//   ERROR,\n-//   TYPE,\n-//   ATTEMPTS\n-//        }\n", "next_change": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -391,18 +369,26 @@ public class IterableTaskManager {\n      * @param data required for the task. JSONObject converted to string\n      * @return Whether or not the task was updated\n      */\n-    Boolean updateData(String id, String data) {\n-        if (!precheck()) return false;\n+    boolean updateData(String id, String data) {\n+        if (!isDatabaseReady()) return false;\n         ContentValues contentValues = new ContentValues();\n         contentValues.put(IterableTask.DATA, data);\n+        return updateTaskWithContentValues(id, contentValues);\n+    }\n+\n+    private boolean updateTaskWithContentValues(String id, ContentValues contentValues) {\n         return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n-    private boolean precheck() {\n+    private boolean isDatabaseReady() {\n         if (database == null) {\n             IterableLogger.e(TAG, \"Database not initialized\");\n             return false;\n         }\n+        if (!database.isOpen()) {\n+            IterableLogger.e(TAG, \"Database is closed\");\n+            return false;\n+        }\n         return true;\n     }\n \n", "next_change": null}]}}]}}, {"oid": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "url": "https://github.com/Iterable/iterable-android-sdk/commit/a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "message": "Revision 2\n\nRemove datamanger code task from IterableAPI.\nMade public methods in IterableTask package private.\nRemoved updateTask as its use case is not fit for our requirement.\nContentvalues is not a global variable and is a local method variable instead.\nRemoved unused enum.\nChanged the data and error to String\nAdded update Error method\nAdded update Data method\nAdded docs to all the methods\nRemove getCount from precheck", "committedDate": "2020-11-23T06:26:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE1NzEzNQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529157135", "body": "What are the required fields for `createTask`? Are `type` and `data` required? If so, they should be arguments for this function.", "bodyText": "What are the required fields for createTask? Are type and data required? If so, they should be arguments for this function.", "bodyHTML": "<p dir=\"auto\">What are the required fields for <code>createTask</code>? Are <code>type</code> and <code>data</code> required? If so, they should be arguments for this function.</p>", "author": "vbabenkoru", "createdAt": "2020-11-24T02:31:08Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -68,14 +70,11 @@ public class IterableTaskManager {\n      * @param name Type of the offline task. See {@link IterableTaskType}\n      * @return unique id of the task created\n      */\n-    String createTask(String name) {\n-\n-        if (database == null) {\n-            IterableLogger.e(TAG, \"Database not initialized\");\n-            return null;\n-        }\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+        if (!isDatabaseReady()) return null;\n         ContentValues contentValues = new ContentValues();\n-        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n         contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n         contentValues.put(IterableTask.NAME, iterableTask.name);\n         contentValues.put(IterableTask.VERSION, iterableTask.version);\n", "next_change": {"commit": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 1bdf558..7e924b5 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -72,43 +88,39 @@ public class IterableTaskManager {\n      */\n     @Nullable\n     String createTask(String name, IterableTaskType type, String data) {\n-        if (!isDatabaseReady()) return null;\n+        if (!isDatabaseReady()) {\n+            return null;\n+        }\n         ContentValues contentValues = new ContentValues();\n         IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n-        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n-        contentValues.put(IterableTask.NAME, iterableTask.name);\n-        contentValues.put(IterableTask.VERSION, iterableTask.version);\n-        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        contentValues.put(TASK_ID, iterableTask.id);\n+        contentValues.put(NAME, iterableTask.name);\n+        contentValues.put(VERSION, iterableTask.version);\n+        contentValues.put(CREATED_AT, iterableTask.createdAt.toString());\n         if (iterableTask.modifiedAt != null) {\n-            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+            contentValues.put(MODIFIED_AT, iterableTask.modifiedAt.toString());\n         }\n         if (iterableTask.lastAttemptedAt != null) {\n-            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+            contentValues.put(LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n         }\n         if (iterableTask.scheduledAt != null) {\n-            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+            contentValues.put(SCHEDULED_AT, iterableTask.scheduledAt.toString());\n         }\n         if (iterableTask.requestedAt != null) {\n-            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n-        }\n-        if (iterableTask.processing != null) {\n-            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n-        }\n-        if (iterableTask.failed != null) {\n-            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n-        }\n-        if (iterableTask.blocking != null) {\n-            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+            contentValues.put(REQUESTED_AT, iterableTask.requestedAt.toString());\n         }\n+        contentValues.put(PROCESSING, iterableTask.processing);\n+        contentValues.put(FAILED, iterableTask.failed);\n+        contentValues.put(BLOCKING, iterableTask.blocking);\n         if (iterableTask.data != null) {\n-            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+            contentValues.put(DATA, iterableTask.data);\n         }\n         if (iterableTask.taskFailureData != null) {\n-            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+            contentValues.put(ERROR, iterableTask.taskFailureData);\n         }\n \n-        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n-        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+        contentValues.put(TYPE, iterableTask.taskType.toString());\n+        contentValues.put(ATTEMPTS, iterableTask.attempts);\n \n         database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n         contentValues.clear();\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE1Nzg1NQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529157855", "body": "Add nullability annotations to methods in this class", "bodyText": "Add nullability annotations to methods in this class", "bodyHTML": "<p dir=\"auto\">Add nullability annotations to methods in this class</p>", "author": "vbabenkoru", "createdAt": "2020-11-24T02:31:54Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -123,8 +122,11 @@ public class IterableTaskManager {\n      * @param id Unique id for the task\n      * @return {@link IterableTask} corresponding to id provided\n      */\n+    @Nullable\n     IterableTask getTask(String id) {\n \n+        if (!isDatabaseReady()) return null;\n+\n         String name = null;\n         IterableTaskType type = null;\n         int version = 1;\n", "next_change": {"commit": "4763626a0df992265a0099810f7eaf78045e4a7f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 1bdf558..91eea42 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -124,20 +116,20 @@ public class IterableTaskManager {\n      */\n     @Nullable\n     IterableTask getTask(String id) {\n-\n-        if (!isDatabaseReady()) return null;\n+        if (!isDatabaseReady()) {\n+            return null;\n+        }\n \n         String name = null;\n         IterableTaskType type = null;\n         int version = 1;\n         int attempts = 0;\n         Date dateCreated = null;\n-        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n-        Boolean processing = false, failed = false, blocking = false;\n+        Date dateModified = null, dateLastAttempted = null, dateScheduled = null, dateRequested = null;\n+        boolean processing = false, failed = false, blocking = false;\n         String data = null, error = null;\n \n-        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n-        Cursor cursor = database.rawQuery(query, null);\n+        Cursor cursor = database.rawQuery(QUERY_GET_TASK_BY_ID, new String[]{id});\n \n         if (!cursor.moveToFirst()) {\n             IterableLogger.d(TAG, \"No record found\");\n", "next_change": {"commit": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 91eea42..7e924b5 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -135,41 +155,41 @@ class IterableTaskManager {\n             IterableLogger.d(TAG, \"No record found\");\n             return null;\n         }\n-        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n-        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n-        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n-            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        name = cursor.getString(cursor.getColumnIndex(NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(MODIFIED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n-            dateLastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(LAST_ATTEMPTED_AT))) {\n+            dateLastAttempted = new Date(cursor.getString(cursor.getColumnIndex(LAST_ATTEMPTED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n-            dateScheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(SCHEDULED_AT))) {\n+            dateScheduled = new Date(cursor.getString(cursor.getColumnIndex(SCHEDULED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n-            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(REQUESTED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n-            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        if (!cursor.isNull(cursor.getColumnIndex(PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(PROCESSING)) > 0;\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n-            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        if (!cursor.isNull(cursor.getColumnIndex(FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(FAILED)) > 0;\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n-            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        if (!cursor.isNull(cursor.getColumnIndex(BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(BLOCKING)) > 0;\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n-            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        if (!cursor.isNull(cursor.getColumnIndex(DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(DATA));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n-            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        if (!cursor.isNull(cursor.getColumnIndex(ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(ERROR));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n-            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        if (!cursor.isNull(cursor.getColumnIndex(TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(TYPE)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n-            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        if (!cursor.isNull(cursor.getColumnIndex(ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(ATTEMPTS));\n         }\n \n         IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, dateLastAttempted, dateScheduled, dateRequested, processing, failed, blocking, data, error, type, attempts);\n", "next_change": {"commit": "343f3a4e8084dbae369fa0b95a3aa08450e7f643", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 7e924b5..443ea65 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -192,21 +200,19 @@ class IterableTaskManager {\n             attempts = cursor.getInt(cursor.getColumnIndex(ATTEMPTS));\n         }\n \n-        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, dateLastAttempted, dateScheduled, dateRequested, processing, failed, blocking, data, error, type, attempts);\n-        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n-        cursor.close();\n-        return task;\n+        return new IterableTask(id, name, version, dateCreated, dateModified, dateLastAttempted, dateScheduled, dateRequested, processing, failed, blocking, data, error, type, attempts);\n     }\n \n     /**\n      * Gets ids of all the tasks in OfflineTask table\n-     *\n      * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n      */\n     @NonNull\n     ArrayList<String> getAllTaskIds() {\n         ArrayList<String> taskIds = new ArrayList<>();\n-        if (!isDatabaseReady()) return taskIds;\n+        if (!isDatabaseReady()) {\n+            return taskIds;\n+        }\n \n         Cursor cursor = database.rawQuery(\"SELECT \" + TASK_ID +\n                         \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NjY4Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529166683", "body": "Is there a datetime type we can use?", "bodyText": "Is there a datetime type we can use?", "bodyHTML": "<p dir=\"auto\">Is there a datetime type we can use?</p>", "author": "vbabenkoru", "createdAt": "2020-11-24T02:51:04Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg2NjY4Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529866683", "bodyText": "No it seems.\nhttps://sqlite.org/datatype3.html#date_and_time_datatype", "author": "Ayyanchira", "createdAt": "2020-11-24T20:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NjY4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4763626a0df992265a0099810f7eaf78045e4a7f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..91eea42 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -3,21 +3,23 @@ package com.iterable.iterableapi;\n import android.content.ContentValues;\n import android.content.Context;\n import android.database.Cursor;\n-import android.database.DatabaseUtils;\n+import android.database.SQLException;\n import android.database.sqlite.SQLiteDatabase;\n \n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n import java.util.ArrayList;\n import java.util.Date;\n \n-public class IterableTaskManager {\n+class IterableTaskManager {\n \n     private static IterableTaskManager sharedInstance;\n \n     private static final String TAG = \"IterableTaskManager\";\n \n     static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n-    private static final String REPLACING_STRING = \"*#*#*#*\";\n-    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = ?\";\n \n     static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n             IterableTask.NAME + \" TEXT,\" +\n", "next_change": {"commit": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 91eea42..7e924b5 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -19,23 +19,41 @@ class IterableTaskManager {\n     private static final String TAG = \"IterableTaskManager\";\n \n     static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n-    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = ?\";\n \n-    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n-            IterableTask.NAME + \" TEXT,\" +\n-            IterableTask.VERSION + \" INTEGER,\" +\n-            IterableTask.CREATED_AT + \" TEXT,\" +\n-            IterableTask.MODIFIED_AT + \" TEXT,\" +\n-            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n-            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n-            IterableTask.REQUESTED_AT + \" TEXT,\" +\n-            IterableTask.PROCESSING + \" BOOLEAN,\" +\n-            IterableTask.FAILED + \" BOOLEAN,\" +\n-            IterableTask.BLOCKING + \" BOOLEAN,\" +\n-            IterableTask.DATA + \" TEXT,\" +\n-            IterableTask.ERROR + \" TEXT,\" +\n-            IterableTask.TYPE + \" TEXT,\" +\n-            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    //String columns as stored in DB\n+    static final String TASK_ID = \"task_id\";\n+    static final String NAME = \"name\";\n+    static final String ATTEMPTS = \"attempts\";\n+    static final String TYPE = \"type\";\n+    static final String ERROR = \"error\";\n+    static final String DATA = \"data\";\n+    static final String BLOCKING = \"blocking\";\n+    static final String FAILED = \"failed\";\n+    static final String PROCESSING = \"processing\";\n+    static final String REQUESTED_AT = \"requested\";\n+    static final String SCHEDULED_AT = \"scheduled\";\n+    static final String LAST_ATTEMPTED_AT = \"last_attempt\";\n+    static final String MODIFIED_AT = \"modified\";\n+    static final String CREATED_AT = \"created\";\n+    static final String VERSION = \"version\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            NAME + \" TEXT,\" +\n+            VERSION + \" INTEGER,\" +\n+            CREATED_AT + \" TEXT,\" +\n+            MODIFIED_AT + \" TEXT,\" +\n+            LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            SCHEDULED_AT + \" TEXT,\" +\n+            REQUESTED_AT + \" TEXT,\" +\n+            PROCESSING + \" BOOLEAN,\" +\n+            FAILED + \" BOOLEAN,\" +\n+            BLOCKING + \" BOOLEAN,\" +\n+            DATA + \" TEXT,\" +\n+            ERROR + \" TEXT,\" +\n+            TYPE + \" TEXT,\" +\n+            ATTEMPTS + \" INTEGER\" + \")\";\n+\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = ?\";\n \n     private SQLiteDatabase database;\n     private IterableDatabaseManager databaseManager;\n", "next_change": {"commit": "afb187868a57f3f65b67ea7c11acc87ebd4e821c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskStorage.java\nsimilarity index 91%\nrename from iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nrename to iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskStorage.java\nindex 7e924b5..59c5ef2 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskStorage.java\n", "chunk": "@@ -58,7 +58,7 @@ class IterableTaskManager {\n     private SQLiteDatabase database;\n     private IterableDatabaseManager databaseManager;\n \n-    private IterableTaskManager(Context context) {\n+    private IterableTaskStorage(Context context) {\n         try {\n             if (context == null) {\n                 return;\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzMyNA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167324", "body": "Return an empty array if the check failed", "bodyText": "Return an empty array if the check failed", "bodyHTML": "<p dir=\"auto\">Return an empty array if the check failed</p>", "author": "vbabenkoru", "createdAt": "2020-11-24T02:53:08Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -197,12 +190,15 @@ public class IterableTaskManager {\n      *\n      * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n      */\n+    @NonNull\n     ArrayList<String> getAllTaskIds() {\n-        if (!precheck()) return null;\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (!isDatabaseReady()) return taskIds;\n+\n         Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n                         \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n                 null);\n-        ArrayList<String> taskIds = new ArrayList<>();\n+\n         if (cursor.moveToFirst()) {\n             do {\n                 taskIds.add(cursor.getString(0));\n", "next_change": {"commit": "4763626a0df992265a0099810f7eaf78045e4a7f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 1bdf558..91eea42 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -205,6 +198,7 @@ public class IterableTaskManager {\n             } while (cursor.moveToNext());\n         }\n         IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        cursor.close();\n         return taskIds;\n     }\n \n", "next_change": {"commit": "343f3a4e8084dbae369fa0b95a3aa08450e7f643", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 91eea42..443ea65 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -202,11 +228,28 @@ class IterableTaskManager {\n         return taskIds;\n     }\n \n+    /**\n+     * Returns the next scheduled task for processing\n+     * @return next scheduled {@link IterableTask}\n+     */\n+    @Nullable\n+    IterableTask nextTask() {\n+        Cursor cursor = database.rawQuery(\"select * from OfflineTask order by scheduled limit 1\", null);\n+        IterableTask task = null;\n+        if (cursor.moveToFirst()) {\n+            task = createTaskFromCursor(cursor);\n+        }\n+        cursor.close();\n+        return task;\n+    }\n+\n     /**\n      * Deletes all the entries from the OfflineTask table.\n      */\n     void deleteAllTasks() {\n-        if (!isDatabaseReady()) return;\n+        if (!isDatabaseReady()) {\n+            return;\n+        }\n         int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n         IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n     }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzUyNA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167524", "body": "What do we need this for?", "bodyText": "What do we need this for?", "bodyHTML": "<p dir=\"auto\">What do we need this for?</p>", "author": "vbabenkoru", "createdAt": "2020-11-24T02:53:48Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg2Njc3MA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529866770", "bodyText": "Just a left over method I thought could be useful. Will remove", "author": "Ayyanchira", "createdAt": "2020-11-24T20:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzUyNA=="}], "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -212,29 +208,11 @@ public class IterableTaskManager {\n         return taskIds;\n     }\n \n-    /**\n-     * Gets number of rows in the OfflineTask table.\n-     *\n-     * @return Number of rows in the event table.\n-     */\n-    long getTaskCount() {\n-        long count = 0;\n-        if (database == null) {\n-            return count;\n-        }\n-        try {\n-            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n-        } catch (Throwable t) {\n-            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n-        }\n-        return count;\n-    }\n-\n     /**\n      * Deletes all the entries from the OfflineTask table.\n      */\n     void deleteAllTasks() {\n-        if (!precheck()) return;\n+        if (!isDatabaseReady()) return;\n         int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n         IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n         return;\n", "next_change": {"commit": "4763626a0df992265a0099810f7eaf78045e4a7f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 1bdf558..91eea42 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -215,7 +209,6 @@ public class IterableTaskManager {\n         if (!isDatabaseReady()) return;\n         int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n         IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n-        return;\n     }\n \n     /**\n", "next_change": {"commit": "343f3a4e8084dbae369fa0b95a3aa08450e7f643", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 91eea42..443ea65 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -202,11 +228,28 @@ class IterableTaskManager {\n         return taskIds;\n     }\n \n+    /**\n+     * Returns the next scheduled task for processing\n+     * @return next scheduled {@link IterableTask}\n+     */\n+    @Nullable\n+    IterableTask nextTask() {\n+        Cursor cursor = database.rawQuery(\"select * from OfflineTask order by scheduled limit 1\", null);\n+        IterableTask task = null;\n+        if (cursor.moveToFirst()) {\n+            task = createTaskFromCursor(cursor);\n+        }\n+        cursor.close();\n+        return task;\n+    }\n+\n     /**\n      * Deletes all the entries from the OfflineTask table.\n      */\n     void deleteAllTasks() {\n-        if (!isDatabaseReady()) return;\n+        if (!isDatabaseReady()) {\n+            return;\n+        }\n         int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n         IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n     }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2NzgxMA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167810", "body": "`incrementAttempts`?", "bodyText": "incrementAttempts?", "bodyHTML": "<p dir=\"auto\"><code>incrementAttempts</code>?</p>", "author": "vbabenkoru", "createdAt": "2020-11-24T02:54:35Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -358,8 +336,8 @@ public class IterableTaskManager {\n      * @param id Unique id for the task\n      * @return Whether or not the task was updated\n      */\n-    Boolean updateAttempts(String id) {\n-        if (!precheck()) return false;\n+    boolean incrementAttempts(String id) {\n+        if (!isDatabaseReady()) return false;\n         IterableTask task = getTask(id);\n         if (task == null) {\n             IterableLogger.e(TAG, \"No task found for id \" + id);\n", "next_change": {"commit": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 1bdf558..7e924b5 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -344,7 +357,7 @@ public class IterableTaskManager {\n             return false;\n         }\n         ContentValues contentValues = new ContentValues();\n-        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        contentValues.put(ATTEMPTS, task.attempts + 1);\n         return updateTaskWithContentValues(id, contentValues);\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2Nzk2MQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529167961", "body": "Can we extract this line into a separate method? Looks like we're doing the same thing for every update method.", "bodyText": "Can we extract this line into a separate method? Looks like we're doing the same thing for every update method.", "bodyHTML": "<p dir=\"auto\">Can we extract this line into a separate method? Looks like we're doing the same thing for every update method.</p>", "author": "vbabenkoru", "createdAt": "2020-11-24T02:55:01Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -358,8 +336,8 @@ public class IterableTaskManager {\n      * @param id Unique id for the task\n      * @return Whether or not the task was updated\n      */\n-    Boolean updateAttempts(String id) {\n-        if (!precheck()) return false;\n+    boolean incrementAttempts(String id) {\n+        if (!isDatabaseReady()) return false;\n         IterableTask task = getTask(id);\n         if (task == null) {\n             IterableLogger.e(TAG, \"No task found for id \" + id);\n", "next_change": {"commit": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 1bdf558..7e924b5 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -344,7 +357,7 @@ public class IterableTaskManager {\n             return false;\n         }\n         ContentValues contentValues = new ContentValues();\n-        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        contentValues.put(ATTEMPTS, task.attempts + 1);\n         return updateTaskWithContentValues(id, contentValues);\n     }\n \n", "next_change": null}]}}, {"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -367,7 +345,7 @@ public class IterableTaskManager {\n         }\n         ContentValues contentValues = new ContentValues();\n         contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n-        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+        return updateTaskWithContentValues(id, contentValues);\n     }\n \n     /**\n", "next_change": {"commit": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 1bdf558..7e924b5 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -344,7 +357,7 @@ public class IterableTaskManager {\n             return false;\n         }\n         ContentValues contentValues = new ContentValues();\n-        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        contentValues.put(ATTEMPTS, task.attempts + 1);\n         return updateTaskWithContentValues(id, contentValues);\n     }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529168398", "body": "I think this should have a clearer name: `isDatabaseReady`/`isDatabaseAvailable` or something like that.", "bodyText": "I think this should have a clearer name: isDatabaseReady/isDatabaseAvailable or something like that.", "bodyHTML": "<p dir=\"auto\">I think this should have a clearer name: <code>isDatabaseReady</code>/<code>isDatabaseAvailable</code> or something like that.</p>", "author": "vbabenkoru", "createdAt": "2020-11-24T02:56:16Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    public static IterableTaskManager sharedInstance() {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager();\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    String createTask(String name) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        if (!precheck()) return null;\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Gets number of rows in the OfflineTask table.\n+     *\n+     * @return Number of rows in the event table.\n+     */\n+    long getTaskCount() {\n+        long count = 0;\n+        if (database == null) {\n+            return count;\n+        }\n+        try {\n+            count = DatabaseUtils.queryNumEntries(database, ITERABLE_TASK_TABLE_NAME);\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Unable to get a number of rows in the table.\", t);\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {\n+        if (!precheck()) return false;\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n+        return true;\n+    }\n+\n+    /**\n+     * Updates Modified at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was modified\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateModifiedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.MODIFIED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Last attempted date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last attempted\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateLastAttemptedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.LAST_ATTEMPTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Requested at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task was last requested\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateRequestedAt(String id, Date date) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.REQUESTED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Scheduled at date for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param date Date when the task is Scheduled\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateScheduledAt(String id, Date date) {\n+        if (precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.SCHEDULED_AT, date.toString());\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the processing state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task is processing or completed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateIsProcessing(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+\n+        contentValues.put(IterableTask.PROCESSING, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates the failed state of task in OfflineTask table\n+     *\n+     * @param id    Unique id for the task\n+     * @param state whether the task failed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateHasFailed(String id, Boolean state) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.FAILED, state);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates Number of attempts for a task in OfflineTask table\n+     *\n+     * @param id      Unique id for the task\n+     * @param attempt number of times the task has been executed\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id, int attempt) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, attempt);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Increments number of attempts made by a task in OfflineTask table\n+     *\n+     * @param id Unique id for the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateAttempts(String id) {\n+        if (!precheck()) return false;\n+        IterableTask task = getTask(id);\n+        if (task == null) {\n+            IterableLogger.e(TAG, \"No task found for id \" + id);\n+            return false;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ATTEMPTS, task.attempts + 1);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates task with error data OfflineTask table\n+     *\n+     * @param id        Unique id for the task\n+     * @param errorData error received after processing the task\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateError(String id, String errorData) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.ERROR, errorData);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    /**\n+     * Updates data for a task in OfflineTask table\n+     *\n+     * @param id   Unique id for the task\n+     * @param data required for the task. JSONObject converted to string\n+     * @return Whether or not the task was updated\n+     */\n+    Boolean updateData(String id, String data) {\n+        if (!precheck()) return false;\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(IterableTask.DATA, data);\n+        return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n+    }\n+\n+    private boolean precheck() {", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg2NzM0NA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529867344", "bodyText": "isOpen and inTransaction() can be a good check to have \ud83d\udc4d", "author": "Ayyanchira", "createdAt": "2020-11-24T20:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MTc1NQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529971755", "bodyText": "Looks like it still has the same name. inTransaction I think is not a good name as it would imply it's in an SQL transaction, and this code doesn't use transactions.", "author": "vbabenkoru", "createdAt": "2020-11-24T22:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3NDY1Nw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529974657", "bodyText": "Basically I don't know what precheck does without looking at its code. Ideally the name should tell what it checks for (in high level terms).", "author": "vbabenkoru", "createdAt": "2020-11-24T22:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk5MzM0MA==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529993340", "bodyText": "oh I misread the comment made. I thought you were suggesting of having additional checks inside the method precheck \ud83e\udd26\u200d\u2642\ufe0f .. my bad", "author": "Ayyanchira", "createdAt": "2020-11-24T23:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2ODM5OA=="}], "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -391,18 +369,26 @@ public class IterableTaskManager {\n      * @param data required for the task. JSONObject converted to string\n      * @return Whether or not the task was updated\n      */\n-    Boolean updateData(String id, String data) {\n-        if (!precheck()) return false;\n+    boolean updateData(String id, String data) {\n+        if (!isDatabaseReady()) return false;\n         ContentValues contentValues = new ContentValues();\n         contentValues.put(IterableTask.DATA, data);\n+        return updateTaskWithContentValues(id, contentValues);\n+    }\n+\n+    private boolean updateTaskWithContentValues(String id, ContentValues contentValues) {\n         return (0 > database.update(ITERABLE_TASK_TABLE_NAME, contentValues, IterableTask.TASK_ID + \"=?\", new String[]{id}));\n     }\n \n-    private boolean precheck() {\n+    private boolean isDatabaseReady() {\n         if (database == null) {\n             IterableLogger.e(TAG, \"Database not initialized\");\n             return false;\n         }\n+        if (!database.isOpen()) {\n+            IterableLogger.e(TAG, \"Database is closed\");\n+            return false;\n+        }\n         return true;\n     }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI0ODA3MQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529248071", "body": "Ideally this should not have an implicit dependency on `IterableApi`.. One alternative is to just pass `Context` around in the constructor and in `sharedInstance`.", "bodyText": "Ideally this should not have an implicit dependency on IterableApi.. One alternative is to just pass Context around in the constructor and in sharedInstance.", "bodyHTML": "<p dir=\"auto\">Ideally this should not have an implicit dependency on <code>IterableApi</code>.. One alternative is to just pass <code>Context</code> around in the constructor and in <code>sharedInstance</code>.</p>", "author": "vbabenkoru", "createdAt": "2020-11-24T07:15:01Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,409 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    IterableTaskManager() {\n+        try {\n+            Context context = IterableApi.getInstance().getMainActivityContext();", "originalCommit": "a345636ddb5d1da1f15b5760cab272b3e7a2da6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex b000a88..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -39,9 +42,8 @@ public class IterableTaskManager {\n     private SQLiteDatabase database;\n     private IterableDatabaseManager databaseManager;\n \n-    IterableTaskManager() {\n+    private IterableTaskManager(Context context) {\n         try {\n-            Context context = IterableApi.getInstance().getMainActivityContext();\n             if (context == null) {\n                 return;\n             }\n", "next_change": {"commit": "afb187868a57f3f65b67ea7c11acc87ebd4e821c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskStorage.java\nsimilarity index 60%\nrename from iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nrename to iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskStorage.java\nindex 1bdf558..59c5ef2 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskStorage.java\n", "chunk": "@@ -12,37 +12,53 @@ import androidx.annotation.Nullable;\n import java.util.ArrayList;\n import java.util.Date;\n \n-public class IterableTaskManager {\n+class IterableTaskStorage {\n \n-    private static IterableTaskManager sharedInstance;\n+    private static IterableTaskStorage sharedInstance;\n \n-    private static final String TAG = \"IterableTaskManager\";\n+    private static final String TAG = \"IterableTaskStorage\";\n \n     static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n-    private static final String REPLACING_STRING = \"*#*#*#*\";\n-    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n-\n-    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n-            IterableTask.NAME + \" TEXT,\" +\n-            IterableTask.VERSION + \" INTEGER,\" +\n-            IterableTask.CREATED_AT + \" TEXT,\" +\n-            IterableTask.MODIFIED_AT + \" TEXT,\" +\n-            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n-            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n-            IterableTask.REQUESTED_AT + \" TEXT,\" +\n-            IterableTask.PROCESSING + \" BOOLEAN,\" +\n-            IterableTask.FAILED + \" BOOLEAN,\" +\n-            IterableTask.BLOCKING + \" BOOLEAN,\" +\n-            IterableTask.DATA + \" TEXT,\" +\n-            IterableTask.ERROR + \" TEXT,\" +\n-            IterableTask.TYPE + \" TEXT,\" +\n-            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n-    private static final String KEY_ROWID = \"rowid\";\n+\n+    //String columns as stored in DB\n+    static final String TASK_ID = \"task_id\";\n+    static final String NAME = \"name\";\n+    static final String ATTEMPTS = \"attempts\";\n+    static final String TYPE = \"type\";\n+    static final String ERROR = \"error\";\n+    static final String DATA = \"data\";\n+    static final String BLOCKING = \"blocking\";\n+    static final String FAILED = \"failed\";\n+    static final String PROCESSING = \"processing\";\n+    static final String REQUESTED_AT = \"requested\";\n+    static final String SCHEDULED_AT = \"scheduled\";\n+    static final String LAST_ATTEMPTED_AT = \"last_attempt\";\n+    static final String MODIFIED_AT = \"modified\";\n+    static final String CREATED_AT = \"created\";\n+    static final String VERSION = \"version\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            NAME + \" TEXT,\" +\n+            VERSION + \" INTEGER,\" +\n+            CREATED_AT + \" TEXT,\" +\n+            MODIFIED_AT + \" TEXT,\" +\n+            LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            SCHEDULED_AT + \" TEXT,\" +\n+            REQUESTED_AT + \" TEXT,\" +\n+            PROCESSING + \" BOOLEAN,\" +\n+            FAILED + \" BOOLEAN,\" +\n+            BLOCKING + \" BOOLEAN,\" +\n+            DATA + \" TEXT,\" +\n+            ERROR + \" TEXT,\" +\n+            TYPE + \" TEXT,\" +\n+            ATTEMPTS + \" INTEGER\" + \")\";\n+\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = ?\";\n \n     private SQLiteDatabase database;\n     private IterableDatabaseManager databaseManager;\n \n-    private IterableTaskManager(Context context) {\n+    private IterableTaskStorage(Context context) {\n         try {\n             if (context == null) {\n                 return;\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2OTAzNw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529969037", "body": "`@NonNull`", "bodyText": "@NonNull", "bodyHTML": "<p dir=\"auto\"><code>@NonNull</code></p>", "author": "vbabenkoru", "createdAt": "2020-11-24T22:54:02Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,402 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.Nullable;\n+\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {", "originalCommit": "42f6e0900fd0061b134ca93817fb444cfce78e07", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 3211be2..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -202,9 +190,10 @@ public class IterableTaskManager {\n      *\n      * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n      */\n+    @NonNull\n     ArrayList<String> getAllTaskIds() {\n         ArrayList<String> taskIds = new ArrayList<>();\n-        if (!precheck()) return taskIds;\n+        if (!isDatabaseReady()) return taskIds;\n \n         Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n                         \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n", "next_change": {"commit": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 1bdf558..7e924b5 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -195,7 +208,7 @@ public class IterableTaskManager {\n         ArrayList<String> taskIds = new ArrayList<>();\n         if (!isDatabaseReady()) return taskIds;\n \n-        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+        Cursor cursor = database.rawQuery(\"SELECT \" + TASK_ID +\n                         \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n                 null);\n \n", "next_change": {"commit": "343f3a4e8084dbae369fa0b95a3aa08450e7f643", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 7e924b5..443ea65 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -192,21 +200,19 @@ class IterableTaskManager {\n             attempts = cursor.getInt(cursor.getColumnIndex(ATTEMPTS));\n         }\n \n-        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, dateLastAttempted, dateScheduled, dateRequested, processing, failed, blocking, data, error, type, attempts);\n-        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n-        cursor.close();\n-        return task;\n+        return new IterableTask(id, name, version, dateCreated, dateModified, dateLastAttempted, dateScheduled, dateRequested, processing, failed, blocking, data, error, type, attempts);\n     }\n \n     /**\n      * Gets ids of all the tasks in OfflineTask table\n-     *\n      * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n      */\n     @NonNull\n     ArrayList<String> getAllTaskIds() {\n         ArrayList<String> taskIds = new ArrayList<>();\n-        if (!isDatabaseReady()) return taskIds;\n+        if (!isDatabaseReady()) {\n+            return taskIds;\n+        }\n \n         Cursor cursor = database.rawQuery(\"SELECT \" + TASK_ID +\n                         \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2OTI5NQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529969295", "body": "Why `Boolean` and not `boolean`?", "bodyText": "Why Boolean and not boolean?", "bodyHTML": "<p dir=\"auto\">Why <code>Boolean</code> and not <code>boolean</code>?</p>", "author": "vbabenkoru", "createdAt": "2020-11-24T22:54:17Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,402 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.Nullable;\n+\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"database not initialized\");\n+            return null;\n+        }\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        }\n+\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        }\n+\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        return task;\n+    }\n+\n+    /**\n+     * Gets ids of all the tasks in OfflineTask table\n+     *\n+     * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n+     */\n+    ArrayList<String> getAllTaskIds() {\n+        ArrayList<String> taskIds = new ArrayList<>();\n+        if (!precheck()) return taskIds;\n+\n+        Cursor cursor = database.rawQuery(\"SELECT \" + IterableTask.TASK_ID +\n+                        \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n+                null);\n+\n+        if (cursor.moveToFirst()) {\n+            do {\n+                taskIds.add(cursor.getString(0));\n+            } while (cursor.moveToNext());\n+        }\n+        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \" columns\");\n+        return taskIds;\n+    }\n+\n+    /**\n+     * Deletes all the entries from the OfflineTask table.\n+     */\n+    void deleteAllTasks() {\n+        if (!precheck()) return;\n+        int numberOfRowsDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, null, null);\n+        IterableLogger.v(TAG, \"Deleted \" + numberOfRowsDeleted + \" offline tasks\");\n+        return;\n+    }\n+\n+    /**\n+     * Deletes a task from OfflineTask table\n+     *\n+     * @param id for the task\n+     * @return Whether or not the task was deleted\n+     */\n+    Boolean deleteTask(String id) {", "originalCommit": "42f6e0900fd0061b134ca93817fb444cfce78e07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwNDYwOQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r530004609", "bodyText": "No particular reason to choose Boolean. Changing it to primitive to keep it simple and consistent.", "author": "Ayyanchira", "createdAt": "2020-11-24T23:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk2OTI5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 3211be2..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -235,8 +224,8 @@ public class IterableTaskManager {\n      * @param id for the task\n      * @return Whether or not the task was deleted\n      */\n-    Boolean deleteTask(String id) {\n-        if (!precheck()) return false;\n+    boolean deleteTask(String id) {\n+        if (!isDatabaseReady()) return false;\n         int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n         IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n         return true;\n", "next_change": {"commit": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 1bdf558..7e924b5 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -226,7 +239,7 @@ public class IterableTaskManager {\n      */\n     boolean deleteTask(String id) {\n         if (!isDatabaseReady()) return false;\n-        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, IterableTask.TASK_ID + \" =?\", new String[]{id});\n+        int numberOfEntriesDeleted = database.delete(ITERABLE_TASK_TABLE_NAME, TASK_ID + \" =?\", new String[]{id});\n         IterableLogger.v(TAG, \"Deleted entry - \" + numberOfEntriesDeleted);\n         return true;\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3MjY3MQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r529972671", "body": "Why is it calling a method (`precheck`) elsewhere and using a direct check here?", "bodyText": "Why is it calling a method (precheck) elsewhere and using a direct check here?", "bodyHTML": "<p dir=\"auto\">Why is it calling a method (<code>precheck</code>) elsewhere and using a direct check here?</p>", "author": "vbabenkoru", "createdAt": "2020-11-24T22:57:32Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,402 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.DatabaseUtils;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.Nullable;\n+\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+\n+        if (database == null) {\n+            IterableLogger.e(TAG, \"Database not initialized\");\n+            return null;\n+        }\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+\n+        if (database == null) {", "originalCommit": "42f6e0900fd0061b134ca93817fb444cfce78e07", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 3211be2..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -139,12 +136,6 @@ public class IterableTaskManager {\n         Boolean processing = false, failed = false, blocking = false;\n         String data = null, error = null;\n \n-\n-        if (database == null) {\n-            IterableLogger.e(TAG, \"database not initialized\");\n-            return null;\n-        }\n-\n         String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n         Cursor cursor = database.rawQuery(query, null);\n \n", "next_change": {"commit": "4763626a0df992265a0099810f7eaf78045e4a7f", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 1bdf558..91eea42 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -124,20 +116,20 @@ public class IterableTaskManager {\n      */\n     @Nullable\n     IterableTask getTask(String id) {\n-\n-        if (!isDatabaseReady()) return null;\n+        if (!isDatabaseReady()) {\n+            return null;\n+        }\n \n         String name = null;\n         IterableTaskType type = null;\n         int version = 1;\n         int attempts = 0;\n         Date dateCreated = null;\n-        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n-        Boolean processing = false, failed = false, blocking = false;\n+        Date dateModified = null, dateLastAttempted = null, dateScheduled = null, dateRequested = null;\n+        boolean processing = false, failed = false, blocking = false;\n         String data = null, error = null;\n \n-        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n-        Cursor cursor = database.rawQuery(query, null);\n+        Cursor cursor = database.rawQuery(QUERY_GET_TASK_BY_ID, new String[]{id});\n \n         if (!cursor.moveToFirst()) {\n             IterableLogger.d(TAG, \"No record found\");\n", "next_change": {"commit": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 91eea42..7e924b5 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -135,41 +155,41 @@ class IterableTaskManager {\n             IterableLogger.d(TAG, \"No record found\");\n             return null;\n         }\n-        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n-        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n-        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n-            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        name = cursor.getString(cursor.getColumnIndex(NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(MODIFIED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n-            dateLastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(LAST_ATTEMPTED_AT))) {\n+            dateLastAttempted = new Date(cursor.getString(cursor.getColumnIndex(LAST_ATTEMPTED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n-            dateScheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(SCHEDULED_AT))) {\n+            dateScheduled = new Date(cursor.getString(cursor.getColumnIndex(SCHEDULED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n-            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(REQUESTED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n-            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        if (!cursor.isNull(cursor.getColumnIndex(PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(PROCESSING)) > 0;\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n-            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        if (!cursor.isNull(cursor.getColumnIndex(FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(FAILED)) > 0;\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n-            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        if (!cursor.isNull(cursor.getColumnIndex(BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(BLOCKING)) > 0;\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n-            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        if (!cursor.isNull(cursor.getColumnIndex(DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(DATA));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n-            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        if (!cursor.isNull(cursor.getColumnIndex(ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(ERROR));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n-            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        if (!cursor.isNull(cursor.getColumnIndex(TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(TYPE)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n-            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        if (!cursor.isNull(cursor.getColumnIndex(ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(ATTEMPTS));\n         }\n \n         IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, dateLastAttempted, dateScheduled, dateRequested, processing, failed, blocking, data, error, type, attempts);\n", "next_change": {"commit": "343f3a4e8084dbae369fa0b95a3aa08450e7f643", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 7e924b5..443ea65 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -192,21 +200,19 @@ class IterableTaskManager {\n             attempts = cursor.getInt(cursor.getColumnIndex(ATTEMPTS));\n         }\n \n-        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, dateLastAttempted, dateScheduled, dateRequested, processing, failed, blocking, data, error, type, attempts);\n-        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n-        cursor.close();\n-        return task;\n+        return new IterableTask(id, name, version, dateCreated, dateModified, dateLastAttempted, dateScheduled, dateRequested, processing, failed, blocking, data, error, type, attempts);\n     }\n \n     /**\n      * Gets ids of all the tasks in OfflineTask table\n-     *\n      * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n      */\n     @NonNull\n     ArrayList<String> getAllTaskIds() {\n         ArrayList<String> taskIds = new ArrayList<>();\n-        if (!isDatabaseReady()) return taskIds;\n+        if (!isDatabaseReady()) {\n+            return taskIds;\n+        }\n \n         Cursor cursor = database.rawQuery(\"SELECT \" + TASK_ID +\n                         \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n", "next_change": null}]}}]}}]}}]}}, {"oid": "7b7b41d296afa01efb4989798b00a4ac98705661", "url": "https://github.com/Iterable/iterable-android-sdk/commit/7b7b41d296afa01efb4989798b00a4ac98705661", "message": "Revision 3\n\nMade recommended changes\n1. precheck now has more db related check to see if its open and if there are any transaction going on\n2. renamed and refactored some functions\n3. deleted getTaskCount as it can derived from getAllTasks and checking the array size if at all needed.\n4. get all taskids now returns empty array and NOT NULL if there table is empty\n5. Added nullable annotations to getTask and createTask method\n6. TaskManager and its shared instance now needs context passed into the constructor. No more dependency on ItearbleApi.getInstance()\n7. Renaming precheck to isDatabaseReady\n8. Primitive boolean instead of Boolean", "committedDate": "2020-11-24T23:34:29Z", "type": "forcePushed"}, {"oid": "473738ab19ad6f21d07ea3b4f7f2e5642f435b7e", "url": "https://github.com/Iterable/iterable-android-sdk/commit/473738ab19ad6f21d07ea3b4f7f2e5642f435b7e", "message": "Revision 3\n\nMade recommended changes\n1. precheck now has more db related check to see if its open and if there are any transaction going on\n2. renamed and refactored some functions\n3. deleted getTaskCount as it can derived from getAllTasks and checking the array size if at all needed.\n4. get all taskids now returns empty array and NOT NULL if there table is empty\n5. Added nullable annotations to getTask and createTask method\n6. TaskManager and its shared instance now needs context passed into the constructor. No more dependency on ItearbleApi.getInstance()\n7. Renaming precheck to isDatabaseReady\n8. Primitive boolean instead of Boolean", "committedDate": "2020-11-24T23:46:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzODA3OQ==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r530038079", "body": "`type` is not used anywhere. Is it needed?", "bodyText": "type is not used anywhere. Is it needed?", "bodyHTML": "<p dir=\"auto\"><code>type</code> is not used anywhere. Is it needed?</p>", "author": "vbabenkoru", "createdAt": "2020-11-25T00:51:18Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,394 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {\n+            IterableLogger.e(TAG, \"Failed to create database\");\n+        }\n+    }\n+\n+    static IterableTaskManager sharedInstance(Context context) {\n+        if (sharedInstance == null) {\n+            sharedInstance = new IterableTaskManager(context);\n+        }\n+        return sharedInstance;\n+    }\n+\n+    /**\n+     * Creates a new instance with default values of IterableTask and stores it in the database\n+     *\n+     * @param name Type of the offline task. See {@link IterableTaskType}\n+     * @return unique id of the task created\n+     */\n+    @Nullable\n+    String createTask(String name, IterableTaskType type, String data) {\n+        if (!isDatabaseReady()) return null;\n+        ContentValues contentValues = new ContentValues();\n+        IterableTask iterableTask = new IterableTask(name, IterableTaskType.API, data);\n+        contentValues.put(IterableTask.TASK_ID, iterableTask.id);\n+        contentValues.put(IterableTask.NAME, iterableTask.name);\n+        contentValues.put(IterableTask.VERSION, iterableTask.version);\n+        contentValues.put(IterableTask.CREATED_AT, iterableTask.createdAt.toString());\n+        if (iterableTask.modifiedAt != null) {\n+            contentValues.put(IterableTask.MODIFIED_AT, iterableTask.modifiedAt.toString());\n+        }\n+        if (iterableTask.lastAttemptedAt != null) {\n+            contentValues.put(IterableTask.LAST_ATTEMPTED_AT, iterableTask.lastAttemptedAt.toString());\n+        }\n+        if (iterableTask.scheduledAt != null) {\n+            contentValues.put(IterableTask.SCHEDULED_AT, iterableTask.scheduledAt.toString());\n+        }\n+        if (iterableTask.requestedAt != null) {\n+            contentValues.put(IterableTask.REQUESTED_AT, iterableTask.requestedAt.toString());\n+        }\n+        if (iterableTask.processing != null) {\n+            contentValues.put(IterableTask.PROCESSING, iterableTask.processing);\n+        }\n+        if (iterableTask.failed != null) {\n+            contentValues.put(IterableTask.FAILED, iterableTask.failed);\n+        }\n+        if (iterableTask.blocking != null) {\n+            contentValues.put(IterableTask.BLOCKING, iterableTask.blocking);\n+        }\n+        if (iterableTask.data != null) {\n+            contentValues.put(IterableTask.DATA, iterableTask.data.toString());\n+        }\n+        if (iterableTask.taskFailureData != null) {\n+            contentValues.put(IterableTask.ERROR, iterableTask.taskFailureData.toString());\n+        }\n+\n+        contentValues.put(IterableTask.TYPE, iterableTask.taskType.toString());\n+        contentValues.put(IterableTask.ATTEMPTS, iterableTask.attempts);\n+\n+        database.insert(ITERABLE_TASK_TABLE_NAME, null, contentValues);\n+        contentValues.clear();\n+\n+        return iterableTask.id;\n+    }\n+\n+    /**\n+     * Gets a Task for the task id provided. Returns null if the database is null.\n+     *\n+     * @param id Unique id for the task\n+     * @return {@link IterableTask} corresponding to id provided\n+     */\n+    @Nullable\n+    IterableTask getTask(String id) {\n+\n+        if (!isDatabaseReady()) return null;\n+\n+        String name = null;\n+        IterableTaskType type = null;\n+        int version = 1;\n+        int attempts = 0;\n+        Date dateCreated = null;\n+        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n+        Boolean processing = false, failed = false, blocking = false;\n+        String data = null, error = null;\n+\n+        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n+        Cursor cursor = database.rawQuery(query, null);\n+\n+        if (!cursor.moveToFirst()) {\n+            IterableLogger.d(TAG, \"No record found\");\n+            return null;\n+        }\n+        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n+            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n+            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        }\n+        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));", "originalCommit": "473738ab19ad6f21d07ea3b4f7f2e5642f435b7e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "716ae687c2fb0aa5849e36c3603dd4a0313493e4", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 81cb8c5..7e924b5 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -123,64 +136,65 @@ public class IterableTaskManager {\n      */\n     @Nullable\n     IterableTask getTask(String id) {\n-\n-        if (!isDatabaseReady()) return null;\n+        if (!isDatabaseReady()) {\n+            return null;\n+        }\n \n         String name = null;\n         IterableTaskType type = null;\n         int version = 1;\n         int attempts = 0;\n         Date dateCreated = null;\n-        Date dateModified = null, datelastAttempted = null, datescheduled = null, dateRequested = null;\n-        Boolean processing = false, failed = false, blocking = false;\n+        Date dateModified = null, dateLastAttempted = null, dateScheduled = null, dateRequested = null;\n+        boolean processing = false, failed = false, blocking = false;\n         String data = null, error = null;\n \n-        String query = QUERY_GET_TASK_BY_ID.replace(REPLACING_STRING, id);\n-        Cursor cursor = database.rawQuery(query, null);\n+        Cursor cursor = database.rawQuery(QUERY_GET_TASK_BY_ID, new String[]{id});\n \n         if (!cursor.moveToFirst()) {\n             IterableLogger.d(TAG, \"No record found\");\n             return null;\n         }\n-        name = cursor.getString(cursor.getColumnIndex(IterableTask.NAME));\n-        version = cursor.getInt(cursor.getColumnIndex(IterableTask.VERSION));\n-        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.CREATED_AT)));\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.MODIFIED_AT))) {\n-            dateModified = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.MODIFIED_AT)));\n+        name = cursor.getString(cursor.getColumnIndex(NAME));\n+        version = cursor.getInt(cursor.getColumnIndex(VERSION));\n+        dateCreated = new Date(cursor.getString(cursor.getColumnIndex(CREATED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(MODIFIED_AT))) {\n+            dateModified = new Date(cursor.getString(cursor.getColumnIndex(MODIFIED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT))) {\n-            datelastAttempted = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.LAST_ATTEMPTED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(LAST_ATTEMPTED_AT))) {\n+            dateLastAttempted = new Date(cursor.getString(cursor.getColumnIndex(LAST_ATTEMPTED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.SCHEDULED_AT))) {\n-            datescheduled = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.SCHEDULED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(SCHEDULED_AT))) {\n+            dateScheduled = new Date(cursor.getString(cursor.getColumnIndex(SCHEDULED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.REQUESTED_AT))) {\n-            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(IterableTask.REQUESTED_AT)));\n+        if (!cursor.isNull(cursor.getColumnIndex(REQUESTED_AT))) {\n+            dateRequested = new Date(cursor.getString(cursor.getColumnIndex(REQUESTED_AT)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.PROCESSING))) {\n-            processing = cursor.getInt(cursor.getColumnIndex(IterableTask.PROCESSING)) > 0;\n+        if (!cursor.isNull(cursor.getColumnIndex(PROCESSING))) {\n+            processing = cursor.getInt(cursor.getColumnIndex(PROCESSING)) > 0;\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.FAILED))) {\n-            failed = cursor.getInt(cursor.getColumnIndex(IterableTask.FAILED)) > 0;\n+        if (!cursor.isNull(cursor.getColumnIndex(FAILED))) {\n+            failed = cursor.getInt(cursor.getColumnIndex(FAILED)) > 0;\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.BLOCKING))) {\n-            blocking = cursor.getInt(cursor.getColumnIndex(IterableTask.BLOCKING)) > 0;\n+        if (!cursor.isNull(cursor.getColumnIndex(BLOCKING))) {\n+            blocking = cursor.getInt(cursor.getColumnIndex(BLOCKING)) > 0;\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.DATA))) {\n-            data = cursor.getString(cursor.getColumnIndex(IterableTask.DATA));\n+        if (!cursor.isNull(cursor.getColumnIndex(DATA))) {\n+            data = cursor.getString(cursor.getColumnIndex(DATA));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ERROR))) {\n-            error = cursor.getString(cursor.getColumnIndex(IterableTask.ERROR));\n+        if (!cursor.isNull(cursor.getColumnIndex(ERROR))) {\n+            error = cursor.getString(cursor.getColumnIndex(ERROR));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.TYPE))) {\n-            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(IterableTask.TYPE)));\n+        if (!cursor.isNull(cursor.getColumnIndex(TYPE))) {\n+            type = IterableTaskType.valueOf(cursor.getString(cursor.getColumnIndex(TYPE)));\n         }\n-        if (!cursor.isNull(cursor.getColumnIndex(IterableTask.ATTEMPTS))) {\n-            attempts = cursor.getInt(cursor.getColumnIndex(IterableTask.ATTEMPTS));\n+        if (!cursor.isNull(cursor.getColumnIndex(ATTEMPTS))) {\n+            attempts = cursor.getInt(cursor.getColumnIndex(ATTEMPTS));\n         }\n \n-        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, datelastAttempted, datescheduled, dateRequested, processing, failed, blocking, data, error, IterableTaskType.API, attempts);\n+        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, dateLastAttempted, dateScheduled, dateRequested, processing, failed, blocking, data, error, type, attempts);\n         IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n+        cursor.close();\n         return task;\n     }\n \n", "next_change": {"commit": "343f3a4e8084dbae369fa0b95a3aa08450e7f643", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 7e924b5..443ea65 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -192,21 +200,19 @@ class IterableTaskManager {\n             attempts = cursor.getInt(cursor.getColumnIndex(ATTEMPTS));\n         }\n \n-        IterableTask task = new IterableTask(id, name, version, dateCreated, dateModified, dateLastAttempted, dateScheduled, dateRequested, processing, failed, blocking, data, error, type, attempts);\n-        IterableLogger.v(TAG, \"Found \" + cursor.getColumnCount() + \"columns\");\n-        cursor.close();\n-        return task;\n+        return new IterableTask(id, name, version, dateCreated, dateModified, dateLastAttempted, dateScheduled, dateRequested, processing, failed, blocking, data, error, type, attempts);\n     }\n \n     /**\n      * Gets ids of all the tasks in OfflineTask table\n-     *\n      * @return {@link ArrayList} of {@link String} ids for all the tasks in OfflineTask table\n      */\n     @NonNull\n     ArrayList<String> getAllTaskIds() {\n         ArrayList<String> taskIds = new ArrayList<>();\n-        if (!isDatabaseReady()) return taskIds;\n+        if (!isDatabaseReady()) {\n+            return taskIds;\n+        }\n \n         Cursor cursor = database.rawQuery(\"SELECT \" + TASK_ID +\n                         \" FROM \" + ITERABLE_TASK_TABLE_NAME,\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzODI4Mw==", "url": "https://github.com/Iterable/iterable-android-sdk/pull/284#discussion_r530038283", "body": "Catch Exception instead of Throwable\r\nSee CodeClimate: https://codeclimate.com/github/Iterable/iterable-android-sdk/pull/284#", "bodyText": "Catch Exception instead of Throwable\nSee CodeClimate: https://codeclimate.com/github/Iterable/iterable-android-sdk/pull/284#", "bodyHTML": "<p dir=\"auto\">Catch Exception instead of Throwable<br>\nSee CodeClimate: <a href=\"https://codeclimate.com/github/Iterable/iterable-android-sdk/pull/284#\" rel=\"nofollow\">https://codeclimate.com/github/Iterable/iterable-android-sdk/pull/284#</a></p>", "author": "vbabenkoru", "createdAt": "2020-11-25T00:51:59Z", "path": "iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java", "diffHunk": "@@ -0,0 +1,394 @@\n+package com.iterable.iterableapi;\n+\n+import android.content.ContentValues;\n+import android.content.Context;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+\n+public class IterableTaskManager {\n+\n+    private static IterableTaskManager sharedInstance;\n+\n+    private static final String TAG = \"IterableTaskManager\";\n+\n+    static final String ITERABLE_TASK_TABLE_NAME = \"OfflineTask\";\n+    private static final String REPLACING_STRING = \"*#*#*#*\";\n+    private static final String QUERY_GET_TASK_BY_ID = \"select * from OfflineTask where task_id = '\" + REPLACING_STRING + \"'\";\n+\n+    static final String OFFLINE_TASK_COLUMN_DATA = \" (\" + IterableTask.TASK_ID + \" TEXT PRIMARY KEY,\" +\n+            IterableTask.NAME + \" TEXT,\" +\n+            IterableTask.VERSION + \" INTEGER,\" +\n+            IterableTask.CREATED_AT + \" TEXT,\" +\n+            IterableTask.MODIFIED_AT + \" TEXT,\" +\n+            IterableTask.LAST_ATTEMPTED_AT + \" TEXT,\" +\n+            IterableTask.SCHEDULED_AT + \" TEXT,\" +\n+            IterableTask.REQUESTED_AT + \" TEXT,\" +\n+            IterableTask.PROCESSING + \" BOOLEAN,\" +\n+            IterableTask.FAILED + \" BOOLEAN,\" +\n+            IterableTask.BLOCKING + \" BOOLEAN,\" +\n+            IterableTask.DATA + \" TEXT,\" +\n+            IterableTask.ERROR + \" TEXT,\" +\n+            IterableTask.TYPE + \" TEXT,\" +\n+            IterableTask.ATTEMPTS + \" INTEGER\" + \")\";\n+    private static final String KEY_ROWID = \"rowid\";\n+\n+    private SQLiteDatabase database;\n+    private IterableDatabaseManager databaseManager;\n+\n+    private IterableTaskManager(Context context) {\n+        try {\n+            if (context == null) {\n+                return;\n+            }\n+\n+            if (databaseManager == null) {\n+                databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n+            }\n+            database = databaseManager.getWritableDatabase();\n+        } catch (Throwable t) {", "originalCommit": "473738ab19ad6f21d07ea3b4f7f2e5642f435b7e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "76d84007dd3243326de0c20003e1951154527a42", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nindex 81cb8c5..1bdf558 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n", "chunk": "@@ -51,8 +52,8 @@ public class IterableTaskManager {\n                 databaseManager = new IterableDatabaseManager(IterableApi.getInstance().getMainActivityContext());\n             }\n             database = databaseManager.getWritableDatabase();\n-        } catch (Throwable t) {\n-            IterableLogger.e(TAG, \"Failed to create database\");\n+        } catch (SQLException e) {\n+            IterableLogger.e(TAG, \"Database cannot be opened for writing\");\n         }\n     }\n \n", "next_change": {"commit": "afb187868a57f3f65b67ea7c11acc87ebd4e821c", "changed_code": [{"header": "diff --git a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskStorage.java\nsimilarity index 60%\nrename from iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\nrename to iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskStorage.java\nindex 1bdf558..59c5ef2 100644\n--- a/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskManager.java\n+++ b/iterableapi/src/main/java/com/iterable/iterableapi/IterableTaskStorage.java\n", "chunk": "@@ -57,9 +73,9 @@ public class IterableTaskManager {\n         }\n     }\n \n-    static IterableTaskManager sharedInstance(Context context) {\n+    static IterableTaskStorage sharedInstance(Context context) {\n         if (sharedInstance == null) {\n-            sharedInstance = new IterableTaskManager(context);\n+            sharedInstance = new IterableTaskStorage(context);\n         }\n         return sharedInstance;\n     }\n", "next_change": null}]}}]}}, {"oid": "76d84007dd3243326de0c20003e1951154527a42", "url": "https://github.com/Iterable/iterable-android-sdk/commit/76d84007dd3243326de0c20003e1951154527a42", "message": "Revision 3\n\nMade recommended changes\n1. precheck now has more db related check to see if its open and if there are any transaction going on\n2. renamed and refactored some functions\n3. deleted getTaskCount as it can derived from getAllTasks and checking the array size if at all needed.\n4. get all taskids now returns empty array and NOT NULL if there table is empty\n5. Added nullable annotations to getTask and createTask method\n6. TaskManager and its shared instance now needs context passed into the constructor. No more dependency on ItearbleApi.getInstance()\n7. Renaming precheck to isDatabaseReady\n8. Primitive boolean instead of Boolean\n9. inlcude type in constructor instead of hardcoded API type.\n10. Handle SQLException instead of just throwable t when getting writeable database.", "committedDate": "2020-11-25T16:43:49Z", "type": "commit"}, {"oid": "76d84007dd3243326de0c20003e1951154527a42", "url": "https://github.com/Iterable/iterable-android-sdk/commit/76d84007dd3243326de0c20003e1951154527a42", "message": "Revision 3\n\nMade recommended changes\n1. precheck now has more db related check to see if its open and if there are any transaction going on\n2. renamed and refactored some functions\n3. deleted getTaskCount as it can derived from getAllTasks and checking the array size if at all needed.\n4. get all taskids now returns empty array and NOT NULL if there table is empty\n5. Added nullable annotations to getTask and createTask method\n6. TaskManager and its shared instance now needs context passed into the constructor. No more dependency on ItearbleApi.getInstance()\n7. Renaming precheck to isDatabaseReady\n8. Primitive boolean instead of Boolean\n9. inlcude type in constructor instead of hardcoded API type.\n10. Handle SQLException instead of just throwable t when getting writeable database.", "committedDate": "2020-11-25T16:43:49Z", "type": "forcePushed"}]}