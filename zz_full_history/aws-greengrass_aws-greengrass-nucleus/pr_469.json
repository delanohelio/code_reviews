{"pr_number": 469, "pr_title": "implement simplified dependency resolution process", "pr_author": "wikimonkey", "pr_createdAt": "2020-09-24T01:07:02Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469", "merge_commit": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "timeline": [{"oid": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "message": "implement simplified dependency resolution process", "committedDate": "2020-09-24T00:55:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU2NTU0NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494565545", "body": "Does customer need to explicitly specify LOCAL in versionRequirement?", "bodyText": "Does customer need to explicitly specify LOCAL in versionRequirement?", "bodyHTML": "<p dir=\"auto\">Does customer need to explicitly specify LOCAL in versionRequirement?</p>", "author": "ShirleyZheng92", "createdAt": "2020-09-24T19:38:30Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +148,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcxOTkzOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494719938", "bodyText": "No, customer doesn't need to. We use LOCAL group for local development, the target components of LOCAL group mean they are local override, so keep using local available version.", "author": "wikimonkey", "createdAt": "2020-09-25T03:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU2NTU0NQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "94a91fb3344a9069462d7bb8828d1376304ec67b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 100366f6..8c27d806 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -148,89 +145,6 @@ public class ComponentManager implements InjectionActions {\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n-        // acquire ever possible local best candidate\n-        Optional<ComponentIdentifier> localCandidateOptional =\n-                findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n-        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n-            // keep using local version if the component is meant to be local override\n-            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n-            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n-                    () -> new NoAvailableComponentVersionException(\n-                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n-                                    componentName, versionRequirements)));\n-            return componentStore.getPackageMetadata(localCandidateId);\n-        } else {\n-            // otherwise use cloud determined version\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n-                    .log(\"Negotiate version with cloud\");\n-            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n-        }\n-    }\n-\n-    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n-                                                        Map<String, Requirement> versionRequirements,\n-                                                        ComponentIdentifier localCandidate) throws PackagingException {\n-        ComponentContent componentContent;\n-\n-        try {\n-            componentContent = componentServiceHelper\n-                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n-                            versionRequirements);\n-        } catch (NoAvailableComponentVersionException e) {\n-            if (localCandidate != null) {\n-                // if it's builtin service, it's not required to have components registered in registry\n-                ComponentMetadata componentMetadata =\n-                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n-                if (componentMetadata != null) {\n-                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n-                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n-                    return componentMetadata;\n-                }\n-            }\n-            throw e;\n-        }\n-        ComponentIdentifier resolvedComponentId =\n-                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n-        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n-\n-        boolean saveContent = true;\n-        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n-\n-        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {\n-            saveContent = false;\n-        }\n-\n-        if (saveContent) {\n-            componentStore.savePackageRecipe(resolvedComponentId, downloadedRecipeContent);\n-        }\n-\n-        return componentStore.getPackageMetadata(resolvedComponentId);\n-    }\n-\n-    private Optional<ComponentIdentifier> findLocalBestCandidate(String componentName,\n-                                                                 Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n-        Requirement req = mergeVersionRequirements(versionRequirements);\n-\n-        Optional<ComponentIdentifier> optionalActiveComponentId = findActiveAndSatisfiedComponent(componentName, req);\n-\n-        // use active one if compatible, otherwise check local available ones\n-        if (optionalActiveComponentId.isPresent()) {\n-            return optionalActiveComponentId;\n-        } else {\n-            return componentStore.findBestMatchAvailableComponent(componentName, req);\n-        }\n-    }\n-\n-    private Requirement mergeVersionRequirements(Map<String, Requirement> versionRequirements) {\n-        return Requirement.buildNPM(\n-                versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n-    }\n-\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": {"commit": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 8c27d806..4d0b2400 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -145,6 +147,89 @@ public class ComponentManager implements InjectionActions {\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n+                if (componentMetadata != null) {\n+                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n+                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n+                    return componentMetadata;\n+                }\n+            }\n+            throw e;\n+        }\n+        ComponentIdentifier resolvedComponentId =\n+                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n+        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n+\n+        boolean saveContent = true;\n+        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n+\n+        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {\n+            saveContent = false;\n+        }\n+\n+        if (saveContent) {\n+            componentStore.savePackageRecipe(resolvedComponentId, downloadedRecipeContent);\n+        }\n+\n+        return componentStore.getPackageMetadata(resolvedComponentId);\n+    }\n+\n+    private Optional<ComponentIdentifier> findLocalBestCandidate(String componentName,\n+                                                                 Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        Requirement req = mergeVersionRequirements(versionRequirements);\n+\n+        Optional<ComponentIdentifier> optionalActiveComponentId = findActiveAndSatisfiedComponent(componentName, req);\n+\n+        // use active one if compatible, otherwise check local available ones\n+        if (optionalActiveComponentId.isPresent()) {\n+            return optionalActiveComponentId;\n+        } else {\n+            return componentStore.findBestMatchAvailableComponent(componentName, req);\n+        }\n+    }\n+\n+    private Requirement mergeVersionRequirements(Map<String, Requirement> versionRequirements) {\n+        return Requirement.buildNPM(\n+                versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n+    }\n+\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": {"commit": "6897122ced7b7708d2909200d545c5a01b158ae2", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 4d0b2400..fae36b56 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -230,6 +230,21 @@ public class ComponentManager implements InjectionActions {\n                 versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n     }\n \n+    private ComponentMetadata getComponentMetadata(ComponentIdentifier componentIdentifier) throws PackagingException {\n+        // If the component is builtin, then we won't be able to get the metadata from the filesystem,\n+        // so in that case we will try getting it from builtin. If that fails too, then we just rethrow.\n+        try {\n+            return componentStore.getPackageMetadata(componentIdentifier);\n+        } catch (PackagingException e) {\n+            ComponentMetadata md =\n+                    getBuiltinComponentMetadata(componentIdentifier.getName(), componentIdentifier.getVersion());\n+            if (md != null) {\n+                return md;\n+            }\n+            throw e;\n+        }\n+    }\n+\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "message": "Merge commit", "committedDate": null}, {"oid": "94a91fb3344a9069462d7bb8828d1376304ec67b", "committedDate": "2020-12-13 21:10:27 -0800", "message": "Naming refactor (#454)"}, {"oid": "640d91990c6e1345bee669ad46f0e12bfc436b1b", "committedDate": "2020-12-13 21:10:28 -0800", "message": "component store file operations (#451)"}, {"oid": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "committedDate": "2020-12-13 21:10:29 -0800", "message": "implement simplified dependency resolution process (#469)"}, {"oid": "4b91b8db36338443b8443c78cb5581e3bb26fa81", "committedDate": "2020-12-13 21:10:29 -0800", "message": "add back public scope to builtin service since it needs to retrieve r\u2026 (#490)"}, {"oid": "6897122ced7b7708d2909200d545c5a01b158ae2", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Switch to new dependency resolution process (#493)"}, {"oid": "188dd671386b8d956d04651e3edd585e5371ec1b", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Device deployment (#486)"}, {"oid": "f41e02ddab79d0e5d128cf7c859026e75dceccf1", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Centralize paths and permissions (#506)"}, {"oid": "e38e39aceceff7d06e6515d43fd47d56397c6405", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Size limit (#473)"}, {"oid": "50bdfe8ef529f397189a4b72f63cd80d9ec70254", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Remove hardcoded scope in ComponentIdentifier (#507)"}, {"oid": "7558dd9dd4a94fa13dde5ed51ad5a52e4a21abbf", "committedDate": "2020-12-13 21:10:31 -0800", "message": "Fix problem with unarchiving being skipped for local artifacts  (#527)"}, {"oid": "29b4ebb6ef8e2245d75aee4324ae7b5617598f0e", "committedDate": "2020-12-13 21:10:33 -0800", "message": "System settings as Nucleus component configuration (#513)"}, {"oid": "f68508f974d61b4caac6ae73b92a26d02f699659", "committedDate": "2020-12-13 21:10:33 -0800", "message": "delete dead API references (#571)"}, {"oid": "773b41c3f20622b4c3249b9a31dff1f5913e7956", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Add timestamp to UpdateBehaviorTree to fix multi-group deployment (#561)"}, {"oid": "01c0b89deb5bff76791c4997e749c4840bb8defd", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Tag TODO items (#556)"}, {"oid": "c272aa34556114365188e21472327cd8a8951985", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Set the owner of artifacts for a service when commands are first run. (#555)"}, {"oid": "21f5f5e6df83324487ec99c55c1d0add7771743c", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Restrict loading of external plugins to cloud based recipes (#582)"}, {"oid": "5a8f026533bb6acc0e00a9f6b125bea352b60e1e", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Set artifact permissions according to recipe artifact permissions (#596)"}, {"oid": "9508d382d9500dc1b9525f90062a19da8aabac1f", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Todos (#601)"}, {"oid": "3fc04969985b8d2b1efa4589286907e05a60dfd0", "committedDate": "2020-12-13 21:10:35 -0800", "message": "refactor truncate tlog, fix tests (#608)"}, {"oid": "2fb3a699a9103045614c5592572d37d4400e9193", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Remove CLI from builtins (#634)"}, {"oid": "5bf7874693dd2184095a4c31af8a2a940934f7c9", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Add more logs to resolveComponentVersion; Add the initial deployment with config update test from PR #579 (#623)"}, {"oid": "5dae3ac8d84b04a3b6d82952f0da367354de7f8c", "committedDate": "2020-12-13 21:10:38 -0800", "message": "Allow going to cloud if no satifying version found locally for local group (#666)"}, {"oid": "1d1a754358376f2efb1532cf3c1634d179961f48", "committedDate": "2020-12-13 21:10:39 -0800", "message": "Add error handling & retry in ArtifactDownloader (#631)"}, {"oid": "88ed81262b145a652a6d6f9f5c450042fd9c957e", "committedDate": "2020-12-13 21:10:40 -0800", "message": "Use new cloud api model (#706)"}, {"oid": "dcbc85aa85f93d2b9610fb9494089ea9622269e1", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Recipe in json format (#722)"}, {"oid": "f28ff5e04af0727517de479e7e686e43882fc979", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use saved recipe content string to calculate recipe digest (#732)"}, {"oid": "2849a794de031e187dd26ea33cb673db8adb317f", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use AWS SDK v2 (#748)"}, {"oid": "4b87b714b44ab837cedfb024b8207b6402716a16", "committedDate": "2020-12-13 21:10:42 -0800", "message": "Add retry on client error(e.g. network loss) during deployment (#751)"}, {"oid": "48bf9decc7eb9bb7112fe9ff8c7fbce347f0268b", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Improve logs for deployment errors (#775)"}, {"oid": "e243971e7c66b3ce00e590c9a12ef723475b79ff", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Bump log to error level (#776)"}, {"oid": "02d8c479dfd957e1be98017caddf0155c93bd5fb", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Rename Kernel to Nucleus in string outputs (#788)"}, {"oid": "3b2350aec4dcacca2e88c06401e63b0078dd051b", "committedDate": "2021-01-20 16:41:43 -0800", "message": "improvement(various): No cloud calls if configured to run offline (#810)"}, {"oid": "2897e45a617ad35521ef94d0f08bf5b13ae4948b", "committedDate": "2021-02-25 15:47:02 -0800", "message": "feat(docker): initial implementation for docker image artifact downloader (#865)"}, {"oid": "d24acec456c0016dee23de2606a62c1ddda68623", "committedDate": "2021-03-10 16:15:02 -0800", "message": "feat(docker): improvements in validation, credential expiry handling, not logging credentials etc (#882)"}, {"oid": "91e8b1fc62cdd3fb1634f93c29e7489cb2421ec3", "committedDate": "2021-04-27 12:49:13 -0700", "message": "chore: use new pre-release dataplane SDK (#937)"}, {"oid": "dea87f115e1cb412cdc8d174b5e662d98fad62b1", "committedDate": "2021-05-27 16:41:08 -0700", "message": "feat(deployment): Support deployment with large configuration bigger than IoT Jobs/Shadow document limit (#963)"}, {"oid": "5be1aeeb9cbec04b7ee3c4d897d3f3b4d05662f2", "committedDate": "2021-08-04 15:56:10 -0700", "message": "fix: validate artifact uri from component recipe (#1013)"}, {"oid": "1a9aa3d87fa384a5d7d2f097d3e100e9a5099cad", "committedDate": "2021-08-05 11:22:40 -0700", "message": "fix(message): improve NoAvailableComponentVersionException messaging (#1040)"}, {"oid": "8a515091fa248d5d837a8521da8cb5682bc586a0", "committedDate": "2021-08-09 10:56:55 -0700", "message": "fix(logging): drop log level for many log messages (#1044)"}, {"oid": "a7e0a892a6f3b4cb787e24b63bc892e05654c223", "committedDate": "2022-08-30 23:07:42 -0700", "message": "feat: assign deployment error codes to deployment workflow (#1291)"}, {"oid": "fde355223d6fc405cca9c64af8c3ff6b5a6b8021", "committedDate": "2022-10-12 14:05:01 -0700", "message": "fix: parse status codes from gg v2 data exception (#1330)"}, {"oid": "2f98760ce8e5c7fb6ba5ac43647f0c8a4b873277", "committedDate": "2022-11-01 09:42:25 -0700", "message": "feat: warning log for discontinued component (#1349)"}, {"oid": "4bb96750c21bc02de3fd3fd6182afb8ecba41b46", "committedDate": "2022-12-08 12:30:56 -0500", "message": "fix: add logging around installed component not found (#1377)"}, {"oid": "6598594fd171065d5d46414353e7b18f3995304a", "committedDate": "2023-03-20 13:11:48 -0700", "message": "fix: re-negotiate with cloud if local recipe metadata contains a mismatched region (#1421)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MzYyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494593627", "body": "If other group contains a component that's not in the deployed group, will this be also marked as target? ", "bodyText": "If other group contains a component that's not in the deployed group, will this be also marked as target?", "bodyHTML": "<p dir=\"auto\">If other group contains a component that's not in the deployed group, will this be also marked as target?</p>", "author": "ShirleyZheng92", "createdAt": "2020-09-24T20:32:43Z", "path": "src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.componentmanager;\n+\n+import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n+import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n+import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n+import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.model.DeploymentDocument;\n+import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.vdurmont.semver4j.Requirement;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n+\n+@NoArgsConstructor\n+public class SimplifiedDependencyResolver {\n+    private static final Logger logger = LogManager.getLogger(SimplifiedDependencyResolver.class);\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String COMPONENT_NAME_KEY = \"componentName\";\n+    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n+\n+    @Inject\n+    private ComponentManager componentManager;\n+\n+    /**\n+     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n+     * conflicts between the components specified in the deployment document and the existing running components on the\n+     * device.\n+     *\n+     * @param document                      deployment document\n+     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n+     * @return a list of components to be run on the device\n+     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n+     * @throws PackagingException                   for other component operation errors\n+     */\n+    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n+                                                         Topics groupToTargetComponentDetails)\n+            throws NoAvailableComponentVersionException, PackagingException {\n+\n+        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n+        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n+        // dependent components posing different version constraints. 2. When the version of a dependent component\n+        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n+        // dependency tree.\n+        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n+\n+        // populate the other groups dependencies version requirement.\n+        Map<String, ComponentIdentifier> otherGroupsComponents =\n+                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n+                        componentNameToVersionConstraints);\n+\n+        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n+\n+        // Get the target components with version requirements in the deployment document\n+        List<String> targetComponentsToResolve = new ArrayList<>();\n+        document.getDeploymentPackageConfigurationList().stream()\n+                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n+            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())\n+                    .log(\"Found component configuration\");\n+            componentNameToVersionConstraints.putIfAbsent(e.getPackageName(), new HashMap<>());\n+            componentNameToVersionConstraints.get(e.getPackageName())\n+                    .put(document.getGroupName(), Requirement.buildNPM(e.getResolvedVersion()));\n+            targetComponentsToResolve.add(e.getPackageName());\n+        });\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-start\")\n+                .kv(\"targetComponents\", targetComponentsToResolve)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Start to resolve group dependencies\");\n+        // resolve target components dependencies\n+        for (String component : targetComponentsToResolve) {\n+            resolvedComponents.putAll(resolveComponentDependencies(component, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager.resolveComponentVersion(name, requirements)));\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Finish resolving group dependencies\");\n+        return new ArrayList<>(resolvedComponents.values());\n+    }\n+\n+\n+    private Set<String> getOtherGroupsTargetComponents(Topics groupToTargetComponentDetails, String deploymentGroupName,\n+                                                       Map<String, Map<String, Requirement>>\n+                                                               componentNameToVersionConstraints) {\n+        Set<String> targetComponents = new HashSet<>();\n+        groupToTargetComponentDetails.forEach(node -> {\n+            Topics groupTopics = (Topics) node;\n+            String groupName = groupTopics.getName();\n+            if (!groupName.equals(deploymentGroupName)) {\n+                groupTopics.forEach(componentTopic -> {\n+                    targetComponents.add(componentTopic.getName());", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMDY4Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494720683", "bodyText": "Yes, the purpose of these piece of code is to retrieve the other groups' target components. They should be resolved (including their dependencies) and running on the device at the time.", "author": "wikimonkey", "createdAt": "2020-09-25T03:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5MzYyNw=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "6897122ced7b7708d2909200d545c5a01b158ae2", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java b/src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java\ndeleted file mode 100644\nindex c9a1581e..00000000\n--- a/src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java\n+++ /dev/null\n", "chunk": "@@ -1,176 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- * SPDX-License-Identifier: Apache-2.0\n- */\n-\n-package com.aws.greengrass.componentmanager;\n-\n-import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n-import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n-import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n-import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n-import com.aws.greengrass.config.Topics;\n-import com.aws.greengrass.deployment.model.DeploymentDocument;\n-import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n-import com.vdurmont.semver4j.Requirement;\n-import lombok.NoArgsConstructor;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Queue;\n-import java.util.Set;\n-import javax.inject.Inject;\n-\n-import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n-\n-@NoArgsConstructor\n-public class SimplifiedDependencyResolver {\n-    private static final Logger logger = LogManager.getLogger(SimplifiedDependencyResolver.class);\n-    private static final String VERSION_KEY = \"version\";\n-    private static final String COMPONENT_NAME_KEY = \"componentName\";\n-    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n-\n-    @Inject\n-    private ComponentManager componentManager;\n-\n-    /**\n-     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n-     * conflicts between the components specified in the deployment document and the existing running components on the\n-     * device.\n-     *\n-     * @param document                      deployment document\n-     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n-     * @return a list of components to be run on the device\n-     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n-     * @throws PackagingException                   for other component operation errors\n-     */\n-    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n-                                                         Topics groupToTargetComponentDetails)\n-            throws NoAvailableComponentVersionException, PackagingException {\n-\n-        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n-        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n-        // dependent components posing different version constraints. 2. When the version of a dependent component\n-        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n-        // dependency tree.\n-        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n-\n-        // populate the other groups dependencies version requirement.\n-        Map<String, ComponentIdentifier> otherGroupsComponents =\n-                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n-                        componentNameToVersionConstraints);\n-\n-        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n-\n-        // Get the target components with version requirements in the deployment document\n-        List<String> targetComponentsToResolve = new ArrayList<>();\n-        document.getDeploymentPackageConfigurationList().stream()\n-                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n-            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())\n-                    .log(\"Found component configuration\");\n-            componentNameToVersionConstraints.putIfAbsent(e.getPackageName(), new HashMap<>());\n-            componentNameToVersionConstraints.get(e.getPackageName())\n-                    .put(document.getGroupName(), Requirement.buildNPM(e.getResolvedVersion()));\n-            targetComponentsToResolve.add(e.getPackageName());\n-        });\n-\n-        logger.atInfo().setEventType(\"resolve-group-dependencies-start\")\n-                .kv(\"targetComponents\", targetComponentsToResolve)\n-                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n-                .log(\"Start to resolve group dependencies\");\n-        // resolve target components dependencies\n-        for (String component : targetComponentsToResolve) {\n-            resolvedComponents.putAll(resolveComponentDependencies(component, componentNameToVersionConstraints,\n-                    (name, requirements) -> componentManager.resolveComponentVersion(name, requirements)));\n-        }\n-\n-        logger.atInfo().setEventType(\"resolve-group-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n-                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n-                .log(\"Finish resolving group dependencies\");\n-        return new ArrayList<>(resolvedComponents.values());\n-    }\n-\n-\n-    private Set<String> getOtherGroupsTargetComponents(Topics groupToTargetComponentDetails, String deploymentGroupName,\n-                                                       Map<String, Map<String, Requirement>>\n-                                                               componentNameToVersionConstraints) {\n-        Set<String> targetComponents = new HashSet<>();\n-        groupToTargetComponentDetails.forEach(node -> {\n-            Topics groupTopics = (Topics) node;\n-            String groupName = groupTopics.getName();\n-            if (!groupName.equals(deploymentGroupName)) {\n-                groupTopics.forEach(componentTopic -> {\n-                    targetComponents.add(componentTopic.getName());\n-                    componentNameToVersionConstraints.putIfAbsent(componentTopic.getName(), new HashMap<>());\n-                    Map<Object, Object> componentDetails = (Map) componentTopic.toPOJO();\n-                    componentNameToVersionConstraints.get(componentTopic.getName()).put(groupName, Requirement\n-                            .buildNPM(componentDetails.get(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).toString()));\n-                });\n-            }\n-        });\n-\n-        return targetComponents;\n-    }\n-\n-    private Map<String, ComponentIdentifier> populateOtherGroupsComponentsDependencies(\n-            Topics groupToTargetComponentDetails, String deploymentGroupName,\n-            Map<String, Map<String, Requirement>> componentNameToVersionConstraints) throws PackagingException {\n-        Set<String> otherGroupTargetComponents =\n-                getOtherGroupsTargetComponents(groupToTargetComponentDetails, deploymentGroupName,\n-                        componentNameToVersionConstraints);\n-        logger.atDebug().kv(\"otherGroupTargets\", otherGroupTargetComponents)\n-                .log(\"Found the other group target components\");\n-        // populate other groups target components dependencies\n-        // retrieve only dependency active version, update version requirement map\n-        Map<String, ComponentIdentifier> resolvedComponent = new HashMap<>();\n-        for (String targetComponent : otherGroupTargetComponents) {\n-            resolvedComponent.putAll(resolveComponentDependencies(targetComponent, componentNameToVersionConstraints,\n-                    (name, requirements) -> componentManager\n-                            .getActiveAndSatisfiedComponentMetadata(name, requirements)));\n-        }\n-\n-        return resolvedComponent;\n-    }\n-\n-    // Breadth first traverse of dependency tree, use component resolve to resolve every component\n-    private Map<String, ComponentIdentifier> resolveComponentDependencies(String targetComponentName,\n-                                                                          Map<String, Map<String, Requirement>>\n-                                                                                  componentNameToVersionConstraints,\n-                                                                          ComponentResolver componentResolver)\n-            throws PackagingException {\n-        logger.atDebug().setEventType(\"traverse-dependencies-start\").kv(\"targetComponent\", targetComponentName)\n-                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n-                .log(\"Start traversing dependencies\");\n-        Queue<String> componentsToResolve = new LinkedList<>();\n-        componentsToResolve.add(targetComponentName);\n-\n-        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>();\n-        while (componentsToResolve.size() != 0) {\n-            String componentToResolve = componentsToResolve.poll();\n-            Map<String, Requirement> versionConstraints = componentNameToVersionConstraints.get(componentToResolve);\n-            ComponentMetadata resolvedVersion = componentResolver.resolve(componentToResolve, versionConstraints);\n-            logger.atDebug().kv(\"resolvedVersion\", resolvedVersion).log(\"Resolved component\");\n-            resolvedComponents.put(componentToResolve, resolvedVersion.getComponentIdentifier());\n-            resolvedVersion.getDependencies().forEach((k, v) -> {\n-                componentNameToVersionConstraints.putIfAbsent(k, new HashMap<>());\n-                componentNameToVersionConstraints.get(k).put(componentToResolve, Requirement.buildNPM(v));\n-                componentsToResolve.add(k);\n-            });\n-        }\n-\n-        logger.atDebug().setEventType(\"traverse-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n-                .log(\"Finish traversing dependencies\");\n-        return resolvedComponents;\n-    }\n-\n-    @FunctionalInterface\n-    public interface ComponentResolver {\n-        ComponentMetadata resolve(String name, Map<String, Requirement> requirements) throws PackagingException;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "message": "Merge commit", "committedDate": null}, {"oid": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "committedDate": "2020-12-13 21:10:29 -0800", "message": "implement simplified dependency resolution process (#469)"}, {"oid": "6897122ced7b7708d2909200d545c5a01b158ae2", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Switch to new dependency resolution process (#493)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5NjQzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494596439", "body": "componentNameToVersionConstraints doesn't have the deployment doc added yet. Why can you resolve component dependencies here? What if the versionConstraints of a component in deployment doc is conflicting with other component version requirement?", "bodyText": "componentNameToVersionConstraints doesn't have the deployment doc added yet. Why can you resolve component dependencies here? What if the versionConstraints of a component in deployment doc is conflicting with other component version requirement?", "bodyHTML": "<p dir=\"auto\">componentNameToVersionConstraints doesn't have the deployment doc added yet. Why can you resolve component dependencies here? What if the versionConstraints of a component in deployment doc is conflicting with other component version requirement?</p>", "author": "ShirleyZheng92", "createdAt": "2020-09-24T20:38:14Z", "path": "src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.greengrass.componentmanager;\n+\n+import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n+import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n+import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n+import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n+import com.aws.greengrass.config.Topics;\n+import com.aws.greengrass.deployment.model.DeploymentDocument;\n+import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n+import com.aws.greengrass.logging.api.Logger;\n+import com.aws.greengrass.logging.impl.LogManager;\n+import com.vdurmont.semver4j.Requirement;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import javax.inject.Inject;\n+\n+import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n+\n+@NoArgsConstructor\n+public class SimplifiedDependencyResolver {\n+    private static final Logger logger = LogManager.getLogger(SimplifiedDependencyResolver.class);\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String COMPONENT_NAME_KEY = \"componentName\";\n+    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n+\n+    @Inject\n+    private ComponentManager componentManager;\n+\n+    /**\n+     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n+     * conflicts between the components specified in the deployment document and the existing running components on the\n+     * device.\n+     *\n+     * @param document                      deployment document\n+     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n+     * @return a list of components to be run on the device\n+     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n+     * @throws PackagingException                   for other component operation errors\n+     */\n+    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n+                                                         Topics groupToTargetComponentDetails)\n+            throws NoAvailableComponentVersionException, PackagingException {\n+\n+        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n+        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n+        // dependent components posing different version constraints. 2. When the version of a dependent component\n+        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n+        // dependency tree.\n+        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n+\n+        // populate the other groups dependencies version requirement.\n+        Map<String, ComponentIdentifier> otherGroupsComponents =\n+                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n+                        componentNameToVersionConstraints);\n+\n+        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n+\n+        // Get the target components with version requirements in the deployment document\n+        List<String> targetComponentsToResolve = new ArrayList<>();\n+        document.getDeploymentPackageConfigurationList().stream()\n+                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n+            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())\n+                    .log(\"Found component configuration\");\n+            componentNameToVersionConstraints.putIfAbsent(e.getPackageName(), new HashMap<>());\n+            componentNameToVersionConstraints.get(e.getPackageName())\n+                    .put(document.getGroupName(), Requirement.buildNPM(e.getResolvedVersion()));\n+            targetComponentsToResolve.add(e.getPackageName());\n+        });\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-start\")\n+                .kv(\"targetComponents\", targetComponentsToResolve)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Start to resolve group dependencies\");\n+        // resolve target components dependencies\n+        for (String component : targetComponentsToResolve) {\n+            resolvedComponents.putAll(resolveComponentDependencies(component, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager.resolveComponentVersion(name, requirements)));\n+        }\n+\n+        logger.atInfo().setEventType(\"resolve-group-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n+                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n+                .log(\"Finish resolving group dependencies\");\n+        return new ArrayList<>(resolvedComponents.values());\n+    }\n+\n+\n+    private Set<String> getOtherGroupsTargetComponents(Topics groupToTargetComponentDetails, String deploymentGroupName,\n+                                                       Map<String, Map<String, Requirement>>\n+                                                               componentNameToVersionConstraints) {\n+        Set<String> targetComponents = new HashSet<>();\n+        groupToTargetComponentDetails.forEach(node -> {\n+            Topics groupTopics = (Topics) node;\n+            String groupName = groupTopics.getName();\n+            if (!groupName.equals(deploymentGroupName)) {\n+                groupTopics.forEach(componentTopic -> {\n+                    targetComponents.add(componentTopic.getName());\n+                    componentNameToVersionConstraints.putIfAbsent(componentTopic.getName(), new HashMap<>());\n+                    Map<Object, Object> componentDetails = (Map) componentTopic.toPOJO();\n+                    componentNameToVersionConstraints.get(componentTopic.getName()).put(groupName, Requirement\n+                            .buildNPM(componentDetails.get(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).toString()));\n+                });\n+            }\n+        });\n+\n+        return targetComponents;\n+    }\n+\n+    private Map<String, ComponentIdentifier> populateOtherGroupsComponentsDependencies(\n+            Topics groupToTargetComponentDetails, String deploymentGroupName,\n+            Map<String, Map<String, Requirement>> componentNameToVersionConstraints) throws PackagingException {\n+        Set<String> otherGroupTargetComponents =\n+                getOtherGroupsTargetComponents(groupToTargetComponentDetails, deploymentGroupName,\n+                        componentNameToVersionConstraints);\n+        logger.atDebug().kv(\"otherGroupTargets\", otherGroupTargetComponents)\n+                .log(\"Found the other group target components\");\n+        // populate other groups target components dependencies\n+        // retrieve only dependency active version, update version requirement map\n+        Map<String, ComponentIdentifier> resolvedComponent = new HashMap<>();\n+        for (String targetComponent : otherGroupTargetComponents) {\n+            resolvedComponent.putAll(resolveComponentDependencies(targetComponent, componentNameToVersionConstraints,\n+                    (name, requirements) -> componentManager\n+                            .getActiveAndSatisfiedComponentMetadata(name, requirements)));\n+        }", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMTU4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494721585", "bodyText": "For the other groups, their dependencies should already be resolved and running on the device. The purpose of this iteration is to 1) build component to version requirements map because current deploying group can have common dependencies with the other groups; 2) get the other groups' resolved version because dependency resolver is supposed to return the full list of components.", "author": "wikimonkey", "createdAt": "2020-09-25T03:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU5NjQzOQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "6897122ced7b7708d2909200d545c5a01b158ae2", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java b/src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java\ndeleted file mode 100644\nindex c9a1581e..00000000\n--- a/src/main/java/com/aws/greengrass/componentmanager/SimplifiedDependencyResolver.java\n+++ /dev/null\n", "chunk": "@@ -1,176 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- * SPDX-License-Identifier: Apache-2.0\n- */\n-\n-package com.aws.greengrass.componentmanager;\n-\n-import com.aws.greengrass.componentmanager.exceptions.NoAvailableComponentVersionException;\n-import com.aws.greengrass.componentmanager.exceptions.PackagingException;\n-import com.aws.greengrass.componentmanager.models.ComponentIdentifier;\n-import com.aws.greengrass.componentmanager.models.ComponentMetadata;\n-import com.aws.greengrass.config.Topics;\n-import com.aws.greengrass.deployment.model.DeploymentDocument;\n-import com.aws.greengrass.deployment.model.DeploymentPackageConfiguration;\n-import com.aws.greengrass.logging.api.Logger;\n-import com.aws.greengrass.logging.impl.LogManager;\n-import com.vdurmont.semver4j.Requirement;\n-import lombok.NoArgsConstructor;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Queue;\n-import java.util.Set;\n-import javax.inject.Inject;\n-\n-import static com.aws.greengrass.deployment.DeploymentService.GROUP_TO_ROOT_COMPONENTS_VERSION_KEY;\n-\n-@NoArgsConstructor\n-public class SimplifiedDependencyResolver {\n-    private static final Logger logger = LogManager.getLogger(SimplifiedDependencyResolver.class);\n-    private static final String VERSION_KEY = \"version\";\n-    private static final String COMPONENT_NAME_KEY = \"componentName\";\n-    private static final String COMPONENT_VERSION_REQUIREMENT_KEY = \"componentToVersionRequirements\";\n-\n-    @Inject\n-    private ComponentManager componentManager;\n-\n-    /**\n-     * Create the full list of components to be run on the device from a deployment document. It also resolves the\n-     * conflicts between the components specified in the deployment document and the existing running components on the\n-     * device.\n-     *\n-     * @param document                      deployment document\n-     * @param groupToTargetComponentDetails {@link Topics} providing component details for each group\n-     * @return a list of components to be run on the device\n-     * @throws NoAvailableComponentVersionException no version of the component can fulfill the deployment\n-     * @throws PackagingException                   for other component operation errors\n-     */\n-    public List<ComponentIdentifier> resolveDependencies(DeploymentDocument document,\n-                                                         Topics groupToTargetComponentDetails)\n-            throws NoAvailableComponentVersionException, PackagingException {\n-\n-        // A map of component version constraints {componentName => {dependentComponentName => versionConstraint}} to be\n-        // maintained and updated. This information needs to be tracked because: 1. One component can have multiple\n-        // dependent components posing different version constraints. 2. When the version of a dependent component\n-        // changes, the version constraints will also change accordingly. 3. The information also shows the complete\n-        // dependency tree.\n-        Map<String, Map<String, Requirement>> componentNameToVersionConstraints = new HashMap<>();\n-\n-        // populate the other groups dependencies version requirement.\n-        Map<String, ComponentIdentifier> otherGroupsComponents =\n-                populateOtherGroupsComponentsDependencies(groupToTargetComponentDetails, document.getGroupName(),\n-                        componentNameToVersionConstraints);\n-\n-        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>(otherGroupsComponents);\n-\n-        // Get the target components with version requirements in the deployment document\n-        List<String> targetComponentsToResolve = new ArrayList<>();\n-        document.getDeploymentPackageConfigurationList().stream()\n-                .filter(DeploymentPackageConfiguration::isRootComponent).forEach(e -> {\n-            logger.atDebug().kv(COMPONENT_NAME_KEY, e.getPackageName()).kv(VERSION_KEY, e.getResolvedVersion())\n-                    .log(\"Found component configuration\");\n-            componentNameToVersionConstraints.putIfAbsent(e.getPackageName(), new HashMap<>());\n-            componentNameToVersionConstraints.get(e.getPackageName())\n-                    .put(document.getGroupName(), Requirement.buildNPM(e.getResolvedVersion()));\n-            targetComponentsToResolve.add(e.getPackageName());\n-        });\n-\n-        logger.atInfo().setEventType(\"resolve-group-dependencies-start\")\n-                .kv(\"targetComponents\", targetComponentsToResolve)\n-                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n-                .log(\"Start to resolve group dependencies\");\n-        // resolve target components dependencies\n-        for (String component : targetComponentsToResolve) {\n-            resolvedComponents.putAll(resolveComponentDependencies(component, componentNameToVersionConstraints,\n-                    (name, requirements) -> componentManager.resolveComponentVersion(name, requirements)));\n-        }\n-\n-        logger.atInfo().setEventType(\"resolve-group-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n-                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n-                .log(\"Finish resolving group dependencies\");\n-        return new ArrayList<>(resolvedComponents.values());\n-    }\n-\n-\n-    private Set<String> getOtherGroupsTargetComponents(Topics groupToTargetComponentDetails, String deploymentGroupName,\n-                                                       Map<String, Map<String, Requirement>>\n-                                                               componentNameToVersionConstraints) {\n-        Set<String> targetComponents = new HashSet<>();\n-        groupToTargetComponentDetails.forEach(node -> {\n-            Topics groupTopics = (Topics) node;\n-            String groupName = groupTopics.getName();\n-            if (!groupName.equals(deploymentGroupName)) {\n-                groupTopics.forEach(componentTopic -> {\n-                    targetComponents.add(componentTopic.getName());\n-                    componentNameToVersionConstraints.putIfAbsent(componentTopic.getName(), new HashMap<>());\n-                    Map<Object, Object> componentDetails = (Map) componentTopic.toPOJO();\n-                    componentNameToVersionConstraints.get(componentTopic.getName()).put(groupName, Requirement\n-                            .buildNPM(componentDetails.get(GROUP_TO_ROOT_COMPONENTS_VERSION_KEY).toString()));\n-                });\n-            }\n-        });\n-\n-        return targetComponents;\n-    }\n-\n-    private Map<String, ComponentIdentifier> populateOtherGroupsComponentsDependencies(\n-            Topics groupToTargetComponentDetails, String deploymentGroupName,\n-            Map<String, Map<String, Requirement>> componentNameToVersionConstraints) throws PackagingException {\n-        Set<String> otherGroupTargetComponents =\n-                getOtherGroupsTargetComponents(groupToTargetComponentDetails, deploymentGroupName,\n-                        componentNameToVersionConstraints);\n-        logger.atDebug().kv(\"otherGroupTargets\", otherGroupTargetComponents)\n-                .log(\"Found the other group target components\");\n-        // populate other groups target components dependencies\n-        // retrieve only dependency active version, update version requirement map\n-        Map<String, ComponentIdentifier> resolvedComponent = new HashMap<>();\n-        for (String targetComponent : otherGroupTargetComponents) {\n-            resolvedComponent.putAll(resolveComponentDependencies(targetComponent, componentNameToVersionConstraints,\n-                    (name, requirements) -> componentManager\n-                            .getActiveAndSatisfiedComponentMetadata(name, requirements)));\n-        }\n-\n-        return resolvedComponent;\n-    }\n-\n-    // Breadth first traverse of dependency tree, use component resolve to resolve every component\n-    private Map<String, ComponentIdentifier> resolveComponentDependencies(String targetComponentName,\n-                                                                          Map<String, Map<String, Requirement>>\n-                                                                                  componentNameToVersionConstraints,\n-                                                                          ComponentResolver componentResolver)\n-            throws PackagingException {\n-        logger.atDebug().setEventType(\"traverse-dependencies-start\").kv(\"targetComponent\", targetComponentName)\n-                .kv(COMPONENT_VERSION_REQUIREMENT_KEY, componentNameToVersionConstraints)\n-                .log(\"Start traversing dependencies\");\n-        Queue<String> componentsToResolve = new LinkedList<>();\n-        componentsToResolve.add(targetComponentName);\n-\n-        Map<String, ComponentIdentifier> resolvedComponents = new HashMap<>();\n-        while (componentsToResolve.size() != 0) {\n-            String componentToResolve = componentsToResolve.poll();\n-            Map<String, Requirement> versionConstraints = componentNameToVersionConstraints.get(componentToResolve);\n-            ComponentMetadata resolvedVersion = componentResolver.resolve(componentToResolve, versionConstraints);\n-            logger.atDebug().kv(\"resolvedVersion\", resolvedVersion).log(\"Resolved component\");\n-            resolvedComponents.put(componentToResolve, resolvedVersion.getComponentIdentifier());\n-            resolvedVersion.getDependencies().forEach((k, v) -> {\n-                componentNameToVersionConstraints.putIfAbsent(k, new HashMap<>());\n-                componentNameToVersionConstraints.get(k).put(componentToResolve, Requirement.buildNPM(v));\n-                componentsToResolve.add(k);\n-            });\n-        }\n-\n-        logger.atDebug().setEventType(\"traverse-dependencies-finish\").kv(\"resolvedComponents\", resolvedComponents)\n-                .log(\"Finish traversing dependencies\");\n-        return resolvedComponents;\n-    }\n-\n-    @FunctionalInterface\n-    public interface ComponentResolver {\n-        ComponentMetadata resolve(String name, Map<String, Requirement> requirements) throws PackagingException;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "message": "Merge commit", "committedDate": null}, {"oid": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "committedDate": "2020-12-13 21:10:29 -0800", "message": "implement simplified dependency resolution process (#469)"}, {"oid": "6897122ced7b7708d2909200d545c5a01b158ae2", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Switch to new dependency resolution process (#493)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494608482", "body": "Is this the entire recipe content string match? Will version check be simpler?", "bodyText": "Is this the entire recipe content string match? Will version check be simpler?", "bodyHTML": "<p dir=\"auto\">Is this the entire recipe content string match? Will version check be simpler?</p>", "author": "ShirleyZheng92", "createdAt": "2020-09-24T21:02:11Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +148,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n+                if (componentMetadata != null) {\n+                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n+                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n+                    return componentMetadata;\n+                }\n+            }\n+            throw e;\n+        }\n+        ComponentIdentifier resolvedComponentId =\n+                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n+        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n+\n+        boolean saveContent = true;\n+        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n+\n+        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMTg4NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494721884", "bodyText": "It needs to do content comparison because private registry name occlusion feature - private is same version as public, but private needs to replace public.", "author": "wikimonkey", "createdAt": "2020-09-25T03:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4ODEwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495188106", "bodyText": "It also has the additional benefit (implicitly) to recover mutated/corrupted recipe...", "author": "leaf94", "createdAt": "2020-09-25T19:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3Mzc3Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496173772", "bodyText": "I'd prefer jsonNode object comparison. But that can be implemented later", "author": "ShirleyZheng92", "createdAt": "2020-09-28T19:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYwODQ4Mg=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "94a91fb3344a9069462d7bb8828d1376304ec67b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 100366f6..8c27d806 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -148,89 +145,6 @@ public class ComponentManager implements InjectionActions {\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n-        // acquire ever possible local best candidate\n-        Optional<ComponentIdentifier> localCandidateOptional =\n-                findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n-        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n-            // keep using local version if the component is meant to be local override\n-            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n-            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n-                    () -> new NoAvailableComponentVersionException(\n-                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n-                                    componentName, versionRequirements)));\n-            return componentStore.getPackageMetadata(localCandidateId);\n-        } else {\n-            // otherwise use cloud determined version\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n-                    .log(\"Negotiate version with cloud\");\n-            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n-        }\n-    }\n-\n-    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n-                                                        Map<String, Requirement> versionRequirements,\n-                                                        ComponentIdentifier localCandidate) throws PackagingException {\n-        ComponentContent componentContent;\n-\n-        try {\n-            componentContent = componentServiceHelper\n-                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n-                            versionRequirements);\n-        } catch (NoAvailableComponentVersionException e) {\n-            if (localCandidate != null) {\n-                // if it's builtin service, it's not required to have components registered in registry\n-                ComponentMetadata componentMetadata =\n-                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n-                if (componentMetadata != null) {\n-                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n-                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n-                    return componentMetadata;\n-                }\n-            }\n-            throw e;\n-        }\n-        ComponentIdentifier resolvedComponentId =\n-                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n-        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n-\n-        boolean saveContent = true;\n-        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n-\n-        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {\n-            saveContent = false;\n-        }\n-\n-        if (saveContent) {\n-            componentStore.savePackageRecipe(resolvedComponentId, downloadedRecipeContent);\n-        }\n-\n-        return componentStore.getPackageMetadata(resolvedComponentId);\n-    }\n-\n-    private Optional<ComponentIdentifier> findLocalBestCandidate(String componentName,\n-                                                                 Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n-        Requirement req = mergeVersionRequirements(versionRequirements);\n-\n-        Optional<ComponentIdentifier> optionalActiveComponentId = findActiveAndSatisfiedComponent(componentName, req);\n-\n-        // use active one if compatible, otherwise check local available ones\n-        if (optionalActiveComponentId.isPresent()) {\n-            return optionalActiveComponentId;\n-        } else {\n-            return componentStore.findBestMatchAvailableComponent(componentName, req);\n-        }\n-    }\n-\n-    private Requirement mergeVersionRequirements(Map<String, Requirement> versionRequirements) {\n-        return Requirement.buildNPM(\n-                versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n-    }\n-\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": {"commit": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 8c27d806..4d0b2400 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -145,6 +147,89 @@ public class ComponentManager implements InjectionActions {\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n+                if (componentMetadata != null) {\n+                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n+                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n+                    return componentMetadata;\n+                }\n+            }\n+            throw e;\n+        }\n+        ComponentIdentifier resolvedComponentId =\n+                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n+        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n+\n+        boolean saveContent = true;\n+        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n+\n+        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {\n+            saveContent = false;\n+        }\n+\n+        if (saveContent) {\n+            componentStore.savePackageRecipe(resolvedComponentId, downloadedRecipeContent);\n+        }\n+\n+        return componentStore.getPackageMetadata(resolvedComponentId);\n+    }\n+\n+    private Optional<ComponentIdentifier> findLocalBestCandidate(String componentName,\n+                                                                 Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        Requirement req = mergeVersionRequirements(versionRequirements);\n+\n+        Optional<ComponentIdentifier> optionalActiveComponentId = findActiveAndSatisfiedComponent(componentName, req);\n+\n+        // use active one if compatible, otherwise check local available ones\n+        if (optionalActiveComponentId.isPresent()) {\n+            return optionalActiveComponentId;\n+        } else {\n+            return componentStore.findBestMatchAvailableComponent(componentName, req);\n+        }\n+    }\n+\n+    private Requirement mergeVersionRequirements(Map<String, Requirement> versionRequirements) {\n+        return Requirement.buildNPM(\n+                versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n+    }\n+\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": {"commit": "6897122ced7b7708d2909200d545c5a01b158ae2", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 4d0b2400..fae36b56 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -230,6 +230,21 @@ public class ComponentManager implements InjectionActions {\n                 versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n     }\n \n+    private ComponentMetadata getComponentMetadata(ComponentIdentifier componentIdentifier) throws PackagingException {\n+        // If the component is builtin, then we won't be able to get the metadata from the filesystem,\n+        // so in that case we will try getting it from builtin. If that fails too, then we just rethrow.\n+        try {\n+            return componentStore.getPackageMetadata(componentIdentifier);\n+        } catch (PackagingException e) {\n+            ComponentMetadata md =\n+                    getBuiltinComponentMetadata(componentIdentifier.getName(), componentIdentifier.getVersion());\n+            if (md != null) {\n+                return md;\n+            }\n+            throw e;\n+        }\n+    }\n+\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "message": "Merge commit", "committedDate": null}, {"oid": "94a91fb3344a9069462d7bb8828d1376304ec67b", "committedDate": "2020-12-13 21:10:27 -0800", "message": "Naming refactor (#454)"}, {"oid": "640d91990c6e1345bee669ad46f0e12bfc436b1b", "committedDate": "2020-12-13 21:10:28 -0800", "message": "component store file operations (#451)"}, {"oid": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "committedDate": "2020-12-13 21:10:29 -0800", "message": "implement simplified dependency resolution process (#469)"}, {"oid": "4b91b8db36338443b8443c78cb5581e3bb26fa81", "committedDate": "2020-12-13 21:10:29 -0800", "message": "add back public scope to builtin service since it needs to retrieve r\u2026 (#490)"}, {"oid": "6897122ced7b7708d2909200d545c5a01b158ae2", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Switch to new dependency resolution process (#493)"}, {"oid": "188dd671386b8d956d04651e3edd585e5371ec1b", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Device deployment (#486)"}, {"oid": "f41e02ddab79d0e5d128cf7c859026e75dceccf1", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Centralize paths and permissions (#506)"}, {"oid": "e38e39aceceff7d06e6515d43fd47d56397c6405", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Size limit (#473)"}, {"oid": "50bdfe8ef529f397189a4b72f63cd80d9ec70254", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Remove hardcoded scope in ComponentIdentifier (#507)"}, {"oid": "7558dd9dd4a94fa13dde5ed51ad5a52e4a21abbf", "committedDate": "2020-12-13 21:10:31 -0800", "message": "Fix problem with unarchiving being skipped for local artifacts  (#527)"}, {"oid": "29b4ebb6ef8e2245d75aee4324ae7b5617598f0e", "committedDate": "2020-12-13 21:10:33 -0800", "message": "System settings as Nucleus component configuration (#513)"}, {"oid": "f68508f974d61b4caac6ae73b92a26d02f699659", "committedDate": "2020-12-13 21:10:33 -0800", "message": "delete dead API references (#571)"}, {"oid": "773b41c3f20622b4c3249b9a31dff1f5913e7956", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Add timestamp to UpdateBehaviorTree to fix multi-group deployment (#561)"}, {"oid": "01c0b89deb5bff76791c4997e749c4840bb8defd", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Tag TODO items (#556)"}, {"oid": "c272aa34556114365188e21472327cd8a8951985", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Set the owner of artifacts for a service when commands are first run. (#555)"}, {"oid": "21f5f5e6df83324487ec99c55c1d0add7771743c", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Restrict loading of external plugins to cloud based recipes (#582)"}, {"oid": "5a8f026533bb6acc0e00a9f6b125bea352b60e1e", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Set artifact permissions according to recipe artifact permissions (#596)"}, {"oid": "9508d382d9500dc1b9525f90062a19da8aabac1f", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Todos (#601)"}, {"oid": "3fc04969985b8d2b1efa4589286907e05a60dfd0", "committedDate": "2020-12-13 21:10:35 -0800", "message": "refactor truncate tlog, fix tests (#608)"}, {"oid": "2fb3a699a9103045614c5592572d37d4400e9193", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Remove CLI from builtins (#634)"}, {"oid": "5bf7874693dd2184095a4c31af8a2a940934f7c9", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Add more logs to resolveComponentVersion; Add the initial deployment with config update test from PR #579 (#623)"}, {"oid": "5dae3ac8d84b04a3b6d82952f0da367354de7f8c", "committedDate": "2020-12-13 21:10:38 -0800", "message": "Allow going to cloud if no satifying version found locally for local group (#666)"}, {"oid": "1d1a754358376f2efb1532cf3c1634d179961f48", "committedDate": "2020-12-13 21:10:39 -0800", "message": "Add error handling & retry in ArtifactDownloader (#631)"}, {"oid": "88ed81262b145a652a6d6f9f5c450042fd9c957e", "committedDate": "2020-12-13 21:10:40 -0800", "message": "Use new cloud api model (#706)"}, {"oid": "dcbc85aa85f93d2b9610fb9494089ea9622269e1", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Recipe in json format (#722)"}, {"oid": "f28ff5e04af0727517de479e7e686e43882fc979", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use saved recipe content string to calculate recipe digest (#732)"}, {"oid": "2849a794de031e187dd26ea33cb673db8adb317f", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use AWS SDK v2 (#748)"}, {"oid": "4b87b714b44ab837cedfb024b8207b6402716a16", "committedDate": "2020-12-13 21:10:42 -0800", "message": "Add retry on client error(e.g. network loss) during deployment (#751)"}, {"oid": "48bf9decc7eb9bb7112fe9ff8c7fbce347f0268b", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Improve logs for deployment errors (#775)"}, {"oid": "e243971e7c66b3ce00e590c9a12ef723475b79ff", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Bump log to error level (#776)"}, {"oid": "02d8c479dfd957e1be98017caddf0155c93bd5fb", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Rename Kernel to Nucleus in string outputs (#788)"}, {"oid": "3b2350aec4dcacca2e88c06401e63b0078dd051b", "committedDate": "2021-01-20 16:41:43 -0800", "message": "improvement(various): No cloud calls if configured to run offline (#810)"}, {"oid": "2897e45a617ad35521ef94d0f08bf5b13ae4948b", "committedDate": "2021-02-25 15:47:02 -0800", "message": "feat(docker): initial implementation for docker image artifact downloader (#865)"}, {"oid": "d24acec456c0016dee23de2606a62c1ddda68623", "committedDate": "2021-03-10 16:15:02 -0800", "message": "feat(docker): improvements in validation, credential expiry handling, not logging credentials etc (#882)"}, {"oid": "91e8b1fc62cdd3fb1634f93c29e7489cb2421ec3", "committedDate": "2021-04-27 12:49:13 -0700", "message": "chore: use new pre-release dataplane SDK (#937)"}, {"oid": "dea87f115e1cb412cdc8d174b5e662d98fad62b1", "committedDate": "2021-05-27 16:41:08 -0700", "message": "feat(deployment): Support deployment with large configuration bigger than IoT Jobs/Shadow document limit (#963)"}, {"oid": "5be1aeeb9cbec04b7ee3c4d897d3f3b4d05662f2", "committedDate": "2021-08-04 15:56:10 -0700", "message": "fix: validate artifact uri from component recipe (#1013)"}, {"oid": "1a9aa3d87fa384a5d7d2f097d3e100e9a5099cad", "committedDate": "2021-08-05 11:22:40 -0700", "message": "fix(message): improve NoAvailableComponentVersionException messaging (#1040)"}, {"oid": "8a515091fa248d5d837a8521da8cb5682bc586a0", "committedDate": "2021-08-09 10:56:55 -0700", "message": "fix(logging): drop log level for many log messages (#1044)"}, {"oid": "a7e0a892a6f3b4cb787e24b63bc892e05654c223", "committedDate": "2022-08-30 23:07:42 -0700", "message": "feat: assign deployment error codes to deployment workflow (#1291)"}, {"oid": "fde355223d6fc405cca9c64af8c3ff6b5a6b8021", "committedDate": "2022-10-12 14:05:01 -0700", "message": "fix: parse status codes from gg v2 data exception (#1330)"}, {"oid": "2f98760ce8e5c7fb6ba5ac43647f0c8a4b873277", "committedDate": "2022-11-01 09:42:25 -0700", "message": "feat: warning log for discontinued component (#1349)"}, {"oid": "4bb96750c21bc02de3fd3fd6182afb8ecba41b46", "committedDate": "2022-12-08 12:30:56 -0500", "message": "fix: add logging around installed component not found (#1377)"}, {"oid": "6598594fd171065d5d46414353e7b18f3995304a", "committedDate": "2023-03-20 13:11:48 -0700", "message": "fix: re-negotiate with cloud if local recipe metadata contains a mismatched region (#1421)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494616018", "body": "What is the sort based on?", "bodyText": "What is the sort based on?", "bodyHTML": "<p dir=\"auto\">What is the sort based on?</p>", "author": "ShirleyZheng92", "createdAt": "2020-09-24T21:17:47Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "diffHunk": "@@ -209,6 +210,39 @@ ComponentMetadata getPackageMetadata(@NonNull ComponentIdentifier pkgId) throws\n         return componentMetadataList;\n     }\n \n+    Optional<ComponentIdentifier> findBestMatchAvailableComponent(@NonNull String componentName,\n+                                                                  @NonNull Requirement requirement)\n+            throws PackageLoadingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n+\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Optional.empty();\n+        }\n+\n+        Arrays.sort(recipeFiles);\n+\n+        List<ComponentIdentifier> componentIdentifierList = new ArrayList<>();\n+        for (File recipeFile : recipeFiles) {\n+            String recipeComponentName = parsePackageNameFromFileName(recipeFile.getName());\n+\n+            if (!recipeComponentName.equalsIgnoreCase(componentName)) {\n+                continue;\n+            }\n+\n+            Semver version = parseVersionFromFileName(recipeFile.getName());\n+            if (requirement.isSatisfiedBy(version)) {\n+                componentIdentifierList.add(new ComponentIdentifier(componentName, version));\n+            }\n+        }\n+        componentIdentifierList.sort(null);", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMjEyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494722129", "bodyText": "based upon semver ordering implemented in Semver4j library which will ensure 1.10 > 1.9 :)", "author": "wikimonkey", "createdAt": "2020-09-25T03:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMjYxMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494722610", "bodyText": "Default sort is ascending order, so the latest version would be last. Is that what you are expecting?", "author": "MikeDombo", "createdAt": "2020-09-25T03:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyNTIxNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494725214", "bodyText": "I want descending order. I think you override ComponentIdentifier::compareTo method, so now it's sorted in descending order.", "author": "wikimonkey", "createdAt": "2020-09-25T03:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxNjAxOA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "94a91fb3344a9069462d7bb8828d1376304ec67b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\nindex 92b8ecb4..420131dc 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n", "chunk": "@@ -210,39 +189,6 @@ public class ComponentStore {\n         return componentMetadataList;\n     }\n \n-    Optional<ComponentIdentifier> findBestMatchAvailableComponent(@NonNull String componentName,\n-                                                                  @NonNull Requirement requirement)\n-            throws PackageLoadingException {\n-        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n-\n-        if (recipeFiles == null || recipeFiles.length == 0) {\n-            return Optional.empty();\n-        }\n-\n-        Arrays.sort(recipeFiles);\n-\n-        List<ComponentIdentifier> componentIdentifierList = new ArrayList<>();\n-        for (File recipeFile : recipeFiles) {\n-            String recipeComponentName = parsePackageNameFromFileName(recipeFile.getName());\n-\n-            if (!recipeComponentName.equalsIgnoreCase(componentName)) {\n-                continue;\n-            }\n-\n-            Semver version = parseVersionFromFileName(recipeFile.getName());\n-            if (requirement.isSatisfiedBy(version)) {\n-                componentIdentifierList.add(new ComponentIdentifier(componentName, version));\n-            }\n-        }\n-        componentIdentifierList.sort(null);\n-\n-        if (componentIdentifierList.isEmpty()) {\n-            return Optional.empty();\n-        } else {\n-            return Optional.of(componentIdentifierList.get(0));\n-        }\n-    }\n-\n \n     /**\n      * Resolve the artifact directory path for a target package id.\n", "next_change": {"commit": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\nindex 420131dc..0b60ba1d 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n", "chunk": "@@ -189,6 +211,39 @@ public class ComponentStore {\n         return componentMetadataList;\n     }\n \n+    Optional<ComponentIdentifier> findBestMatchAvailableComponent(@NonNull String componentName,\n+                                                                  @NonNull Requirement requirement)\n+            throws PackageLoadingException {\n+        File[] recipeFiles = recipeDirectory.toFile().listFiles();\n+\n+        if (recipeFiles == null || recipeFiles.length == 0) {\n+            return Optional.empty();\n+        }\n+\n+        Arrays.sort(recipeFiles);\n+\n+        List<ComponentIdentifier> componentIdentifierList = new ArrayList<>();\n+        for (File recipeFile : recipeFiles) {\n+            String recipeComponentName = parsePackageNameFromFileName(recipeFile.getName());\n+\n+            if (!recipeComponentName.equalsIgnoreCase(componentName)) {\n+                continue;\n+            }\n+\n+            Semver version = parseVersionFromFileName(recipeFile.getName());\n+            if (requirement.isSatisfiedBy(version)) {\n+                componentIdentifierList.add(new ComponentIdentifier(componentName, version));\n+            }\n+        }\n+        componentIdentifierList.sort(null);\n+\n+        if (componentIdentifierList.isEmpty()) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(componentIdentifierList.get(0));\n+        }\n+    }\n+\n \n     /**\n      * Resolve the artifact directory path for a target package id.\n", "next_change": {"commit": "f41e02ddab79d0e5d128cf7c859026e75dceccf1", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\nindex 0b60ba1d..7ceba172 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n", "chunk": "@@ -250,10 +252,15 @@ public class ComponentStore {\n      *\n      * @param componentIdentifier packageIdentifier\n      * @return the artifact directory path for target package.\n+     * @throws PackageLoadingException if creating the directory fails\n      */\n-    public Path resolveArtifactDirectoryPath(@NonNull ComponentIdentifier componentIdentifier) {\n-        return artifactDirectory.resolve(componentIdentifier.getName())\n-                .resolve(componentIdentifier.getVersion().getValue());\n+    public Path resolveArtifactDirectoryPath(@NonNull ComponentIdentifier componentIdentifier)\n+            throws PackageLoadingException {\n+        try {\n+            return nucleusPaths.artifactPath(componentIdentifier);\n+        } catch (IOException e) {\n+            throw new PackageLoadingException(\"Unable to create artifact path\", e);\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "0874798bd8d343f605e53aaa7a27b64e13403986", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\nindex 7ceba172..fd537abe 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n", "chunk": "@@ -268,14 +342,14 @@ public class ComponentStore {\n      *\n      * @param componentIdentifier packageIdentifier\n      * @return the recipe file path for target package.\n+     * @throws PackageLoadingException if unable to resolve recipe file path\n      */\n-    public Path resolveRecipePath(@NonNull ComponentIdentifier componentIdentifier) {\n-        return resolveRecipePath(componentIdentifier.getName(), componentIdentifier.getVersion());\n-    }\n+    public Path resolveRecipePath(@NonNull ComponentIdentifier componentIdentifier) throws PackageLoadingException {\n+        // .recipe is to indicate it is the recipe\n+        // .yaml at the end is to indicate the file content type is a yaml\n+        String recipeFileName = String.format(\"%s.recipe.yaml\", getFilenamePrefixFromComponentId(componentIdentifier));\n \n-    private Path resolveRecipePath(String packageName, Semver packageVersion) {\n-        return nucleusPaths.recipePath().resolve(String.format(RECIPE_FILE_NAME_FORMAT,\n-                packageName, packageVersion.getValue()));\n+        return nucleusPaths.recipePath().resolve(recipeFileName);\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "message": "Merge commit", "committedDate": null}, {"oid": "94a91fb3344a9069462d7bb8828d1376304ec67b", "committedDate": "2020-12-13 21:10:27 -0800", "message": "Naming refactor (#454)"}, {"oid": "640d91990c6e1345bee669ad46f0e12bfc436b1b", "committedDate": "2020-12-13 21:10:28 -0800", "message": "component store file operations (#451)"}, {"oid": "41fdc60642a1698e9de83b93ad08983f92743219", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Resolve SonarLint found issues (#480)"}, {"oid": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "committedDate": "2020-12-13 21:10:29 -0800", "message": "implement simplified dependency resolution process (#469)"}, {"oid": "f41e02ddab79d0e5d128cf7c859026e75dceccf1", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Centralize paths and permissions (#506)"}, {"oid": "e38e39aceceff7d06e6515d43fd47d56397c6405", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Size limit (#473)"}, {"oid": "7f570740b4d9e06637cd5e3f510836143811760b", "committedDate": "2020-12-13 21:10:31 -0800", "message": "Add version to command line, CLI support for recipes in json and not precicely named files (#523)"}, {"oid": "01c0b89deb5bff76791c4997e749c4840bb8defd", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Tag TODO items (#556)"}, {"oid": "21f5f5e6df83324487ec99c55c1d0add7771743c", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Restrict loading of external plugins to cloud based recipes (#582)"}, {"oid": "9508d382d9500dc1b9525f90062a19da8aabac1f", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Todos (#601)"}, {"oid": "a1e0f330c52838c023f6e91115157dff78f0c881", "committedDate": "2020-12-13 21:10:39 -0800", "message": "Re-created pull request for platform search Nucleus changes (#688)"}, {"oid": "88ed81262b145a652a6d6f9f5c450042fd9c957e", "committedDate": "2020-12-13 21:10:40 -0800", "message": "Use new cloud api model (#706)"}, {"oid": "0874798bd8d343f605e53aaa7a27b64e13403986", "committedDate": "2020-12-13 21:10:40 -0800", "message": "Recipe storage upgrade so that it is cross platform safe. (#697)"}, {"oid": "dcbc85aa85f93d2b9610fb9494089ea9622269e1", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Recipe in json format (#722)"}, {"oid": "f28ff5e04af0727517de479e7e686e43882fc979", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use saved recipe content string to calculate recipe digest (#732)"}, {"oid": "cb1793dbaff65d5bfce9220081037461bd4180df", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Close Files.list() and Files.walk() streams (#771)"}, {"oid": "8a515091fa248d5d837a8521da8cb5682bc586a0", "committedDate": "2021-08-09 10:56:55 -0700", "message": "fix(logging): drop log level for many log messages (#1044)"}, {"oid": "a7e0a892a6f3b4cb787e24b63bc892e05654c223", "committedDate": "2022-08-30 23:07:42 -0700", "message": "feat: assign deployment error codes to deployment workflow (#1291)"}, {"oid": "a7f545bb1e4165c9b5c5753149d3be754cdb3975", "committedDate": "2022-10-27 10:35:27 -0700", "message": "fix: handle empty recipe content correctly when calculating digest (#1350)"}, {"oid": "6598594fd171065d5d46414353e7b18f3995304a", "committedDate": "2023-03-20 13:11:48 -0700", "message": "fix: re-negotiate with cloud if local recipe metadata contains a mismatched region (#1421)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxODMwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494618308", "body": "Does it mean findComponentRecipeContent() can return file name instead of file content?", "bodyText": "Does it mean findComponentRecipeContent() can return file name instead of file content?", "bodyHTML": "<p dir=\"auto\">Does it mean findComponentRecipeContent() can return file name instead of file content?</p>", "author": "ShirleyZheng92", "createdAt": "2020-09-24T21:22:44Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java", "diffHunk": "@@ -98,25 +98,27 @@ void savePackageRecipe(@NonNull ComponentIdentifier pkgId, String recipeContent)\n      * @throws PackageLoadingException if fails to parse the recipe file.\n      */\n     Optional<ComponentRecipe> findPackageRecipe(@NonNull ComponentIdentifier pkgId) throws PackageLoadingException {\n-        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+        Optional<String> recipeContent = findComponentRecipeContent(pkgId);\n+\n+        return recipeContent.isPresent() ? RecipeLoader.loadFromFile(recipeContent.get()) : Optional.empty();", "originalCommit": "5c6ecbcabd9f1deec0896d565543e86a3e4b8d99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDcyMjY0Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r494722643", "bodyText": "As mentioned above, it needs content comparison to support name occlusion feature.", "author": "wikimonkey", "createdAt": "2020-09-25T03:11:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYxODMwOA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "94a91fb3344a9069462d7bb8828d1376304ec67b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\nindex 92b8ecb4..420131dc 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n", "chunk": "@@ -98,14 +97,7 @@ public class ComponentStore {\n      * @throws PackageLoadingException if fails to parse the recipe file.\n      */\n     Optional<ComponentRecipe> findPackageRecipe(@NonNull ComponentIdentifier pkgId) throws PackageLoadingException {\n-        Optional<String> recipeContent = findComponentRecipeContent(pkgId);\n-\n-        return recipeContent.isPresent() ? RecipeLoader.loadFromFile(recipeContent.get()) : Optional.empty();\n-    }\n-\n-    Optional<String> findComponentRecipeContent(@NonNull ComponentIdentifier componentId)\n-            throws PackageLoadingException {\n-        Path recipePath = resolveRecipePath(componentId.getName(), componentId.getVersion());\n+        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n \n         logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n \n", "next_change": {"commit": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\nindex 420131dc..0b60ba1d 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n", "chunk": "@@ -97,7 +99,14 @@ public class ComponentStore {\n      * @throws PackageLoadingException if fails to parse the recipe file.\n      */\n     Optional<ComponentRecipe> findPackageRecipe(@NonNull ComponentIdentifier pkgId) throws PackageLoadingException {\n-        Path recipePath = resolveRecipePath(pkgId.getName(), pkgId.getVersion());\n+        Optional<String> recipeContent = findComponentRecipeContent(pkgId);\n+\n+        return recipeContent.isPresent() ? RecipeLoader.loadFromFile(recipeContent.get()) : Optional.empty();\n+    }\n+\n+    Optional<String> findComponentRecipeContent(@NonNull ComponentIdentifier componentId)\n+            throws PackageLoadingException {\n+        Path recipePath = resolveRecipePath(componentId.getName(), componentId.getVersion());\n \n         logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n \n", "next_change": {"commit": "21f5f5e6df83324487ec99c55c1d0add7771743c", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\nindex 0b60ba1d..2f2e54a6 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n", "chunk": "@@ -104,6 +91,39 @@ public class ComponentStore {\n         return recipeContent.isPresent() ? RecipeLoader.loadFromFile(recipeContent.get()) : Optional.empty();\n     }\n \n+    /**\n+     * Validate whether given digest matches the component recipe on disk.\n+     * @param componentIdentifier component whose recipe is read from disk\n+     * @param expectedDigest expected digest for the recipe\n+     * @return whether the expected digest matches the calculated digest on disk\n+     */\n+    public boolean validateComponentRecipeDigest(@NonNull ComponentIdentifier componentIdentifier,\n+                                                 String expectedDigest) {\n+        try {\n+            Optional<String> recipeContent = findComponentRecipeContent(componentIdentifier);\n+            if (!recipeContent.isPresent()) {\n+                logger.atError(\"plugin-load-error\").kv(GreengrassService.SERVICE_NAME_KEY,\n+                        componentIdentifier.getName())\n+                        .log(\"Recipe not found for component \" + componentIdentifier.getName());\n+                return false;\n+            }\n+            String digest = Digest.calculate(recipeContent.get());\n+            logger.atInfo(\"plugin-load\").log(\"Digest from store: \" + Coerce.toString(expectedDigest));\n+            logger.atInfo(\"plugin-load\").log(\"Digest from recipe: \" + Coerce.toString(digest));\n+            if (!Digest.isEqual(digest, expectedDigest)) {\n+                logger.atError(\"plugin-load-error\").kv(GreengrassService.SERVICE_NAME_KEY,\n+                        componentIdentifier.getName())\n+                        .log(\"Recipe on disk was modified after it was downloaded from cloud\");\n+                return false;\n+            }\n+            return true;\n+        } catch (PackageLoadingException | NoSuchAlgorithmException e) {\n+            logger.atError(\"plugin-load-error\").kv(GreengrassService.SERVICE_NAME_KEY,\n+                    componentIdentifier.getName()).log(\"Cannot validate digest for recipe\");\n+        }\n+        return false;\n+    }\n+\n     Optional<String> findComponentRecipeContent(@NonNull ComponentIdentifier componentId)\n             throws PackageLoadingException {\n         Path recipePath = resolveRecipePath(componentId.getName(), componentId.getVersion());\n", "next_change": {"commit": "88ed81262b145a652a6d6f9f5c450042fd9c957e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\nindex 2f2e54a6..3ddd740f 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n", "chunk": "@@ -111,15 +124,15 @@ public class ComponentStore {\n             logger.atInfo(\"plugin-load\").log(\"Digest from store: \" + Coerce.toString(expectedDigest));\n             logger.atInfo(\"plugin-load\").log(\"Digest from recipe: \" + Coerce.toString(digest));\n             if (!Digest.isEqual(digest, expectedDigest)) {\n-                logger.atError(\"plugin-load-error\").kv(GreengrassService.SERVICE_NAME_KEY,\n-                        componentIdentifier.getName())\n+                logger.atError(\"plugin-load-error\")\n+                        .kv(GreengrassService.SERVICE_NAME_KEY, componentIdentifier.getName())\n                         .log(\"Recipe on disk was modified after it was downloaded from cloud\");\n                 return false;\n             }\n             return true;\n         } catch (PackageLoadingException | NoSuchAlgorithmException e) {\n-            logger.atError(\"plugin-load-error\").kv(GreengrassService.SERVICE_NAME_KEY,\n-                    componentIdentifier.getName()).log(\"Cannot validate digest for recipe\");\n+            logger.atError(\"plugin-load-error\").kv(GreengrassService.SERVICE_NAME_KEY, componentIdentifier.getName())\n+                    .log(\"Cannot validate digest for recipe\");\n         }\n         return false;\n     }\n", "next_change": {"commit": "0874798bd8d343f605e53aaa7a27b64e13403986", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\nindex 3ddd740f..fd537abe 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n", "chunk": "@@ -139,7 +140,7 @@ public class ComponentStore {\n \n     Optional<String> findComponentRecipeContent(@NonNull ComponentIdentifier componentId)\n             throws PackageLoadingException {\n-        Path recipePath = resolveRecipePath(componentId.getName(), componentId.getVersion());\n+        Path recipePath = resolveRecipePath(componentId);\n \n         logger.atDebug().setEventType(\"finding-package-recipe\").addKeyValue(\"packageRecipePath\", recipePath).log();\n \n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\nindex 420131dc..0b60ba1d 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n", "chunk": "@@ -105,17 +114,12 @@ public class ComponentStore {\n             return Optional.empty();\n         }\n \n-        String recipeContent;\n-\n-\n         try {\n-            recipeContent = new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8);\n+            return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n         } catch (IOException e) {\n             throw new PackageLoadingException(\n                     String.format(\"Failed to read package recipe from disk with path: `%s`\", recipePath), e);\n         }\n-\n-        return RecipeLoader.loadFromFile(recipeContent);\n     }\n \n     /**\n", "next_change": {"commit": "a7e0a892a6f3b4cb787e24b63bc892e05654c223", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\nindex 0b60ba1d..a21e9603 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentStore.java\n", "chunk": "@@ -118,7 +195,8 @@ public class ComponentStore {\n             return Optional.of(new String(Files.readAllBytes(recipePath), StandardCharsets.UTF_8));\n         } catch (IOException e) {\n             throw new PackageLoadingException(\n-                    String.format(\"Failed to read package recipe from disk with path: `%s`\", recipePath), e);\n+                    String.format(\"Failed to read package recipe from disk with path: `%s`\", recipePath),\n+                    e).withErrorContext(e, DeploymentErrorCode.IO_READ_ERROR);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "message": "Merge commit", "committedDate": null}, {"oid": "94a91fb3344a9069462d7bb8828d1376304ec67b", "committedDate": "2020-12-13 21:10:27 -0800", "message": "Naming refactor (#454)"}, {"oid": "640d91990c6e1345bee669ad46f0e12bfc436b1b", "committedDate": "2020-12-13 21:10:28 -0800", "message": "component store file operations (#451)"}, {"oid": "41fdc60642a1698e9de83b93ad08983f92743219", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Resolve SonarLint found issues (#480)"}, {"oid": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "committedDate": "2020-12-13 21:10:29 -0800", "message": "implement simplified dependency resolution process (#469)"}, {"oid": "f41e02ddab79d0e5d128cf7c859026e75dceccf1", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Centralize paths and permissions (#506)"}, {"oid": "e38e39aceceff7d06e6515d43fd47d56397c6405", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Size limit (#473)"}, {"oid": "7f570740b4d9e06637cd5e3f510836143811760b", "committedDate": "2020-12-13 21:10:31 -0800", "message": "Add version to command line, CLI support for recipes in json and not precicely named files (#523)"}, {"oid": "01c0b89deb5bff76791c4997e749c4840bb8defd", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Tag TODO items (#556)"}, {"oid": "21f5f5e6df83324487ec99c55c1d0add7771743c", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Restrict loading of external plugins to cloud based recipes (#582)"}, {"oid": "9508d382d9500dc1b9525f90062a19da8aabac1f", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Todos (#601)"}, {"oid": "a1e0f330c52838c023f6e91115157dff78f0c881", "committedDate": "2020-12-13 21:10:39 -0800", "message": "Re-created pull request for platform search Nucleus changes (#688)"}, {"oid": "88ed81262b145a652a6d6f9f5c450042fd9c957e", "committedDate": "2020-12-13 21:10:40 -0800", "message": "Use new cloud api model (#706)"}, {"oid": "0874798bd8d343f605e53aaa7a27b64e13403986", "committedDate": "2020-12-13 21:10:40 -0800", "message": "Recipe storage upgrade so that it is cross platform safe. (#697)"}, {"oid": "dcbc85aa85f93d2b9610fb9494089ea9622269e1", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Recipe in json format (#722)"}, {"oid": "f28ff5e04af0727517de479e7e686e43882fc979", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use saved recipe content string to calculate recipe digest (#732)"}, {"oid": "cb1793dbaff65d5bfce9220081037461bd4180df", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Close Files.list() and Files.walk() streams (#771)"}, {"oid": "8a515091fa248d5d837a8521da8cb5682bc586a0", "committedDate": "2021-08-09 10:56:55 -0700", "message": "fix(logging): drop log level for many log messages (#1044)"}, {"oid": "a7e0a892a6f3b4cb787e24b63bc892e05654c223", "committedDate": "2022-08-30 23:07:42 -0700", "message": "feat: assign deployment error codes to deployment workflow (#1291)"}, {"oid": "a7f545bb1e4165c9b5c5753149d3be754cdb3975", "committedDate": "2022-10-27 10:35:27 -0700", "message": "fix: handle empty recipe content correctly when calculating digest (#1350)"}, {"oid": "6598594fd171065d5d46414353e7b18f3995304a", "committedDate": "2023-03-20 13:11:48 -0700", "message": "fix: re-negotiate with cloud if local recipe metadata contains a mismatched region (#1421)"}]}, {"oid": "bd0c9f52b230148c06d2149d0375fe53571ae582", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/bd0c9f52b230148c06d2149d0375fe53571ae582", "message": "add unit test", "committedDate": "2020-09-25T01:31:02Z", "type": "commit"}, {"oid": "09bed162541b080bc05499a93591aacf95475996", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/09bed162541b080bc05499a93591aacf95475996", "message": "delete unused import", "committedDate": "2020-09-25T01:44:41Z", "type": "commit"}, {"oid": "5094d0c393254a8459ae93a87757d270885e2488", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/5094d0c393254a8459ae93a87757d270885e2488", "message": "Merge branch 'master' into simplified_dependency_resolution", "committedDate": "2020-09-25T15:17:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NTkzMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495185930", "body": "Just to point out that this changes from the existing behavior for \"currently running version will be retained\". The new behavior for currently running version might not be retained - depend on cloud's result. I think that's what we want (so that transitive dependencies could be auto bumped for newer version within the specified version range...) Just double check on this change of behavior", "bodyText": "Just to point out that this changes from the existing behavior for \"currently running version will be retained\". The new behavior for currently running version might not be retained - depend on cloud's result. I think that's what we want (so that transitive dependencies could be auto bumped for newer version within the specified version range...) Just double check on this change of behavior", "bodyHTML": "<p dir=\"auto\">Just to point out that this changes from the existing behavior for \"currently running version will be retained\". The new behavior for currently running version might not be retained - depend on cloud's result. I think that's what we want (so that transitive dependencies could be auto bumped for newer version within the specified version range...) Just double check on this change of behavior</p>", "author": "leaf94", "createdAt": "2020-09-25T19:20:13Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +147,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version", "originalCommit": "5094d0c393254a8459ae93a87757d270885e2488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4ODY4MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495188681", "bodyText": "yes, that is what we want. By launch, we have the process alway trying to update to the latest versions of dependencies. Next, we will consider adding options to let customer keep the existing running version.", "author": "wikimonkey", "createdAt": "2020-09-25T19:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NTkzMA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "94a91fb3344a9069462d7bb8828d1376304ec67b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 2723671a..8c27d806 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -147,89 +145,6 @@ public class ComponentManager implements InjectionActions {\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n-        // acquire ever possible local best candidate\n-        Optional<ComponentIdentifier> localCandidateOptional =\n-                findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n-        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n-            // keep using local version if the component is meant to be local override\n-            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n-            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n-                    () -> new NoAvailableComponentVersionException(\n-                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n-                                    componentName, versionRequirements)));\n-            return componentStore.getPackageMetadata(localCandidateId);\n-        } else {\n-            // otherwise use cloud determined version\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n-                    .log(\"Negotiate version with cloud\");\n-            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n-        }\n-    }\n-\n-    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n-                                                        Map<String, Requirement> versionRequirements,\n-                                                        ComponentIdentifier localCandidate) throws PackagingException {\n-        ComponentContent componentContent;\n-\n-        try {\n-            componentContent = componentServiceHelper\n-                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n-                            versionRequirements);\n-        } catch (NoAvailableComponentVersionException e) {\n-            if (localCandidate != null) {\n-                // if it's builtin service, it's not required to have components registered in registry\n-                ComponentMetadata componentMetadata =\n-                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n-                if (componentMetadata != null) {\n-                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n-                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n-                    return componentMetadata;\n-                }\n-            }\n-            throw e;\n-        }\n-        ComponentIdentifier resolvedComponentId =\n-                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n-        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n-\n-        boolean saveContent = true;\n-        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n-\n-        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {\n-            saveContent = false;\n-        }\n-\n-        if (saveContent) {\n-            componentStore.savePackageRecipe(resolvedComponentId, downloadedRecipeContent);\n-        }\n-\n-        return componentStore.getPackageMetadata(resolvedComponentId);\n-    }\n-\n-    private Optional<ComponentIdentifier> findLocalBestCandidate(String componentName,\n-                                                                 Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n-        Requirement req = mergeVersionRequirements(versionRequirements);\n-\n-        Optional<ComponentIdentifier> optionalActiveComponentId = findActiveAndSatisfiedComponent(componentName, req);\n-\n-        // use active one if compatible, otherwise check local available ones\n-        if (optionalActiveComponentId.isPresent()) {\n-            return optionalActiveComponentId;\n-        } else {\n-            return componentStore.findBestMatchAvailableComponent(componentName, req);\n-        }\n-    }\n-\n-    private Requirement mergeVersionRequirements(Map<String, Requirement> versionRequirements) {\n-        return Requirement.buildNPM(\n-                versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n-    }\n-\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": {"commit": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 8c27d806..4d0b2400 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -145,6 +147,89 @@ public class ComponentManager implements InjectionActions {\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n+                if (componentMetadata != null) {\n+                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n+                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n+                    return componentMetadata;\n+                }\n+            }\n+            throw e;\n+        }\n+        ComponentIdentifier resolvedComponentId =\n+                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n+        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n+\n+        boolean saveContent = true;\n+        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n+\n+        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {\n+            saveContent = false;\n+        }\n+\n+        if (saveContent) {\n+            componentStore.savePackageRecipe(resolvedComponentId, downloadedRecipeContent);\n+        }\n+\n+        return componentStore.getPackageMetadata(resolvedComponentId);\n+    }\n+\n+    private Optional<ComponentIdentifier> findLocalBestCandidate(String componentName,\n+                                                                 Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        Requirement req = mergeVersionRequirements(versionRequirements);\n+\n+        Optional<ComponentIdentifier> optionalActiveComponentId = findActiveAndSatisfiedComponent(componentName, req);\n+\n+        // use active one if compatible, otherwise check local available ones\n+        if (optionalActiveComponentId.isPresent()) {\n+            return optionalActiveComponentId;\n+        } else {\n+            return componentStore.findBestMatchAvailableComponent(componentName, req);\n+        }\n+    }\n+\n+    private Requirement mergeVersionRequirements(Map<String, Requirement> versionRequirements) {\n+        return Requirement.buildNPM(\n+                versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n+    }\n+\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": {"commit": "6897122ced7b7708d2909200d545c5a01b158ae2", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 4d0b2400..fae36b56 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -230,6 +230,21 @@ public class ComponentManager implements InjectionActions {\n                 versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n     }\n \n+    private ComponentMetadata getComponentMetadata(ComponentIdentifier componentIdentifier) throws PackagingException {\n+        // If the component is builtin, then we won't be able to get the metadata from the filesystem,\n+        // so in that case we will try getting it from builtin. If that fails too, then we just rethrow.\n+        try {\n+            return componentStore.getPackageMetadata(componentIdentifier);\n+        } catch (PackagingException e) {\n+            ComponentMetadata md =\n+                    getBuiltinComponentMetadata(componentIdentifier.getName(), componentIdentifier.getVersion());\n+            if (md != null) {\n+                return md;\n+            }\n+            throw e;\n+        }\n+    }\n+\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "message": "Merge commit", "committedDate": null}, {"oid": "94a91fb3344a9069462d7bb8828d1376304ec67b", "committedDate": "2020-12-13 21:10:27 -0800", "message": "Naming refactor (#454)"}, {"oid": "640d91990c6e1345bee669ad46f0e12bfc436b1b", "committedDate": "2020-12-13 21:10:28 -0800", "message": "component store file operations (#451)"}, {"oid": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "committedDate": "2020-12-13 21:10:29 -0800", "message": "implement simplified dependency resolution process (#469)"}, {"oid": "4b91b8db36338443b8443c78cb5581e3bb26fa81", "committedDate": "2020-12-13 21:10:29 -0800", "message": "add back public scope to builtin service since it needs to retrieve r\u2026 (#490)"}, {"oid": "6897122ced7b7708d2909200d545c5a01b158ae2", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Switch to new dependency resolution process (#493)"}, {"oid": "188dd671386b8d956d04651e3edd585e5371ec1b", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Device deployment (#486)"}, {"oid": "f41e02ddab79d0e5d128cf7c859026e75dceccf1", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Centralize paths and permissions (#506)"}, {"oid": "e38e39aceceff7d06e6515d43fd47d56397c6405", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Size limit (#473)"}, {"oid": "50bdfe8ef529f397189a4b72f63cd80d9ec70254", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Remove hardcoded scope in ComponentIdentifier (#507)"}, {"oid": "7558dd9dd4a94fa13dde5ed51ad5a52e4a21abbf", "committedDate": "2020-12-13 21:10:31 -0800", "message": "Fix problem with unarchiving being skipped for local artifacts  (#527)"}, {"oid": "29b4ebb6ef8e2245d75aee4324ae7b5617598f0e", "committedDate": "2020-12-13 21:10:33 -0800", "message": "System settings as Nucleus component configuration (#513)"}, {"oid": "f68508f974d61b4caac6ae73b92a26d02f699659", "committedDate": "2020-12-13 21:10:33 -0800", "message": "delete dead API references (#571)"}, {"oid": "773b41c3f20622b4c3249b9a31dff1f5913e7956", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Add timestamp to UpdateBehaviorTree to fix multi-group deployment (#561)"}, {"oid": "01c0b89deb5bff76791c4997e749c4840bb8defd", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Tag TODO items (#556)"}, {"oid": "c272aa34556114365188e21472327cd8a8951985", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Set the owner of artifacts for a service when commands are first run. (#555)"}, {"oid": "21f5f5e6df83324487ec99c55c1d0add7771743c", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Restrict loading of external plugins to cloud based recipes (#582)"}, {"oid": "5a8f026533bb6acc0e00a9f6b125bea352b60e1e", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Set artifact permissions according to recipe artifact permissions (#596)"}, {"oid": "9508d382d9500dc1b9525f90062a19da8aabac1f", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Todos (#601)"}, {"oid": "3fc04969985b8d2b1efa4589286907e05a60dfd0", "committedDate": "2020-12-13 21:10:35 -0800", "message": "refactor truncate tlog, fix tests (#608)"}, {"oid": "2fb3a699a9103045614c5592572d37d4400e9193", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Remove CLI from builtins (#634)"}, {"oid": "5bf7874693dd2184095a4c31af8a2a940934f7c9", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Add more logs to resolveComponentVersion; Add the initial deployment with config update test from PR #579 (#623)"}, {"oid": "5dae3ac8d84b04a3b6d82952f0da367354de7f8c", "committedDate": "2020-12-13 21:10:38 -0800", "message": "Allow going to cloud if no satifying version found locally for local group (#666)"}, {"oid": "1d1a754358376f2efb1532cf3c1634d179961f48", "committedDate": "2020-12-13 21:10:39 -0800", "message": "Add error handling & retry in ArtifactDownloader (#631)"}, {"oid": "88ed81262b145a652a6d6f9f5c450042fd9c957e", "committedDate": "2020-12-13 21:10:40 -0800", "message": "Use new cloud api model (#706)"}, {"oid": "dcbc85aa85f93d2b9610fb9494089ea9622269e1", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Recipe in json format (#722)"}, {"oid": "f28ff5e04af0727517de479e7e686e43882fc979", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use saved recipe content string to calculate recipe digest (#732)"}, {"oid": "2849a794de031e187dd26ea33cb673db8adb317f", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use AWS SDK v2 (#748)"}, {"oid": "4b87b714b44ab837cedfb024b8207b6402716a16", "committedDate": "2020-12-13 21:10:42 -0800", "message": "Add retry on client error(e.g. network loss) during deployment (#751)"}, {"oid": "48bf9decc7eb9bb7112fe9ff8c7fbce347f0268b", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Improve logs for deployment errors (#775)"}, {"oid": "e243971e7c66b3ce00e590c9a12ef723475b79ff", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Bump log to error level (#776)"}, {"oid": "02d8c479dfd957e1be98017caddf0155c93bd5fb", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Rename Kernel to Nucleus in string outputs (#788)"}, {"oid": "3b2350aec4dcacca2e88c06401e63b0078dd051b", "committedDate": "2021-01-20 16:41:43 -0800", "message": "improvement(various): No cloud calls if configured to run offline (#810)"}, {"oid": "2897e45a617ad35521ef94d0f08bf5b13ae4948b", "committedDate": "2021-02-25 15:47:02 -0800", "message": "feat(docker): initial implementation for docker image artifact downloader (#865)"}, {"oid": "d24acec456c0016dee23de2606a62c1ddda68623", "committedDate": "2021-03-10 16:15:02 -0800", "message": "feat(docker): improvements in validation, credential expiry handling, not logging credentials etc (#882)"}, {"oid": "91e8b1fc62cdd3fb1634f93c29e7489cb2421ec3", "committedDate": "2021-04-27 12:49:13 -0700", "message": "chore: use new pre-release dataplane SDK (#937)"}, {"oid": "dea87f115e1cb412cdc8d174b5e662d98fad62b1", "committedDate": "2021-05-27 16:41:08 -0700", "message": "feat(deployment): Support deployment with large configuration bigger than IoT Jobs/Shadow document limit (#963)"}, {"oid": "5be1aeeb9cbec04b7ee3c4d897d3f3b4d05662f2", "committedDate": "2021-08-04 15:56:10 -0700", "message": "fix: validate artifact uri from component recipe (#1013)"}, {"oid": "1a9aa3d87fa384a5d7d2f097d3e100e9a5099cad", "committedDate": "2021-08-05 11:22:40 -0700", "message": "fix(message): improve NoAvailableComponentVersionException messaging (#1040)"}, {"oid": "8a515091fa248d5d837a8521da8cb5682bc586a0", "committedDate": "2021-08-09 10:56:55 -0700", "message": "fix(logging): drop log level for many log messages (#1044)"}, {"oid": "a7e0a892a6f3b4cb787e24b63bc892e05654c223", "committedDate": "2022-08-30 23:07:42 -0700", "message": "feat: assign deployment error codes to deployment workflow (#1291)"}, {"oid": "fde355223d6fc405cca9c64af8c3ff6b5a6b8021", "committedDate": "2022-10-12 14:05:01 -0700", "message": "fix: parse status codes from gg v2 data exception (#1330)"}, {"oid": "2f98760ce8e5c7fb6ba5ac43647f0c8a4b873277", "committedDate": "2022-11-01 09:42:25 -0700", "message": "feat: warning log for discontinued component (#1349)"}, {"oid": "4bb96750c21bc02de3fd3fd6182afb8ecba41b46", "committedDate": "2022-12-08 12:30:56 -0500", "message": "fix: add logging around installed component not found (#1377)"}, {"oid": "6598594fd171065d5d46414353e7b18f3995304a", "committedDate": "2023-03-20 13:11:48 -0700", "message": "fix: re-negotiate with cloud if local recipe metadata contains a mismatched region (#1421)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NzE3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495187171", "body": "Sorry didn't thought about when looking at the code yesterday - should we just skip calling cloud if it's a builtin service?", "bodyText": "Sorry didn't thought about when looking at the code yesterday - should we just skip calling cloud if it's a builtin service?", "bodyHTML": "<p dir=\"auto\">Sorry didn't thought about when looking at the code yesterday - should we just skip calling cloud if it's a builtin service?</p>", "author": "leaf94", "createdAt": "2020-09-25T19:23:09Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -145,6 +147,89 @@ public ComponentManager(S3Downloader s3ArtifactsDownloader,\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());", "originalCommit": "5094d0c393254a8459ae93a87757d270885e2488", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MDE4MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r495190180", "bodyText": "I am thinking if it has recipes in cloud, it could be updated.", "author": "wikimonkey", "createdAt": "2020-09-25T19:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NzE3MQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "94a91fb3344a9069462d7bb8828d1376304ec67b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 2723671a..8c27d806 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -147,89 +145,6 @@ public class ComponentManager implements InjectionActions {\n         return componentMetadataList.iterator();\n     }\n \n-    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n-        // acquire ever possible local best candidate\n-        Optional<ComponentIdentifier> localCandidateOptional =\n-                findLocalBestCandidate(componentName, versionRequirements);\n-        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n-                .log(\"Resolve to local version\");\n-        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n-            // keep using local version if the component is meant to be local override\n-            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n-            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n-                    () -> new NoAvailableComponentVersionException(\n-                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n-                                    componentName, versionRequirements)));\n-            return componentStore.getPackageMetadata(localCandidateId);\n-        } else {\n-            // otherwise use cloud determined version\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n-                    .log(\"Negotiate version with cloud\");\n-            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n-        }\n-    }\n-\n-    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n-                                                        Map<String, Requirement> versionRequirements,\n-                                                        ComponentIdentifier localCandidate) throws PackagingException {\n-        ComponentContent componentContent;\n-\n-        try {\n-            componentContent = componentServiceHelper\n-                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n-                            versionRequirements);\n-        } catch (NoAvailableComponentVersionException e) {\n-            if (localCandidate != null) {\n-                // if it's builtin service, it's not required to have components registered in registry\n-                ComponentMetadata componentMetadata =\n-                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n-                if (componentMetadata != null) {\n-                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n-                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n-                    return componentMetadata;\n-                }\n-            }\n-            throw e;\n-        }\n-        ComponentIdentifier resolvedComponentId =\n-                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n-        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n-\n-        boolean saveContent = true;\n-        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n-\n-        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {\n-            saveContent = false;\n-        }\n-\n-        if (saveContent) {\n-            componentStore.savePackageRecipe(resolvedComponentId, downloadedRecipeContent);\n-        }\n-\n-        return componentStore.getPackageMetadata(resolvedComponentId);\n-    }\n-\n-    private Optional<ComponentIdentifier> findLocalBestCandidate(String componentName,\n-                                                                 Map<String, Requirement> versionRequirements)\n-            throws PackagingException {\n-        Requirement req = mergeVersionRequirements(versionRequirements);\n-\n-        Optional<ComponentIdentifier> optionalActiveComponentId = findActiveAndSatisfiedComponent(componentName, req);\n-\n-        // use active one if compatible, otherwise check local available ones\n-        if (optionalActiveComponentId.isPresent()) {\n-            return optionalActiveComponentId;\n-        } else {\n-            return componentStore.findBestMatchAvailableComponent(componentName, req);\n-        }\n-    }\n-\n-    private Requirement mergeVersionRequirements(Map<String, Requirement> versionRequirements) {\n-        return Requirement.buildNPM(\n-                versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n-    }\n-\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": {"commit": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 8c27d806..4d0b2400 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -145,6 +147,89 @@ public class ComponentManager implements InjectionActions {\n         return componentMetadataList.iterator();\n     }\n \n+    ComponentMetadata resolveComponentVersion(String componentName, Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        // acquire ever possible local best candidate\n+        Optional<ComponentIdentifier> localCandidateOptional =\n+                findLocalBestCandidate(componentName, versionRequirements);\n+        logger.atDebug().kv(\"componentName\", componentName).kv(\"localCandidate\", localCandidateOptional.orElse(null))\n+                .log(\"Resolve to local version\");\n+        if (versionRequirements.containsKey(Deployment.DeploymentType.LOCAL.toString())) {\n+            // keep using local version if the component is meant to be local override\n+            logger.atDebug().kv(\"componentName\", componentName).log(\"Keep local version if it's local override\");\n+            ComponentIdentifier localCandidateId = localCandidateOptional.orElseThrow(\n+                    () -> new NoAvailableComponentVersionException(\n+                            String.format(\"Component %s is meant to be local override, but no version can satisfy %s\",\n+                                    componentName, versionRequirements)));\n+            return componentStore.getPackageMetadata(localCandidateId);\n+        } else {\n+            // otherwise use cloud determined version\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirement\", versionRequirements)\n+                    .log(\"Negotiate version with cloud\");\n+            return negotiateVersionWithCloud(componentName, versionRequirements, localCandidateOptional.orElse(null));\n+        }\n+    }\n+\n+    private ComponentMetadata negotiateVersionWithCloud(String componentName,\n+                                                        Map<String, Requirement> versionRequirements,\n+                                                        ComponentIdentifier localCandidate) throws PackagingException {\n+        ComponentContent componentContent;\n+\n+        try {\n+            componentContent = componentServiceHelper\n+                    .resolveComponentVersion(componentName, localCandidate == null ? null : localCandidate.getVersion(),\n+                            versionRequirements);\n+        } catch (NoAvailableComponentVersionException e) {\n+            if (localCandidate != null) {\n+                // if it's builtin service, it's not required to have components registered in registry\n+                ComponentMetadata componentMetadata =\n+                        getBuiltinComponentMetadata(localCandidate.getName(), localCandidate.getVersion());\n+                if (componentMetadata != null) {\n+                    logger.atDebug().kv(\"componentMetadata\", componentMetadata)\n+                            .log(\"Builtin service and no available\" + \" version in registry, keep using local version\");\n+                    return componentMetadata;\n+                }\n+            }\n+            throw e;\n+        }\n+        ComponentIdentifier resolvedComponentId =\n+                new ComponentIdentifier(componentContent.getName(), new Semver(componentContent.getVersion()));\n+        String downloadedRecipeContent = StandardCharsets.UTF_8.decode(componentContent.getRecipe()).toString();\n+\n+        boolean saveContent = true;\n+        Optional<String> recipeContentOnDevice = componentStore.findComponentRecipeContent(resolvedComponentId);\n+\n+        if (recipeContentOnDevice.filter(recipe -> recipe.equals(downloadedRecipeContent)).isPresent()) {\n+            saveContent = false;\n+        }\n+\n+        if (saveContent) {\n+            componentStore.savePackageRecipe(resolvedComponentId, downloadedRecipeContent);\n+        }\n+\n+        return componentStore.getPackageMetadata(resolvedComponentId);\n+    }\n+\n+    private Optional<ComponentIdentifier> findLocalBestCandidate(String componentName,\n+                                                                 Map<String, Requirement> versionRequirements)\n+            throws PackagingException {\n+        Requirement req = mergeVersionRequirements(versionRequirements);\n+\n+        Optional<ComponentIdentifier> optionalActiveComponentId = findActiveAndSatisfiedComponent(componentName, req);\n+\n+        // use active one if compatible, otherwise check local available ones\n+        if (optionalActiveComponentId.isPresent()) {\n+            return optionalActiveComponentId;\n+        } else {\n+            return componentStore.findBestMatchAvailableComponent(componentName, req);\n+        }\n+    }\n+\n+    private Requirement mergeVersionRequirements(Map<String, Requirement> versionRequirements) {\n+        return Requirement.buildNPM(\n+                versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n+    }\n+\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": {"commit": "6897122ced7b7708d2909200d545c5a01b158ae2", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 4d0b2400..fae36b56 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -230,6 +230,21 @@ public class ComponentManager implements InjectionActions {\n                 versionRequirements.values().stream().map(Requirement::toString).collect(Collectors.joining(\" \")));\n     }\n \n+    private ComponentMetadata getComponentMetadata(ComponentIdentifier componentIdentifier) throws PackagingException {\n+        // If the component is builtin, then we won't be able to get the metadata from the filesystem,\n+        // so in that case we will try getting it from builtin. If that fails too, then we just rethrow.\n+        try {\n+            return componentStore.getPackageMetadata(componentIdentifier);\n+        } catch (PackagingException e) {\n+            ComponentMetadata md =\n+                    getBuiltinComponentMetadata(componentIdentifier.getName(), componentIdentifier.getVersion());\n+            if (md != null) {\n+                return md;\n+            }\n+            throw e;\n+        }\n+    }\n+\n     /**\n      * Make sure all the specified packages exist in the package cache. Download them from remote repository if they\n      * don't exist.\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "message": "Merge commit", "committedDate": null}, {"oid": "94a91fb3344a9069462d7bb8828d1376304ec67b", "committedDate": "2020-12-13 21:10:27 -0800", "message": "Naming refactor (#454)"}, {"oid": "640d91990c6e1345bee669ad46f0e12bfc436b1b", "committedDate": "2020-12-13 21:10:28 -0800", "message": "component store file operations (#451)"}, {"oid": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "committedDate": "2020-12-13 21:10:29 -0800", "message": "implement simplified dependency resolution process (#469)"}, {"oid": "4b91b8db36338443b8443c78cb5581e3bb26fa81", "committedDate": "2020-12-13 21:10:29 -0800", "message": "add back public scope to builtin service since it needs to retrieve r\u2026 (#490)"}, {"oid": "6897122ced7b7708d2909200d545c5a01b158ae2", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Switch to new dependency resolution process (#493)"}, {"oid": "188dd671386b8d956d04651e3edd585e5371ec1b", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Device deployment (#486)"}, {"oid": "f41e02ddab79d0e5d128cf7c859026e75dceccf1", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Centralize paths and permissions (#506)"}, {"oid": "e38e39aceceff7d06e6515d43fd47d56397c6405", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Size limit (#473)"}, {"oid": "50bdfe8ef529f397189a4b72f63cd80d9ec70254", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Remove hardcoded scope in ComponentIdentifier (#507)"}, {"oid": "7558dd9dd4a94fa13dde5ed51ad5a52e4a21abbf", "committedDate": "2020-12-13 21:10:31 -0800", "message": "Fix problem with unarchiving being skipped for local artifacts  (#527)"}, {"oid": "29b4ebb6ef8e2245d75aee4324ae7b5617598f0e", "committedDate": "2020-12-13 21:10:33 -0800", "message": "System settings as Nucleus component configuration (#513)"}, {"oid": "f68508f974d61b4caac6ae73b92a26d02f699659", "committedDate": "2020-12-13 21:10:33 -0800", "message": "delete dead API references (#571)"}, {"oid": "773b41c3f20622b4c3249b9a31dff1f5913e7956", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Add timestamp to UpdateBehaviorTree to fix multi-group deployment (#561)"}, {"oid": "01c0b89deb5bff76791c4997e749c4840bb8defd", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Tag TODO items (#556)"}, {"oid": "c272aa34556114365188e21472327cd8a8951985", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Set the owner of artifacts for a service when commands are first run. (#555)"}, {"oid": "21f5f5e6df83324487ec99c55c1d0add7771743c", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Restrict loading of external plugins to cloud based recipes (#582)"}, {"oid": "5a8f026533bb6acc0e00a9f6b125bea352b60e1e", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Set artifact permissions according to recipe artifact permissions (#596)"}, {"oid": "9508d382d9500dc1b9525f90062a19da8aabac1f", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Todos (#601)"}, {"oid": "3fc04969985b8d2b1efa4589286907e05a60dfd0", "committedDate": "2020-12-13 21:10:35 -0800", "message": "refactor truncate tlog, fix tests (#608)"}, {"oid": "2fb3a699a9103045614c5592572d37d4400e9193", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Remove CLI from builtins (#634)"}, {"oid": "5bf7874693dd2184095a4c31af8a2a940934f7c9", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Add more logs to resolveComponentVersion; Add the initial deployment with config update test from PR #579 (#623)"}, {"oid": "5dae3ac8d84b04a3b6d82952f0da367354de7f8c", "committedDate": "2020-12-13 21:10:38 -0800", "message": "Allow going to cloud if no satifying version found locally for local group (#666)"}, {"oid": "1d1a754358376f2efb1532cf3c1634d179961f48", "committedDate": "2020-12-13 21:10:39 -0800", "message": "Add error handling & retry in ArtifactDownloader (#631)"}, {"oid": "88ed81262b145a652a6d6f9f5c450042fd9c957e", "committedDate": "2020-12-13 21:10:40 -0800", "message": "Use new cloud api model (#706)"}, {"oid": "dcbc85aa85f93d2b9610fb9494089ea9622269e1", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Recipe in json format (#722)"}, {"oid": "f28ff5e04af0727517de479e7e686e43882fc979", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use saved recipe content string to calculate recipe digest (#732)"}, {"oid": "2849a794de031e187dd26ea33cb673db8adb317f", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use AWS SDK v2 (#748)"}, {"oid": "4b87b714b44ab837cedfb024b8207b6402716a16", "committedDate": "2020-12-13 21:10:42 -0800", "message": "Add retry on client error(e.g. network loss) during deployment (#751)"}, {"oid": "48bf9decc7eb9bb7112fe9ff8c7fbce347f0268b", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Improve logs for deployment errors (#775)"}, {"oid": "e243971e7c66b3ce00e590c9a12ef723475b79ff", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Bump log to error level (#776)"}, {"oid": "02d8c479dfd957e1be98017caddf0155c93bd5fb", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Rename Kernel to Nucleus in string outputs (#788)"}, {"oid": "3b2350aec4dcacca2e88c06401e63b0078dd051b", "committedDate": "2021-01-20 16:41:43 -0800", "message": "improvement(various): No cloud calls if configured to run offline (#810)"}, {"oid": "2897e45a617ad35521ef94d0f08bf5b13ae4948b", "committedDate": "2021-02-25 15:47:02 -0800", "message": "feat(docker): initial implementation for docker image artifact downloader (#865)"}, {"oid": "d24acec456c0016dee23de2606a62c1ddda68623", "committedDate": "2021-03-10 16:15:02 -0800", "message": "feat(docker): improvements in validation, credential expiry handling, not logging credentials etc (#882)"}, {"oid": "91e8b1fc62cdd3fb1634f93c29e7489cb2421ec3", "committedDate": "2021-04-27 12:49:13 -0700", "message": "chore: use new pre-release dataplane SDK (#937)"}, {"oid": "dea87f115e1cb412cdc8d174b5e662d98fad62b1", "committedDate": "2021-05-27 16:41:08 -0700", "message": "feat(deployment): Support deployment with large configuration bigger than IoT Jobs/Shadow document limit (#963)"}, {"oid": "5be1aeeb9cbec04b7ee3c4d897d3f3b4d05662f2", "committedDate": "2021-08-04 15:56:10 -0700", "message": "fix: validate artifact uri from component recipe (#1013)"}, {"oid": "1a9aa3d87fa384a5d7d2f097d3e100e9a5099cad", "committedDate": "2021-08-05 11:22:40 -0700", "message": "fix(message): improve NoAvailableComponentVersionException messaging (#1040)"}, {"oid": "8a515091fa248d5d837a8521da8cb5682bc586a0", "committedDate": "2021-08-09 10:56:55 -0700", "message": "fix(logging): drop log level for many log messages (#1044)"}, {"oid": "a7e0a892a6f3b4cb787e24b63bc892e05654c223", "committedDate": "2022-08-30 23:07:42 -0700", "message": "feat: assign deployment error codes to deployment workflow (#1291)"}, {"oid": "fde355223d6fc405cca9c64af8c3ff6b5a6b8021", "committedDate": "2022-10-12 14:05:01 -0700", "message": "fix: parse status codes from gg v2 data exception (#1330)"}, {"oid": "2f98760ce8e5c7fb6ba5ac43647f0c8a4b873277", "committedDate": "2022-11-01 09:42:25 -0700", "message": "feat: warning log for discontinued component (#1349)"}, {"oid": "4bb96750c21bc02de3fd3fd6182afb8ecba41b46", "committedDate": "2022-12-08 12:30:56 -0500", "message": "fix: add logging around installed component not found (#1377)"}, {"oid": "6598594fd171065d5d46414353e7b18f3995304a", "committedDate": "2023-03-20 13:11:48 -0700", "message": "fix: re-negotiate with cloud if local recipe metadata contains a mismatched region (#1421)"}]}, {"oid": "c44a1f8b48e45965706ad30f98ed5868f63c0fa8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c44a1f8b48e45965706ad30f98ed5868f63c0fa8", "message": "Merge branch 'master' into simplified_dependency_resolution", "committedDate": "2020-09-25T20:47:55Z", "type": "commit"}, {"oid": "c611c9d2024eee1a537f07ef1c5d9958c8910fed", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c611c9d2024eee1a537f07ef1c5d9958c8910fed", "message": "add unit test", "committedDate": "2020-09-25T23:21:45Z", "type": "commit"}, {"oid": "8dd85e3a7afc8f7a535b17668e3ed27e7ad52bff", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8dd85e3a7afc8f7a535b17668e3ed27e7ad52bff", "message": "delete unused import", "committedDate": "2020-09-25T23:21:45Z", "type": "commit"}, {"oid": "96e3c70f5006fa479020762b658d791ec37798f6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/96e3c70f5006fa479020762b658d791ec37798f6", "message": "Publish as public component, Fix error in \"startup\" based service if it errors after RUNNING (#468)\n\n* Publish as public component\r\n\r\n* If startup script fails after reporting running, it should still go to error", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "774ba32205bc9725d8e2d5529fc55df22d80cf5b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/774ba32205bc9725d8e2d5529fc55df22d80cf5b", "message": "Add TelemetryAgent service (#378)\n\n* Implemented emission, aggregation and publish of metrics.\r\n* Beta 1 metrics - System metrics , kernel component state metrics\r\n* Unit tests and Integration tests", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "d711cde65cfa02549389f2b5b3d046bbb8f7b837", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/d711cde65cfa02549389f2b5b3d046bbb8f7b837", "message": "wait till the publish interval to check the periodic metrics future s\u2026 (#474)\n\n* wait till the publish interval to check the periodic metrics future status\r\n\r\n* assert non null on periodic metrics future", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "0d55c42a7e40480f0faa4d24acd0fa319692f1ce", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0d55c42a7e40480f0faa4d24acd0fa319692f1ce", "message": "Remove \"generic\" type from map (#475)", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "3cc5e881acca9aaa135ec4db1410649aad228525", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cc5e881acca9aaa135ec4db1410649aad228525", "message": "Adding retry for Iot Jobs subscriptions (#462)\n\nCo-authored-by: Michael Dombrowski <mdombro@amazon.com>", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "94fe3529f87db39d36c826da61ca15750de857b8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/94fe3529f87db39d36c826da61ca15750de857b8", "message": "getIotClient(awsRegion, stage, credentialsProvider) API (#470)\n\n* getIotClient(awsRegion, stage, credentialsProvider) API\r\n\r\n* region and docstring\r\n\r\n* common implementation for all getIotClient APIs\r\n\r\n* throw URISyntaxException\r\n\r\n* number of retries\r\n\r\nCo-authored-by: Michael Dombrowski <mdombro@amazon.com>", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "3e2d9d286b48d968efbca9ae56b997cdf49220b4", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3e2d9d286b48d968efbca9ae56b997cdf49220b4", "message": "Making cli_ipc_info readable only for the owner (#471)\n\nCo-authored-by: Michael Dombrowski <mdombro@amazon.com>", "committedDate": "2020-09-25T23:21:46Z", "type": "commit"}, {"oid": "18b7904347b848464573ddb81ed911532d74a55c", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/18b7904347b848464573ddb81ed911532d74a55c", "message": "Merge branch 'simplified_dependency_resolution' of https://github.com/aws/aws-greengrass-kernel into simplified_dependency_resolution", "committedDate": "2020-09-25T23:21:54Z", "type": "commit"}, {"oid": "0b3b197ca716307265a78cf6a5a6d86f49e5a83a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0b3b197ca716307265a78cf6a5a6d86f49e5a83a", "message": "Merge branch 'master' into simplified_dependency_resolution", "committedDate": "2020-09-28T15:17:47Z", "type": "commit"}, {"oid": "c2ec3f7cd119b0a46270c643d5fe921695b981c2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/c2ec3f7cd119b0a46270c643d5fe921695b981c2", "message": "temporarily lower integ test coverage ratio since the new DR process is not integrated into deployment flow yet", "committedDate": "2020-09-28T17:30:57Z", "type": "commit"}, {"oid": "83e74ad405a0794ef484e90b22bcac16dbf6f45b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/83e74ad405a0794ef484e90b22bcac16dbf6f45b", "message": "Merge branch 'master' into simplified_dependency_resolution", "committedDate": "2020-09-28T17:31:54Z", "type": "commit"}, {"oid": "1f45d63b4c06e425bb8b231514a3570dc4ab3073", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1f45d63b4c06e425bb8b231514a3570dc4ab3073", "message": "Merge branch 'master' into simplified_dependency_resolution", "committedDate": "2020-09-28T19:17:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NDUxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496174516", "body": "NIT: add a comment. requirementMap is a groupId->requirement map", "bodyText": "NIT: add a comment. requirementMap is a groupId->requirement map", "bodyHTML": "<p dir=\"auto\">NIT: add a comment. requirementMap is a groupId-&gt;requirement map</p>", "author": "ShirleyZheng92", "createdAt": "2020-09-28T19:13:07Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -333,6 +418,32 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n         }\n     }\n \n+    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,", "originalCommit": "83e74ad405a0794ef484e90b22bcac16dbf6f45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NjMxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496186313", "bodyText": "will add", "author": "wikimonkey", "createdAt": "2020-09-28T19:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NDUxNg=="}], "type": "inlineReview", "revised_code": {"commit": "ae8b113b0716f9685260adce73f68035b45c20dd", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 2723671a..4d0b2400 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -418,6 +418,13 @@ public class ComponentManager implements InjectionActions {\n         }\n     }\n \n+    /** Get active component version and dependencies, the component version satisfies dependent version requirements.\n+     *\n+     * @param componentName component name\n+     * @param requirementMap dependent component to version requirement map\n+     * @return active component metadata which satisfies version requirement\n+     * @throws PackagingException no available version exception\n+     */\n     ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,\n                                                              Map<String, Requirement> requirementMap)\n             throws PackagingException {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 2723671a..4d0b2400 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -418,6 +418,13 @@ public class ComponentManager implements InjectionActions {\n         }\n     }\n \n+    /** Get active component version and dependencies, the component version satisfies dependent version requirements.\n+     *\n+     * @param componentName component name\n+     * @param requirementMap dependent component to version requirement map\n+     * @return active component metadata which satisfies version requirement\n+     * @throws PackagingException no available version exception\n+     */\n     ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,\n                                                              Map<String, Requirement> requirementMap)\n             throws PackagingException {\n", "next_change": {"commit": "94a91fb3344a9069462d7bb8828d1376304ec67b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 4d0b2400..8c27d806 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -418,39 +332,6 @@ public class ComponentManager implements InjectionActions {\n         }\n     }\n \n-    /** Get active component version and dependencies, the component version satisfies dependent version requirements.\n-     *\n-     * @param componentName component name\n-     * @param requirementMap dependent component to version requirement map\n-     * @return active component metadata which satisfies version requirement\n-     * @throws PackagingException no available version exception\n-     */\n-    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,\n-                                                             Map<String, Requirement> requirementMap)\n-            throws PackagingException {\n-        return getActiveAndSatisfiedComponentMetadata(componentName, mergeVersionRequirements(requirementMap));\n-    }\n-\n-    private ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName, Requirement requirement)\n-            throws PackagingException {\n-        Optional<ComponentMetadata> componentMetadataOptional =\n-                findActiveAndSatisfiedPackageMetadata(componentName, requirement);\n-        if (!componentMetadataOptional.isPresent()) {\n-            throw new NoAvailableComponentVersionException(\n-                    String.format(\"There is no version of component %s satisfying %s\", componentName, requirement));\n-        }\n-\n-        return componentMetadataOptional.get();\n-    }\n-\n-    private Optional<ComponentIdentifier> findActiveAndSatisfiedComponent(String componentName,\n-                                                                          Requirement requirement) {\n-        Optional<Semver> activeVersionOptional = findActiveVersion(componentName);\n-\n-        return activeVersionOptional.filter(requirement::isSatisfiedBy)\n-                .map(version -> new ComponentIdentifier(componentName, version));\n-    }\n-\n     @Nullable\n     private ComponentMetadata getBuiltinComponentMetadata(String packageName, Semver activeVersion) {\n         try {\n", "next_change": {"commit": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 8c27d806..4d0b2400 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -332,6 +418,39 @@ public class ComponentManager implements InjectionActions {\n         }\n     }\n \n+    /** Get active component version and dependencies, the component version satisfies dependent version requirements.\n+     *\n+     * @param componentName component name\n+     * @param requirementMap dependent component to version requirement map\n+     * @return active component metadata which satisfies version requirement\n+     * @throws PackagingException no available version exception\n+     */\n+    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,\n+                                                             Map<String, Requirement> requirementMap)\n+            throws PackagingException {\n+        return getActiveAndSatisfiedComponentMetadata(componentName, mergeVersionRequirements(requirementMap));\n+    }\n+\n+    private ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName, Requirement requirement)\n+            throws PackagingException {\n+        Optional<ComponentMetadata> componentMetadataOptional =\n+                findActiveAndSatisfiedPackageMetadata(componentName, requirement);\n+        if (!componentMetadataOptional.isPresent()) {\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"There is no version of component %s satisfying %s\", componentName, requirement));\n+        }\n+\n+        return componentMetadataOptional.get();\n+    }\n+\n+    private Optional<ComponentIdentifier> findActiveAndSatisfiedComponent(String componentName,\n+                                                                          Requirement requirement) {\n+        Optional<Semver> activeVersionOptional = findActiveVersion(componentName);\n+\n+        return activeVersionOptional.filter(requirement::isSatisfiedBy)\n+                .map(version -> new ComponentIdentifier(componentName, version));\n+    }\n+\n     @Nullable\n     private ComponentMetadata getBuiltinComponentMetadata(String packageName, Semver activeVersion) {\n         try {\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "message": "Merge commit", "committedDate": null}, {"oid": "94a91fb3344a9069462d7bb8828d1376304ec67b", "committedDate": "2020-12-13 21:10:27 -0800", "message": "Naming refactor (#454)"}, {"oid": "640d91990c6e1345bee669ad46f0e12bfc436b1b", "committedDate": "2020-12-13 21:10:28 -0800", "message": "component store file operations (#451)"}, {"oid": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "committedDate": "2020-12-13 21:10:29 -0800", "message": "implement simplified dependency resolution process (#469)"}, {"oid": "4b91b8db36338443b8443c78cb5581e3bb26fa81", "committedDate": "2020-12-13 21:10:29 -0800", "message": "add back public scope to builtin service since it needs to retrieve r\u2026 (#490)"}, {"oid": "6897122ced7b7708d2909200d545c5a01b158ae2", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Switch to new dependency resolution process (#493)"}, {"oid": "188dd671386b8d956d04651e3edd585e5371ec1b", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Device deployment (#486)"}, {"oid": "f41e02ddab79d0e5d128cf7c859026e75dceccf1", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Centralize paths and permissions (#506)"}, {"oid": "e38e39aceceff7d06e6515d43fd47d56397c6405", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Size limit (#473)"}, {"oid": "50bdfe8ef529f397189a4b72f63cd80d9ec70254", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Remove hardcoded scope in ComponentIdentifier (#507)"}, {"oid": "7558dd9dd4a94fa13dde5ed51ad5a52e4a21abbf", "committedDate": "2020-12-13 21:10:31 -0800", "message": "Fix problem with unarchiving being skipped for local artifacts  (#527)"}, {"oid": "29b4ebb6ef8e2245d75aee4324ae7b5617598f0e", "committedDate": "2020-12-13 21:10:33 -0800", "message": "System settings as Nucleus component configuration (#513)"}, {"oid": "f68508f974d61b4caac6ae73b92a26d02f699659", "committedDate": "2020-12-13 21:10:33 -0800", "message": "delete dead API references (#571)"}, {"oid": "773b41c3f20622b4c3249b9a31dff1f5913e7956", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Add timestamp to UpdateBehaviorTree to fix multi-group deployment (#561)"}, {"oid": "01c0b89deb5bff76791c4997e749c4840bb8defd", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Tag TODO items (#556)"}, {"oid": "c272aa34556114365188e21472327cd8a8951985", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Set the owner of artifacts for a service when commands are first run. (#555)"}, {"oid": "21f5f5e6df83324487ec99c55c1d0add7771743c", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Restrict loading of external plugins to cloud based recipes (#582)"}, {"oid": "5a8f026533bb6acc0e00a9f6b125bea352b60e1e", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Set artifact permissions according to recipe artifact permissions (#596)"}, {"oid": "9508d382d9500dc1b9525f90062a19da8aabac1f", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Todos (#601)"}, {"oid": "3fc04969985b8d2b1efa4589286907e05a60dfd0", "committedDate": "2020-12-13 21:10:35 -0800", "message": "refactor truncate tlog, fix tests (#608)"}, {"oid": "2fb3a699a9103045614c5592572d37d4400e9193", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Remove CLI from builtins (#634)"}, {"oid": "5bf7874693dd2184095a4c31af8a2a940934f7c9", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Add more logs to resolveComponentVersion; Add the initial deployment with config update test from PR #579 (#623)"}, {"oid": "5dae3ac8d84b04a3b6d82952f0da367354de7f8c", "committedDate": "2020-12-13 21:10:38 -0800", "message": "Allow going to cloud if no satifying version found locally for local group (#666)"}, {"oid": "1d1a754358376f2efb1532cf3c1634d179961f48", "committedDate": "2020-12-13 21:10:39 -0800", "message": "Add error handling & retry in ArtifactDownloader (#631)"}, {"oid": "88ed81262b145a652a6d6f9f5c450042fd9c957e", "committedDate": "2020-12-13 21:10:40 -0800", "message": "Use new cloud api model (#706)"}, {"oid": "dcbc85aa85f93d2b9610fb9494089ea9622269e1", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Recipe in json format (#722)"}, {"oid": "f28ff5e04af0727517de479e7e686e43882fc979", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use saved recipe content string to calculate recipe digest (#732)"}, {"oid": "2849a794de031e187dd26ea33cb673db8adb317f", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use AWS SDK v2 (#748)"}, {"oid": "4b87b714b44ab837cedfb024b8207b6402716a16", "committedDate": "2020-12-13 21:10:42 -0800", "message": "Add retry on client error(e.g. network loss) during deployment (#751)"}, {"oid": "48bf9decc7eb9bb7112fe9ff8c7fbce347f0268b", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Improve logs for deployment errors (#775)"}, {"oid": "e243971e7c66b3ce00e590c9a12ef723475b79ff", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Bump log to error level (#776)"}, {"oid": "02d8c479dfd957e1be98017caddf0155c93bd5fb", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Rename Kernel to Nucleus in string outputs (#788)"}, {"oid": "3b2350aec4dcacca2e88c06401e63b0078dd051b", "committedDate": "2021-01-20 16:41:43 -0800", "message": "improvement(various): No cloud calls if configured to run offline (#810)"}, {"oid": "2897e45a617ad35521ef94d0f08bf5b13ae4948b", "committedDate": "2021-02-25 15:47:02 -0800", "message": "feat(docker): initial implementation for docker image artifact downloader (#865)"}, {"oid": "d24acec456c0016dee23de2606a62c1ddda68623", "committedDate": "2021-03-10 16:15:02 -0800", "message": "feat(docker): improvements in validation, credential expiry handling, not logging credentials etc (#882)"}, {"oid": "91e8b1fc62cdd3fb1634f93c29e7489cb2421ec3", "committedDate": "2021-04-27 12:49:13 -0700", "message": "chore: use new pre-release dataplane SDK (#937)"}, {"oid": "dea87f115e1cb412cdc8d174b5e662d98fad62b1", "committedDate": "2021-05-27 16:41:08 -0700", "message": "feat(deployment): Support deployment with large configuration bigger than IoT Jobs/Shadow document limit (#963)"}, {"oid": "5be1aeeb9cbec04b7ee3c4d897d3f3b4d05662f2", "committedDate": "2021-08-04 15:56:10 -0700", "message": "fix: validate artifact uri from component recipe (#1013)"}, {"oid": "1a9aa3d87fa384a5d7d2f097d3e100e9a5099cad", "committedDate": "2021-08-05 11:22:40 -0700", "message": "fix(message): improve NoAvailableComponentVersionException messaging (#1040)"}, {"oid": "8a515091fa248d5d837a8521da8cb5682bc586a0", "committedDate": "2021-08-09 10:56:55 -0700", "message": "fix(logging): drop log level for many log messages (#1044)"}, {"oid": "a7e0a892a6f3b4cb787e24b63bc892e05654c223", "committedDate": "2022-08-30 23:07:42 -0700", "message": "feat: assign deployment error codes to deployment workflow (#1291)"}, {"oid": "fde355223d6fc405cca9c64af8c3ff6b5a6b8021", "committedDate": "2022-10-12 14:05:01 -0700", "message": "fix: parse status codes from gg v2 data exception (#1330)"}, {"oid": "2f98760ce8e5c7fb6ba5ac43647f0c8a4b873277", "committedDate": "2022-11-01 09:42:25 -0700", "message": "feat: warning log for discontinued component (#1349)"}, {"oid": "4bb96750c21bc02de3fd3fd6182afb8ecba41b46", "committedDate": "2022-12-08 12:30:56 -0500", "message": "fix: add logging around installed component not found (#1377)"}, {"oid": "6598594fd171065d5d46414353e7b18f3995304a", "committedDate": "2023-03-20 13:11:48 -0700", "message": "fix: re-negotiate with cloud if local recipe metadata contains a mismatched region (#1421)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTQ2Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496175466", "body": "How is this different from findActiveAndSatisfiedPackageMetadata?", "bodyText": "How is this different from findActiveAndSatisfiedPackageMetadata?", "bodyHTML": "<p dir=\"auto\">How is this different from findActiveAndSatisfiedPackageMetadata?</p>", "author": "ShirleyZheng92", "createdAt": "2020-09-28T19:14:56Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java", "diffHunk": "@@ -333,6 +418,32 @@ Semver getPackageVersionFromService(final GreengrassService service) {\n         }\n     }\n \n+    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,\n+                                                             Map<String, Requirement> requirementMap)\n+            throws PackagingException {\n+        return getActiveAndSatisfiedComponentMetadata(componentName, mergeVersionRequirements(requirementMap));\n+    }\n+\n+    private ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName, Requirement requirement)\n+            throws PackagingException {\n+        Optional<ComponentMetadata> componentMetadataOptional =\n+                findActiveAndSatisfiedPackageMetadata(componentName, requirement);\n+        if (!componentMetadataOptional.isPresent()) {\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"There is no version of component %s satisfying %s\", componentName, requirement));\n+        }\n+\n+        return componentMetadataOptional.get();\n+    }\n+\n+    private Optional<ComponentIdentifier> findActiveAndSatisfiedComponent(String componentName,", "originalCommit": "83e74ad405a0794ef484e90b22bcac16dbf6f45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NTg3OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496185878", "bodyText": "this returns component identifier, no need to read recipe from file. findActiveAndSatisfiedPackageMetadata  will be cleaned out once we made the switch.", "author": "wikimonkey", "createdAt": "2020-09-28T19:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5MzE2NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496193164", "bodyText": "Ok. you can add @deprecated on findActiveAndSatisfiedPackageMetadata later", "author": "ShirleyZheng92", "createdAt": "2020-09-28T19:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTQ2Ng=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "94a91fb3344a9069462d7bb8828d1376304ec67b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 2723671a..8c27d806 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -418,32 +332,6 @@ public class ComponentManager implements InjectionActions {\n         }\n     }\n \n-    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,\n-                                                             Map<String, Requirement> requirementMap)\n-            throws PackagingException {\n-        return getActiveAndSatisfiedComponentMetadata(componentName, mergeVersionRequirements(requirementMap));\n-    }\n-\n-    private ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName, Requirement requirement)\n-            throws PackagingException {\n-        Optional<ComponentMetadata> componentMetadataOptional =\n-                findActiveAndSatisfiedPackageMetadata(componentName, requirement);\n-        if (!componentMetadataOptional.isPresent()) {\n-            throw new NoAvailableComponentVersionException(\n-                    String.format(\"There is no version of component %s satisfying %s\", componentName, requirement));\n-        }\n-\n-        return componentMetadataOptional.get();\n-    }\n-\n-    private Optional<ComponentIdentifier> findActiveAndSatisfiedComponent(String componentName,\n-                                                                          Requirement requirement) {\n-        Optional<Semver> activeVersionOptional = findActiveVersion(componentName);\n-\n-        return activeVersionOptional.filter(requirement::isSatisfiedBy)\n-                .map(version -> new ComponentIdentifier(componentName, version));\n-    }\n-\n     @Nullable\n     private ComponentMetadata getBuiltinComponentMetadata(String packageName, Semver activeVersion) {\n         try {\n", "next_change": {"commit": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\nindex 8c27d806..4d0b2400 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentManager.java\n", "chunk": "@@ -332,6 +418,39 @@ public class ComponentManager implements InjectionActions {\n         }\n     }\n \n+    /** Get active component version and dependencies, the component version satisfies dependent version requirements.\n+     *\n+     * @param componentName component name\n+     * @param requirementMap dependent component to version requirement map\n+     * @return active component metadata which satisfies version requirement\n+     * @throws PackagingException no available version exception\n+     */\n+    ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName,\n+                                                             Map<String, Requirement> requirementMap)\n+            throws PackagingException {\n+        return getActiveAndSatisfiedComponentMetadata(componentName, mergeVersionRequirements(requirementMap));\n+    }\n+\n+    private ComponentMetadata getActiveAndSatisfiedComponentMetadata(String componentName, Requirement requirement)\n+            throws PackagingException {\n+        Optional<ComponentMetadata> componentMetadataOptional =\n+                findActiveAndSatisfiedPackageMetadata(componentName, requirement);\n+        if (!componentMetadataOptional.isPresent()) {\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"There is no version of component %s satisfying %s\", componentName, requirement));\n+        }\n+\n+        return componentMetadataOptional.get();\n+    }\n+\n+    private Optional<ComponentIdentifier> findActiveAndSatisfiedComponent(String componentName,\n+                                                                          Requirement requirement) {\n+        Optional<Semver> activeVersionOptional = findActiveVersion(componentName);\n+\n+        return activeVersionOptional.filter(requirement::isSatisfiedBy)\n+                .map(version -> new ComponentIdentifier(componentName, version));\n+    }\n+\n     @Nullable\n     private ComponentMetadata getBuiltinComponentMetadata(String packageName, Semver activeVersion) {\n         try {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "message": "Merge commit", "committedDate": null}, {"oid": "94a91fb3344a9069462d7bb8828d1376304ec67b", "committedDate": "2020-12-13 21:10:27 -0800", "message": "Naming refactor (#454)"}, {"oid": "640d91990c6e1345bee669ad46f0e12bfc436b1b", "committedDate": "2020-12-13 21:10:28 -0800", "message": "component store file operations (#451)"}, {"oid": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "committedDate": "2020-12-13 21:10:29 -0800", "message": "implement simplified dependency resolution process (#469)"}, {"oid": "4b91b8db36338443b8443c78cb5581e3bb26fa81", "committedDate": "2020-12-13 21:10:29 -0800", "message": "add back public scope to builtin service since it needs to retrieve r\u2026 (#490)"}, {"oid": "6897122ced7b7708d2909200d545c5a01b158ae2", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Switch to new dependency resolution process (#493)"}, {"oid": "188dd671386b8d956d04651e3edd585e5371ec1b", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Device deployment (#486)"}, {"oid": "f41e02ddab79d0e5d128cf7c859026e75dceccf1", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Centralize paths and permissions (#506)"}, {"oid": "e38e39aceceff7d06e6515d43fd47d56397c6405", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Size limit (#473)"}, {"oid": "50bdfe8ef529f397189a4b72f63cd80d9ec70254", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Remove hardcoded scope in ComponentIdentifier (#507)"}, {"oid": "7558dd9dd4a94fa13dde5ed51ad5a52e4a21abbf", "committedDate": "2020-12-13 21:10:31 -0800", "message": "Fix problem with unarchiving being skipped for local artifacts  (#527)"}, {"oid": "29b4ebb6ef8e2245d75aee4324ae7b5617598f0e", "committedDate": "2020-12-13 21:10:33 -0800", "message": "System settings as Nucleus component configuration (#513)"}, {"oid": "f68508f974d61b4caac6ae73b92a26d02f699659", "committedDate": "2020-12-13 21:10:33 -0800", "message": "delete dead API references (#571)"}, {"oid": "773b41c3f20622b4c3249b9a31dff1f5913e7956", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Add timestamp to UpdateBehaviorTree to fix multi-group deployment (#561)"}, {"oid": "01c0b89deb5bff76791c4997e749c4840bb8defd", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Tag TODO items (#556)"}, {"oid": "c272aa34556114365188e21472327cd8a8951985", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Set the owner of artifacts for a service when commands are first run. (#555)"}, {"oid": "21f5f5e6df83324487ec99c55c1d0add7771743c", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Restrict loading of external plugins to cloud based recipes (#582)"}, {"oid": "5a8f026533bb6acc0e00a9f6b125bea352b60e1e", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Set artifact permissions according to recipe artifact permissions (#596)"}, {"oid": "9508d382d9500dc1b9525f90062a19da8aabac1f", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Todos (#601)"}, {"oid": "3fc04969985b8d2b1efa4589286907e05a60dfd0", "committedDate": "2020-12-13 21:10:35 -0800", "message": "refactor truncate tlog, fix tests (#608)"}, {"oid": "2fb3a699a9103045614c5592572d37d4400e9193", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Remove CLI from builtins (#634)"}, {"oid": "5bf7874693dd2184095a4c31af8a2a940934f7c9", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Add more logs to resolveComponentVersion; Add the initial deployment with config update test from PR #579 (#623)"}, {"oid": "5dae3ac8d84b04a3b6d82952f0da367354de7f8c", "committedDate": "2020-12-13 21:10:38 -0800", "message": "Allow going to cloud if no satifying version found locally for local group (#666)"}, {"oid": "1d1a754358376f2efb1532cf3c1634d179961f48", "committedDate": "2020-12-13 21:10:39 -0800", "message": "Add error handling & retry in ArtifactDownloader (#631)"}, {"oid": "88ed81262b145a652a6d6f9f5c450042fd9c957e", "committedDate": "2020-12-13 21:10:40 -0800", "message": "Use new cloud api model (#706)"}, {"oid": "dcbc85aa85f93d2b9610fb9494089ea9622269e1", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Recipe in json format (#722)"}, {"oid": "f28ff5e04af0727517de479e7e686e43882fc979", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use saved recipe content string to calculate recipe digest (#732)"}, {"oid": "2849a794de031e187dd26ea33cb673db8adb317f", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use AWS SDK v2 (#748)"}, {"oid": "4b87b714b44ab837cedfb024b8207b6402716a16", "committedDate": "2020-12-13 21:10:42 -0800", "message": "Add retry on client error(e.g. network loss) during deployment (#751)"}, {"oid": "48bf9decc7eb9bb7112fe9ff8c7fbce347f0268b", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Improve logs for deployment errors (#775)"}, {"oid": "e243971e7c66b3ce00e590c9a12ef723475b79ff", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Bump log to error level (#776)"}, {"oid": "02d8c479dfd957e1be98017caddf0155c93bd5fb", "committedDate": "2020-12-13 21:10:43 -0800", "message": "Rename Kernel to Nucleus in string outputs (#788)"}, {"oid": "3b2350aec4dcacca2e88c06401e63b0078dd051b", "committedDate": "2021-01-20 16:41:43 -0800", "message": "improvement(various): No cloud calls if configured to run offline (#810)"}, {"oid": "2897e45a617ad35521ef94d0f08bf5b13ae4948b", "committedDate": "2021-02-25 15:47:02 -0800", "message": "feat(docker): initial implementation for docker image artifact downloader (#865)"}, {"oid": "d24acec456c0016dee23de2606a62c1ddda68623", "committedDate": "2021-03-10 16:15:02 -0800", "message": "feat(docker): improvements in validation, credential expiry handling, not logging credentials etc (#882)"}, {"oid": "91e8b1fc62cdd3fb1634f93c29e7489cb2421ec3", "committedDate": "2021-04-27 12:49:13 -0700", "message": "chore: use new pre-release dataplane SDK (#937)"}, {"oid": "dea87f115e1cb412cdc8d174b5e662d98fad62b1", "committedDate": "2021-05-27 16:41:08 -0700", "message": "feat(deployment): Support deployment with large configuration bigger than IoT Jobs/Shadow document limit (#963)"}, {"oid": "5be1aeeb9cbec04b7ee3c4d897d3f3b4d05662f2", "committedDate": "2021-08-04 15:56:10 -0700", "message": "fix: validate artifact uri from component recipe (#1013)"}, {"oid": "1a9aa3d87fa384a5d7d2f097d3e100e9a5099cad", "committedDate": "2021-08-05 11:22:40 -0700", "message": "fix(message): improve NoAvailableComponentVersionException messaging (#1040)"}, {"oid": "8a515091fa248d5d837a8521da8cb5682bc586a0", "committedDate": "2021-08-09 10:56:55 -0700", "message": "fix(logging): drop log level for many log messages (#1044)"}, {"oid": "a7e0a892a6f3b4cb787e24b63bc892e05654c223", "committedDate": "2022-08-30 23:07:42 -0700", "message": "feat: assign deployment error codes to deployment workflow (#1291)"}, {"oid": "fde355223d6fc405cca9c64af8c3ff6b5a6b8021", "committedDate": "2022-10-12 14:05:01 -0700", "message": "fix: parse status codes from gg v2 data exception (#1330)"}, {"oid": "2f98760ce8e5c7fb6ba5ac43647f0c8a4b873277", "committedDate": "2022-11-01 09:42:25 -0700", "message": "feat: warning log for discontinued component (#1349)"}, {"oid": "4bb96750c21bc02de3fd3fd6182afb8ecba41b46", "committedDate": "2022-12-08 12:30:56 -0500", "message": "fix: add logging around installed component not found (#1377)"}, {"oid": "6598594fd171065d5d46414353e7b18f3995304a", "committedDate": "2023-03-20 13:11:48 -0700", "message": "fix: re-negotiate with cloud if local recipe metadata contains a mismatched region (#1421)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTkwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496175906", "body": "This can be in the platform resolver class. Also add a TODO to add osVersion", "bodyText": "This can be in the platform resolver class. Also add a TODO to add osVersion", "bodyHTML": "<p dir=\"auto\">This can be in the platform resolver class. Also add a TODO to add osVersion</p>", "author": "ShirleyZheng92", "createdAt": "2020-09-28T19:15:48Z", "path": "src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java", "diffHunk": "@@ -90,6 +101,42 @@ public ComponentServiceHelper(GreengrassComponentServiceClientFactory clientFact\n         return ret;\n     }\n \n+    // Even though the cloud API signature can take a list of components at the same dependency level to resolve, the\n+    // algorithm is going through the dependencies node by node, so one time one component got resolved.\n+    ComponentContent resolveComponentVersion(String componentName, Semver localCandidateVersion,\n+                                             Map<String, Requirement> versionRequirements)\n+            throws NoAvailableComponentVersionException, ComponentVersionNegotiationException {\n+\n+        ComponentPlatform platform = new ComponentPlatform().withOs(PlatformResolver.CURRENT_PLATFORM.getOs().getName())\n+                .withArchitecture(PlatformResolver.CURRENT_PLATFORM.getArchitecture().getName());", "originalCommit": "83e74ad405a0794ef484e90b22bcac16dbf6f45b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NjI0Mg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/469#discussion_r496186242", "bodyText": "I would rather keep it here because ComponentPlatform is GCS coral object. Will add comment.", "author": "wikimonkey", "createdAt": "2020-09-28T19:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NTkwNg=="}], "type": "inlineReview", "revised_code": {"commit": "ae8b113b0716f9685260adce73f68035b45c20dd", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\nindex a4f7a9d1..b4fa15fa 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n", "chunk": "@@ -107,6 +107,7 @@ public class ComponentServiceHelper {\n                                              Map<String, Requirement> versionRequirements)\n             throws NoAvailableComponentVersionException, ComponentVersionNegotiationException {\n \n+        // TODO add osVersion and osFlavor once they are supported\n         ComponentPlatform platform = new ComponentPlatform().withOs(PlatformResolver.CURRENT_PLATFORM.getOs().getName())\n                 .withArchitecture(PlatformResolver.CURRENT_PLATFORM.getArchitecture().getName());\n         Map<String, String> versionRequirementsInString = versionRequirements.entrySet().stream()\n", "next_change": null}]}, "revised_code_in_main": {"commit": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\nindex a4f7a9d1..b4fa15fa 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n", "chunk": "@@ -107,6 +107,7 @@ public class ComponentServiceHelper {\n                                              Map<String, Requirement> versionRequirements)\n             throws NoAvailableComponentVersionException, ComponentVersionNegotiationException {\n \n+        // TODO add osVersion and osFlavor once they are supported\n         ComponentPlatform platform = new ComponentPlatform().withOs(PlatformResolver.CURRENT_PLATFORM.getOs().getName())\n                 .withArchitecture(PlatformResolver.CURRENT_PLATFORM.getArchitecture().getName());\n         Map<String, String> versionRequirementsInString = versionRequirements.entrySet().stream()\n", "next_change": {"commit": "94a91fb3344a9069462d7bb8828d1376304ec67b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\nindex b4fa15fa..39816f97 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n", "chunk": "@@ -101,43 +90,6 @@ public class ComponentServiceHelper {\n         return ret;\n     }\n \n-    // Even though the cloud API signature can take a list of components at the same dependency level to resolve, the\n-    // algorithm is going through the dependencies node by node, so one time one component got resolved.\n-    ComponentContent resolveComponentVersion(String componentName, Semver localCandidateVersion,\n-                                             Map<String, Requirement> versionRequirements)\n-            throws NoAvailableComponentVersionException, ComponentVersionNegotiationException {\n-\n-        // TODO add osVersion and osFlavor once they are supported\n-        ComponentPlatform platform = new ComponentPlatform().withOs(PlatformResolver.CURRENT_PLATFORM.getOs().getName())\n-                .withArchitecture(PlatformResolver.CURRENT_PLATFORM.getArchitecture().getName());\n-        Map<String, String> versionRequirementsInString = versionRequirements.entrySet().stream()\n-                .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().toString()));\n-        ComponentCandidate candidate = new ComponentCandidate().withName(componentName)\n-                .withVersion(localCandidateVersion == null ? null : localCandidateVersion.getValue())\n-                .withVersionRequirements(versionRequirementsInString);\n-        ResolveComponentVersionsRequest request = new ResolveComponentVersionsRequest().withPlatform(platform)\n-                .withComponentCandidates(Collections.singletonList(candidate));\n-\n-        ResolveComponentVersionsResult result;\n-        try {\n-            result = evgCmsClient.resolveComponentVersions(request);\n-        } catch (ResourceNotFoundException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"No available version when resolving component\");\n-            throw new NoAvailableComponentVersionException(String.format(\"No applicable version of component %s \"\n-                    + \"found in cloud registry satisfying %s\", componentName, versionRequirements), e);\n-        } catch (AmazonClientException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"Server error when resolving component\");\n-            throw new ComponentVersionNegotiationException(String.format(\"Component service error when resolving %s\",\n-                    componentName), e);\n-        }\n-\n-        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1, \"Component service \"\n-                + \"invalid response, it should contain resolved component version\");\n-        return result.getComponents().get(0);\n-    }\n-\n     /**\n      * Download a package recipe.\n      *\n", "next_change": {"commit": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\nindex 39816f97..b4fa15fa 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n", "chunk": "@@ -90,6 +101,43 @@ public class ComponentServiceHelper {\n         return ret;\n     }\n \n+    // Even though the cloud API signature can take a list of components at the same dependency level to resolve, the\n+    // algorithm is going through the dependencies node by node, so one time one component got resolved.\n+    ComponentContent resolveComponentVersion(String componentName, Semver localCandidateVersion,\n+                                             Map<String, Requirement> versionRequirements)\n+            throws NoAvailableComponentVersionException, ComponentVersionNegotiationException {\n+\n+        // TODO add osVersion and osFlavor once they are supported\n+        ComponentPlatform platform = new ComponentPlatform().withOs(PlatformResolver.CURRENT_PLATFORM.getOs().getName())\n+                .withArchitecture(PlatformResolver.CURRENT_PLATFORM.getArchitecture().getName());\n+        Map<String, String> versionRequirementsInString = versionRequirements.entrySet().stream()\n+                .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue().toString()));\n+        ComponentCandidate candidate = new ComponentCandidate().withName(componentName)\n+                .withVersion(localCandidateVersion == null ? null : localCandidateVersion.getValue())\n+                .withVersionRequirements(versionRequirementsInString);\n+        ResolveComponentVersionsRequest request = new ResolveComponentVersionsRequest().withPlatform(platform)\n+                .withComponentCandidates(Collections.singletonList(candidate));\n+\n+        ResolveComponentVersionsResult result;\n+        try {\n+            result = evgCmsClient.resolveComponentVersions(request);\n+        } catch (ResourceNotFoundException e) {\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n+                    \"No available version when resolving component\");\n+            throw new NoAvailableComponentVersionException(String.format(\"No applicable version of component %s \"\n+                    + \"found in cloud registry satisfying %s\", componentName, versionRequirements), e);\n+        } catch (AmazonClientException e) {\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n+                    \"Server error when resolving component\");\n+            throw new ComponentVersionNegotiationException(String.format(\"Component service error when resolving %s\",\n+                    componentName), e);\n+        }\n+\n+        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1, \"Component service \"\n+                + \"invalid response, it should contain resolved component version\");\n+        return result.getComponents().get(0);\n+    }\n+\n     /**\n      * Download a package recipe.\n      *\n", "next_change": {"commit": "6897122ced7b7708d2909200d545c5a01b158ae2", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\nindex b4fa15fa..b6b73c5d 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n", "chunk": "@@ -116,25 +128,30 @@ public class ComponentServiceHelper {\n                 .withVersion(localCandidateVersion == null ? null : localCandidateVersion.getValue())\n                 .withVersionRequirements(versionRequirementsInString);\n         ResolveComponentVersionsRequest request = new ResolveComponentVersionsRequest().withPlatform(platform)\n-                .withComponentCandidates(Collections.singletonList(candidate));\n+                .withComponentCandidates(Collections.singletonList(candidate))\n+                // TODO switch back deploymentConfigurationId once it's removed from URL path\n+                // use UUID to avoid ARN complication in URL, deploymentConfigurationId is used for logging purpose\n+                // in server, so could have this hack now\n+                .withDeploymentConfigurationId(UUID.randomUUID().toString());\n \n         ResolveComponentVersionsResult result;\n         try {\n             result = evgCmsClient.resolveComponentVersions(request);\n         } catch (ResourceNotFoundException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"No available version when resolving component\");\n-            throw new NoAvailableComponentVersionException(String.format(\"No applicable version of component %s \"\n-                    + \"found in cloud registry satisfying %s\", componentName, versionRequirements), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"No available version when resolving component\");\n+            throw new NoAvailableComponentVersionException(\n+                    String.format(\"No applicable version of component %s \" + \"found in cloud registry satisfying %s\",\n+                            componentName, versionRequirements), e);\n         } catch (AmazonClientException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements).log(\n-                    \"Server error when resolving component\");\n-            throw new ComponentVersionNegotiationException(String.format(\"Component service error when resolving %s\",\n-                    componentName), e);\n+            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n+                    .log(\"Server error when resolving component\");\n+            throw new ComponentVersionNegotiationException(\n+                    String.format(\"Component service error when resolving %s\", componentName), e);\n         }\n \n-        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1, \"Component service \"\n-                + \"invalid response, it should contain resolved component version\");\n+        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1,\n+                \"Component service \" + \"invalid response, it should contain resolved component version\");\n         return result.getComponents().get(0);\n     }\n \n", "next_change": {"commit": "3c479bb0e30376e3077a44dbc6ee1a27814f6361", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\nindex b6b73c5d..f9cc7f06 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n", "chunk": "@@ -151,7 +103,7 @@ public class ComponentServiceHelper {\n         }\n \n         Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1,\n-                \"Component service \" + \"invalid response, it should contain resolved component version\");\n+                        \"Component service \" + \"invalid response, it should contain resolved component version\");\n         return result.getComponents().get(0);\n     }\n \n", "next_change": {"commit": "5bf7874693dd2184095a4c31af8a2a940934f7c9", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\nindex f9cc7f06..7600e2bc 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n", "chunk": "@@ -91,19 +91,20 @@ public class ComponentServiceHelper {\n             result = evgCmsClient.resolveComponentVersions(request);\n         } catch (ResourceNotFoundException e) {\n             logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n-                    .log(\"No available version when resolving component\");\n-            throw new NoAvailableComponentVersionException(\n-                    String.format(\"No applicable version of component %s \" + \"found in cloud registry satisfying %s\",\n-                                  componentName, versionRequirements), e);\n+                    .log(\"No applicable version found in cloud registry\");\n+            throw new NoAvailableComponentVersionException(String.format(\n+                    \"No applicable version found in cloud registry for component: '%s' satisfying requirement: '%s'.\",\n+                    componentName, versionRequirements), e);\n         } catch (AmazonClientException e) {\n             logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n-                    .log(\"Server error when resolving component\");\n+                    .log(\"Failed to get result from Greengrass cloud when resolving component\");\n             throw new ComponentVersionNegotiationException(\n-                    String.format(\"Component service error when resolving %s\", componentName), e);\n+                    String.format(\"Failed to get result from Greengrass cloud when resolving component: '%s'.\",\n+                                  componentName), e);\n         }\n \n         Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1,\n-                        \"Component service \" + \"invalid response, it should contain resolved component version\");\n+                        \"Component service returns invalid response. It should have one resolved component version\");\n         return result.getComponents().get(0);\n     }\n \n", "next_change": {"commit": "88ed81262b145a652a6d6f9f5c450042fd9c957e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\nindex 7600e2bc..26a42a0a 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n", "chunk": "@@ -103,77 +88,9 @@ public class ComponentServiceHelper {\n                                   componentName), e);\n         }\n \n-        Validate.isTrue(result.getComponents() != null && result.getComponents().size() == 1,\n-                        \"Component service returns invalid response. It should have one resolved component version\");\n-        return result.getComponents().get(0);\n-    }\n-\n-    /**\n-     * Download a package recipe.\n-     *\n-     * @param componentIdentifier identifier of the recipe to be downloaded\n-     * @return recipe\n-     * @throws PackageDownloadException if downloading fails\n-     */\n-    public String downloadPackageRecipeAsString(ComponentIdentifier componentIdentifier)\n-            throws PackageDownloadException {\n-        GetComponentVersionRequest getComponentVersionRequest =\n-                new GetComponentVersionRequest().withComponentName(componentIdentifier.getName())\n-                        .withComponentVersion(componentIdentifier.getVersion().toString())\n-                        .withType(RecipeFormatType.YAML);\n-\n-        GetComponentVersionResult getPackageResult = download(getComponentVersionRequest, componentIdentifier);\n-        return StandardCharsets.UTF_8.decode(getPackageResult.getRecipe()).toString();\n-    }\n-\n-    private GetComponentVersionResult download(GetComponentVersionRequest r, ComponentIdentifier id)\n-            throws PackageDownloadException {\n-        try {\n-            return evgCmsClient.getComponentVersion(r);\n-        } catch (AmazonClientException e) {\n-            // TODO: [P41215221]: Properly handle all retryable/nonretryable exceptions\n-            String errorMsg = String.format(PACKAGE_RECIPE_DOWNLOAD_EXCEPTION_FMT, id);\n-            throw new PackageDownloadException(errorMsg, e);\n-        }\n-    }\n-\n-    /**\n-     * Create a component with the given recipe file.\n-     *\n-     * @param cmsClient      client of Component Management Service\n-     * @param recipeFilePath the path to the component recipe file\n-     * @return {@link CreateComponentResult}\n-     * @throws IOException if file reading fails\n-     */\n-    // TODO: [P41215855]: Make createComponent method non static\n-    public static CreateComponentResult createComponent(AWSEvergreen cmsClient, Path recipeFilePath)\n-            throws IOException {\n-        ByteBuffer recipeBuf = ByteBuffer.wrap(Files.readAllBytes(recipeFilePath));\n-        CreateComponentRequest createComponentRequest = new CreateComponentRequest().withRecipe(recipeBuf);\n-        logger.atDebug(\"create-component\").kv(\"request\", createComponentRequest).log();\n-        CreateComponentResult createComponentResult = cmsClient.createComponent(createComponentRequest);\n-        logger.atDebug(\"create-component\").kv(\"result\", createComponentResult).log();\n-        return createComponentResult;\n-    }\n-\n-\n-    /**\n-     * Delete a component of the given name and version.\n-     *\n-     * @param cmsClient        client of Component Management Service\n-     * @param componentName    name of the component to delete\n-     * @param componentVersion version of the component to delete\n-     * @return {@link DeleteComponentVersionResult}\n-     */\n-    public static DeleteComponentVersionResult deleteComponent(AWSEvergreen cmsClient, String componentName,\n-            String componentVersion) {\n-        DeleteComponentVersionRequest deleteComponentVersionRequest =\n-                new DeleteComponentVersionRequest().withComponentName(componentName)\n-                        .withComponentVersion(componentVersion);\n-        logger.atDebug(\"delete-component\").kv(\"request\", deleteComponentVersionRequest).log();\n-        DeleteComponentVersionResult deleteComponentVersionResult =\n-                cmsClient.deleteComponentVersion(deleteComponentVersionRequest);\n-        logger.atDebug(\"delete-component\").kv(\"result\", deleteComponentVersionResult).log();\n-        return deleteComponentVersionResult;\n+        Validate.isTrue(\n+                result.getResolvedComponentVersions() != null && result.getResolvedComponentVersions().size() == 1,\n+                \"Component service returns invalid response. It should have one resolved component version\");\n+        return result.getResolvedComponentVersions().get(0);\n     }\n }\n", "next_change": {"commit": "2849a794de031e187dd26ea33cb673db8adb317f", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\nindex 26a42a0a..89121896 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n", "chunk": "@@ -89,8 +84,8 @@ public class ComponentServiceHelper {\n         }\n \n         Validate.isTrue(\n-                result.getResolvedComponentVersions() != null && result.getResolvedComponentVersions().size() == 1,\n+                result.resolvedComponentVersions() != null && result.resolvedComponentVersions().size() == 1,\n                 \"Component service returns invalid response. It should have one resolved component version\");\n-        return result.getResolvedComponentVersions().get(0);\n+        return result.resolvedComponentVersions().get(0);\n     }\n }\n", "next_change": {"commit": "a7e0a892a6f3b4cb787e24b63bc892e05654c223", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\nindex 89121896..be2f962a 100644\n--- a/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n+++ b/src/main/java/com/aws/greengrass/componentmanager/ComponentServiceHelper.java\n", "chunk": "@@ -67,25 +73,29 @@ public class ComponentServiceHelper {\n                 .componentCandidates(Collections.singletonList(candidate)).build();\n \n         ResolveComponentCandidatesResponse result;\n-        try {\n-            result = clientFactory.getCmsClient().resolveComponentCandidates(request);\n+\n+        RetryUtils.RetryConfig clientExceptionRetryConfig =\n+                RetryUtils.RetryConfig.builder().initialRetryInterval(Duration.ofSeconds(30))\n+                        .maxRetryInterval(Duration.ofSeconds(30)).maxAttempt(CLIENT_RETRY_COUNT)\n+                        .retryableExceptions(Arrays.asList(DeviceConfigurationException.class)).build();\n+\n+        try (GreengrassV2DataClient greengrasV2DataClient = RetryUtils.runWithRetry(clientExceptionRetryConfig, () -> {\n+            return clientFactory.fetchGreengrassV2DataClient();\n+        }, \"get-greengrass-v2-data-client\", logger)) {\n+\n+            result = greengrasV2DataClient.resolveComponentCandidates(request);\n+\n         } catch (ResourceNotFoundException e) {\n             logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n-                    .log(\"No applicable version found in cloud registry\");\n-            throw new NoAvailableComponentVersionException(String.format(\n-                    \"No applicable version found in cloud registry for component: '%s' satisfying requirement: '%s'.\",\n-                    componentName, versionRequirements), e);\n-        } catch (SdkClientException e) {\n-            logger.atDebug().kv(\"componentName\", componentName).kv(\"versionRequirements\", versionRequirements)\n-                    .log(\"Failed to get result from Greengrass cloud when resolving component\");\n-            throw new ComponentVersionNegotiationException(\n-                    String.format(\"Failed to get result from Greengrass cloud when resolving component: '%s'.\",\n-                                  componentName), e);\n+                    .log(\"No applicable version found in cloud registry\", e);\n+            throw new NoAvailableComponentVersionException(\"No cloud component version satisfies the requirements.\",\n+                    componentName, versionRequirements);\n+        }\n+        if (result.resolvedComponentVersions() == null || result.resolvedComponentVersions().size() != 1) {\n+            throw new PackagingException(\n+                    \"Component service returns invalid response. It should have one resolved component version\",\n+                    DeploymentErrorCode.RESOLVE_COMPONENT_CANDIDATES_BAD_RESPONSE);\n         }\n-\n-        Validate.isTrue(\n-                result.resolvedComponentVersions() != null && result.resolvedComponentVersions().size() == 1,\n-                \"Component service returns invalid response. It should have one resolved component version\");\n         return result.resolvedComponentVersions().get(0);\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "8a154feeef52c767c3da3d82e0dbac670639a0a7", "message": "Merge commit", "committedDate": null}, {"oid": "94a91fb3344a9069462d7bb8828d1376304ec67b", "committedDate": "2020-12-13 21:10:27 -0800", "message": "Naming refactor (#454)"}, {"oid": "7bea66177e0fffcbf8f53e05d6a57f4e1e432ad5", "committedDate": "2020-12-13 21:10:29 -0800", "message": "implement simplified dependency resolution process (#469)"}, {"oid": "6897122ced7b7708d2909200d545c5a01b158ae2", "committedDate": "2020-12-13 21:10:29 -0800", "message": "Switch to new dependency resolution process (#493)"}, {"oid": "50bdfe8ef529f397189a4b72f63cd80d9ec70254", "committedDate": "2020-12-13 21:10:30 -0800", "message": "Remove hardcoded scope in ComponentIdentifier (#507)"}, {"oid": "f68508f974d61b4caac6ae73b92a26d02f699659", "committedDate": "2020-12-13 21:10:33 -0800", "message": "delete dead API references (#571)"}, {"oid": "01c0b89deb5bff76791c4997e749c4840bb8defd", "committedDate": "2020-12-13 21:10:34 -0800", "message": "Tag TODO items (#556)"}, {"oid": "9508d382d9500dc1b9525f90062a19da8aabac1f", "committedDate": "2020-12-13 21:10:35 -0800", "message": "Todos (#601)"}, {"oid": "3c479bb0e30376e3077a44dbc6ee1a27814f6361", "committedDate": "2020-12-13 21:10:36 -0800", "message": "Integrate create deployment (#581)"}, {"oid": "5bf7874693dd2184095a4c31af8a2a940934f7c9", "committedDate": "2020-12-13 21:10:37 -0800", "message": "Add more logs to resolveComponentVersion; Add the initial deployment with config update test from PR #579 (#623)"}, {"oid": "92ae5a2c559fba514260453c703867df7e5db078", "committedDate": "2020-12-13 21:10:38 -0800", "message": "React to nucleus config changes (#670)"}, {"oid": "2dadb42f717a6bde25e25e48d3fccc105ed45437", "committedDate": "2020-12-13 21:10:39 -0800", "message": "Just migrate the cloud API names so that new SDK can be consumed (#691)"}, {"oid": "a1e0f330c52838c023f6e91115157dff78f0c881", "committedDate": "2020-12-13 21:10:39 -0800", "message": "Re-created pull request for platform search Nucleus changes (#688)"}, {"oid": "88ed81262b145a652a6d6f9f5c450042fd9c957e", "committedDate": "2020-12-13 21:10:40 -0800", "message": "Use new cloud api model (#706)"}, {"oid": "dcbc85aa85f93d2b9610fb9494089ea9622269e1", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Recipe in json format (#722)"}, {"oid": "7647011d76441c39b9f1a82c0d45eb95e95c1605", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Enable component service helper to send attributes to cloud (#708)"}, {"oid": "2849a794de031e187dd26ea33cb673db8adb317f", "committedDate": "2020-12-13 21:10:41 -0800", "message": "Use AWS SDK v2 (#748)"}, {"oid": "4b87b714b44ab837cedfb024b8207b6402716a16", "committedDate": "2020-12-13 21:10:42 -0800", "message": "Add retry on client error(e.g. network loss) during deployment (#751)"}, {"oid": "91e8b1fc62cdd3fb1634f93c29e7489cb2421ec3", "committedDate": "2021-04-27 12:49:13 -0700", "message": "chore: use new pre-release dataplane SDK (#937)"}, {"oid": "1a9aa3d87fa384a5d7d2f097d3e100e9a5099cad", "committedDate": "2021-08-05 11:22:40 -0700", "message": "fix(message): improve NoAvailableComponentVersionException messaging (#1040)"}, {"oid": "0f1ed3bb00b8e2ba441a49c3d2f5921eb0412797", "committedDate": "2022-05-06 10:01:16 -0700", "message": "fix: handle null ggv2dataclient (#1218)"}, {"oid": "a7e0a892a6f3b4cb787e24b63bc892e05654c223", "committedDate": "2022-08-30 23:07:42 -0700", "message": "feat: assign deployment error codes to deployment workflow (#1291)"}, {"oid": "8f2d69192241ffb124411c75dda11dc7322b6ff6", "committedDate": "2022-09-12 08:08:40 -0700", "message": "test: speed up tests by decreasing waits with TestFeatureParameters (#1303)"}, {"oid": "7d40923786f075e4731b44197bdb7c7ab594fa06", "committedDate": "2023-03-16 14:08:12 -0700", "message": "chore: exception and logging for incompatible platform claim (#1413)"}]}, {"oid": "ae8b113b0716f9685260adce73f68035b45c20dd", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ae8b113b0716f9685260adce73f68035b45c20dd", "message": "add comments", "committedDate": "2020-09-28T19:46:01Z", "type": "commit"}]}